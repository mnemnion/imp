
AVRASM ver. 2.1.51  leonardo.asm Mon Dec 23 20:35:21 2013

leonardo.asm(1): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
leonardo.asm(2): Including file '../../core/devices/atmega32u4\device.asm'
../../core/devices/atmega32u4\device.asm(5): Including file '../../Atmel/Appnotes2\m32U4def.inc'
leonardo.asm(21): Including file '../../core\drivers/usart_1.asm'
../../core\drivers/usart_1.asm(31): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
leonardo.asm(23): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(5): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(6): Including file '../../core\words/marker.asm'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(10): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl_core.inc(16): Including file '../../core\words/fill.asm'
dict_appl_core.inc(17): Including file '../../core\words/d-2star.asm'
dict_appl_core.inc(18): Including file '../../core\words/d-plus.asm'
dict_appl_core.inc(19): Including file '../../core\words/d-minus.asm'
dict_appl_core.inc(20): Including file '../../core\words/d-invert.asm'
dict_appl_core.inc(21): Including file '../../core\words/udot.asm'
dict_appl_core.inc(22): Including file '../../core\words/dot-s.asm'
dict_appl_core.inc(24): Including file '../../core\words/dotstring.asm'
dict_appl_core.inc(25): Including file '../../core\words/squote.asm'
dict_appl_core.inc(27): Including file '../../core\words/edefer.asm'
dict_appl_core.inc(28): Including file '../../core\words/rdefer.asm'
dict_appl_core.inc(29): Including file '../../core\words/is.asm'
dict_appl_core.inc(31): Including file 'words/applturnkey.asm'
dict_appl_core.inc(32): Including file '../../core\words/1ms.asm'
dict_appl_core.inc(33): Including file '../../core\words/ms.asm'
dict_appl_core.inc(34): Including file '../../core\words/show-wordlist.asm'
dict_appl_core.inc(35): Including file '../../core\words/words.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_WATCHDOG = 0
                 .set WANT_PORTD = 0
                 .set WANT_SPI = 0
                 .set WANT_USART1 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_CPU = 0
                 .set WANT_PLL = 0
                 .set WANT_USB_DEVICE = 0
                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0e6      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0e4      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0e2      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d0e0      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d0de      	 rcall isr ; Reserved1
                 .org 12
00000c d0dc      	 rcall isr ; Reserved2
                 .org 14
00000e d0da      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d0d8      	 rcall isr ; Reserved3
                 .org 18
000012 d0d6      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d0d4      	 rcall isr ; USB General Interrupt Request
                 .org 22
000016 d0d2      	 rcall isr ; USB Endpoint/Pipe Interrupt Communication Request
                 .org 24
000018 d0d0      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d0ce      	 rcall isr ; Reserved4
                 .org 28
00001c d0cc      	 rcall isr ; Reserved5
                 .org 30
00001e d0ca      	 rcall isr ; Reserved6
                 .org 32
000020 d0c8      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d0c6      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d0c4      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d0c2      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d0c0      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d0be      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d0bc      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d0ba      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d0b8      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d0b6      	 rcall isr ; USART1, Rx Complete
                 .org 52
000034 d0b4      	 rcall isr ; USART1 Data register Empty
                 .org 54
000036 d0b2      	 rcall isr ; USART1, Tx Complete
                 .org 56
000038 d0b0      	 rcall isr ; Analog Comparator
                 .org 58
00003a d0ae      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d0ac      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d0aa      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0a8      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0a6      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0a4      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d0a2      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d0a0      	 rcall isr ; 2-wire Serial Interface        
                 .org 74
00004a d09e      	 rcall isr ; Store Program Memory Read
                 .org 76
00004c d09c      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 78
00004e d09a      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 80
000050 d098      	 rcall isr ; Timer/Counter4 Compare Match D
                 .org 82
000052 d096      	 rcall isr ; Timer/Counter4 Overflow
                 .org 84
000054 d094      	 rcall isr ; Timer/Counter4 Fault Protection Interrupt
                 .equ INTVECTORS = 43
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000055 0a00      	.dw 2560
                 mcu_eepromsize:
000056 0400      	.dw 1024
                 mcu_maxdp:
000057 7000      	.dw 28672 
                 mcu_numints:
000058 002b      	.dw 43
                 mcu_name:
000059 000a      	.dw 10
00005a 5441
00005b 656d
00005c 6167
00005d 3233
00005e 3455      	.db "ATmega32U4"
                 .set codestart=pc
                 
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64   ; 80 characters is one line...
                 .equ APPUSERSIZE = 10 ; size of application user area
                 
                 ; the dictionary search treats lowercase and uppercase
                 ; letters the same. Set to 0 if you do not want it
                 .set WANT_IGNORECASE = 1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 .set NUMWORDLISTS = 8
                 ; baud rate of terminal
                 .equ BAUD = 38400
                 .include "drivers/usart_1.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR1H
                   .equ USART_C = UCSR1C
                   .equ USART_B = UCSR1B
                   .equ USART_A = UCSR1A
                   .equ USART_DATA = UDR1
                 
                 .equ URXCaddr = URXC1addr
                 .equ UDREaddr = UDRE1addr
                 
                 .equ bm_USART_RXRD = 1 << RXC1
                 .equ bm_USART_TXRD = 1 << UDRE1
                 .equ bm_ENABLE_TX  = 1 << TXEN1
                 .equ bm_ENABLE_RX  = 1 << RXEN1
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE1
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE1
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000032 940c 005f   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00005f 93af        push xl
000060 b7af        in xl, SREG
000061 93af        push xl
000062 93bf        push xh
000063 93ef        push zl
000064 93ff        push zh
                 
000065 91b0 00ce   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
000067 91a0 0100   lds xl,usart_rx_in
000069 e0e2        ldi zl, low(usart_rx_data)
00006a e0f1        ldi zh, high(usart_rx_data)
00006b 0fea        add zl, xl
00006c 1df3        adc zh, zeroh
00006d 83b0        st Z, xh
                 
00006e 95a3        inc xl
00006f 70af        andi xl,usart_rx_mask
                 
000070 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000072 91ff        pop zh
000073 91ef        pop zl
000074 91bf        pop xh
000075 91af        pop xl
000076 bfaf        out SREG, xl
000077 91af        pop xl
000078 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000079 3800        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00007a 3934        .dw XT_ZERO
00007b 3837        .dw XT_DOLITERAL
00007c 0100        .dw usart_rx_in
00007d 387c        .dw XT_STORE
                 
00007e 381a        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00007f ff06          .dw $ff06
000080 7872
000081 692d
000082 7273          .db "rx-isr"
000083 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000084 3800          .dw DO_COLON
                 PFA_RX_ISR:
000085 009e        .dw XT_RXQ_ISR
000086 3830        .dw XT_DOCONDBRANCH
000087 0085        .dw PFA_RX_ISR
000088 3837        .dw XT_DOLITERAL
000089 0101        .dw usart_rx_out
00008a 3893        .dw XT_CFETCH
00008b 38ac        .dw XT_DUP
00008c 3a38        .dw XT_1PLUS
00008d 3837        .dw XT_DOLITERAL
00008e 000f        .dw usart_rx_mask
00008f 3a1c        .dw XT_AND
000090 3837        .dw XT_DOLITERAL
000091 0101        .dw usart_rx_out
000092 3888        .dw XT_CSTORE
000093 3837        .dw XT_DOLITERAL
000094 0102        .dw usart_rx_data
000095 39a6        .dw XT_PLUS
000096 3893        .dw XT_CFETCH
000097 381a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000098 ff07          .dw $ff07
000099 7872
00009a 2d3f
00009b 7369
00009c 0072          .db "rx?-isr",0
00009d 007f          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
00009e 3800          .dw DO_COLON
                 PFA_RXQ_ISR:
00009f 06d5        .dw XT_PAUSE
0000a0 3837        .dw XT_DOLITERAL
0000a1 0101        .dw usart_rx_out
0000a2 3893        .dw XT_CFETCH
0000a3 3837        .dw XT_DOLITERAL
0000a4 0100        .dw usart_rx_in
0000a5 3893        .dw XT_CFETCH
0000a6 3907        .dw XT_NOTEQUAL
0000a7 381a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000a8 ff07          .dw $ff07
0000a9 7874
0000aa 702d
0000ab 6c6f
0000ac 006c          .db "tx-poll",0
0000ad 0098          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ae 3800          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000af 00bc        .dw XT_TXQ_POLL
0000b0 3830        .dw XT_DOCONDBRANCH
0000b1 00af        .dw PFA_TX_POLL
                   ; send to usart
0000b2 3837        .dw XT_DOLITERAL
0000b3 00ce        .dw USART_DATA
0000b4 3888        .dw XT_CSTORE
0000b5 381a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000b6 ff08          .dw $ff08
0000b7 7874
0000b8 2d3f
0000b9 6f70
0000ba 6c6c          .db "tx?-poll"
0000bb 00a8          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000bc 3800          .dw DO_COLON
                 PFA_TXQ_POLL:
0000bd 06d5        .dw XT_PAUSE
0000be 3837        .dw XT_DOLITERAL
0000bf 00c8        .dw USART_A
0000c0 3893        .dw XT_CFETCH
0000c1 3837        .dw XT_DOLITERAL
0000c2 0020        .dw bm_USART_TXRD
0000c3 3a1c        .dw XT_AND
0000c4 381a        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000c5 ff04        .dw $ff04
0000c6 6275
0000c7 7272        .db "ubrr"
0000c8 00b6        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000c9 3869        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ca 0054        .dw EE_UBRRVAL
0000cb 3d5a        .dw XT_EVALUEFETCH
0000cc 3d5e        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000cd ff06        .dw $ff06
0000ce 752b
0000cf 6173
0000d0 7472        .db "+usart"
0000d1 00c5        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000d2 3800        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000d3 3837        .dw XT_DOLITERAL
0000d4 0098        .dw USART_B_VALUE
0000d5 3837        .dw XT_DOLITERAL
0000d6 00c9        .dw USART_B
0000d7 3888        .dw XT_CSTORE
                 
0000d8 3837        .dw XT_DOLITERAL
0000d9 0006        .dw USART_C_VALUE
0000da 3837        .dw XT_DOLITERAL
0000db 00ca        .dw USART_C | bm_USARTC_en
0000dc 3888        .dw XT_CSTORE
                 
0000dd 00c9        .dw XT_UBRR
0000de 38ac        .dw XT_DUP
0000df 3b0e        .dw XT_BYTESWAP
0000e0 3837        .dw XT_DOLITERAL
0000e1 00cd        .dw BAUDRATE_HIGH
0000e2 3888        .dw XT_CSTORE
0000e3 3837        .dw XT_DOLITERAL
0000e4 00cc        .dw BAUDRATE_LOW
0000e5 3888        .dw XT_CSTORE
                 
0000e6 0079        .dw XT_USART_INIT_RX
0000e7 07cf        .dw XT_USART_INIT_TX
0000e8 381a        .dw XT_EXIT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 06de   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000e9 920a          st -Y, r0
0000ea b60f          in r0, SREG
0000eb 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000ec 900f          pop r0
0000ed 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000ee 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000ef 9200 0114     sts intcur, r0
0000f1 9009          ld r0, Y+
0000f2 be0f          out SREG, r0
0000f3 9009          ld r0, Y+
0000f4 9468          set ; set the interrupt flag for the inner interpreter
0000f5 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0000f6 ff04          .dw $ff04
0000f7 692b
0000f8 746e          .db "+int"
0000f9 00cd          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0000fa 00fb          .dw PFA_INTON
                 PFA_INTON:
0000fb 9478          sei
0000fc 940c 3804     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0000fe ff04          .dw $ff04
0000ff 692d
000100 746e          .db "-int"
000101 00f6          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000102 0103          .dw PFA_INTOFF
                 PFA_INTOFF:
000103 94f8          cli
000104 940c 3804     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000106 ff04          .dw $ff04
000107 6e69
000108 2174          .db "int!"
000109 00fe          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00010a 3800          .dw DO_COLON
                 PFA_INTSTORE:
00010b 3837          .dw XT_DOLITERAL
00010c 0115          .dw intvec
00010d 39a6          .dw XT_PLUS
00010e 387c          .dw XT_STORE
00010f 381a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000110 ff04          .dw $ff04
000111 6e69
000112 4074          .db "int@"
000113 0106          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000114 3800          .dw DO_COLON
                 PFA_INTFETCH:
000115 3837          .dw XT_DOLITERAL
000116 0115          .dw intvec
000117 39a6          .dw XT_PLUS
000118 3874          .dw XT_FETCH
000119 381a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00011a ff08          .dw $ff08
00011b 6e69
00011c 2d74
00011d 7274
00011e 7061          .db "int-trap"
00011f 0110          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000120 0121          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000121 9380 0114     sts intcur, tosl
000123 9189
000124 9199          loadtos
000125 9468          set ; set the interrupt flag for the inner interpreter
000126 940c 3804     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000128 3800          .dw DO_COLON
                 PFA_ISREXEC:
000129 3837          .dw XT_DOLITERAL
00012a 0114          .dw intcur
00012b 3893          .dw XT_CFETCH
00012c 3837          .dw XT_DOLITERAL
00012d 0115          .dw intvec
00012e 39a6          .dw XT_PLUS
00012f 3874          .dw XT_FETCH
000130 3824          .dw XT_EXECUTE
000131 0133          .dw XT_ISREND
000132 381a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000133 0134          .dw PFA_ISREND
                 PFA_ISREND:
000134 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000135 940c 3804     jmp_ DO_NEXT
                 PFA_ISREND1:
000137 9518          reti
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
000138 ff05          .dw $ff05
000139 5f66
00013a 7063
00013b 0075          .db "f_cpu",0
00013c 011a          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00013d 3869          .dw PFA_DOVALUE1
                 PFA_F_CPU:
00013e 0056          .dw EE_FCPU
00013f 0141          .dw XT_FETCH2E
000140 014a          .dw XT_STORE2E
                 
                 XT_FETCH2E:
000141 3800          .dw DO_COLON
                 PFA_FETCH2E:
000142 3bc7          .dw XT_FETCHI
000143 38ac          .dw XT_DUP
000144 0168          .dw XT_CELLPLUS
000145 3b5b          .dw XT_FETCHE
000146 38bf          .dw XT_SWAP
000147 3b5b          .dw XT_FETCHE
000148 38bf          .dw XT_SWAP
000149 381a          .dw XT_EXIT
                 
                 XT_STORE2E:
00014a 3800          .dw DO_COLON
                 PFA_STORE2E:
00014b 3837          .dw XT_DOLITERAL
00014c ffeb          .dw -21
00014d 04bf          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00014e ff05          .dw $ff05
00014f 7473
000150 7461
000151 0065          .db "state",0
000152 0138          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
000153 3842          .dw PFA_DOVARIABLE
                 PFA_STATE:
000154 016b          .dw ram_state
                 
                 .dseg
00016b           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
000155 ff04          .dw $ff04
000156 6162
000157 6573          .db "base"
000158 014e          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000159 3852          .dw PFA_DOUSER
                 PFA_BASE:
00015a 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00015b ff05          .dw $ff05
00015c 6563
00015d 6c6c
00015e 0073          .db "cells",0
00015f 0155          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
000160 3800          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
000161 3a14          .dw XT_2STAR
                 .else
                 .endif
000162 381a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
000163 ff05          .dw $ff05
000164 6563
000165 6c6c
000166 002b          .db "cell+",0
000167 015b          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000168 0169          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000169 9602          adiw tosl, CELLSIZE
00016a 940c 3804     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
00016c ff04          .dw $ff04
00016d 6432
00016e 7075          .db "2dup"
00016f 0163          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000170 3800          .dw DO_COLON
                 PFA_2DUP:
000171 38ca          .dw XT_OVER
000172 38ca          .dw XT_OVER
000173 381a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
000174 ff05          .dw $ff05
000175 6432
000176 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
000177 0070          .db "2drop"
000178 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000179 3800          .dw DO_COLON
                 PFA_2DROP:
00017a 38d4          .dw XT_DROP
00017b 38d4          .dw XT_DROP
00017c 381a          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
00017d ff03          .dw $ff03
00017e 693e
00017f 006e          .db ">in",0
000180 0174          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000181 3852          .dw PFA_DOUSER
                 PFA_G_IN:
000182 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
000183 ff04          .dw $ff04
000184 7423
000185 6269          .db "#tib"
000186 017d          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000187 3842          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000188 016d          .dw ram_sharptib
                 
                 .dseg
00016d           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000189 ff03          .dw $ff03
00018a 6170
00018b 0064          .db "pad",0
00018c 0183          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00018d 3800          .dw DO_COLON
                 PFA_PAD:
00018e 01c7          .dw XT_HERE
00018f 3837          .dw XT_DOLITERAL
000190 0064          .dw 100
000191 39a6          .dw XT_PLUS
000192 381a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
000193 ff04          .dw $ff04
000194 6d65
000195 7469          .db "emit"
000196 0189          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000197 0832          .dw PFA_DODEFER
                 PFA_EMIT:
000198 000e          .dw USER_EMIT
000199 080a          .dw XT_UDEFERFETCH
00019a 0811          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00019b ff05          .dw $ff05
00019c 6d65
00019d 7469
00019e 003f          .db "emit?",0
00019f 0193          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0001a0 0832          .dw PFA_DODEFER
                 PFA_EMITQ:
0001a1 0010          .dw USER_EMITQ
0001a2 080a          .dw XT_UDEFERFETCH
0001a3 0811          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
0001a4 ff03          .dw $ff03
0001a5 656b
0001a6 0079          .db "key",0
0001a7 019b          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0001a8 0832          .dw PFA_DODEFER
                 PFA_KEY:
0001a9 0012          .dw USER_KEY
0001aa 080a          .dw XT_UDEFERFETCH
0001ab 0811          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
0001ac ff04          .dw $ff04
0001ad 656b
0001ae 3f79          .db "key?"
0001af 01a4          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0001b0 0832          .dw PFA_DODEFER
                 PFA_KEYQ:
0001b1 0014          .dw USER_KEYQ
0001b2 080a          .dw XT_UDEFERFETCH
0001b3 0811          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0001b4 ff02          .dw $ff02
0001b5 7064          .db "dp"
0001b6 01ac          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0001b7 3869          .dw PFA_DOVALUE1
                 PFA_DP:
0001b8 0002          .dw EE_DP
0001b9 3d5a          .dw XT_EVALUEFETCH
0001ba 3d5e          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
0001bb ff03          .dw $ff03
0001bc 6465
0001bd 0070          .db "edp",0
0001be 01b4          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
0001bf 3869          .dw PFA_DOVALUE1
                 PFA_EDP:
0001c0 0006          .dw EE_EDP
0001c1 3d5a          .dw XT_EVALUEFETCH
0001c2 3d5e          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0001c3 ff04          .dw $ff04
0001c4 6568
0001c5 6572          .db "here"
0001c6 01bb          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0001c7 3869          .dw PFA_DOVALUE1
                 PFA_HERE:
0001c8 0004          .dw EE_HERE
0001c9 3d5a          .dw XT_EVALUEFETCH
0001ca 3d5e          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0001cb ff05          .dw $ff05
0001cc 6c61
0001cd 6f6c
0001ce 0074          .db "allot",0
0001cf 01c3          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0001d0 3800          .dw DO_COLON
                 PFA_ALLOT:
0001d1 01c7          .dw XT_HERE
0001d2 39a6          .dw XT_PLUS
0001d3 07ea          .dw XT_DOTO
0001d4 01c8          .dw PFA_HERE
0001d5 381a          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
0001d6 ff08          .dw $ff08
0001d7 6328
0001d8 6572
0001d9 7461
0001da 2965          .db "(create)"
0001db 01cb          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001dc 3800          .dw DO_COLON
                 PFA_DOCREATE:
0001dd 064f          .dw XT_PARSENAME
0001de 3caa          .dw XT_WLSCOPE
0001df 38ac          .dw XT_DUP
0001e0 38f3          .dw XT_TO_R
0001e1 3c8f          .dw XT_HEADER
0001e2 38ea          .dw XT_R_FROM
                 .dseg
00016f           COLON_SMUDGE: .byte 4
                 .cseg
0001e3 3837          .dw XT_DOLITERAL
0001e4 0171          .dw COLON_SMUDGE+2
0001e5 387c          .dw XT_STORE		; save wid
0001e6 3837          .dw XT_DOLITERAL
0001e7 016f          .dw COLON_SMUDGE+0
0001e8 387c          .dw XT_STORE		; save NFA
                 
0001e9 381a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
0001ea 0001          .dw $0001
0001eb 005c          .db "\",0
0001ec 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001ed 3800          .dw DO_COLON
                 PFA_BACKSLASH:
0001ee 0634          .dw XT_SOURCE
0001ef 38bf          .dw XT_SWAP
0001f0 38d4          .dw XT_DROP
0001f1 0181          .dw XT_G_IN
0001f2 387c          .dw XT_STORE
0001f3 381a          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
0001f4 0001          .dw $0001
0001f5 0028          .db "(" ,0
0001f6 01ea          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
0001f7 3800          .dw DO_COLON
                 PFA_LPARENTHESIS:
0001f8 3837          .dw XT_DOLITERAL
0001f9 0029          .dw $29
0001fa 0600          .dw XT_PARSE
0001fb 0179          .dw XT_2DROP
0001fc 381a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
0001fd ff07          .dw $ff07
0001fe 6f63
0001ff 706d
000200 6c69
000201 0065          .db "compile",0
000202 01f4          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000203 3800          .dw DO_COLON
                 PFA_COMPILE:
000204 38ea          .dw XT_R_FROM
000205 38ac          .dw XT_DUP
000206 3a38          .dw XT_1PLUS
000207 38f3          .dw XT_TO_R
000208 3bc7          .dw XT_FETCHI
000209 020e          .dw XT_COMMA
00020a 381a          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
00020b ff01          .dw $ff01
00020c 002c          .db ',',0 ; ,
00020d 01fd          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
00020e 3800          .dw DO_COLON
                 PFA_COMMA:
00020f 01b7          .dw XT_DP
000210 3b6f          .dw XT_STOREI
000211 01b7          .dw XT_DP
000212 3a38          .dw XT_1PLUS
000213 07ea          .dw XT_DOTO
000214 01b8          .dw PFA_DP
000215 381a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
000216 0003          .dw $0003
000217 275b
000218 005d          .db "[']",0
000219 020b          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
00021a 3800          .dw DO_COLON
                 PFA_BRACKETTICK:
00021b 0203          .dw XT_COMPILE
00021c 3837          .dw XT_DOLITERAL
00021d 0492          .dw XT_TICK
00021e 020e          .dw XT_COMMA
00021f 381a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
000220 ff03          .dw $ff03
000221 6962
000222 006e          .db "bin",0
000223 0216          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
000224 3800          .dw DO_COLON
                 PFA_BIN:
000225 3837          .dw XT_DOLITERAL
000226 0002          .dw 2
000227 0159          .dw XT_BASE
000228 387c          .dw XT_STORE
000229 381a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
00022a ff07          .dw $ff07
00022b 6564
00022c 6963
00022d 616d
00022e 006c          .db "decimal",0
00022f 0220          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000230 3800          .dw DO_COLON
                 PFA_DECIMAL:
000231 3837          .dw XT_DOLITERAL
000232 000a          .dw 10
000233 0159          .dw XT_BASE
000234 387c          .dw XT_STORE
000235 381a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
000236 ff03          .dw $ff03
000237 6568
000238 0078          .db "hex",0
000239 022a          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00023a 3800          .dw DO_COLON
                 PFA_HEX:
00023b 3837          .dw XT_DOLITERAL
00023c 0010          .dw 16
00023d 0159          .dw XT_BASE
00023e 387c          .dw XT_STORE
00023f 381a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
000240 ff02          .dw $ff02
000241 6c62          .db "bl"
000242 0236          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000243 3842          .dw PFA_DOVARIABLE
                 PFA_BL:
000244 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000245 ff07          .dw $ff07
000246 7574
000247 6e72
000248 656b
000249 0079          .db "turnkey",0
00024a 0240          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00024b 0832          .dw PFA_DODEFER
                 PFA_TURNKEY:
00024c 0008          .dw EE_TURNKEY
00024d 07f6          .dw XT_EDEFERFETCH
00024e 07fb          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
00024f ff05          .dw $ff05
000250 2f2a
000251 6f6d
000252 0064          .db "*/mod",0
000253 0245          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
000254 3800          .dw DO_COLON
                 PFA_STARSLASHMOD:
000255 38f3          .dw XT_TO_R
000256 39af          .dw XT_MSTAR
000257 38ea          .dw XT_R_FROM
000258 39cb          .dw XT_UMSLASHMOD
000259 381a          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00025a ff04          .dw $ff04
00025b 6d2f
00025c 646f          .db "/mod"
00025d 024f          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00025e 025f          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00025f 019c          movw temp2, tosl
                     
000260 9109          ld temp0, Y+
000261 9119          ld temp1, Y+
                 
000262 2f41          mov	temp6,temp1	;move dividend High to sign register
000263 2743          eor	temp6,temp3	;xor divisor High with sign register
000264 ff17          sbrs	temp1,7	;if MSB in dividend set
000265 c004          rjmp	PFA_SLASHMOD_1
000266 9510          com	temp1		;    change sign of dividend
000267 9500          com	temp0		
000268 5f0f          subi	temp0,low(-1)
000269 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00026a ff37          sbrs	temp3,7	;if MSB in divisor set
00026b c004          rjmp	PFA_SLASHMOD_2
00026c 9530          com	temp3		;    change sign of divisor
00026d 9520          com	temp2		
00026e 5f2f          subi	temp2,low(-1)
00026f 4f3f          sbci	temp3,high(-1)
000270 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000271 18ff          sub	temp5,temp5;clear remainder High byte and carry
000272 e151          ldi	temp7,17	;init loop counter
                 
000273 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000274 1f11          rol	temp1
000275 955a          dec	temp7		;decrement counter
000276 f439          brne	PFA_SLASHMOD_5		;if done
000277 ff47          sbrs	temp6,7		;    if MSB in sign register set
000278 c004          rjmp	PFA_SLASHMOD_4
000279 9510          com	temp1	;        change sign of result
00027a 9500          com	temp0
00027b 5f0f          subi	temp0,low(-1)
00027c 4f1f          sbci	temp1,high(-1)
00027d c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00027e 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00027f 1cff          rol	temp5
000280 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000281 0af3          sbc	temp5,temp3	;
000282 f420          brcc	PFA_SLASHMOD_6		;if result negative
000283 0ee2          add	temp4,temp2	;    restore remainder
000284 1ef3          adc	temp5,temp3
000285 9488          clc			;    clear carry to be shifted into result
000286 cfec          rjmp	PFA_SLASHMOD_3		;else
000287 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000288 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000289 92fa          st -Y,temp5
00028a 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00028b 01c8          movw tosl, temp0
00028c 940c 3804     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
00028e ff02          .dw $ff02
00028f 2f2a          .db "*/"
000290 025a          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000291 3800          .dw DO_COLON
                 PFA_STARSLASH:
000292 0254          .dw XT_STARSLASHMOD
000293 38bf          .dw XT_SWAP
000294 38d4          .dw XT_DROP
000295 381a          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000296 ff05          .dw $ff05
000297 2f75
000298 6f6d
000299 0064          .db "u/mod",0
00029a 028e          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00029b 3800          .dw DO_COLON
                 PFA_USLASHMOD:
00029c 38f3          .dw XT_TO_R
00029d 3934          .dw XT_ZERO
00029e 38ea          .dw XT_R_FROM
00029f 39cb          .dw XT_UMSLASHMOD
0002a0 381a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
0002a1 ff06          .dw $ff06
0002a2 656e
0002a3 6167
0002a4 6574          .db "negate"
0002a5 0296          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
0002a6 3800          .dw DO_COLON
                 PFA_NEGATE:
0002a7 3a06          .dw XT_INVERT
0002a8 3a38          .dw XT_1PLUS
0002a9 381a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
0002aa ff01          .dw $ff01
0002ab 002f          .db "/",0
0002ac 02a1          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
0002ad 3800          .dw DO_COLON
                 PFA_SLASH:
0002ae 025e          .dw XT_SLASHMOD
0002af 38bf          .dw XT_SWAP
0002b0 38d4          .dw XT_DROP
0002b1 381a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
0002b2 ff03          .dw $ff03
0002b3 6f6d
0002b4 0064          .db "mod",0
0002b5 02aa          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0002b6 3800          .dw DO_COLON
                 PFA_MOD:
0002b7 025e          .dw XT_SLASHMOD
0002b8 38d4          .dw XT_DROP
0002b9 381a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
0002ba ff03          .dw $ff03
0002bb 6261
0002bc 0073          .db "abs",0
0002bd 02b2          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
0002be 02bf          .dw PFA_ABS
                 PFA_ABS:
0002bf 2399          tst tosh
0002c0 f41a          brpl PFA_ABS1
0002c1 9580          com tosl
0002c2 9590          com tosh
0002c3 9601          adiw tosl, 1
                 PFA_ABS1:
0002c4 940c 3804     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
0002c6 ff03          .dw $ff03
0002c7 696d
0002c8 006e          .db "min",0
0002c9 02ba          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
0002ca 3800          .dw DO_COLON
                 PFA_MIN:
0002cb 0170          .dw XT_2DUP
0002cc 3926          .dw XT_GREATER
0002cd 3830          .dw XT_DOCONDBRANCH
0002ce 02d0          .dw PFA_MIN1
0002cf 38bf          .dw XT_SWAP
                 PFA_MIN1:
0002d0 38d4          .dw XT_DROP
0002d1 381a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
0002d2 ff03          .dw $ff03
0002d3 616d
0002d4 0078          .db "max",0
0002d5 02c6          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
0002d6 3800          .dw DO_COLON
                 PFA_MAX:
0002d7 0170          .dw XT_2DUP
0002d8 391f          .dw XT_LESS
0002d9 3830          .dw XT_DOCONDBRANCH
0002da 02dc          .dw PFA_MAX1
0002db 38bf          .dw XT_SWAP
                 PFA_MAX1:
0002dc 38d4          .dw XT_DROP
0002dd 381a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
0002de ff06          .dw $ff06
0002df 6977
0002e0 6874
0002e1 6e69          .db "within"
0002e2 02d2          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
0002e3 3800          .dw DO_COLON
                 PFA_WITHIN:
0002e4 38ca          .dw XT_OVER
0002e5 399c          .dw XT_MINUS
0002e6 38f3          .dw XT_TO_R
0002e7 399c          .dw XT_MINUS
0002e8 38ea          .dw XT_R_FROM
0002e9 3946          .dw XT_ULESS
0002ea 381a          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
0002eb ff07          .dw $ff07 
0002ec 6f74
0002ed 7075
0002ee 6570
0002ef 0072          .db "toupper",0
0002f0 02de          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0002f1 3800          .dw DO_COLON 
                 PFA_TOUPPER:
0002f2 38ac          .dw XT_DUP 
0002f3 3837          .dw XT_DOLITERAL 
0002f4 0061          .dw 'a' 
0002f5 3837          .dw XT_DOLITERAL 
0002f6 007b          .dw 'z'+1
0002f7 02e3          .dw XT_WITHIN 
0002f8 3830          .dw XT_DOCONDBRANCH
0002f9 02fd          .dw PFA_TOUPPER0 
0002fa 3837          .dw XT_DOLITERAL
0002fb 00df          .dw $df ; inverse of 0x20
0002fc 3a1c          .dw XT_AND 
                 PFA_TOUPPER0:
0002fd 381a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
0002fe ff07          .dw $ff07
0002ff 6f74
000300 6f6c
000301 6577
000302 0072          .db "tolower",0
000303 02eb          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000304 3800          .dw DO_COLON
                 PFA_TOLOWER:
000305 38ac          .dw XT_DUP
000306 3837          .dw XT_DOLITERAL
000307 0041          .dw 'A'
000308 3837          .dw XT_DOLITERAL
000309 005b          .dw 'Z'+1
00030a 02e3          .dw XT_WITHIN
00030b 3830          .dw XT_DOCONDBRANCH
00030c 0310          .dw PFA_TOLOWER0 
00030d 3837          .dw XT_DOLITERAL
00030e 0020          .dw $20 
00030f 3a25          .dw XT_OR 
                 PFA_TOLOWER0:
000310 381a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000311 ff03          .dw $ff03
000312 6c68
000313 0064          .db "hld",0
000314 02fe          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000315 3842          .dw PFA_DOVARIABLE
                 PFA_HLD:
000316 0173          .dw ram_hld
                 
                 .dseg
000173           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
000317 ff04          .dw $ff04
000318 6f68
000319 646c          .db "hold"
00031a 0311          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00031b 3800          .dw DO_COLON
                 PFA_HOLD:
00031c 0315          .dw XT_HLD
00031d 38ac          .dw XT_DUP
00031e 3874          .dw XT_FETCH
00031f 3a3e          .dw XT_1MINUS
000320 38ac          .dw XT_DUP
000321 38f3          .dw XT_TO_R
000322 38bf          .dw XT_SWAP
000323 387c          .dw XT_STORE
000324 38ea          .dw XT_R_FROM
000325 3888          .dw XT_CSTORE
000326 381a          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
000327 ff02          .dw $ff02
000328 233c          .db "<#"
000329 0317          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00032a 3800          .dw DO_COLON
                 PFA_L_SHARP:
00032b 018d          .dw XT_PAD
00032c 0315          .dw XT_HLD
00032d 387c          .dw XT_STORE
00032e 381a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
00032f ff01          .dw $ff01
000330 0023          .db "#",0
000331 0327          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000332 3800          .dw DO_COLON
                 PFA_SHARP:
000333 0159          .dw XT_BASE
000334 3874          .dw XT_FETCH
000335 03b1          .dw XT_UDSLASHMOD
000336 38dc          .dw XT_ROT
000337 3837          .dw XT_DOLITERAL
000338 0009          .dw 9
000339 38ca          .dw XT_OVER
00033a 391f          .dw XT_LESS
00033b 3830          .dw XT_DOCONDBRANCH
00033c 0340          .dw PFA_SHARP1
00033d 3837          .dw XT_DOLITERAL
00033e 0007          .dw 7
00033f 39a6          .dw XT_PLUS
                 PFA_SHARP1:
000340 3837          .dw XT_DOLITERAL
000341 0030          .dw $30
000342 39a6          .dw XT_PLUS
000343 031b          .dw XT_HOLD
000344 381a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
000345 ff02          .dw $ff02
000346 7323          .db "#s"
000347 032f          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000348 3800          .dw DO_COLON
                 PFA_SHARP_S:
000349 0332          .dw XT_SHARP
00034a 0170          .dw XT_2DUP
00034b 3a25          .dw XT_OR
00034c 3918          .dw XT_EQUALZERO
00034d 3830          .dw XT_DOCONDBRANCH
00034e 0349          .dw PFA_SHARP_S
00034f 381a          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
000350 ff02          .dw $ff02
000351 3e23          .db "#>"
000352 0345          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000353 3800          .dw DO_COLON
                 PFA_SHARP_G:
000354 0179          .dw XT_2DROP
000355 0315          .dw XT_HLD
000356 3874          .dw XT_FETCH
000357 38ac          .dw XT_DUP
000358 018d          .dw XT_PAD
000359 38bf          .dw XT_SWAP
00035a 399c          .dw XT_MINUS
00035b 381a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
00035c ff04          .dw $ff04
00035d 6973
00035e 6e67          .db "sign"
00035f 0350          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000360 3800          .dw DO_COLON
                 PFA_SIGN:
000361 392d          .dw XT_LESSZERO
000362 3830          .dw XT_DOCONDBRANCH
000363 0367          .dw PFA_SIGN1
000364 3837          .dw XT_DOLITERAL
000365 002d          .dw $2d
000366 031b          .dw XT_HOLD
                 PFA_SIGN1:
000367 381a          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
000368 ff03          .dw $ff03
000369 2e64
00036a 0072          .db "d.r",0
00036b 035c          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00036c 3800          .dw DO_COLON
                 PFA_DDOTR:
00036d 38f3          .dw XT_TO_R
00036e 38bf          .dw XT_SWAP
00036f 38ca          .dw XT_OVER
000370 0903          .dw XT_DABS
000371 032a          .dw XT_L_SHARP
000372 0348          .dw XT_SHARP_S
000373 38dc          .dw XT_ROT
000374 0360          .dw XT_SIGN
000375 0353          .dw XT_SHARP_G
000376 38ea          .dw XT_R_FROM
000377 38ca          .dw XT_OVER
000378 399c          .dw XT_MINUS
000379 0474          .dw XT_SPACES
00037a 0483          .dw XT_TYPE
00037b 381a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
00037c ff02          .dw $ff02
00037d 722e          .db ".r"
00037e 0368          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00037f 3800          .dw DO_COLON
                 PFA_DOTR:
000380 38f3          .dw XT_TO_R
000381 3b29          .dw XT_S2D
000382 38ea          .dw XT_R_FROM
000383 036c          .dw XT_DDOTR
000384 381a          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
000385 ff02          .dw $ff02
000386 2e64          .db "d."
000387 037c          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000388 3800          .dw DO_COLON
                 PFA_DDOT:
000389 3934          .dw XT_ZERO
00038a 036c          .dw XT_DDOTR
00038b 046b          .dw XT_SPACE
00038c 381a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
00038d ff01          .dw $ff01
00038e 002e          .db ".",0
00038f 0385          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000390 3800          .dw DO_COLON
                 PFA_DOT:
000391 3b29          .dw XT_S2D
000392 0388          .dw XT_DDOT
000393 381a          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
000394 ff03          .dw $ff03
000395 6475
000396 002e          .db "ud.",0
000397 038d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000398 3800          .dw DO_COLON
                 PFA_UDDOT:
000399 3934          .dw XT_ZERO
00039a 03a1          .dw XT_UDDOTR
00039b 046b          .dw XT_SPACE
00039c 381a          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
00039d ff04          .dw $ff04
00039e 6475
00039f 722e          .db "ud.r"
0003a0 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
0003a1 3800          .dw DO_COLON
                 PFA_UDDOTR:
0003a2 38f3          .dw XT_TO_R
0003a3 032a          .dw XT_L_SHARP
0003a4 0348          .dw XT_SHARP_S
0003a5 0353          .dw XT_SHARP_G
0003a6 38ea          .dw XT_R_FROM
0003a7 38ca          .dw XT_OVER
0003a8 399c          .dw XT_MINUS
0003a9 0474          .dw XT_SPACES
0003aa 0483          .dw XT_TYPE
0003ab 381a          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
0003ac ff06          .dw $ff06
0003ad 6475
0003ae 6d2f
0003af 646f          .db "ud/mod"
0003b0 039d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0003b1 3800          .dw DO_COLON
                 PFA_UDSLASHMOD:
0003b2 38f3          .dw XT_TO_R
0003b3 3934          .dw XT_ZERO
0003b4 38fc          .dw XT_R_FETCH
0003b5 39cb          .dw XT_UMSLASHMOD
0003b6 38ea          .dw XT_R_FROM
0003b7 38bf          .dw XT_SWAP
0003b8 38f3          .dw XT_TO_R
0003b9 39cb          .dw XT_UMSLASHMOD
0003ba 38ea          .dw XT_R_FROM
0003bb 381a          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
0003bc ff06          .dw $ff06 
0003bd 6964
0003be 6967
0003bf 3f74          .db "digit?"
0003c0 03ac          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0003c1 3800          .dw DO_COLON 
                 PFA_DIGITQ:
0003c2 02f1          .dw XT_TOUPPER
0003c3 3837          .dw XT_DOLITERAL 
0003c4 0030          .dw $30 
0003c5 399c          .dw XT_MINUS 
0003c6 38ac          .dw XT_DUP 
0003c7 3837          .dw XT_DOLITERAL
0003c8 0009          .dw $09 
0003c9 3951          .dw XT_UGREATER 
0003ca 3830          .dw XT_DOCONDBRANCH
0003cb 03d8          .dw PFA_DIGITQ0 
0003cc 3837          .dw XT_DOLITERAL
0003cd 0007          .dw $07 
0003ce 399c          .dw XT_MINUS 
0003cf 38ac          .dw XT_DUP 
0003d0 3837          .dw XT_DOLITERAL
0003d1 0009          .dw $09 
0003d2 03e7          .dw XT_ULESSEQUAL
0003d3 3830          .dw XT_DOCONDBRANCH
0003d4 03d8          .dw PFA_DIGITQ1 
0003d5 38d4          .dw XT_DROP 
0003d6 3934          .dw XT_ZERO
0003d7 381a          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
0003d8 38ac          .dw XT_DUP 
0003d9 0159          .dw XT_BASE 
0003da 3874          .dw XT_FETCH 
0003db 03ef          .dw XT_UGREATEREQUAL
0003dc 3830          .dw XT_DOCONDBRANCH
0003dd 03e1          .dw PFA_DIGITQ2 
0003de 38d4          .dw XT_DROP 
0003df 3934          .dw XT_ZERO
0003e0 381a          .dw XT_EXIT 
                 PFA_DIGITQ2:
0003e1 393d          .dw XT_TRUE
0003e2 381a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
0003e3 ff03          .dw $ff03 
0003e4 3c75
0003e5 003d          .db "u<=",0
0003e6 03bc          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
0003e7 3800          .dw DO_COLON 
                 PFA_ULESSEQUAL:
0003e8 3951          .dw XT_UGREATER 
0003e9 3a06          .dw XT_INVERT 
0003ea 381a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
0003eb ff03          .dw $ff03 
0003ec 3e75
0003ed 003d          .db "u>=",0
0003ee 03e3          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
0003ef 3800          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
0003f0 3946          .dw XT_ULESS 
0003f1 3a06          .dw XT_INVERT 
0003f2 381a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003f3 3800        .dw DO_COLON
                 PFA_DOSLITERAL:
0003f4 38ea        .dw XT_R_FROM   ; ( -- addr )
0003f5 38ac        .dw XT_DUP      ; ( -- addr addr )
0003f6 38ac        .dw XT_DUP
0003f7 3bc7        .dw XT_FETCHI   ; ( -- addr addr n )
0003f8 38bf        .dw XT_SWAP
0003f9 3a38        .dw XT_1PLUS
0003fa 38bf        .dw XT_SWAP
0003fb 38dc        .dw XT_ROT      ; ( -- addr' n addr )
0003fc 38ca        .dw XT_OVER     ; ( -- addr' n addr n)
0003fd 3a38        .dw XT_1PLUS
0003fe 3a0d        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003ff 39a6        .dw XT_PLUS     ; ( -- addr' n addr'' )
000400 3a38        .dw XT_1PLUS
000401 38f3        .dw XT_TO_R     ; ( -- )
000402 381a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000403 ff02        .dw $ff02
000404 2c73        .db "s",$2c
000405 03eb        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000406 3800          .dw DO_COLON
                 PFA_SCOMMA:
000407 38ac          .dw XT_DUP
000408 040a          .dw XT_DOSCOMMA
000409 381a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00040a 3800          .dw DO_COLON
                 PFA_DOSCOMMA:
00040b 020e          .dw XT_COMMA
00040c 38ac          .dw XT_DUP   ; ( --addr len len)
00040d 3a0d          .dw XT_2SLASH ; ( -- addr len len/2
00040e 38bf          .dw XT_SWAP   ; ( -- addr len/2 len
00040f 38ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
000410 3a14          .dw XT_2STAR  ; ( -- addr len/2 len len'
000411 399c          .dw XT_MINUS  ; ( -- addr len/2 rem
000412 38f3          .dw XT_TO_R
000413 3934          .dw XT_ZERO
000414 3aaa          .dw XT_DOQDO
000415 041c          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
000416 38ac          .dw XT_DUP         ; ( -- addr addr )
000417 3874          .dw XT_FETCH       ; ( -- addr c1c2 )
000418 020e          .dw XT_COMMA       ; ( -- addr )
000419 0168          .dw XT_CELLPLUS    ; ( -- addr+cell )
00041a 3ad8          .dw XT_DOLOOP
00041b 0416          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00041c 38ea          .dw XT_R_FROM
00041d 395c          .dw XT_GREATERZERO
00041e 3830          .dw XT_DOCONDBRANCH
00041f 0423          .dw PFA_SCOMMA3
000420 38ac            .dw XT_DUP     ; well, tricky
000421 3893            .dw XT_CFETCH
000422 020e            .dw XT_COMMA
                 PFA_SCOMMA3:
000423 38d4          .dw XT_DROP        ; ( -- )
000424 381a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000425 ff05          .dw $ff05
000426 7469
000427 7079
000428 0065          .db "itype",0
000429 0403          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00042a 3800          .dw DO_COLON
                 PFA_ITYPE:
00042b 38ac          .dw XT_DUP    ; ( --addr len len)
00042c 3a0d          .dw XT_2SLASH ; ( -- addr len len/2
00042d 38bf          .dw XT_SWAP   ; ( -- addr len/2 len
00042e 38ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
00042f 3a14          .dw XT_2STAR  ; ( -- addr len/2 len len'
000430 399c          .dw XT_MINUS  ; ( -- addr len/2 rem
000431 38f3          .dw XT_TO_R
000432 3934          .dw XT_ZERO
000433 3aaa          .dw XT_DOQDO
000434 043d          .dw PFA_ITYPE2
                 PFA_ITYPE1:
000435 38ac          .dw XT_DUP         ; ( -- addr addr )
000436 3bc7          .dw XT_FETCHI      ; ( -- addr c1c2 )
000437 38ac          .dw XT_DUP
000438 044a          .dw XT_LOWEMIT
000439 0446          .dw XT_HIEMIT
00043a 3a38          .dw XT_1PLUS    ; ( -- addr+cell )
00043b 3ad8          .dw XT_DOLOOP
00043c 0435          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00043d 38ea          .dw XT_R_FROM
00043e 395c          .dw XT_GREATERZERO
00043f 3830          .dw XT_DOCONDBRANCH
000440 0444          .dw PFA_ITYPE3
000441 38ac            .dw XT_DUP     ; make sure the drop below has always something to do
000442 3bc7            .dw XT_FETCHI
000443 044a            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000444 38d4          .dw XT_DROP
000445 381a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000446 3800          .dw DO_COLON
                 PFA_HIEMIT:
000447 3b0e          .dw XT_BYTESWAP
000448 044a          .dw XT_LOWEMIT
000449 381a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00044a 3800          .dw DO_COLON
                 PFA_LOWEMIT:
00044b 3837          .dw XT_DOLITERAL
00044c 00ff          .dw $00ff
00044d 3a1c          .dw XT_AND
00044e 0197          .dw XT_EMIT
00044f 381a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000450 ff06          .dw $ff06
000451 6369
000452 756f
000453 746e          .db "icount"
000454 0425          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000455 3800          .dw DO_COLON
                 PFA_ICOUNT:
000456 38ac          .dw XT_DUP
000457 3a38          .dw XT_1PLUS
000458 38bf          .dw XT_SWAP
000459 3bc7          .dw XT_FETCHI
00045a 381a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
00045b ff02          .dw $ff02
00045c 7263          .db "cr"
00045d 0450          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00045e 3800          .dw DO_COLON
                 PFA_CR:
00045f 3837          .dw XT_DOLITERAL
000460 000d          .dw 13
000461 0197          .dw XT_EMIT
000462 3837          .dw XT_DOLITERAL
000463 000a          .dw 10
000464 0197          .dw XT_EMIT
000465 381a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
000466 ff05          .dw $ff05
000467 7073
000468 6361
000469 0065          .db "space",0
00046a 045b          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00046b 3800          .dw DO_COLON
                 PFA_SPACE:
00046c 0243          .dw XT_BL
00046d 0197          .dw XT_EMIT
00046e 381a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
00046f ff06          .dw $ff06
000470 7073
000471 6361
000472 7365          .db "spaces"
000473 0466          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000474 3800          .dw DO_COLON
                 PFA_SPACES:
000475 38ac          .dw XT_DUP
000476 395c          .dw XT_GREATERZERO
000477 3a1c          .dw XT_AND
000478 3934          .dw XT_ZERO
000479 3aaa          .dw XT_DOQDO
00047a 047e          .dw PFA_SPACES2
                 PFA_SPACES1:
00047b 046b          .dw XT_SPACE
00047c 3ad8          .dw XT_DOLOOP
00047d 047b          .dw PFA_SPACES1
                 PFA_SPACES2:
00047e 381a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
00047f ff04          .dw $ff04
000480 7974
000481 6570          .db "type"
000482 046f          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000483 3800          .dw DO_COLON
                 PFA_TYPE:
000484 38ca          .dw XT_OVER
000485 39a6          .dw XT_PLUS
000486 38bf          .dW XT_SWAP
000487 3aaa          .dw XT_DOQDO
000488 048e          .dw PFA_TYPE2
                 PFA_TYPE1:
000489 3abd          .dw XT_I
00048a 3893          .dw XT_CFETCH
00048b 0197          .dw XT_EMIT
00048c 3ad8          .dw XT_DOLOOP
00048d 0489          .dw PFA_TYPE1
                 PFA_TYPE2:
00048e 381a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
00048f ff01          .dw $ff01
000490 0027          .db "'",0
000491 047f          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000492 3800          .dw DO_COLON
                 PFA_TICK:
000493 064f          .dw XT_PARSENAME
000494 066c          .dw XT_FINDNAME
000495 3918          .dw XT_EQUALZERO
000496 3830          .dw XT_DOCONDBRANCH
000497 049b          .dw PFA_TICK1
000498 3837          .dw XT_DOLITERAL
000499 fff3          .dw -13
00049a 04bf          .dw XT_THROW
                 PFA_TICK1:
00049b 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
00049c ff07          .dw $ff07
00049d 6168
00049e 646e
00049f 656c
0004a0 0072          .db "handler",0
0004a1 048f          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
0004a2 3852          .dw PFA_DOUSER
                 PFA_HANDLER:
0004a3 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
0004a4 ff05          .dw $ff05
0004a5 6163
0004a6 6374
0004a7 0068          .db "catch",0
0004a8 049c          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
0004a9 3800          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
0004aa 3a8a          .dw XT_SP_FETCH
0004ab 38f3          .dw XT_TO_R
                     ; handler @ >r
0004ac 04a2          .dw XT_HANDLER
0004ad 3874          .dw XT_FETCH
0004ae 38f3          .dw XT_TO_R
                     ; rp@ handler !
0004af 3a73          .dw XT_RP_FETCH
0004b0 04a2          .dw XT_HANDLER
0004b1 387c          .dw XT_STORE
0004b2 3824          .dw XT_EXECUTE
                     ; r> handler !
0004b3 38ea          .dw XT_R_FROM
0004b4 04a2          .dw XT_HANDLER
0004b5 387c          .dw XT_STORE
0004b6 38ea          .dw XT_R_FROM
0004b7 38d4          .dw XT_DROP
0004b8 3934          .dw XT_ZERO
0004b9 381a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
0004ba ff05          .dw $ff05
0004bb 6874
0004bc 6f72
0004bd 0077          .db "throw",0
0004be 04a4          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
0004bf 3800          .dw DO_COLON
                 PFA_THROW:
0004c0 38ac          .dw XT_DUP
0004c1 3918          .dw XT_EQUALZERO
0004c2 3830          .dw XT_DOCONDBRANCH
0004c3 04c6          .dw PFA_THROW1
0004c4 38d4      	.dw XT_DROP
0004c5 381a      	.dw XT_EXIT
                 PFA_THROW1:
0004c6 04a2          .dw XT_HANDLER
0004c7 3874          .dw XT_FETCH
0004c8 3a7d          .dw XT_RP_STORE
0004c9 38ea          .dw XT_R_FROM
0004ca 04a2          .dw XT_HANDLER
0004cb 387c          .dw XT_STORE
0004cc 38ea          .dw XT_R_FROM
0004cd 38bf          .dw XT_SWAP
0004ce 38f3          .dw XT_TO_R
0004cf 3a93          .dw XT_SP_STORE
0004d0 38d4          .dw XT_DROP
0004d1 38ea          .dw XT_R_FROM    
0004d2 381a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
0004d3 ff05          .dw $ff05
0004d4 7363
0004d5 696b
0004d6 0070          .db "cskip",0
0004d7 04ba          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
0004d8 3800          .dw DO_COLON
                 PFA_CSKIP:
0004d9 38f3          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0004da 38ac          .dw XT_DUP            ; ( -- addr' n' n' )
0004db 3830          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0004dc 04e8          .dw PFA_CSKIP2
0004dd 38ca          .dw XT_OVER           ; ( -- addr' n' addr' )
0004de 3893          .dw XT_CFETCH         ; ( -- addr' n' c' )
0004df 38fc          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0004e0 3911          .dw XT_EQUAL          ; ( -- addr' n' f )
0004e1 3830          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0004e2 04e8          .dw PFA_CSKIP2
0004e3 3837          .dw XT_DOLITERAL
0004e4 0001          .dw 1
0004e5 063e          .dw XT_SLASHSTRING
0004e6 3829          .dw XT_DOBRANCH
0004e7 04da          .dw PFA_CSKIP1
                 PFA_CSKIP2:
0004e8 38ea          .dw XT_R_FROM
0004e9 38d4          .dw XT_DROP           ; ( -- addr2 n2)
0004ea 381a          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
0004eb ff06          .dw $ff06
0004ec 6361
0004ed 6563
0004ee 7470          .db "accept"
0004ef 04d3          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0004f0 3800          .dw DO_COLON
                 PFA_ACCEPT:
0004f1 38ac          .dw XT_DUP        ; ( -- addr n1 n1)
0004f2 38f3          .dw XT_TO_R
0004f3 38f3          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
0004f4 01a8          .dw XT_KEY        ; ( -- addr k )
0004f5 38ac          .dw XT_DUP        ; ( -- addr k k )
0004f6 3837          .dw XT_DOLITERAL
0004f7 000a          .dw 10
0004f8 3907          .dw XT_NOTEQUAL
0004f9 3830          .dw XT_DOCONDBRANCH
0004fa 052e          .dw PFA_ACCEPT2
0004fb 38ac          .dw XT_DUP
0004fc 3837          .dw XT_DOLITERAL
0004fd 000d          .dw 13
0004fe 3907          .dw XT_NOTEQUAL
0004ff 3830          .dw XT_DOCONDBRANCH
000500 052e          .dw PFA_ACCEPT2
                     ; check backspace
000501 38ac          .dw XT_DUP
000502 3837          .dw XT_DOLITERAL
000503 0008          .dw 8
000504 3911          .dw XT_EQUAL
000505 3830          .dw XT_DOCONDBRANCH
000506 051a          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
000507 38ea          .dw XT_R_FROM             ; ( -- addr k n1 )
000508 38fc          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
000509 38ca          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
00050a 38f3          .dw XT_TO_R
00050b 3911          .dw XT_EQUAL              ; ( -- addr k f )
00050c 3830          .dw XT_DOCONDBRANCH
00050d 0511          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
00050e 38d4          .dw XT_DROP               ; ( -- addr )
00050f 3829          .dw XT_DOBRANCH
000510 04f4          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
000511 38ac          .dw XT_DUP                ; ( -- addr k k )
000512 0197          .dw XT_EMIT               ; ( -- addr k )
000513 046b          .dw XT_SPACE              ; ( -- addr k )
000514 0197          .dw XT_EMIT               ; ( -- addr )
000515 3a3e          .dw XT_1MINUS             ; ( -- addr--)
000516 38ea          .dw XT_R_FROM
000517 3a38          .dw XT_1PLUS
000518 3829          .dw XT_DOBRANCH
000519 0528          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
00051a 38ac          .dw XT_DUP            ; ( -- addr k k )
00051b 0243          .dw XT_BL
00051c 391f          .dw XT_LESS
00051d 3830          .dw XT_DOCONDBRANCH
00051e 0521          .dw PFA_ACCEPT6
00051f 38d4          .dw XT_DROP
000520 0243          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
000521 38ac          .dw XT_DUP            ; ( -- addr k k)
000522 0197          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
000523 38ca          .dw XT_OVER           ; ( -- addr k addr
000524 3888          .dw XT_CSTORE         ; ( -- addr)
000525 3a38          .dw XT_1PLUS          ; ( -- addr++)
000526 38ea          .dw XT_R_FROM         ; ( -- addr n1)
000527 3a3e          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
000528 38ac          .dw XT_DUP
000529 38f3          .dw XT_TO_R
00052a 3918          .dw XT_EQUALZERO
00052b 3830          .dw XT_DOCONDBRANCH
00052c 04f4          .dw PFA_ACCEPT1
00052d 38ac          .dw XT_DUP
                 PFA_ACCEPT2:
00052e 0179          .dw XT_2DROP
00052f 38ea          .dw XT_R_FROM
000530 38ea          .dw XT_R_FROM
000531 38bf          .dw XT_SWAP
000532 399c          .dw XT_MINUS
000533 045e          .dw XT_CR
000534 381a          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
000535 ff06          .dw $ff06
000536 6572
000537 6966
000538 6c6c          .db "refill"
000539 04eb          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00053a 0832          .dw PFA_DODEFER
                 PFA_REFILL:
00053b 001a          .dw USER_REFILL
00053c 080a          .dw XT_UDEFERFETCH
00053d 0811          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
00053e ff04          .dw $ff04
00053f 6863
000540 7261          .db "char"
000541 0535          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000542 3800          .dw DO_COLON
                 PFA_CHAR:
000543 064f          .dw XT_PARSENAME
000544 38d4          .dw XT_DROP
000545 3893          .dw XT_CFETCH
000546 381a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
000547 ff06          .dw $ff06
000548 756e
000549 626d
00054a 7265          .db "number"
00054b 053e          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00054c 3800          .dw DO_COLON
                 PFA_NUMBER:
00054d 0159          .dw XT_BASE
00054e 3874          .dw XT_FETCH
00054f 38f3          .dw XT_TO_R
000550 05bd          .dw XT_NUMBERSIGN
000551 38f3          .dw XT_TO_R
000552 0589          .dw XT_PRAEFIX
000553 05bd          .dw XT_NUMBERSIGN
000554 38ea          .dw XT_R_FROM
000555 3a25          .dw XT_OR
000556 38f3          .dw XT_TO_R
000557 38f3          .dw XT_TO_R
000558 38f3          .dw XT_TO_R
000559 3934          .dw XT_ZERO       ; starting value
00055a 3934          .dw XT_ZERO
00055b 38ea          .dw XT_R_FROM
00055c 38ea          .dw XT_R_FROM
00055d 05dc          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00055e 38b4          .dw XT_QDUP
00055f 3830              .dw XT_DOCONDBRANCH
000560 057d      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
000561 3837          .dw XT_DOLITERAL
000562 0001          .dw 1
000563 3911          .dw XT_EQUAL
000564 3830          .dw XT_DOCONDBRANCH
000565 0574          .dw PFA_NUMBER2
                 	; excatly one character is left
000566 3893      	.dw XT_CFETCH
000567 3837      	.dw XT_DOLITERAL
000568 002e      	.dw $2e ; .
000569 3911      	.dw XT_EQUAL
00056a 3830      	.dw XT_DOCONDBRANCH
00056b 0574      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
00056c 38ea      	.dw XT_R_FROM
00056d 3830              .dw XT_DOCONDBRANCH
00056e 0570      	.dw PFA_NUMBER3
00056f 0910              .dw XT_DNEGATE
                 PFA_NUMBER3:
000570 3837      	.dw XT_DOLITERAL
000571 0002      	.dw 2
000572 3829      	.dw XT_DOBRANCH
000573 0584      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
000574 0179      	.dw XT_2DROP
000575 38d4      	.dw XT_DROP
000576 38ea      	.dw XT_R_FROM
000577 38d4      	.dw XT_DROP
000578 38ea              .dw XT_R_FROM
000579 0159              .dw XT_BASE
00057a 387c              .dw XT_STORE
00057b 3934      	.dw XT_ZERO
00057c 381a      	.dw XT_EXIT
                 PFA_NUMBER1:
00057d 0179          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00057e 38ea          .dw XT_R_FROM
00057f 3830          .dw XT_DOCONDBRANCH
000580 0582          .dw PFA_NUMBER4
000581 02a6          .dw XT_NEGATE
                 PFA_NUMBER4:
000582 3837          .dw XT_DOLITERAL
000583 0001          .dw 1
                 PFA_NUMBER5:
000584 38ea          .dw XT_R_FROM
000585 0159          .dw XT_BASE
000586 387c          .dw XT_STORE
000587 393d          .dw XT_TRUE
000588 381a          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
000589 3800          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
00058a 38ca          .dw XT_OVER 
00058b 3893          .dw XT_CFETCH 
00058c 3837          .dw XT_DOLITERAL
00058d 0029          .dw $29 
00058e 3926          .dw XT_GREATER 
00058f 3830          .dw XT_DOCONDBRANCH
000590 0592          .dw PFA_PRAEFIX0 
000591 381a          .dw XT_EXIT 
                 PFA_PRAEFIX0:
000592 38ca          .dw XT_OVER 
000593 3893          .dw XT_CFETCH 
000594 0599          .dw XT_SETBASE
000595 3837          .dw XT_DOLITERAL
000596 0001          .dw $1 
000597 063e          .dw XT_SLASHSTRING 
000598 381a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000599 3800          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
00059a 38ac          .dw XT_DUP 
00059b 3837          .dw XT_DOLITERAL
00059c 0024          .dw '$' 
00059d 3911          .dw XT_EQUAL 
00059e 3830          .dw XT_DOCONDBRANCH
00059f 05a3          .dw PFA_SETBASE0 
0005a0 38d4          .dw XT_DROP 
0005a1 023a          .dw XT_HEX 
0005a2 381a          .dw XT_EXIT 
                 PFA_SETBASE0:
0005a3 38ac          .dw XT_DUP 
0005a4 3837          .dw XT_DOLITERAL
0005a5 0025          .dw '%' 
0005a6 3911          .dw XT_EQUAL 
0005a7 3830          .dw XT_DOCONDBRANCH
0005a8 05ac          .dw PFA_SETBASE1 
0005a9 38d4          .dw XT_DROP 
0005aa 0224          .dw XT_BIN
0005ab 381a          .dw XT_EXIT 
                 PFA_SETBASE1:
0005ac 38ac          .dw XT_DUP 
0005ad 3837          .dw XT_DOLITERAL
0005ae 0026          .dw '&'
0005af 3911          .dw XT_EQUAL 
0005b0 3830          .dw XT_DOCONDBRANCH
0005b1 05b5          .dw PFA_SETBASE2 
0005b2 38d4          .dw XT_DROP
0005b3 0230          .dw XT_DECIMAL 
0005b4 381a          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
0005b5 3837          .dw XT_DOLITERAL
0005b6 0023          .dw '#'
0005b7 3911          .dw XT_EQUAL 
0005b8 3830          .dw XT_DOCONDBRANCH
0005b9 05bc          .dw PFA_SETBASE3 
0005ba 0230          .dw XT_DECIMAL 
0005bb 381a          .dw XT_EXIT 
                 PFA_SETBASE3:
0005bc 381a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
0005bd 3800          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
0005be 38ca          .dw XT_OVER
0005bf 3893          .dw XT_CFETCH
0005c0 3837          .dw XT_DOLITERAL
0005c1 002b          .dw '+'
0005c2 3911          .dw XT_EQUAL
0005c3 3830          .dw XT_DOCONDBRANCH
0005c4 05c8          .dw PFA_NUMBERSIGN_MINUS
0005c5 3837            .dw XT_DOLITERAL
0005c6 0001            .dw 1
0005c7 063e            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
0005c8 38ca          .dw XT_OVER    ; ( -- addr len addr )
0005c9 3893          .dw XT_CFETCH
0005ca 3837          .dw XT_DOLITERAL
0005cb 002d          .dw '-'
0005cc 3911          .dw XT_EQUAL  ; ( -- addr len flag )
0005cd 38ac          .dw XT_DUP
0005ce 38f3          .dw XT_TO_R
0005cf 3830          .dw XT_DOCONDBRANCH
0005d0 05d4          .dw PFA_NUMBERSIGN_PLUS
0005d1 3837          .dw XT_DOLITERAL      ; skip sign character
0005d2 0001          .dw 1
0005d3 063e          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
0005d4 38ea          .dw XT_R_FROM
0005d5 381a          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
0005d6 ff07          .dw $ff07
0005d7 6e3e
0005d8 6d75
0005d9 6562
0005da 0072          .db ">number",0
0005db 0547          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0005dc 3800          .dw DO_COLON
                 PFA_TO_NUMBER:
0005dd 38ac          .dw XT_DUP
0005de 3830          .dw XT_DOCONDBRANCH
0005df 05fa          .dw PFA_TO_NUMBER1
0005e0 38ca              .dw XT_OVER
0005e1 3893              .dw XT_CFETCH
0005e2 03c1              .dw XT_DIGITQ
0005e3 3918              .dw XT_EQUALZERO
0005e4 3830              .dw XT_DOCONDBRANCH
0005e5 05e7              .dw PFA_TO_NUMBER2
0005e6 381a                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
0005e7 38f3              .dw XT_TO_R
0005e8 0935              .dw XT_2SWAP
0005e9 38ea              .dw XT_R_FROM
0005ea 38bf              .dw XT_SWAP
0005eb 0159              .dw XT_BASE
0005ec 3874              .dw XT_FETCH
0005ed 39e9              .dw XT_UMSTAR
0005ee 38d4              .dw XT_DROP
0005ef 38dc              .dw XT_ROT
0005f0 0159              .dw XT_BASE
0005f1 3874              .dw XT_FETCH
0005f2 39e9              .dw XT_UMSTAR
0005f3 3ebb              .dw XT_DPLUS
0005f4 0935              .dw XT_2SWAP
0005f5 3837              .dw XT_DOLITERAL
0005f6 0001              .dw 1
0005f7 063e              .dw XT_SLASHSTRING
0005f8 3829          .dw XT_DOBRANCH
0005f9 05dd          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
0005fa 381a          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
0005fb ff05          .dw $ff05
0005fc 6170
0005fd 7372
0005fe 0065          .db "parse",0
0005ff 05d6          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000600 3800          .dw DO_COLON
                 PFA_PARSE:
000601 38f3          .dw XT_TO_R     ; ( -- )
000602 0634          .dw XT_SOURCE   ; ( -- addr len)
000603 0181          .dw XT_G_IN     ; ( -- addr len >in)
000604 3874          .dw XT_FETCH
000605 063e          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000606 38ea          .dw XT_R_FROM      ; ( -- addr' len' c)
000607 0615          .dw XT_CSCAN       ; ( -- addr' len'')
000608 38ac          .dw XT_DUP         ; ( -- addr' len'' len'')
000609 3a38          .dw XT_1PLUS
00060a 0181          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
00060b 3a62          .dw XT_PLUSSTORE   ; ( -- addr' len')
00060c 3837          .dw XT_DOLITERAL
00060d 0001          .dw 1
00060e 063e          .dw XT_SLASHSTRING
00060f 381a          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
000610 ff05          .dw $ff05
000611 7363
000612 6163
000613 006e          .db "cscan",0
000614 05fb          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000615 3800          .dw DO_COLON
                 PFA_CSCAN:
000616 38bf          .dw XT_SWAP         ; ( -- addr1 c n1 )
000617 38ac          .dw XT_DUP          ; ( -- addr1 c n1 n1)
000618 38f3          .dw XT_TO_R         ; ( -- addr1 c n1)
000619 3934          .dw XT_ZERO         ; ( -- addr1 c n1 0)
00061a 3aaa          .dw XT_DOQDO        ; ( -- addr1 c)
00061b 062c          .dw PFA_CSCAN3
                 PFA_CSCAN1:
00061c 38ca          .dw XT_OVER         ; ( -- addr1 c addr1 )
00061d 3abd          .dw XT_I            ; ( -- addr1 c addr1 i)
00061e 39a6          .dw XT_PLUS         ; ( -- addr1 c addr')
00061f 3893          .dw XT_CFETCH       ; ( -- addr1 c c')
000620 38ca          .dw XT_OVER         ; ( -- addr1 c c' c)
000621 3911          .dw XT_EQUAL        ; ( -- addr1 c f)
000622 3830          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
000623 062a          .dw PFA_CSCAN2
000624 38d4          .dw XT_DROP         ; ( -- addr1 )
000625 3abd          .dw XT_I            ; ( -- addr1 n2)
000626 3ae7          .dw XT_UNLOOP       ; ( -- addr1 n2)
000627 38ea          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
000628 38d4          .dw XT_DROP         ; ( -- addr1 n2)
000629 381a          .dw XT_EXIT
                 PFA_CSCAN2:
00062a 3ad8          .dw XT_DOLOOP
00062b 061c          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
00062c 38d4          .dw XT_DROP         ; ( -- addr1)
00062d 38ea          .dw XT_R_FROM       ; ( -- addr1 n1)
00062e 381a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
00062f ff06          .dw $FF06
000630 6f73
000631 7275
000632 6563          .db "source"
000633 0610          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000634 0832          .dw PFA_DODEFER
                 PFA_SOURCE:
000635 0016          .dw USER_SOURCE
000636 080a          .dw XT_UDEFERFETCH
000637 0811          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
000638 ff07          .dw $ff07
000639 732f
00063a 7274
00063b 6e69
00063c 0067          .db "/string",0
00063d 062f          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00063e 3800          .dw DO_COLON
                 PFA_SLASHSTRING:
00063f 38ca          .dw XT_OVER    ; ( -- addr1 u1 n u1)
000640 02ca          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
000641 38dc          .dw XT_ROT     ; ( -- u1 n addr1 )
000642 38ca          .dw XT_OVER    ; ( -- u1 n addr1 n)
000643 39a6          .dw XT_PLUS    ; ( -- u1 n addr2 )
000644 38dc          .dw XT_ROT     ; ( -- n addr2 u1)
000645 38dc          .dw XT_ROT     ; ( -- addr2 u1 n)
000646 399c          .dw XT_MINUS   ; ( -- addr2 u2)
000647 381a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
000648 ff0a          .dw $FF0A 
000649 6170
00064a 7372
00064b 2d65
00064c 616e
00064d 656d          .db "parse-name"
00064e 0638          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00064f 3800          .dw DO_COLON 
                 PFA_PARSENAME:
000650 0243          .dw XT_BL
000651 0653          .dw XT_SKIPSCANCHAR
000652 381a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000653 3800          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
000654 38f3          .dw XT_TO_R
000655 0634          .dw XT_SOURCE 
000656 0181          .dw XT_G_IN 
000657 3874          .dw XT_FETCH 
000658 063e          .dw XT_SLASHSTRING 
                 
000659 38fc          .dw XT_R_FETCH
00065a 04d8          .dw XT_CSKIP
00065b 38ea          .dw XT_R_FROM
00065c 0615          .dw XT_CSCAN
                 
                     ; adjust >IN
00065d 0170          .dw XT_2DUP
00065e 39a6          .dw XT_PLUS
00065f 0634          .dw XT_SOURCE 
000660 38d4          .dw XT_DROP
000661 399c          .dw XT_MINUS
000662 0181          .dw XT_G_IN
000663 387c          .dw XT_STORE
000664 381a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
000665 ff09          .dw $ff09
000666 6966
000667 646e
000668 6e2d
000669 6d61
00066a 0065          .db "find-name",0
00066b 0648          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
00066c 3800          .dw DO_COLON
                 PFA_FINDNAME:
00066d 3837          .dw XT_DOLITERAL
00066e 0014          .dw EE_ORDERLISTLEN
00066f 3b5b          .dw XT_FETCHE
000670 3934          .dw XT_ZERO
000671 3aaa          .dw XT_DOQDO
000672 0687          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
000673 0170          .dw XT_2DUP
000674 3837          .dw XT_DOLITERAL
000675 0016          .dw EE_ORDERLIST
000676 3abd          .dw XT_I
000677 0160          .dw XT_CELLS
000678 39a6          .dw XT_PLUS  
000679 3b5b          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
00067a 0846          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
00067b 38b4          .dw XT_QDUP
00067c 3830          .dw XT_DOCONDBRANCH
00067d 0685          .dw PFA_FINDNAME4
00067e 38f3      	.dw XT_TO_R
00067f 38f3      	.dw XT_TO_R
000680 0179      	.dw XT_2DROP
000681 38ea      	.dw XT_R_FROM
000682 38ea      	.dw XT_R_FROM
000683 3ae7      	.dw XT_UNLOOP
000684 381a      	.dw XT_EXIT
                 PFA_FINDNAME4:
000685 3ad8          .dw XT_DOLOOP
000686 0673          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000687 0179          .dw XT_2DROP
000688 3934          .dw XT_ZERO
000689 381a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
00068a ff04          .dw $ff04
00068b 7571
00068c 7469          .db "quit"
00068d 0665          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00068e 3800          .dw DO_COLON
                 PFA_QUIT:
00068f 0706          .dw XT_SP0
000690 3a93          .dw XT_SP_STORE
000691 071b          .dw XT_RP0
000692 3a7d          .dw XT_RP_STORE
000693 3d1b          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000694 0153          .dw XT_STATE
000695 3874          .dw XT_FETCH
000696 3918          .dw XT_EQUALZERO
000697 3830          .dw XT_DOCONDBRANCH
000698 069a          .dw PFA_QUIT4
000699 06b0          .dw XT_PROMPTRDY
                 PFA_QUIT4:
00069a 053a          .dw XT_REFILL
00069b 3830          .dw XT_DOCONDBRANCH
00069c 0694          .dw PFA_QUIT2
00069d 3837          .dw XT_DOLITERAL
00069e 0734          .dw XT_INTERPRET
00069f 04a9          .dw XT_CATCH
0006a0 38b4          .dw XT_QDUP
0006a1 3830          .dw XT_DOCONDBRANCH
0006a2 06ac          .dw PFA_QUIT3
0006a3 38ac      	.dw XT_DUP
0006a4 3837      	.dw XT_DOLITERAL
0006a5 fffe      	.dw -2
0006a6 391f      	.dw XT_LESS
0006a7 3830      	.dw XT_DOCONDBRANCH
0006a8 06aa      	.dw PFA_QUIT5
0006a9 06be      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
0006aa 3829      	.dw XT_DOBRANCH
0006ab 068f      	.dw PFA_QUIT
                 PFA_QUIT3:
0006ac 06b7          .dw XT_PROMPTOK
0006ad 3829          .dw XT_DOBRANCH
0006ae 0694          .dw PFA_QUIT2
0006af 381a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
0006b0 3800          .dw DO_COLON
                 PFA_PROMPTRDY:
0006b1 045e          .dw XT_CR
0006b2 03f3          .dw XT_DOSLITERAL
0006b3 0002          .dw 2
0006b4 203e          .db "> "
0006b5 042a          .dw XT_ITYPE
0006b6 381a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
0006b7 3800          .dw DO_COLON
                 PFA_PROMPTOK:
0006b8 03f3          .dw XT_DOSLITERAL
0006b9 0003          .dw 3
0006ba 6f20
0006bb 006b          .db " ok",0
0006bc 042a          .dw XT_ITYPE
0006bd 381a          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
0006be 3800          .dw DO_COLON
                 PFA_PROMPTERROR:
0006bf 03f3      	.dw XT_DOSLITERAL
0006c0 0004      	.dw 4
0006c1 3f20
0006c2 203f      	.db  " ?? "
0006c3 042a          .dw XT_ITYPE
0006c4 0159      	.dw XT_BASE
0006c5 3874      	.dw XT_FETCH
0006c6 38f3      	.dw XT_TO_R
0006c7 0230      	.dw XT_DECIMAL
0006c8 0390      	.dw XT_DOT
0006c9 0181      	.dw XT_G_IN
0006ca 3874      	.dw XT_FETCH
0006cb 0390      	.dw XT_DOT
0006cc 38ea      	.dw XT_R_FROM
0006cd 0159      	.dw XT_BASE
0006ce 387c      	.dw XT_STORE
0006cf 381a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
0006d0 ff05          .dw $ff05
0006d1 6170
0006d2 7375
0006d3 0065          .db "pause",0
0006d4 068a          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
0006d5 0832          .dw PFA_DODEFER
                 PFA_PAUSE:
0006d6 0175          .dw ram_pause
0006d7 0800          .dw XT_RDEFERFETCH
0006d8 0805          .dw XT_RDEFERSTORE
                 
                 .dseg
000175           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
0006d9 ff04          .dw $ff04
0006da 6f63
0006db 646c          .db "cold"
0006dc 06d0          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
0006dd 06de          .dw PFA_COLD
                 PFA_COLD:
0006de b6a4          in_ r10, MCUSR
0006df 24bb          clr r11
0006e0 2422          clr zerol
0006e1 2433          clr zeroh
0006e2 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000177           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
0006e3 e7e7          ldi zl, low(ram_user1)
0006e4 e0f1          ldi zh, high(ram_user1)
0006e5 012f          movw upl, zl
                     ; init return stack pointer
0006e6 ef0f          ldi temp0,low(rstackstart)
0006e7 bf0d          out_ SPL,temp0
0006e8 8304          std Z+4, temp0
0006e9 e01a          ldi temp1,high(rstackstart)
0006ea bf1e          out_ SPH,temp1
0006eb 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
0006ec eacf          ldi yl,low(stackstart)
0006ed 83c6          std Z+6, yl
0006ee e0da          ldi yh,high(stackstart)
0006ef 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
0006f0 efa9          ldi XL, low(PFA_WARM)
0006f1 e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
0006f2 940c 3804     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
0006f4 ff04          .dw $ff04
0006f5 6177
0006f6 6d72          .db "warm"
0006f7 06d9          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
0006f8 3800          .dw DO_COLON
                 PFA_WARM:
0006f9 0985          .dw XT_INITUSER
0006fa 3837          .dw XT_DOLITERAL
0006fb 07cf          .dw XT_NOOP
0006fc 3837          .dw XT_DOLITERAL
0006fd 06d5          .dw XT_PAUSE
0006fe 081d          .dw XT_DEFERSTORE
0006ff 024b          .dw XT_TURNKEY
000700 068e          .dw XT_QUIT
000701 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000702 ff03          .dw $ff03
000703 7073
000704 0030          .db "sp0",0
000705 06f4          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000706 3869          .dw PFA_DOVALUE1
                 PFA_SP0:
000707 0006          .dw USER_SP0
000708 070f          .dw XT_UVALUEFETCH
000709 0713          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
00070a ff02          .dw $ff02
00070b 7073          .db "sp"
00070c 0702          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
00070d 3852          .dw PFA_DOUSER
                 PFA_SP:
00070e 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
00070f 3800          .dw DO_COLON
                 PFA_UVALUEFETCH:
000710 3bc7          .dw XT_FETCHI
000711 389b          .dw XT_FETCHU
000712 381a          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
000713 3800          .dw DO_COLON
                 PFA_UVALUESTORE:
000714 3bc7          .dw XT_FETCHI
000715 38a3          .dw XT_STOREU
000716 381a          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000717 ff03          .dw $ff03
000718 7072
000719 0030          .db "rp0",0
00071a 070a          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00071b 3800          .dw DO_COLON
                 PFA_RP0:
00071c 071f          .dw XT_DORP0
00071d 3874          .dw XT_FETCH
00071e 381a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00071f 3852          .dw PFA_DOUSER
                 PFA_DORP0:
000720 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
000721 ff05          .dw $ff05
000722 6564
000723 7470
000724 0068          .db "depth",0
000725 0717          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000726 3800          .dw DO_COLON
                 PFA_DEPTH:
000727 0706          .dw XT_SP0
000728 3a8a          .dw XT_SP_FETCH
000729 399c          .dw XT_MINUS
00072a 3a0d          .dw XT_2SLASH
00072b 3a3e          .dw XT_1MINUS
00072c 381a          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
00072d ff09          .dw $ff09
00072e 6e69
00072f 6574
000730 7072
000731 6572
000732 0074          .db "interpret",0
000733 0721          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000734 3800          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
000735 064f          .dw XT_PARSENAME ; ( -- addr len )
000736 38b4          .dw XT_QDUP   ; ( -- addr len len )
000737 395c          .dw XT_GREATERZERO
000738 3830          .dw XT_DOCONDBRANCH
000739 0758          .dw PFA_INTERPRET5
00073a 3837          .dw XT_DOLITERAL
00073b 0026          .dw EE_RECOGNIZERLISTLEN
00073c 3b5b          .dw XT_FETCHE       ; ( addr len rec # -- )
00073d 3934          .dw XT_ZERO
                 
00073e 3aaa          .dw XT_DOQDO
00073f 0754          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
000740 0170          .dw XT_2DUP ; ( -- addr len addr len  )
000741 3abd          .dw XT_I    ; ( -- addr len addr len i )
000742 38dc          .dw XT_ROT  ; ( -- addr len len i addr )
000743 38dc          .dw XT_ROT  ; ( -- addr len i addr len )
000744 38f3          .dw XT_TO_R
000745 38f3          .dw XT_TO_R
                 
000746 0160          .dw XT_CELLS
000747 3837          .dw XT_DOLITERAL
000748 0028          .dw EE_RECOGNIZERLIST
000749 39a6          .dw XT_PLUS
00074a 3b5b          .dw XT_FETCHE
                 
00074b 3824          .dw XT_EXECUTE
00074c 38ea          .dw XT_R_FROM
00074d 38ea          .dw XT_R_FROM
00074e 38dc          .dw XT_ROT
00074f 3830          .dw XT_DOCONDBRANCH
000750 0752          .dw PFA_INTERPRET3
000751 3c6d            .dw XT_LEAVE
                 PFA_INTERPRET3:
000752 3ad8          .dw XT_DOLOOP
000753 0740          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
000754 0179          .dw XT_2DROP
000755 07a5          .dw XT_QSTACK
000756 3829          .dw XT_DOBRANCH
000757 0735          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
000758 38d4          .dw xT_DROP
000759 381a          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
00075a ff0a          .dw $ff0a
00075b 6572
00075c 2d63
00075d 6e69
00075e 6e74
00075f 6d75          .db "rec-intnum"
000760 072d          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
000761 3800          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
000762 054c          .dw XT_NUMBER 
000763 3830          .dw XT_DOCONDBRANCH 
000764 0776          .dw PFA_REC_NONUMBER
                 
000765 0153          .dw XT_STATE
000766 3874          .dw XT_FETCH
000767 3830          .dw XT_DOCONDBRANCH
000768 0773          .dw PFA_REC_NUMBER_DONE
000769 3837      	.dw XT_DOLITERAL
00076a 0002      	.dw 2
00076b 3911      	.dw XT_EQUAL
00076c 3830      	.dw XT_DOCONDBRANCH
00076d 0770      	.dw PFA_REC_NUMBER_SINGLE
00076e 38bf      	.dw XT_SWAP
00076f 3bd4              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
000770 3bd4              .dw XT_LITERAL
000771 3829              .dw XT_DOBRANCH
000772 0774              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
000773 38d4          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000774 393d          .dw XT_TRUE
000775 381a          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000776 3934          .dw XT_ZERO
000777 381a          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000778 ff08          .dw $ff08
000779 6572
00077a 2d63
00077b 6966
00077c 646e          .db "rec-find"
00077d 075a          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00077e 3800          .dw DO_COLON
                 PFA_REC_FIND:
00077f 066c          .dw XT_FINDNAME
000780 38ac          .dw XT_DUP
000781 3830          .dw XT_DOCONDBRANCH 
000782 0791          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
000783 395c      	.dw XT_GREATERZERO
000784 3830      	.dw XT_DOCONDBRANCH
000785 0788      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000786 3829      	    .dw XT_DOBRANCH
000787 078f      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000788 0153      	    .dw XT_STATE
000789 3874      	    .dw XT_FETCH
00078a 3830      	    .dw XT_DOCONDBRANCH
00078b 078f      	    .dw PFA_REC_FIND_EXECUTE
00078c 020e      	    .dw XT_COMMA
00078d 3829      	    .dw XT_DOBRANCH
00078e 0790      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
00078f 3824          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
000790 393d          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000791 381a          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
000792 ff0c          .dw $ff0c
000793 6572
000794 2d63
000795 6f6e
000796 6674
000797 756f
000798 646e          .db "rec-notfound"
000799 0778          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
00079a 3800          .dw DO_COLON
                 PFA_REC_NOTFOUND:
00079b 0483          .dw XT_TYPE
00079c 3837          .dw XT_DOLITERAL
00079d fff3          .dw -13
00079e 04bf          .dw XT_THROW
00079f 381a          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
0007a0 ff06          .dw $ff06
0007a1 733f
0007a2 6174
0007a3 6b63          .db "?stack"
0007a4 0792          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
0007a5 3800          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
0007a6 0726          .dw XT_DEPTH
0007a7 392d          .dw XT_LESSZERO
0007a8 3830          .dw XT_DOCONDBRANCH
0007a9 07ad          .dw PFA_QSTACK1
0007aa 3837            .dw XT_DOLITERAL
0007ab fffc            .dw -4
0007ac 04bf            .dw XT_THROW
                 PFA_QSTACK1:
0007ad 381a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
0007ae ff03          .dw $ff03
0007af 6576
0007b0 0072          .db "ver",0
0007b1 07a0          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
0007b2 3800          .dw DO_COLON
                 PFA_VER:
0007b3 3def          .dw XT_ENV_FORTHNAME
0007b4 042a          .dw XT_ITYPE
0007b5 046b          .dw XT_SPACE
0007b6 0159          .dw XT_BASE
0007b7 3874          .dw XT_FETCH
0007b8 38f3          .dw XT_TO_R
0007b9 0230          .dw XT_DECIMAL
                 
0007ba 3dfd          .dw XT_ENV_FORTHVERSION
0007bb 3b29          .dw XT_S2D
0007bc 032a          .dw XT_L_SHARP
0007bd 0332          .dw XT_SHARP
0007be 3837          .dw XT_DOLITERAL
0007bf 002e          .dw '.'
0007c0 031b          .dw XT_HOLD
0007c1 0348          .dw XT_SHARP_S
0007c2 0353          .dw XT_SHARP_G
0007c3 38ea          .dw XT_R_FROM
0007c4 0159          .dw XT_BASE
0007c5 387c          .dw XT_STORE
                 
0007c6 0483          .dw XT_TYPE
0007c7 046b          .dw XT_SPACE
0007c8 3e05          .dw XT_ENV_CPU
0007c9 042a          .dw XT_ITYPE
0007ca 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
0007cb ff04          .dw $ff04
0007cc 6f6e
0007cd 706f          .db "noop"
0007ce 07ae          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
0007cf 07d0          .dw PFA_NOOP
                 PFA_NOOP:
0007d0 940c 3804     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
0007d2 ff06          .dw $ff06
0007d3 6e75
0007d4 7375
0007d5 6465          .db "unused"
0007d6 07cb          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
0007d7 3800          .dw DO_COLON
                 PFA_UNUSED:
0007d8 0706          .dw XT_SP0
0007d9 01c7          .dw XT_HERE
0007da 399c          .dw XT_MINUS
0007db 381a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
0007dc 0002          .dw $0002
0007dd 6f74          .db "to"
0007de 07d2          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
0007df 3800          .dw DO_COLON
                 PFA_TO:
0007e0 0492          .dw XT_TICK
0007e1 3a38          .dw XT_1PLUS  		; to body
0007e2 0153          .dw XT_STATE
0007e3 3874          .dw XT_FETCH
0007e4 3830          .dw XT_DOCONDBRANCH
0007e5 07f0          .dw PFA_TO1
0007e6 0203          .dw XT_COMPILE
0007e7 07ea          .dw XT_DOTO
0007e8 020e          .dw XT_COMMA
0007e9 381a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
0007ea 3800          .dw DO_COLON
                 PFA_DOTO:
0007eb 38ea          .dw XT_R_FROM
0007ec 38ac          .dw XT_DUP
0007ed 3a38          .dw XT_1PLUS
0007ee 38f3          .dw XT_TO_R
0007ef 3bc7          .dw XT_FETCHI
                 PFA_TO1:
0007f0 38ac          .dw XT_DUP
0007f1 3a38          .dw XT_1PLUS
0007f2 3a38          .dw XT_1PLUS
0007f3 3bc7          .dw XT_FETCHI
0007f4 3824          .dw XT_EXECUTE
0007f5 381a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
0007f6 3800          .dw DO_COLON
                 PFA_EDEFERFETCH:
0007f7 3a38          .dw XT_1PLUS ; >body
0007f8 3bc7          .dw XT_FETCHI
0007f9 3b5b          .dw XT_FETCHE
0007fa 381a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
0007fb 3800          .dw DO_COLON
                 PFA_EDEFERSTORE:
0007fc 3a38          .dw XT_1PLUS
0007fd 3bc7          .dw XT_FETCHI
0007fe 3b37          .dw XT_STOREE
0007ff 381a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000800 3800          .dw DO_COLON
                 PFA_RDEFERFETCH:
000801 3a38          .dw XT_1PLUS ; >body
000802 3bc7          .dw XT_FETCHI
000803 3874          .dw XT_FETCH
000804 381a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000805 3800          .dw DO_COLON
                 PFA_RDEFERSTORE:
000806 3a38          .dw XT_1PLUS
000807 3bc7          .dw XT_FETCHI
000808 387c          .dw XT_STORE
000809 381a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00080a 3800          .dw DO_COLON
                 PFA_UDEFERFETCH:
00080b 3a38          .dw XT_1PLUS ; >body
00080c 3bc7          .dw XT_FETCHI
00080d 3b17          .dw XT_UP_FETCH
00080e 39a6          .dw XT_PLUS
00080f 3874          .dw XT_FETCH
000810 381a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000811 3800          .dw DO_COLON
                 PFA_UDEFERSTORE:
000812 3a38          .dw XT_1PLUS
000813 3bc7          .dw XT_FETCHI
000814 3b17          .dw XT_UP_FETCH
000815 39a6          .dw XT_PLUS
000816 387c          .dw XT_STORE
000817 381a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
000818 ff06          .dw $ff06
000819 6564
00081a 6566
00081b 2172          .db "defer!"
00081c 07dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00081d 3800          .dw DO_COLON
                 PFA_DEFERSTORE:
00081e 38ac          .dw XT_DUP
00081f 3837          .dw XT_DOLITERAL
000820 0003          .dw 3
000821 39a6          .dw XT_PLUS   ; >body 2 +
000822 3bc7          .dw XT_FETCHI
000823 3824          .dw XT_EXECUTE
000824 381a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
000825 ff06          .dw $ff06
000826 6564
000827 6566
000828 4072          .db "defer@"
000829 0818          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00082a 3800          .dw DO_COLON
                 PFA_DEFERFETCH:
00082b 38ac          .dw XT_DUP
00082c 3a38          .dw XT_1PLUS ; >body
00082d 3a38          .dw XT_1PLUS 
00082e 3bc7          .dw XT_FETCHI
00082f 3824          .dw XT_EXECUTE
000830 381a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
000831 0832          .dw PFA_DODEFER
                 PFA_DODEFER:
000832 940e 3cd7     call_ DO_DODOES
000834 38ac          .dw XT_DUP
000835 3a3e          .dw XT_1MINUS
000836 38bf          .dw XT_SWAP
000837 3a38          .dw XT_1PLUS
000838 3bc7          .dw XT_FETCHI
000839 3824          .dw XT_EXECUTE 
00083a 3824          .dw XT_EXECUTE
00083b 381a          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
00083c ff0f          .dw $ff0f
00083d 6573
00083e 7261
00083f 6863
000840 772d
000841 726f
000842 6c64
000843 7369
000844 0074          .db "search-wordlist",0
000845 0825          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000846 3800          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
000847 3934          .dw XT_ZERO
000848 38bf          .dw XT_SWAP
000849 3837          .dw XT_DOLITERAL
00084a 0855          .dw XT_ISWORD
00084b 38bf          .dw XT_SWAP
00084c 088c          .dw XT_TRAVERSEWORDLIST
00084d 38ac          .dw XT_DUP
00084e 3918          .dw XT_EQUALZERO
00084f 3830          .dw XT_DOCONDBRANCH
000850 0854          .dw PFA_SEARCH_WORDLIST1
000851 0179             .dw XT_2DROP
000852 38d4             .dw XT_DROP
000853 3934             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
000854 381a          .dw XT_EXIT
                 
                 XT_ISWORD:
000855 3800          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
000856 38f3          .dw XT_TO_R
000857 38f3          .dw XT_TO_R
000858 0170          .dw XT_2DUP
000859 38ea          .dw XT_R_FROM
00085a 38dc          .dw XT_ROT
00085b 38dc          .dw XT_ROT
00085c 38fc          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
00085d 087b          .dw XT_NAME2STRING
00085e 08a7          .dw XT_ICOMPARE      ; (-- addr len 0 f )
00085f 3830          .dw XT_DOCONDBRANCH
000860 086f          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
000861 0179            .dw XT_2DROP
000862 38d4            .dw XT_DROP
                       ; ... get the XT ...
000863 38fc            .dw XT_R_FETCH
000864 3e8f            .dw XT_NFA2LFA
000865 3a38            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
000866 393d            .dw XT_TRUE
000867 38ea            .dw XT_R_FROM
000868 3bc7            .dw XT_FETCHI
000869 395c            .dw XT_GREATERZERO
00086a 3830            .dw XT_DOCONDBRANCH
00086b 086d            .dw PFA_ISWORD1
00086c 02a6               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
00086d 3934            .dw XT_ZERO       ; finish traverse-wordlist
00086e 381a            .dw XT_EXIT
                 PFA_ISWORD3:
00086f 38ea          .dw XT_R_FROM
000870 38d4          .dw XT_DROP
000871 393d          .dw XT_TRUE         ; maybe next word
000872 381a          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
000873 ff0b          .dw $ff0b
000874 616e
000875 656d
000876 733e
000877 7274
000878 6e69
000879 0067          .db "name>string",0
00087a 083c          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00087b 3800          .dw DO_COLON
                 PFA_NAME2STRING:
00087c 0455          .dw XT_ICOUNT   ; ( -- addr n )
00087d 3837          .dw XT_DOLITERAL
00087e 00ff          .dw $00FF
00087f 3a1c          .dw XT_AND      ; mask immediate bit
000880 381a          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000881 ff11          .dw $ff11
000882 7274
000883 7661
000884 7265
000885 6573
000886 772d
000887 726f
000888 6c64
000889 7369
00088a 0074          .db "traverse-wordlist",0
00088b 0873          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00088c 3800          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
00088d 3b5b          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00088e 38ac          .dw XT_DUP           ; ( -- xt nt nt )
00088f 3830          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000890 089f          .dw PFA_TRAVERSEWORDLIST2       ;
000891 0170          .dw XT_2DUP
000892 38f3          .dw XT_TO_R
000893 38f3          .dw XT_TO_R
000894 38bf          .dw XT_SWAP
000895 3824          .dw XT_EXECUTE
000896 38ea          .dw XT_R_FROM
000897 38ea          .dw XT_R_FROM
000898 38dc          .dw XT_ROT
000899 3830          .dw XT_DOCONDBRANCH
00089a 089f          .dw PFA_TRAVERSEWORDLIST2
00089b 3e8f          .dw XT_NFA2LFA
00089c 3bc7          .dw XT_FETCHI        ; ( -- addr )
00089d 3829          .dw XT_DOBRANCH      ; ( -- addr )
00089e 088e          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00089f 0179          .dw XT_2DROP
0008a0 381a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
0008a1 ff08          .dw $ff08
0008a2 6369
0008a3 6d6f
0008a4 6170
0008a5 6572          .db "icompare"
0008a6 0881          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0008a7 3800          .dw DO_COLON
                 PFA_ICOMPARE:
0008a8 38f3          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0008a9 38ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0008aa 38ea          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0008ab 3907          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0008ac 3830          .dw XT_DOCONDBRANCH
0008ad 08b2          .dw PFA_ICOMPARE_SAMELEN
0008ae 0179            .dw XT_2DROP
0008af 38d4            .dw XT_DROP
0008b0 3934            .dw XT_ZERO
0008b1 381a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0008b2 38bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
0008b3 3934          .dw XT_ZERO
0008b4 3aaa          .dw XT_DOQDO
0008b5 08d5          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0008b6 38ca          .dw XT_OVER
0008b7 3874          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
0008b8 08d8          .dw XT_ICOMPARE_LC
                 .endif
0008b9 38ca          .dw XT_OVER
0008ba 3bc7          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
0008bb 08d8          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0008bc 38ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0008bd 3837          .dw XT_DOLITERAL
0008be 0100          .dw $100
0008bf 3946          .dw XT_ULESS
0008c0 3830          .dw XT_DOCONDBRANCH
0008c1 08c6          .dw PFA_ICOMPARE_LASTCELL
0008c2 38bf          .dw XT_SWAP
0008c3 3837          .dw XT_DOLITERAL
0008c4 00ff          .dw $00FF
0008c5 3a1c          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0008c6 3907          .dw XT_NOTEQUAL
0008c7 3830          .dw XT_DOCONDBRANCH
0008c8 08cd          .dw PFA_ICOMPARE_NEXTLOOP
0008c9 0179          .dw XT_2DROP
0008ca 3934          .dw XT_ZERO
0008cb 3ae7          .dw XT_UNLOOP
0008cc 381a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
0008cd 3a38          .dw XT_1PLUS
0008ce 38bf          .dw XT_SWAP
0008cf 0168          .dw XT_CELLPLUS
0008d0 38bf          .dw XT_SWAP
0008d1 3837          .dw XT_DOLITERAL
0008d2 0002          .dw 2
0008d3 3abe          .dw XT_DOPLUSLOOP
0008d4 08b6          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
0008d5 0179          .dw XT_2DROP
0008d6 393d          .dw XT_TRUE
0008d7 381a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
0008d8 3800          .dw DO_COLON
                 PFA_ICOMPARE_LC:
0008d9 38ac          .dw XT_DUP
0008da 3837          .dw XT_DOLITERAL
0008db 00ff          .dw $00ff
0008dc 3a1c          .dw XT_AND
0008dd 0304          .dw XT_TOLOWER
0008de 38bf          .dw XT_SWAP
0008df 3b0e          .dw XT_BYTESWAP
0008e0 3837          .dw XT_DOLITERAL
0008e1 00ff          .dw $00ff
0008e2 3a1c          .dw XT_AND
0008e3 0304          .dw XT_TOLOWER
0008e4 3b0e          .dw XT_BYTESWAP
0008e5 3a25          .dw XT_OR
0008e6 381a          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
0008e7 ff01          .dw $ff01
0008e8 002a          .db "*",0
0008e9 08a1          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
0008ea 3800          .dw DO_COLON
                 PFA_STAR:
0008eb 39af          .dw XT_MSTAR
0008ec 08fc          .dw XT_D2S
0008ed 381a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
0008ee ff01          .dw $FF01
0008ef 006a          .db "j",0
0008f0 08e7          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
0008f1 3800          .dw DO_COLON
                 PFA_J:
0008f2 3a73          .dw XT_RP_FETCH
0008f3 3837          .dw XT_DOLITERAL
0008f4 0009          .dw 9
0008f5 39a6          .dw XT_PLUS
0008f6 3874          .dw XT_FETCH
0008f7 381a          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
0008f8 ff03          .dw $ff03
0008f9 3e64
0008fa 0073          .db "d>s",0
0008fb 08ee          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
0008fc 3800          .dw DO_COLON
                 PFA_D2S:
0008fd 38d4          .dw XT_DROP
0008fe 381a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
0008ff ff04          .dw $ff04
000900 6164
000901 7362          .db "dabs"
000902 08f8          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000903 3800          .dw DO_COLON
                 PFA_DABS:
000904 38ac          .dw XT_DUP
000905 392d          .dw XT_LESSZERO
000906 3830          .dw XT_DOCONDBRANCH
000907 0909          .dw PFA_DABS1
000908 0910          .dw XT_DNEGATE
                 PFA_DABS1:
000909 381a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00090a ff07          .dw $ff07
00090b 6e64
00090c 6765
00090d 7461
00090e 0065          .db "dnegate",0
00090f 08ff          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000910 3800          .dw DO_COLON
                 PFA_DNEGATE:
000911 3ee1          .dw XT_DINVERT
000912 3837          .dw XT_DOLITERAL
000913 0001          .dw 1
000914 3934          .dw XT_ZERO
000915 3ebb          .dw XT_DPLUS
000916 381a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000917 ff05          .dw $ff05
000918 6d63
000919 766f
00091a 0065          .db "cmove",0
00091b 090a          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00091c 091d          .dw PFA_CMOVE
                 PFA_CMOVE:
00091d 93bf          push xh
00091e 93af          push xl
00091f 91e9          ld zl, Y+
000920 91f9          ld zh, Y+ ; addr-to
000921 91a9          ld xl, Y+
000922 91b9          ld xh, Y+ ; addr-from
000923 2f09          mov temp0, tosh
000924 2b08          or temp0, tosl
000925 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000926 911d          ld temp1, X+
000927 9311          st Z+, temp1
000928 9701          sbiw tosl, 1
000929 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00092a 91af          pop xl
00092b 91bf          pop xh
00092c 9189
00092d 9199          loadtos
00092e 940c 3804     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
000930 ff05          .dw $ff05
000931 7332
000932 6177
000933 0070          .db "2swap",0
000934 0917          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000935 3800          .dw DO_COLON
                 PFA_2SWAP:
000936 38dc          .dw XT_ROT
000937 38f3          .dw XT_TO_R
000938 38dc          .dw XT_ROT
000939 38ea          .dw XT_R_FROM
00093a 381a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
00093b ff03          .dw $ff03
00093c 6974
00093d 0062          .db "tib",0
00093e 0930          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00093f 3842          .dw PFA_DOVARIABLE
                 PFA_TIB:
000940 019d          .dw ram_tib
                     
                 .dseg
00019d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
000941 ff0a          .dw $ff0a
000942 6572
000943 6966
000944 6c6c
000945 742d
000946 6269          .db "refill-tib"
000947 093b          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000948 3800          .dw DO_COLON
                 PFA_REFILLTIB:
000949 093f          .dw XT_TIB
00094a 3837          .dw XT_DOLITERAL
00094b 0064          .dw TIBSIZE
00094c 04f0          .dw XT_ACCEPT
00094d 0187          .dw XT_NUMBERTIB
00094e 387c          .dw XT_STORE
00094f 3934          .dw XT_ZERO
000950 0181          .dw XT_G_IN
000951 387c          .dw XT_STORE
000952 3837          .dw XT_DOLITERAL
000953 ffff          .dw -1
000954 381a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
000955 ff0a          .dw $FF0A
000956 6f73
000957 7275
000958 6563
000959 742d
00095a 6269          .db "source-tib"
00095b 0941          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00095c 3800          .dw DO_COLON
                 PFA_SOURCETIB:
00095d 093f          .dw XT_TIB
00095e 0187          .dw XT_NUMBERTIB
00095f 3874          .dw XT_FETCH
000960 381a          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
000961 ff07        .dw $ff07
000962 6565
000963 752d
000964 6573
000965 0072        .db "ee-user",0
000966 0955        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
000967 3842        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
000968 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000969 ff06        .dw $ff06
00096a 6565
00096b 723e
00096c 6d61        .db "ee>ram"
00096d 0961        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00096e 3800        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00096f 3934          .dw XT_ZERO
000970 3aaa          .dw XT_DOQDO
000971 097c          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000972 38ca          .dw XT_OVER
000973 3b5b          .dw XT_FETCHE
000974 38ca          .dw XT_OVER
000975 387c          .dw XT_STORE
000976 0168          .dw XT_CELLPLUS
000977 38bf          .dw XT_SWAP
000978 0168          .dw XT_CELLPLUS
000979 38bf          .dw XT_SWAP
00097a 3ad8          .dw XT_DOLOOP
00097b 0972          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00097c 0179          .dw XT_2DROP
00097d 381a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00097e ff09        .dw $ff09
00097f 6e69
000980 7469
000981 752d
000982 6573
000983 0072        .db "init-user",0
000984 0969        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000985 3800        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000986 0967          .dw XT_EEUSER
000987 3b17          .dw XT_UP_FETCH
000988 3837          .dw XT_DOLITERAL
000989 001c          .dw SYSUSERSIZE
00098a 3a0d          .dw XT_2SLASH
00098b 096e          .dw XT_EE2RAM
00098c 381a          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_MARKER:
00098d ff08          .dw $ff08
00098e 6d28
00098f 7261
000990 656b
000991 2972          .db "(marker)"
000992 097e          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000993 3869          .dw PFA_DOVALUE1
                 PFA_MARKER:
000994 0036          .dw EE_MARKER
000995 3d5a          .dw XT_EVALUEFETCH
000996 3d5e          .dw XT_EVALUESTORE
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
003800 93bf          push XH
003801 93af          push XL          ; PUSH IP
003802 01db          movw XL, wl
003803 9611          adiw xl, 1
                 DO_NEXT:
003804 f06e          brts DO_INTERRUPT
003805 01fd          movw zl, XL        ; READ IP
003806 0fee
003807 1fff
003808 9165
003809 9175          readflashcell wl, wh
00380a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00380b 01fb          movw zl, wl
00380c 0fee
00380d 1fff
00380e 9105
00380f 9115          readflashcell temp0,temp1
003810 01f8          movw zl, temp0
003811 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
003812 94e8          clt
003813 e268          ldi wl, LOW(XT_ISREXEC)
003814 e071          ldi wh, HIGH(XT_ISREXEC)
003815 cff5          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
003816 ff04          .dw $ff04
003817 7865
003818 7469          .db "exit"
003819 098d          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00381a 381b          .dw PFA_EXIT
                 PFA_EXIT:
00381b 91af          pop XL
00381c 91bf          pop XH
00381d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00381e ff07          .dw $ff07
00381f 7865
003820 6365
003821 7475
003822 0065          .db "execute",0
003823 3816          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
003824 3825          .dw PFA_EXECUTE
                 PFA_EXECUTE:
003825 01bc          movw wl, tosl
003826 9189
003827 9199          loadtos
003828 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
003829 382a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00382a 01fd          movw zl, XL
00382b 0fee
00382c 1fff
00382d 91a5
00382e 91b5          readflashcell XL,XH
00382f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
003830 3831          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
003831 2b98          or tosh, tosl
003832 9189
003833 9199          loadtos
003834 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
003835 9611          adiw XL, 1
003836 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
003837 3838          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
003838 939a
003839 938a          savetos
00383a 01fd          movw zl, xl
00383b 0fee
00383c 1fff
00383d 9185
00383e 9195          readflashcell tosl,tosh
00383f 9611          adiw xl, 1
003840 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
003841 3842          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
003842 939a
003843 938a          savetos
003844 01fb          movw zl, wl
003845 9631          adiw zl,1
003846 0fee
003847 1fff
003848 9185
003849 9195          readflashcell tosl,tosh
00384a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00384b 384c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00384c 939a
00384d 938a          savetos
00384e 01cb          movw tosl, wl
00384f 9601          adiw tosl, 1
003850 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
003851 3852          .dw PFA_DOUSER
                 PFA_DOUSER:
003852 939a
003853 938a          savetos
003854 01fb          movw zl, wl
003855 9631          adiw zl, 1
003856 0fee
003857 1fff
003858 9185
003859 9195          readflashcell tosl,tosh
00385a 0d84          add tosl, upl
00385b 1d95          adc tosh, uph
00385c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00385d ff07          .dw $ff07
00385e 7628
00385f 6c61
003860 6575
003861 0029          .db "(value)", 0
003862 381e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
003863 3800          .dw DO_COLON
                 PFA_DOVALUE:
003864 01dc          .dw XT_DOCREATE
003865 3cb3          .dw XT_REVEAL
003866 0203          .dw XT_COMPILE
003867 3869          .dw PFA_DOVALUE1
003868 381a          .dw XT_EXIT
                 PFA_DOVALUE1:
003869 940e 3cd7     call_ DO_DODOES
00386b 38ac          .dw XT_DUP
00386c 38bf          .dw XT_SWAP
00386d 3a38          .dw XT_1PLUS
00386e 3bc7          .dw XT_FETCHI
00386f 3824          .dw XT_EXECUTE
003870 381a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
003871 ff01          .dw $ff01
003872 0040          .db "@",0
003873 385d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
003874 3875          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
003875 01fc          movw zl, tosl
                     ; low byte is read before the high byte
003876 9181          ld tosl, z+
003877 9191          ld tosh, z+
003878 cf8b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
003879 ff01          .dw $ff01
00387a 0021          .db "!",0
00387b 3871          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00387c 387d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00387d 01fc          movw zl, tosl
00387e 9189
00387f 9199          loadtos
                     ; the high byte is written before the low byte
003880 8391          std Z+1, tosh
003881 8380          std Z+0, tosl
003882 9189
003883 9199          loadtos
003884 cf7f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
003885 ff02          .dw $ff02
003886 2163          .db "c!"
003887 3879          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
003888 3889          .dw PFA_CSTORE
                 PFA_CSTORE:
003889 01fc          movw zl, tosl
00388a 9189
00388b 9199          loadtos
00388c 8380          st Z, tosl
00388d 9189
00388e 9199          loadtos
00388f cf74          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
003890 ff02          .dw $ff02
003891 4063          .db "c@"
003892 3885          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
003893 3894          .dw PFA_CFETCH
                 PFA_CFETCH:
003894 01fc          movw zl, tosl
003895 2799          clr tosh
003896 8180          ld tosl, Z
003897 cf6c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
003898 ff02          .dw $ff02
003899 7540          .db "@u"
00389a 3890          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00389b 3800          .dw DO_COLON
                 PFA_FETCHU:
00389c 3b17          .dw XT_UP_FETCH
00389d 39a6          .dw XT_PLUS
00389e 3874          .dw XT_FETCH
00389f 381a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
0038a0 ff02          .dw $ff02
0038a1 7521          .db "!u"
0038a2 3898          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0038a3 3800          .dw DO_COLON
                 PFA_STOREU:
0038a4 3b17          .dw XT_UP_FETCH
0038a5 39a6          .dw XT_PLUS
0038a6 387c          .dw XT_STORE
0038a7 381a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0038a8 ff03          .dw $ff03
0038a9 7564
0038aa 0070          .db "dup",0
0038ab 38a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0038ac 38ad          .dw PFA_DUP
                 PFA_DUP:
0038ad 939a
0038ae 938a          savetos
0038af cf54          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0038b0 ff04          .dw $ff04
0038b1 643f
0038b2 7075          .db "?dup"
0038b3 38a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0038b4 38b5          .dw PFA_QDUP
                 PFA_QDUP:
0038b5 2f08          mov temp0, tosl
0038b6 2b09          or temp0, tosh
0038b7 f011          breq PFA_QDUP1
0038b8 939a
0038b9 938a          savetos
                 PFA_QDUP1:
0038ba cf49          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0038bb ff04          .dw $ff04
0038bc 7773
0038bd 7061          .db "swap"
0038be 38b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0038bf 38c0          .dw PFA_SWAP
                 PFA_SWAP:
0038c0 018c          movw temp0, tosl
0038c1 9189
0038c2 9199          loadtos
0038c3 931a          st -Y, temp1
0038c4 930a          st -Y, temp0
0038c5 cf3e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0038c6 ff04          .dw $ff04
0038c7 766f
0038c8 7265          .db "over"
0038c9 38bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0038ca 38cb          .dw PFA_OVER
                 PFA_OVER:
0038cb 939a
0038cc 938a          savetos
0038cd 818a          ldd tosl, Y+2
0038ce 819b          ldd tosh, Y+3
                 
0038cf cf34          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0038d0 ff04          .dw $ff04
0038d1 7264
0038d2 706f          .db "drop"
0038d3 38c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0038d4 38d5          .dw PFA_DROP
                 PFA_DROP:
0038d5 9189
0038d6 9199          loadtos
0038d7 cf2c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0038d8 ff03          .dw $ff03
0038d9 6f72
0038da 0074          .db "rot",0
0038db 38d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0038dc 38dd          .dw PFA_ROT
                 PFA_ROT:
0038dd 018c          movw temp0, tosl
0038de 9129          ld temp2, Y+
0038df 9139          ld temp3, Y+ 
0038e0 9189
0038e1 9199          loadtos
                         
0038e2 933a          st -Y, temp3
0038e3 932a          st -Y, temp2
0038e4 931a          st -Y, temp1
0038e5 930a          st -Y, temp0
                 
0038e6 cf1d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0038e7 ff02          .dw $ff02
0038e8 3e72          .db "r>"
0038e9 38d8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0038ea 38eb          .dw PFA_R_FROM
                 PFA_R_FROM:
0038eb 939a
0038ec 938a          savetos
0038ed 918f          pop tosl
0038ee 919f          pop tosh
0038ef cf14          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0038f0 ff02          .dw $ff02
0038f1 723e          .db ">r"
0038f2 38e7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0038f3 38f4          .dw PFA_TO_R
                 PFA_TO_R:
0038f4 939f          push tosh
0038f5 938f          push tosl
0038f6 9189
0038f7 9199          loadtos
0038f8 cf0b          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
0038f9 ff02          .dw $ff02
0038fa 4072          .db "r@"
0038fb 38f0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
0038fc 38fd          .dw PFA_R_FETCH
                 PFA_R_FETCH:
0038fd 939a
0038fe 938a          savetos
0038ff 918f          pop tosl
003900 919f          pop tosh
003901 939f          push tosh
003902 938f          push tosl
003903 cf00          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
003904 ff02          .dw $ff02
003905 3e3c          .db "<>"
003906 38f9          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
003907 3908          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
003908 9129          ld temp2, Y+
003909 9139          ld temp3, Y+
00390a 1782          cp tosl, temp2
00390b 0793          cpc tosh, temp3
00390c f151          breq PFA_ZERO1
00390d c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00390e ff01          .dw $ff01
00390f 003d          .db "=",0
003910 3904          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
003911 3800          .dw DO_COLON
                 PFA_EQUAL:
003912 399c          .dw XT_MINUS
003913 3918          .dw XT_EQUALZERO
003914 381a          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
003915 ff02          .dw $ff02
003916 3d30          .db "0="
003917 390e          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
003918 3919          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
003919 2b98          or tosh, tosl
00391a f4e1          brne PFA_ZERO1
00391b c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00391c ff01          .dw $ff01
00391d 003c          .db "<",0
00391e 3915          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00391f 3800          .dw DO_COLON
                 PFA_LESS:
003920 399c          .dw XT_MINUS
003921 392d          .dw XT_LESSZERO
003922 381a          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
003923 ff01          .dw $ff01
003924 003e          .db ">",0
003925 391c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
003926 3800          .dw DO_COLON
                 PFA_GREATER:
003927 399c          .dw XT_MINUS
003928 395c          .dw XT_GREATERZERO
003929 381a          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00392a ff02          .dw $ff02
00392b 3c30          .db "0<"
00392c 3923          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00392d 392e          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00392e fd97          sbrc tosh,7
00392f c010          rjmp PFA_TRUE1
003930 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
003931 ff01          .dw $ff01
003932 0030          .db "0",0
003933 392a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
003934 3935          .dw PFA_ZERO
                 PFA_ZERO:
003935 939a
003936 938a          savetos
                 PFA_ZERO1:
003937 01c1          movw tosl, zerol
003938 cecb          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
003939 ff04          .dw $ff04
00393a 7274
00393b 6575          .db "true"
00393c 3931          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00393d 393e          .dw PFA_TRUE
                 PFA_TRUE:
00393e 939a
00393f 938a          savetos
                 PFA_TRUE1:
003940 ef8f          ser tosl
003941 ef9f          ser tosh
003942 cec1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
003943 ff02          .dw $ff02
003944 3c75          .db "u<"
003945 3939          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
003946 3947          .dw PFA_ULESS
                 PFA_ULESS:
003947 9129          ld temp2, Y+
003948 9139          ld temp3, Y+
003949 1782          cp tosl, temp2
00394a 0793          cpc tosh, temp3
00394b f358          brlo PFA_ZERO1
00394c f351          brbs 1, PFA_ZERO1
00394d cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00394e ff02          .dw $ff02
00394f 3e75          .db "u>"
003950 3943          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
003951 3952          .dw PFA_UGREATER
                 PFA_UGREATER:
003952 9129          ld temp2, Y+
003953 9139          ld temp3, Y+
003954 1728          cp temp2, tosl
003955 0739          cpc temp3, tosh
003956 f300          brlo PFA_ZERO1
003957 f2f9          brbs 1, PFA_ZERO1
003958 cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
003959 ff02          .dw $ff02
00395a 3e30          .db "0>"
00395b 394e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00395c 395d          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00395d 1582          cp tosl, zerol
00395e 0593          cpc tosh, zeroh
00395f f2bc          brlt PFA_ZERO1
003960 f2b1          brbs 1, PFA_ZERO1
003961 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
003962 ff02          .dw $ff02
003963 3e64          .db "d>"
003964 3959          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
003965 3800          .dw DO_COLON
                 PFA_DGREATER:
003966 3ecc          .dw XT_DMINUS
003967 396d          .dw XT_DGREATERZERO
003968 381a          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
003969 ff03          .dw $ff03
00396a 3064
00396b 003e          .db "d0>",0
00396c 3962          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00396d 396e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00396e 1582          cp tosl, zerol
00396f 0593          cpc tosh, zeroh
003970 9189
003971 9199          loadtos
003972 0582          cpc tosl, zerol
003973 0593          cpc tosh, zeroh
003974 f214          brlt PFA_ZERO1
003975 f209          brbs 1, PFA_ZERO1
003976 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
003977 ff02          .dw $ff02
003978 3c64          .db "d<"
003979 3969          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00397a 3800          .dw DO_COLON
                 PFA_DLESS:
00397b 3ecc          .dw XT_DMINUS
00397c 3982          .dw XT_DLESSZERO
00397d 381a          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00397e ff03          .dw $ff03
00397f 3064
003980 003c          .db "d0<",0
003981 3977          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
003982 3983          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
003983 9622          adiw Y,2
003984 fd97          sbrc tosh,7
003985 940c 3940     jmp PFA_TRUE1
003987 940c 3937     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
003989 ff04          .dw $ff04
00398a 6f6c
00398b 3267          .db "log2"
00398c 397e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00398d 398e          .dw PFA_LOG2
                 PFA_LOG2:
00398e 01fc          movw zl, tosl
00398f 2799          clr tosh
003990 e180          ldi tosl, 16
                 PFA_LOG2_1:
003991 958a          dec tosl
003992 f022          brmi PFA_LOG2_2 ; wrong data
003993 0fee          lsl  zl
003994 1fff          rol  zh
003995 f7d8          brcc PFA_LOG2_1
003996 ce6d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
003997 959a          dec tosh
003998 ce6b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
003999 ff01          .dw $ff01
00399a 002d          .db "-",0
00399b 3989          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00399c 399d          .dw PFA_MINUS
                 PFA_MINUS:
00399d 9109          ld temp0, Y+
00399e 9119          ld temp1, Y+
00399f 1b08          sub temp0, tosl
0039a0 0b19          sbc temp1, tosh
0039a1 01c8          movw tosl, temp0
0039a2 ce61          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
0039a3 ff01          .dw $ff01
0039a4 002b          .db "+",0
0039a5 3999          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
0039a6 39a7          .dw PFA_PLUS
                 PFA_PLUS:
0039a7 9109          ld temp0, Y+
0039a8 9119          ld temp1, Y+
0039a9 0f80          add tosl, temp0
0039aa 1f91          adc tosh, temp1
0039ab ce58          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0039ac ff02          .dw $ff02
0039ad 2a6d          .db "m*"
0039ae 39a3          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0039af 39b0          .dw PFA_MSTAR
                 PFA_MSTAR:
0039b0 018c          movw temp0, tosl
0039b1 9189
0039b2 9199          loadtos
0039b3 019c          movw temp2, tosl
                     ; high cell ah*bh
0039b4 0231          muls temp3, temp1
0039b5 0170          movw temp4, r0
                     ; low cell  al*bl
0039b6 9f20          mul  temp2, temp0
0039b7 01c0          movw tosl, r0
                     ; signed ah*bl
0039b8 0330          mulsu temp3, temp0
0039b9 08f3          sbc   temp5, zeroh
0039ba 0d90          add   tosh,  r0
0039bb 1ce1          adc   temp4, r1
0039bc 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0039bd 0312          mulsu temp1, temp2
0039be 08f3          sbc   temp5, zeroh
0039bf 0d90          add   tosh,  r0
0039c0 1ce1          adc   temp4, r1
0039c1 1cf3          adc   temp5, zeroh
                 
0039c2 939a
0039c3 938a          savetos
0039c4 01c7          movw tosl, temp4
0039c5 ce3e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0039c6 ff06          .dw $ff06
0039c7 6d75
0039c8 6d2f
0039c9 646f          .db "um/mod"
0039ca 39ac          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0039cb 39cc          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0039cc 017c          movw temp4, tosl
                 
0039cd 9129          ld temp2, Y+
0039ce 9139          ld temp3, Y+
                   
0039cf 9109          ld temp0, Y+
0039d0 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0039d1 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0039d2 2755          clr temp7
0039d3 0f00          lsl temp0
0039d4 1f11          rol temp1
0039d5 1f22          rol temp2
0039d6 1f33          rol temp3
0039d7 1f55          rol temp7
                 
                   ; try subtracting divisor
0039d8 152e          cp temp2, temp4
0039d9 053f          cpc temp3, temp5
0039da 0552          cpc temp7,zerol
                 
0039db f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0039dc 9503          inc temp0
0039dd 192e          sub temp2, temp4
0039de 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0039df 954a          dec  temp6
0039e0 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0039e1 933a          st -Y,temp3
0039e2 932a          st -Y,temp2
                 
                     ; put quotient on stack
0039e3 01c8          movw tosl, temp0
0039e4 ce1f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0039e5 ff03          .dw $ff03
0039e6 6d75
0039e7 002a          .db "um*",0
0039e8 39c6          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0039e9 39ea          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0039ea 018c          movw temp0, tosl
0039eb 9189
0039ec 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0039ed 9f80          mul tosl,temp0
0039ee 01f0          movw zl, r0
0039ef 2722          clr temp2
0039f0 2733          clr temp3
                     ; middle bytes
0039f1 9f90          mul tosh, temp0
0039f2 0df0          add zh, r0
0039f3 1d21          adc temp2, r1
0039f4 1d33          adc temp3, zeroh
                         
0039f5 9f81          mul tosl, temp1
0039f6 0df0          add zh, r0
0039f7 1d21          adc temp2, r1
0039f8 1d33          adc temp3, zeroh
                     
0039f9 9f91          mul tosh, temp1
0039fa 0d20          add temp2, r0
0039fb 1d31          adc temp3, r1
0039fc 01cf          movw tosl, zl
0039fd 939a
0039fe 938a          savetos
0039ff 01c9          movw tosl, temp2
003a00 ce03          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
003a01 ff06          .dw $ff06
003a02 6e69
003a03 6576
003a04 7472          .db "invert"
003a05 39e5          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
003a06 3a07          .dw PFA_INVERT
                 PFA_INVERT:
003a07 9580          com tosl
003a08 9590          com tosh
003a09 cdfa          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
003a0a ff02          .dw $ff02
003a0b 2f32          .db "2/"
003a0c 3a01          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
003a0d 3a0e          .dw PFA_2SLASH
                 PFA_2SLASH:
003a0e 9595          asr tosh
003a0f 9587          ror tosl
003a10 cdf3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
003a11 ff02          .dw $ff02
003a12 2a32          .db "2*"
003a13 3a0a          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
003a14 3a15          .dw PFA_2STAR
                 PFA_2STAR:
003a15 0f88          lsl tosl
003a16 1f99          rol tosh
003a17 cdec          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
003a18 ff03          .dw $ff03
003a19 6e61
003a1a 0064          .db "and",0
003a1b 3a11          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
003a1c 3a1d          .dw PFA_AND
                 PFA_AND:
003a1d 9109          ld temp0, Y+
003a1e 9119          ld temp1, Y+
003a1f 2380          and tosl, temp0
003a20 2391          and tosh, temp1
003a21 cde2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
003a22 ff02          .dw $ff02
003a23 726f          .db "or"
003a24 3a18          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
003a25 3a26          .dw PFA_OR
                 PFA_OR:
003a26 9109          ld temp0, Y+
003a27 9119          ld temp1, Y+
003a28 2b80          or tosl, temp0
003a29 2b91          or tosh, temp1
003a2a cdd9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
003a2b ff03          .dw $ff03
003a2c 6f78
003a2d 0072          .db "xor",0
003a2e 3a22          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
003a2f 3a30          .dw PFA_XOR
                 PFA_XOR:
003a30 9109          ld temp0, Y+
003a31 9119          ld temp1, Y+
003a32 2780          eor tosl, temp0
003a33 2791          eor tosh, temp1
003a34 cdcf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
003a35 ff02          .dw $ff02
003a36 2b31          .db "1+"
003a37 3a2b          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
003a38 3a39          .dw PFA_1PLUS
                 PFA_1PLUS:
003a39 9601          adiw tosl,1
003a3a cdc9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
003a3b ff02          .dw $ff02 
003a3c 2d31          .db "1-"
003a3d 3a35          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
003a3e 3a3f          .dw PFA_1MINUS
                 PFA_1MINUS:
003a3f 9701          sbiw tosl, 1
003a40 cdc3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
003a41 ff06          .dw $ff06
003a42 736c
003a43 6968
003a44 7466          .db "lshift"
003a45 3a3b          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
003a46 3a47          .dw PFA_LSHIFT
                 PFA_LSHIFT:
003a47 01fc          movw zl, tosl
003a48 9189
003a49 9199          loadtos
                 PFA_LSHIFT1:
003a4a 9731          sbiw zl, 1
003a4b f01a          brmi PFA_LSHIFT2
003a4c 0f88          lsl tosl
003a4d 1f99          rol tosh
003a4e cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
003a4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
003a50 ff06          .dw $ff06
003a51 7372
003a52 6968
003a53 7466          .db "rshift"
003a54 3a41          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
003a55 3a56          .dw PFA_RSHIFT
                 PFA_RSHIFT:
003a56 01fc          movw zl, tosl
003a57 9189
003a58 9199          loadtos
                 PFA_RSHIFT1:
003a59 9731          sbiw zl, 1
003a5a f01a          brmi PFA_RSHIFT2
003a5b 9596          lsr tosh
003a5c 9587          ror tosl
003a5d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
003a5e cda5          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
003a5f ff02          .dw $ff02
003a60 212b          .db "+!"
003a61 3a50          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
003a62 3a63          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
003a63 01fc          movw zl, tosl
003a64 9189
003a65 9199          loadtos
003a66 8120          ldd temp2, Z+0
003a67 8131          ldd temp3, Z+1
003a68 0f82          add tosl, temp2
003a69 1f93          adc tosh, temp3
003a6a 8380          std Z+0, tosl
003a6b 8391          std Z+1, tosh
003a6c 9189
003a6d 9199          loadtos
003a6e cd95          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
003a6f ff03          .dw $ff03
003a70 7072
003a71 0040          .db "rp@",0
003a72 3a5f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
003a73 3a74          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
003a74 939a
003a75 938a          savetos
003a76 b78d          in tosl, SPL
003a77 b79e          in tosh, SPH
003a78 cd8b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
003a79 ff03          .dw $ff03
003a7a 7072
003a7b 0021          .db "rp!",0
003a7c 3a6f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
003a7d 3a7e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
003a7e b72f          in temp2, SREG
003a7f 94f8          cli
003a80 bf8d          out SPL, tosl
003a81 bf9e          out SPH, tosh
003a82 bf2f          out SREG, temp2
003a83 9189
003a84 9199          loadtos
003a85 cd7e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
003a86 ff03          .dw $ff03
003a87 7073
003a88 0040          .db "sp@",0
003a89 3a79          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
003a8a 3a8b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
003a8b 939a
003a8c 938a          savetos
003a8d 01ce          movw tosl, yl
003a8e cd75          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
003a8f ff03          .dw $ff03
003a90 7073
003a91 0021          .db "sp!",0
003a92 3a86          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
003a93 3a94          .dw PFA_SP_STORE
                 PFA_SP_STORE:
003a94 01ec          movw yl, tosl
003a95 9189
003a96 9199          loadtos
003a97 cd6c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
003a98 3a99          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
003a99 01fd          movw zl, xl
003a9a 0fee
003a9b 1fff
003a9c 9105
003a9d 9115          readflashcell temp0,temp1
003a9e 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
003a9f 9129          ld temp2, Y+
003aa0 9139          ld temp3, Y+
                 PFA_DODO1:
003aa1 931f          push temp1
003aa2 930f          push temp0
003aa3 933f          push temp3
003aa4 932f          push temp2
003aa5 939f          push tosh
003aa6 938f          push tosl
003aa7 9189
003aa8 9199          loadtos
003aa9 cd5a          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
003aaa 3aab          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
003aab 01fd          movw zl, xl
003aac 0fee
003aad 1fff
003aae 9105
003aaf 9115          readflashcell temp0,temp1
003ab0 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
003ab1 9129          ld temp2, Y+
003ab2 9139          ld temp3, Y+
                     ; now check for equality
003ab3 1782          cp tosl, temp2
003ab4 0793          cpc tosh, temp3
003ab5 f759          brne PFA_DODO1
                     ; both values are the same -> skip loop
003ab6 01d8          movw xl, temp0
003ab7 9189
003ab8 9199          loadtos
003ab9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
003aba ff01          .dw $FF01
003abb 0069          .db "i",0
003abc 3a8f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
003abd 38fd          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
003abe 3abf          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
003abf 91ef          pop zl
003ac0 91ff          pop zh
003ac1 0fe8          add zl, tosl
003ac2 1ff9          adc zh, tosh
003ac3 2f19          mov temp1, tosh
003ac4 9189
003ac5 9199          loadtos
                 PFA_DOPLUSLOOP4: 
003ac6 912f          pop temp2
003ac7 913f          pop temp3
003ac8 17e2          cp zl, temp2
003ac9 07f3          cpc zh, temp3
003aca ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
003acb c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
003acc f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
003acd c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
003ace f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
003acf 933f          push temp3
003ad0 932f          push temp2
003ad1 93ff          push zh
003ad2 93ef          push zl
003ad3 cd56          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
003ad4 910f          pop  temp0
003ad5 911f          pop  temp1  ; remove leave destination
003ad6 9611          adiw xl, 1 ; skip branch-back address
003ad7 cd2c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
003ad8 3ad9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
003ad9 91ef          pop zl
003ada 91ff          pop zh
003adb 9631          adiw zl,1
003adc 912f          pop temp2
003add 913f          pop temp3
003ade 17e2          cp zl, temp2
003adf 07f3          cpc zh, temp3
003ae0 f399          breq PFA_DOPLUSLOOP1
003ae1 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
003ae2 ff06          .dw $ff06
003ae3 6e75
003ae4 6f6c
003ae5 706f          .db "unloop"
003ae6 3aba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
003ae7 3ae8          .dw PFA_UNLOOP
                 PFA_UNLOOP:
003ae8 911f          pop temp1
003ae9 910f          pop temp0
003aea 911f          pop temp1
003aeb 910f          pop temp0
003aec 911f          pop temp1
003aed 910f          pop temp0
003aee cd15          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
003aef ff06          .dw $ff06
003af0 6d63
003af1 766f
003af2 3e65          .db "cmove>"
003af3 3ae2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
003af4 3af5          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
003af5 93bf          push xh
003af6 93af          push xl
003af7 91e9          ld zl, Y+
003af8 91f9          ld zh, Y+ ; addr-to
003af9 91a9          ld xl, Y+
003afa 91b9          ld xh, Y+ ; addr-from
003afb 2f09          mov temp0, tosh
003afc 2b08          or temp0, tosl
003afd f041          brbs 1, PFA_CMOVE_G1
003afe 0fe8          add zl, tosl
003aff 1ff9          adc zh, tosh
003b00 0fa8          add xl, tosl
003b01 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
003b02 911e          ld temp1, -X
003b03 9312          st -Z, temp1
003b04 9701          sbiw tosl, 1
003b05 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
003b06 91af          pop xl
003b07 91bf          pop xh
003b08 9189
003b09 9199          loadtos
003b0a ccf9          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
003b0b ff02          .dw $ff02
003b0c 3c3e          .db "><"
003b0d 3aef          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
003b0e 3b0f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
003b0f 2f09          mov temp0, tosh
003b10 2f98          mov tosh, tosl
003b11 2f80          mov tosl, temp0
003b12 ccf1          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
003b13 ff03          .dw $ff03
003b14 7075
003b15 0040          .db "up@",0
003b16 3b0b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
003b17 3b18          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
003b18 939a
003b19 938a          savetos
003b1a 01c2          movw tosl, upl
003b1b cce8          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
003b1c ff03          .dw $ff03
003b1d 7075
003b1e 0021          .db "up!",0
003b1f 3b13          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
003b20 3b21          .dw PFA_UP_STORE
                 PFA_UP_STORE:
003b21 012c          movw upl, tosl
003b22 9189
003b23 9199          loadtos
003b24 ccdf          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
003b25 ff03          .dw $ff03
003b26 3e73
003b27 0064          .db "s>d",0
003b28 3b1c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
003b29 3800          .dw DO_COLON
                 PFA_S2D:
003b2a 38ac          .dw XT_DUP
003b2b 392d          .dw XT_LESSZERO
                 .include "words/not.asm"
003b2c 381a      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
003b2d ff03          .dw $ff03
003b2e 6f6e
003b2f 0074          .db "not",0
003b30 3b25          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
003b31 3800          .dw DO_COLON
                 PFA_NOT:
003b32 3918          .dw XT_EQUALZERO
003b33 381a          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
003b34 ff02          .dw $ff02
003b35 6521          .db "!e"
003b36 3b2d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
003b37 3b38          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
003b38 01fc          movw zl, tosl
003b39 9189
003b3a 9199          loadtos
003b3b b72f          in_ temp2, SREG
003b3c 94f8          cli
003b3d d028          rcall PFA_FETCHE2
003b3e b500          in_  temp0, EEDR
003b3f 1708          cp temp0,tosl
003b40 f009          breq PFA_STOREE3
003b41 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
003b42 9631          adiw zl,1
003b43 d022          rcall PFA_FETCHE2
003b44 b500          in_  temp0, EEDR
003b45 1709          cp temp0,tosh
003b46 f011          breq PFA_STOREE4
003b47 2f89          mov tosl, tosh
003b48 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
003b49 bf2f          out_ SREG, temp2
003b4a 9189
003b4b 9199          loadtos
003b4c ccb7          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
003b4d 99f9          sbic EECR, EEPE
003b4e cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
003b4f b707          in_ temp0, SPMCSR
003b50 fd00          sbrc temp0,SPMEN
003b51 cffd          rjmp PFA_STOREE2
                 
003b52 bdf2          out_ EEARH,zh
003b53 bde1          out_ EEARL,zl
003b54 bd80          out_ EEDR, tosl
003b55 9afa          sbi EECR,EEMPE
003b56 9af9          sbi EECR,EEPE
                 
003b57 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
003b58 ff02          .dw $ff02
003b59 6540          .db "@e"
003b5a 3b34          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
003b5b 3b5c          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
003b5c b72f          in_ temp2, SREG
003b5d 94f8          cli
003b5e 01fc          movw zl, tosl
003b5f d006          rcall PFA_FETCHE2
003b60 b580          in_ tosl, EEDR
                 
003b61 9631          adiw zl,1
                 
003b62 d003          rcall PFA_FETCHE2
003b63 b590          in_  tosh, EEDR
003b64 bf2f          out_ SREG, temp2
003b65 cc9e          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
003b66 99f9          sbic EECR, EEPE
003b67 cffe          rjmp PFA_FETCHE2
                 
003b68 bdf2          out_ EEARH,zh
003b69 bde1          out_ EEARL,zl
                 
003b6a 9af8          sbi EECR,EERE
003b6b 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
003b6c ff02          .dw $ff02
003b6d 6921          .db "!i"
003b6e 3b58          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
003b6f 0832          .dw PFA_DODEFER
                 PFA_STOREI:
003b70 000a          .dw EE_STOREI
003b71 07f6          .dw XT_EDEFERFETCH
003b72 07fb          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
003b73 ff09          .dw $ff09
003b74 2128
003b75 2d69
003b76 726e
003b77 7777
003b78 0029          .db "(!i-nrww)",0
003b79 3b6c          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
003b7a 3b7b          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
003b7b b71f        in temp1,SREG
003b7c 931f        push temp1
003b7d 94f8        cli
                 
003b7e 019c        movw temp2, tosl ; save the (word) address
003b7f 9189
003b80 9199        loadtos          ; get the new value for the flash cell
003b81 93af        push xl
003b82 93bf        push xh
003b83 93cf        push yl
003b84 93df        push yh
003b85 d009        rcall DO_STOREI_atmega
003b86 91df        pop yh
003b87 91cf        pop yl
003b88 91bf        pop xh
003b89 91af        pop xl
                   ; finally clear the stack
003b8a 9189
003b8b 9199        loadtos
003b8c 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
003b8d bf1f        out SREG,temp1
                 
003b8e cc75        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
003b8f d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
003b90 94e0        com temp4
003b91 94f0        com temp5
003b92 218e        and tosl, temp4
003b93 219f        and tosh, temp5
003b94 2b98        or tosh, tosl
003b95 f019        breq DO_STOREI_writepage 
                 
003b96 01f9          movw zl, temp2
003b97 e002          ldi temp0,(1<<PGERS)
003b98 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
003b99 01f9        movw zl, temp2
003b9a e004        ldi temp0,(1<<PGWRT)
003b9b d01d        rcall dospm
                 
                   ; reenable RWW section
003b9c 01f9        movw zl, temp2
003b9d e100        ldi temp0,(1<<RWWSRE)
003b9e d01a        rcall dospm
003b9f 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
003ba0 01f9        movw zl, temp2
                   ; get the beginning of page
003ba1 7ce0        andi zl,low(pagemask)
003ba2 7fff        andi zh,high(pagemask)
003ba3 01ef        movw y, z
                   ; loop counter (in words)
003ba4 e4a0        ldi xl,low(pagesize)
003ba5 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
003ba6 01fe        movw z, y
003ba7 0fee
003ba8 1fff
003ba9 9145
003baa 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003bab 01fe        movw z, y
003bac 17e2        cp zl, temp2
003bad 07f3        cpc zh, temp3
003bae f011        breq pageload_newdata
003baf 010a          movw r0, temp6
003bb0 c002          rjmp pageload_cont
                 pageload_newdata:
003bb1 017a          movw temp4, temp6
003bb2 010c          movw r0, tosl
                 pageload_cont:
003bb3 2700        clr temp0
003bb4 d004        rcall dospm
003bb5 9621        adiw y, 1
003bb6 9711        sbiw x, 1
003bb7 f771        brne pageload_loop
                 
                 pageload_done:
003bb8 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
003bb9 99f9        sbic EECR, EEPE
003bba cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
003bbb b717        in_  temp1, SPMCSR
003bbc fd10        sbrc temp1, SPMEN
003bbd cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
003bbe 0fee
003bbf 1fff        writeflashcell
                   ; execute spm
003bc0 6001        ori temp0, (1<<SPMEN)
003bc1 bf07        out_ SPMCSR,temp0
003bc2 95e8        spm
003bc3 9508        ret
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
003bc4 ff02          .dw $ff02
003bc5 6940          .db "@i"
003bc6 3b73          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
003bc7 3bc8          .dw PFA_FETCHI
                 PFA_FETCHI:
003bc8 01fc          movw zl, tosl
003bc9 0fee
003bca 1fff
003bcb 9185
003bcc 9195          readflashcell tosl,tosh
003bcd cc36          jmp_ DO_NEXT
                 ;.include "dict_interrupt.inc"
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
003bce 0007          .dw $0007
003bcf 696c
003bd0 6574
003bd1 6172
003bd2 006c          .db "literal",0
003bd3 3bc4          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
003bd4 3800          .dw DO_COLON
                 PFA_LITERAL:
003bd5 0203          .dw XT_COMPILE
003bd6 3837          .dw XT_DOLITERAL
003bd7 020e          .dw XT_COMMA
003bd8 381a          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
003bd9 0008        .dw $0008
003bda 6c73
003bdb 7469
003bdc 7265
003bdd 6c61        .db "sliteral"
003bde 3bce        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
003bdf 3800          .dw DO_COLON
                 PFA_SLITERAL:
003be0 0203          .dw XT_COMPILE
003be1 03f3          .dw XT_DOSLITERAL    ; ( -- addr n)
003be2 0406          .dw XT_SCOMMA
003be3 381a          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
003be4 3800          .dw DO_COLON
                 PFA_GMARK:
003be5 01b7          .dw XT_DP
003be6 0203          .dw XT_COMPILE
003be7 ffff          .dw -1           ; ffff does not erase flash
003be8 381a          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
003be9 3800          .dw DO_COLON
                 PFA_GRESOLVE:
003bea 07a5          .dw XT_QSTACK
003beb 01b7          .dw XT_DP
003bec 38bf          .dw XT_SWAP
003bed 3b6f          .dw XT_STOREI
003bee 381a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
003bef 3800          .dw DO_COLON
                 PFA_LMARK:
003bf0 01b7          .dw XT_DP
003bf1 381a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
003bf2 3800          .dw DO_COLON
                 PFA_LRESOLVE:
003bf3 07a5          .dw XT_QSTACK
003bf4 020e          .dw XT_COMMA
003bf5 381a          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
003bf6 0005          .dw $0005
003bf7 6861
003bf8 6165
003bf9 0064          .db "ahead",0
003bfa 3bd9          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
003bfb 3800          .dw DO_COLON
                 PFA_AHEAD:
003bfc 0203          .dw XT_COMPILE
003bfd 3829          .dw XT_DOBRANCH
003bfe 3be4          .dw XT_GMARK
003bff 381a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
003c00 0002          .dw $0002
003c01 6669          .db "if"
003c02 3bf6          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
003c03 3800          .dw DO_COLON
                 PFA_IF:
003c04 0203          .dw XT_COMPILE
003c05 3830          .dw XT_DOCONDBRANCH
003c06 3be4          .dw XT_GMARK
003c07 381a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
003c08 0004          .dw $0004
003c09 6c65
003c0a 6573          .db "else"
003c0b 3c00          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
003c0c 3800          .dw DO_COLON
                 PFA_ELSE:
003c0d 0203          .dw XT_COMPILE
003c0e 3829          .dw XT_DOBRANCH
003c0f 3be4          .dw XT_GMARK
003c10 38bf          .dw XT_SWAP
003c11 3be9          .dw XT_GRESOLVE
003c12 381a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
003c13 0004          .dw $0004
003c14 6874
003c15 6e65          .db "then"
003c16 3c08          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
003c17 3800          .dw DO_COLON
                 PFA_THEN:
003c18 3be9          .dw XT_GRESOLVE
003c19 381a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
003c1a 0005          .dw $0005
003c1b 6562
003c1c 6967
003c1d 006e          .db "begin",0
003c1e 3c13          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
003c1f 3800          .dw DO_COLON
                 PFA_BEGIN:
003c20 3bef          .dw XT_LMARK
003c21 381a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
003c22 0005          .dw $0005
003c23 6877
003c24 6c69
003c25 0065          .db "while",0
003c26 3c1a          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
003c27 3800          .dw DO_COLON
                 PFA_WHILE:
003c28 0203          .dw XT_COMPILE
003c29 3830          .dw XT_DOCONDBRANCH
003c2a 3be4          .dw XT_GMARK
003c2b 38bf          .dw XT_SWAP
003c2c 381a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
003c2d 0006          .dw $0006
003c2e 6572
003c2f 6570
003c30 7461          .db "repeat"
003c31 3c22          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
003c32 3800          .dw DO_COLON
                 PFA_REPEAT:
003c33 3c45          .dw XT_AGAIN
003c34 3be9          .dw XT_GRESOLVE
003c35 381a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
003c36 0005          .dw $0005
003c37 6e75
003c38 6974
003c39 006c          .db "until",0
003c3a 3c2d          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
003c3b 3800          .dw DO_COLON
                 PFA_UNTIL:
003c3c 0203          .dw XT_COMPILE
003c3d 3830          .dw XT_DOCONDBRANCH
003c3e 3bf2          .dw XT_LRESOLVE
003c3f 381a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
003c40 0005          .dw $0005
003c41 6761
003c42 6961
003c43 006e          .db "again",0
003c44 3c36          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
003c45 3800          .dw DO_COLON
                 PFA_AGAIN:
003c46 0203          .dw XT_COMPILE
003c47 3829          .dw XT_DOBRANCH
003c48 3bf2          .dw XT_LRESOLVE
003c49 381a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
003c4a 0002          .dw $0002
003c4b 6f64          .db "do"
003c4c 3c40          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
003c4d 3800          .dw DO_COLON
                 PFA_DO:
003c4e 0203          .dw XT_COMPILE
003c4f 3a98          .dw XT_DODO
003c50 3be4          .dw XT_GMARK
003c51 3bef          .dw XT_LMARK
003c52 381a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
003c53 0004          .dw $0004
003c54 6f6c
003c55 706f          .db "loop"
003c56 3c4a          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
003c57 3800          .dw DO_COLON
                 PFA_LOOP:
003c58 0203          .dw XT_COMPILE
003c59 3ad8          .dw XT_DOLOOP
003c5a 3bf2          .dw XT_LRESOLVE
003c5b 3be9          .dw XT_GRESOLVE
003c5c 381a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
003c5d 0005          .dw $0005
003c5e 6c2b
003c5f 6f6f
003c60 0070          .db "+loop",0
003c61 3c53          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
003c62 3800          .dw DO_COLON
                 PFA_PLUSLOOP:
003c63 0203          .dw XT_COMPILE
003c64 3abe          .dw XT_DOPLUSLOOP
003c65 3bf2          .dw XT_LRESOLVE
003c66 3be9          .dw XT_GRESOLVE
003c67 381a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
003c68 ff05         .dw $FF05
003c69 656c
003c6a 7661
003c6b 0065         .db "leave",0
003c6c 3c5d         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
003c6d 3c6e          .dw PFA_LEAVE
                 PFA_LEAVE:
003c6e 910f          pop temp0  ; drop limit and counter from returnstack
003c6f 911f          pop temp1
003c70 910f          pop temp0
003c71 911f          pop temp1
003c72 91af          pop xl
003c73 91bf          pop xh
003c74 cb8f          jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
003c75 0003          .dw $0003
003c76 643f
003c77 006f          .db "?do",0
003c78 3c68          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
003c79 3800          .dw DO_COLON
                 PFA_QDO:
003c7a 0203          .dw XT_COMPILE
003c7b 3aaa          .dw XT_DOQDO
003c7c 3be4          .dw XT_GMARK
003c7d 3bef          .dw XT_LMARK
003c7e 381a          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
003c7f ff06          .dw $ff06
003c80 7263
003c81 6165
003c82 6574          .db "create"
003c83 3c75          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
003c84 3800          .dw DO_COLON
                 PFA_CREATE:
003c85 01dc          .dw XT_DOCREATE
003c86 3cb3          .dw XT_REVEAL
003c87 0203          .dw XT_COMPILE
003c88 384c          .dw PFA_DOCONSTANT
003c89 381a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
003c8a ff06          .dw $ff06
003c8b 6568
003c8c 6461
003c8d 7265          .db "header"
003c8e 3c7f          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
003c8f 3800          .dw DO_COLON
                 PFA_HEADER:
003c90 01b7          .dw XT_DP           ; the new Name Field
003c91 38f3          .dw XT_TO_R
003c92 38f3          .dw XT_TO_R		; ( R: NFA WID )
003c93 38ac          .dw XT_DUP    
003c94 395c          .dw XT_GREATERZERO 
003c95 3830          .dw XT_DOCONDBRANCH
003c96 3ca1          .dw PFA_HEADER1
003c97 38ac          .dw XT_DUP
003c98 3837          .dw XT_DOLITERAL
003c99 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
003c9a 3a25          .dw XT_OR
003c9b 040a          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
003c9c 38ea          .dw XT_R_FROM
003c9d 3b5b          .dw XT_FETCHE
003c9e 020e          .dw XT_COMMA
003c9f 38ea          .dw XT_R_FROM
003ca0 381a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
003ca1 3837          .dw XT_DOLITERAL
003ca2 fff0          .dw -16
003ca3 04bf          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
003ca4 ff07          .dw $ff07
003ca5 6c77
003ca6 6373
003ca7 706f
003ca8 0065          .db "wlscope",0
003ca9 3c8a          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
003caa 0832          .dw PFA_DODEFER
                 PFA_WLSCOPE:
003cab 0034          .dw EE_WLSCOPE
003cac 07f6          .dw XT_EDEFERFETCH
003cad 07fb          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
003cae ff06          .dw $ff06
003caf 6572
003cb0 6576
003cb1 6c61          .db "reveal"
003cb2 3ca4          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
003cb3 3800          .dw DO_COLON
                 PFA_REVEAL:
003cb4 3837          .dw XT_DOLITERAL
003cb5 016f          .dw COLON_SMUDGE+0
003cb6 3874          .dw XT_FETCH
003cb7 38b4          .dw XT_QDUP
003cb8 3830          .dw XT_DOCONDBRANCH
003cb9 3cc2          .dw PFA_REVEAL1
                 ;
003cba 3837          .dw XT_DOLITERAL
003cbb 0171          .dw COLON_SMUDGE+2
003cbc 3874          .dw XT_FETCH		; ( NFA WID )
003cbd 3b37          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
003cbe 3934          .dw XT_ZERO
003cbf 3837          .dw XT_DOLITERAL
003cc0 016f          .dw COLON_SMUDGE+0
003cc1 387c          .dw XT_STORE
                 PFA_REVEAL1:
003cc2 381a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
003cc3 ff06          .dw $ff06
003cc4 616c
003cc5 6574
003cc6 7473          .db "latest"
003cc7 3cae          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
003cc8 3842          .dw PFA_DOVARIABLE
                 PFA_LATEST:
003cc9 0201          .dw ram_LATEST
                 
                 .dseg
000201           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
003cca 0005          .dw $0005
003ccb 6f64
003ccc 7365
003ccd 003e          .db "does>",0
003cce 3cc3          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
003ccf 3800          .dw DO_COLON
                 PFA_DOES:
003cd0 0203          .dw XT_COMPILE
003cd1 3ce1          .dw XT_DODOES
003cd2 0203          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
003cd3 940e          .dw $940e       ; the address of this compiled
003cd4 0203          .dw XT_COMPILE  ; code will replace the XT of the 
003cd5 3cd7          .dw DO_DODOES   ; word that CREATE created
003cd6 381a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
003cd7 939a
003cd8 938a          savetos
003cd9 01cb          movw tosl, wl
003cda 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
003cdb 917f          pop wh
003cdc 916f          pop wl
                 
003cdd 93bf          push XH
003cde 93af          push XL
003cdf 01db          movw XL, wl
003ce0 cb23          jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
003ce1 3800          .dw DO_COLON
                 PFA_DODOES:
003ce2 38ea          .dw XT_R_FROM
003ce3 3837          .dw XT_DOLITERAL
003ce4 0171          .dw COLON_SMUDGE+2
003ce5 3874          .dw XT_FETCH
003ce6 3b5b          .dw XT_FETCHE
003ce7 3e8f          .dw XT_NFA2LFA
003ce8 3a38          .dw XT_1PLUS   ; lfa>xt
                 
003ce9 3b6f          .dw XT_STOREI
003cea 381a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
003ceb ff01          .dw $ff01
003cec 003a          .db ":",0
003ced 3cca          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
003cee 3800          .dw DO_COLON
                 PFA_COLON:
003cef 01dc          .dw XT_DOCREATE
003cf0 01b7          .dw XT_DP
003cf1 3cc8          .dw XT_LATEST
003cf2 387c          .dw XT_STORE
003cf3 0203          .dw XT_COMPILE
003cf4 3800          .dw DO_COLON
003cf5 3d12          .dw XT_RBRACKET
003cf6 381a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
003cf7 ff07          .dw $ff07
003cf8 6e3a
003cf9 6e6f
003cfa 6d61
003cfb 0065          .db ":noname",0
003cfc 3ceb          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
003cfd 3800          .dw DO_COLON
                 PFA_COLONNONAME:
003cfe 01b7          .dw XT_DP
003cff 38ac          .dw XT_DUP
003d00 3cc8          .dw XT_LATEST
003d01 387c          .dw XT_STORE
                 
003d02 0203          .dw XT_COMPILE
003d03 3800          .dw DO_COLON
                 
003d04 3d12          .dw XT_RBRACKET
003d05 381a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
003d06 0001          .dw $0001
003d07 003b          .db $3b,0
003d08 3cf7          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
003d09 3800          .dw DO_COLON
                 PFA_SEMICOLON:
003d0a 0203          .dw XT_COMPILE
003d0b 381a          .dw XT_EXIT
003d0c 3d1b          .dw XT_LBRACKET
003d0d 3cb3          .dw XT_REVEAL
003d0e 381a          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
003d0f ff01          .dw $ff01
003d10 005d          .db "]",0
003d11 3d06          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
003d12 3800          .dw DO_COLON
                 PFA_RBRACKET:
003d13 3837          .dw XT_DOLITERAL
003d14 0001          .dw 1
003d15 0153          .dw XT_STATE
003d16 387c          .dw XT_STORE
003d17 381a          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
003d18 0001          .dw $0001
003d19 005b          .db "[",0
003d1a 3d0f          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
003d1b 3800          .dw DO_COLON
                 PFA_LBRACKET:
003d1c 3934          .dw XT_ZERO
003d1d 0153          .dw XT_STATE
003d1e 387c          .dw XT_STORE
003d1f 381a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
003d20 ff08          .dw $ff08
003d21 6176
003d22 6972
003d23 6261
003d24 656c          .db "variable"
003d25 3d18          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
003d26 3800          .dw DO_COLON
                 PFA_VARIABLE:
003d27 01c7          .dw XT_HERE
003d28 3d33          .dw XT_CONSTANT
003d29 3837          .dw XT_DOLITERAL
003d2a 0002          .dw 2
003d2b 01d0          .dw XT_ALLOT
003d2c 381a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
003d2d ff08          .dw $ff08
003d2e 6f63
003d2f 736e
003d30 6174
003d31 746e          .db "constant"
003d32 3d20          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
003d33 3800          .dw DO_COLON
                 PFA_CONSTANT:
003d34 01dc          .dw XT_DOCREATE
003d35 3cb3          .dw XT_REVEAL
003d36 0203          .dw XT_COMPILE
003d37 3842          .dw PFA_DOVARIABLE
003d38 020e          .dw XT_COMMA
003d39 381a          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
003d3a ff04          .dw $ff04
003d3b 7375
003d3c 7265          .db "user"
003d3d 3d2d          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
003d3e 3800          .dw DO_COLON
                 PFA_USER:
003d3f 01dc          .dw XT_DOCREATE
003d40 3cb3          .dw XT_REVEAL
                 
003d41 0203          .dw XT_COMPILE
003d42 3852          .dw PFA_DOUSER
003d43 020e          .dw XT_COMMA
003d44 381a          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
003d45 ff05          .dw $ff05
003d46 6176
003d47 756c
003d48 0065          .db "value",0
003d49 3d3a          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
003d4a 3800          .dw DO_COLON
                 PFA_VALUE:
003d4b 3863          .dw XT_DOVALUE
003d4c 01bf          .dw XT_EDP
003d4d 020e          .dw XT_COMMA
003d4e 0203          .dw XT_COMPILE
003d4f 3d5a          .dw XT_EVALUEFETCH
003d50 0203          .dw XT_COMPILE
003d51 3d5e          .dw XT_EVALUESTORE
003d52 01bf          .dw XT_EDP
003d53 38ac          .dw XT_DUP
003d54 3a38          .dw XT_1PLUS
003d55 3a38          .dw XT_1PLUS
003d56 07ea          .dw XT_DOTO
003d57 01c0          .dw PFA_EDP
003d58 3b37          .dw XT_STOREE
003d59 381a          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
003d5a 3800          .dw DO_COLON
                 PFA_EVALUEFETCH:
003d5b 3bc7          .dw XT_FETCHI
003d5c 3b5b          .dw XT_FETCHE
003d5d 381a          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
003d5e 3800          .dw DO_COLON
                 PFA_EVALUESTORE:
003d5f 3bc7          .dw XT_FETCHI
003d60 3b37          .dw XT_STOREE
003d61 381a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
003d62 0007          .dw $0007
003d63 6572
003d64 7563
003d65 7372
003d66 0065          .db "recurse",0
003d67 3d45          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
003d68 3800          .dw DO_COLON
                 PFA_RECURSE:
003d69 3cc8          .dw XT_LATEST
003d6a 3874          .dw XT_FETCH
003d6b 020e          .dw XT_COMMA
003d6c 381a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
003d6d ff09          .dw $ff09
003d6e 6d69
003d6f 656d
003d70 6964
003d71 7461
003d72 0065          .db "immediate",0
003d73 3d62          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
003d74 3800          .dw DO_COLON
                 PFA_IMMEDIATE:
003d75 3e51          .dw XT_GET_CURRENT
003d76 3b5b          .dw XT_FETCHE
003d77 38ac          .dw XT_DUP
003d78 3bc7          .dw XT_FETCHI
003d79 3837          .dw XT_DOLITERAL
003d7a 7fff          .dw $7fff
003d7b 3a1c          .dw XT_AND
003d7c 38bf          .dw XT_SWAP
003d7d 3b6f          .dw XT_STOREI
003d7e 381a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
003d7f 0006          .dw $0006
003d80 635b
003d81 6168
003d82 5d72          .db "[char]"
003d83 3d6d          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
003d84 3800          .dw DO_COLON
                 PFA_BRACKETCHAR:
003d85 0203          .dw XT_COMPILE
003d86 3837          .dw XT_DOLITERAL
003d87 0542          .dw XT_CHAR
003d88 020e          .dw XT_COMMA
003d89 381a          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
003d8a 0006          .dw $0006
003d8b 6261
003d8c 726f
003d8d 2274          .db "abort", $22
003d8e 3d7f          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
003d8f 3800          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
003d90 0203          .dw XT_COMPILE
003d91 3830          .dw XT_DOCONDBRANCH
003d92 01b7          .dw XT_DP
003d93 0203          .dw XT_COMPILE
003d94 ffff          .dw -1
                     
003d95 3f06          .dw XT_DOTSTRING
                     
003d96 0203          .dw XT_COMPILE
003d97 3837          .dw XT_DOLITERAL
                     
003d98 0203          .dw XT_COMPILE
003d99 fffe          .dw -2
003d9a 0203          .dw XT_COMPILE
003d9b 04bf          .dw XT_THROW
                     ; then
003d9c 01b7          .dw XT_DP
003d9d 38bf          .dw XT_SWAP
003d9e 3b6f          .dw XT_STOREI
003d9f 381a          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
003da0 ff05          .dw $ff05
003da1 6261
003da2 726f
003da3 0074          .db "abort",0
003da4 3d8a          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
003da5 3800          .dw DO_COLON
                 PFA_ABORT:
003da6 3837          .dw XT_DOLITERAL
003da7 ffff          .dw -1
003da8 04bf          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
003da9 ff04          .dw $ff04
003daa 6f63
003dab 6564          .db "code"
003dac 3da0          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
003dad 3800          .dw DO_COLON
                 PFA_CODE:
003dae 01dc          .dw XT_DOCREATE
003daf 3cb3          .dw XT_REVEAL
003db0 01b7          .dw XT_DP
003db1 3a38          .dw XT_1PLUS
003db2 020e          .dw XT_COMMA
003db3 381a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
003db4 ff08          .dw $ff08
003db5 6e65
003db6 2d64
003db7 6f63
003db8 6564          .db "end-code"
003db9 3da9          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
003dba 3800          .dw DO_COLON
                 PFA_ENDCODE:
003dbb 0203          .dw XT_COMPILE
003dbc 940c          .dw $940c
003dbd 0203          .dw XT_COMPILE
003dbe 3804          .dw DO_NEXT
003dbf 381a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
003dc0 ff0b          .dw $ff0b
003dc1 6e65
003dc2 6976
003dc3 6f72
003dc4 6d6e
003dc5 6e65
003dc6 0074          .db "environment",0
003dc7 3db4          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
003dc8 3842          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
003dc9 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
003dca ff09          .dw $ff09
003dcb 6f77
003dcc 6472
003dcd 696c
003dce 7473
003dcf 0073          .db "wordlists",0
003dd0 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
003dd1 3800          .dw DO_COLON
                 PFA_ENVWORDLISTS:
003dd2 3837          .dw XT_DOLITERAL
003dd3 0008          .dw NUMWORDLISTS
003dd4 381a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
003dd5 ff04          .dw $ff04
003dd6 702f
003dd7 6461          .db "/pad"
003dd8 3dca          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
003dd9 3800          .dw DO_COLON
                 PFA_ENVSLASHPAD:
003dda 3a8a          .dw XT_SP_FETCH
003ddb 018d          .dw XT_PAD
003ddc 399c          .dw XT_MINUS
003ddd 381a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
003dde ff05          .dw $ff05
003ddf 682f
003de0 6c6f
003de1 0064          .db "/hold",0
003de2 3dd5          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
003de3 3800          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
003de4 018d          .dw XT_PAD
003de5 01c7          .dw XT_HERE
003de6 399c          .dw XT_MINUS
003de7 381a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
003de8 ff0a          .dw $ff0a
003de9 6f66
003dea 7472
003deb 2d68
003dec 616e
003ded 656d          .db "forth-name"
003dee 3dde          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
003def 3800          .dw DO_COLON
                 PFA_EN_FORTHNAME:
003df0 03f3          .dw XT_DOSLITERAL
003df1 0007          .dw 7
003df2 6d61
003df3 6f66
003df4 7472
003df5 0068          .db "amforth",0
003df6 381a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
003df7 ff07          .dw $ff07
003df8 6576
003df9 7372
003dfa 6f69
003dfb 006e          .db "version",0
003dfc 3de8          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
003dfd 3800          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
003dfe 3837          .dw XT_DOLITERAL
003dff 0034          .dw 52
003e00 381a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
003e01 ff03          .dw $ff03
003e02 7063
003e03 0075          .db "cpu",0
003e04 3df7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
003e05 3800          .dw DO_COLON
                 PFA_EN_CPU:
003e06 3837          .dw XT_DOLITERAL
003e07 0059          .dw mcu_name
003e08 0455          .dw XT_ICOUNT
003e09 381a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
003e0a ff08          .dw $ff08
003e0b 636d
003e0c 2d75
003e0d 6e69
003e0e 6f66          .db "mcu-info"
003e0f 3e01          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
003e10 3800          .dw DO_COLON
                 PFA_EN_MCUINFO:
003e11 3837          .dw XT_DOLITERAL
003e12 0055          .dw mcu_info
003e13 381a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
003e14 ff05          .dw $ff05
003e15 752f
003e16 6573
003e17 0072          .db "/user",0
003e18 3e0a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
003e19 3800          .dw DO_COLON
                 PFA_ENVUSERSIZE:
003e1a 3837          .dw XT_DOLITERAL
003e1b 0026          .dw SYSUSERSIZE + APPUSERSIZE
003e1c 381a          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
003e1d ff04          .dw $ff04
003e1e 6540
003e1f 5d5b          .db "@e[]"
003e20 3dc0          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
003e21 3800          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
003e22 38ac          .dw XT_DUP
003e23 3b5b          .dw XT_FETCHE
003e24 38f3          .dw XT_TO_R    ; save the counter to r-stack
003e25 38fc          .dw XT_R_FETCH
003e26 3934          .dw XT_ZERO
003e27 38bf          .dw XT_SWAP    ; go from bigger to smaller addresses
003e28 3aaa          .dw XT_DOQDO
003e29 3e33          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
003e2a 3abd          .dw XT_I
003e2b 0160          .dw XT_CELLS ; ( -- ee-addr i*2 )
003e2c 38ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
003e2d 39a6          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
003e2e 3b5b          .dw XT_FETCHE ;( -- ee-addr item_i )
003e2f 38bf          .dw XT_SWAP   ;( -- item_i ee-addr )
003e30 393d          .dw XT_TRUE  ; shortcut for -1
003e31 3abe          .dw XT_DOPLUSLOOP
003e32 3e2a          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
003e33 0179          .dw XT_2DROP
003e34 38ea          .dw XT_R_FROM ; get the counter from r-stack
003e35 381a          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
003e36 ff04          .dw $ff04
003e37 6521
003e38 5d5b          .db "!e[]"
003e39 3e1d          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
003e3a 3800          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
003e3b 0170          .dw XT_2DUP
003e3c 3b37          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
003e3d 38bf          .dw XT_SWAP    
003e3e 3934          .dw XT_ZERO
003e3f 3aaa          .dw XT_DOQDO
003e40 3e47          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
003e41 0168          .dw XT_CELLPLUS ; ( -- i_x e-addr )
003e42 38bf          .dw XT_SWAP
003e43 38ca          .dw XT_OVER      ; ( -- e-addr i_x e-addr
003e44 3b37          .dw XT_STOREE
003e45 3ad8          .dw XT_DOLOOP
003e46 3e41          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
003e47 38d4          .dw XT_DROP
003e48 381a          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
003e49 ff0b          .dw $ff0b
003e4a 6567
003e4b 2d74
003e4c 7563
003e4d 7272
003e4e 6e65
003e4f 0074          .db "get-current",0
003e50 3e36          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
003e51 3800          .dw DO_COLON
                 PFA_GET_CURRENT:
003e52 3837          .dw XT_DOLITERAL
003e53 0010          .dw EE_CURRENT
003e54 3b5b          .dw XT_FETCHE
003e55 381a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
003e56 ff09          .dw $ff09
003e57 6567
003e58 2d74
003e59 726f
003e5a 6564
003e5b 0072          .db "get-order",0
003e5c 3e49          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
003e5d 3800          .dw DO_COLON
                 PFA_GET_ORDER:
003e5e 3837          .dw XT_DOLITERAL
003e5f 0014          .dw EE_ORDERLISTLEN
003e60 3e21          .dw XT_FETCH_EE_ARRAY
003e61 381a          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
003e62 ff07          .dw $ff07
003e63 6f63
003e64 706d
003e65 7261
003e66 0065          .db "compare",0
003e67 3e56          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
003e68 3e69          .dw PFA_COMPARE
                 PFA_COMPARE:
003e69 93bf          push xh
003e6a 93af          push xl
003e6b 018c          movw temp0, tosl
003e6c 9189
003e6d 9199          loadtos
003e6e 01dc          movw xl, tosl
003e6f 9189
003e70 9199          loadtos
003e71 019c          movw temp2, tosl
003e72 9189
003e73 9199          loadtos
003e74 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
003e75 90ed          ld temp4, X+
003e76 90f1          ld temp5, Z+
003e77 14ef          cp temp4, temp5
003e78 f451          brne PFA_COMPARE_NOTEQUAL
003e79 950a          dec temp0
003e7a f019          breq PFA_COMPARE_ENDREACHED2
003e7b 952a          dec temp2
003e7c f7c1          brne PFA_COMPARE_LOOP
003e7d c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
003e7e 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
003e7f 2b02          or temp0, temp2
003e80 f411          brne PFA_COMPARE_CHECKLASTCHAR
003e81 2788          clr tosl
003e82 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
003e83 ef8f          ser tosl
003e84 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
003e85 2f98          mov tosh, tosl
003e86 91af          pop xl
003e87 91bf          pop xh
003e88 c97b          jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
003e89 ff07         .dw $ff07
003e8a 666e
003e8b 3e61
003e8c 666c
003e8d 0061         .db "nfa>lfa",0
003e8e 3e62         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
003e8f 3800          .dw DO_COLON
                 PFA_NFA2LFA:
003e90 0455          .dw XT_ICOUNT 
003e91 3837          .dw XT_DOLITERAL
003e92 00ff          .dw $00ff
003e93 3a1c          .dw XT_AND
003e94 3a38          .dw XT_1PLUS
003e95 3a0d          .dw XT_2SLASH
003e96 39a6          .dw XT_PLUS
003e97 381a          .dw XT_EXIT
                 ;.include "dict_usart.inc"
                 ;.include "dict_wl.inc"
                 ;.include "dict_mcu.inc"
                 ;.include "dict_minimum.inc"
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
003e98 ff04          .dw $ff04
003e99 6966
003e9a 6c6c          .db "fill"
003e9b 3e89          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
003e9c 3800          .dw DO_COLON
                 PFA_FILL:
003e9d 38dc          .dw XT_ROT
003e9e 38dc          .dw XT_ROT
003e9f 3934          .dw XT_ZERO
003ea0 3aaa          .dw XT_DOQDO
003ea1 3ea7          .dw PFA_FILL2
                 PFA_FILL1:
003ea2 0170          .dw XT_2DUP
003ea3 3888          .dw XT_CSTORE  ; ( -- c c-addr)
003ea4 3a38          .dw XT_1PLUS
003ea5 3ad8          .dw XT_DOLOOP
003ea6 3ea2          .dw PFA_FILL1
                 PFA_FILL2:
003ea7 38d4          .dw XT_DROP
003ea8 38d4          .dw XT_DROP
003ea9 381a          .dw XT_EXIT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
003eaa ff03          .dw $ff03
003eab 3264
003eac 002a          .db "d2*",0
003ead 3e98          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
003eae 3eaf          .dw PFA_D2STAR
                 PFA_D2STAR:
003eaf 9109          ld temp0, Y+
003eb0 9119          ld temp1, Y+
003eb1 0f00          lsl temp0
003eb2 1f11          rol temp1
003eb3 1f88          rol tosl
003eb4 1f99          rol tosh
003eb5 931a          st -Y, temp1
003eb6 930a          st -Y, temp0
003eb7 c94c          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
003eb8 ff02          .dw $ff02
003eb9 2b64          .db "d+"
003eba 3eaa          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
003ebb 3ebc          .dw PFA_DPLUS
                 PFA_DPLUS:
003ebc 9129          ld temp2, Y+
003ebd 9139          ld temp3, Y+
                 
003ebe 90e9          ld temp4, Y+
003ebf 90f9          ld temp5, Y+
003ec0 9149          ld temp6, Y+
003ec1 9159          ld temp7, Y+
                 
003ec2 0f24          add temp2, temp6
003ec3 1f35          adc temp3, temp7
003ec4 1d8e          adc tosl, temp4
003ec5 1d9f          adc tosh, temp5
                     
003ec6 933a          st -Y, temp3
003ec7 932a          st -Y, temp2
003ec8 c93b          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
003ec9 ff02          .dw $ff02
003eca 2d64          .db "d-"
003ecb 3eb8          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
003ecc 3ecd          .dw PFA_DMINUS
                 PFA_DMINUS:
003ecd 9129          ld temp2, Y+
003ece 9139          ld temp3, Y+
                 
003ecf 90e9          ld temp4, Y+
003ed0 90f9          ld temp5, Y+
003ed1 9149          ld temp6, Y+
003ed2 9159          ld temp7, Y+
                 
003ed3 1b42          sub temp6, temp2
003ed4 0b53          sbc temp7, temp3
003ed5 0ae8          sbc temp4, tosl
003ed6 0af9          sbc temp5, tosh
                 
003ed7 935a          st -Y, temp7
003ed8 934a          st -Y, temp6
003ed9 01c7          movw tosl, temp4
003eda c929          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
003edb ff07          .dw $ff07
003edc 6964
003edd 766e
003ede 7265
003edf 0074          .db "dinvert",0
003ee0 3ec9          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
003ee1 3ee2          .dw PFA_DINVERT
                 PFA_DINVERT:
003ee2 9109          ld temp0, Y+
003ee3 9119          ld temp1, Y+
003ee4 9580          com tosl
003ee5 9590          com tosh
003ee6 9500          com temp0
003ee7 9510          com temp1
003ee8 931a          st -Y, temp1
003ee9 930a          st -Y, temp0
003eea c919          jmp_ DO_NEXT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
003eeb ff02          .dw $ff02
003eec 2e75          .db "u."
003eed 3edb          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
003eee 3800          .dw DO_COLON
                 PFA_UDOT:
003eef 3934          .dw XT_ZERO
003ef0 0398          .dw XT_UDDOT
003ef1 381a          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
003ef2 ff02          .dw $ff02
003ef3 732e          .db ".s"
003ef4 3eeb          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
003ef5 3800          .dw DO_COLON
                 PFA_DOTS:
003ef6 0706          .dw XT_SP0
003ef7 3a8a          .dw XT_SP_FETCH
003ef8 0168          .dw XT_CELLPLUS
003ef9 3aaa          .dw XT_DOQDO
003efa 3f02          .dw PFA_DOTS2
                 PFA_DOTS1:
003efb 3abd          .dw XT_I
003efc 3874          .dw XT_FETCH 
003efd 3eee          .dw XT_UDOT
003efe 3837          .dw XT_DOLITERAL
003eff 0002          .dw 2
003f00 3abe          .dw XT_DOPLUSLOOP
003f01 3efb          .dw PFA_DOTS1
                 PFA_DOTS2:
003f02 381a          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
003f03 0002          .dw $0002
003f04 222e          .db ".",$22
003f05 3ef2          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
003f06 3800          .dw DO_COLON
                 PFA_DOTSTRING:
003f07 3f0e          .dw XT_SQUOTE
003f08 0203          .dw XT_COMPILE
003f09 042a          .dw XT_ITYPE
003f0a 381a          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
003f0b 0002        .dw $0002
003f0c 2273        .db "s",$22
003f0d 3f03        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
003f0e 3800          .dw DO_COLON
                 PFA_SQUOTE:
003f0f 3837          .dw XT_DOLITERAL
003f10 0022          .dw $22
003f11 0600          .dw XT_PARSE       ; ( -- addr n)
003f12 0153          .dw XT_STATE
003f13 3874          .dw XT_FETCH
003f14 3830          .dw XT_DOCONDBRANCH
003f15 3f19          .dw PFA_SQUOTE1
003f16 0203            .dw XT_COMPILE
003f17 03f3            .dw XT_DOSLITERAL    ; ( -- addr n)
003f18 0406            .dw XT_SCOMMA
                 PFA_SQUOTE1:
003f19 381a          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
003f1a ff06          .dw $ff06
003f1b 6445
003f1c 6665
003f1d 7265          .db "Edefer"
003f1e 3f0b          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
003f1f 3800          .dw DO_COLON
                 PFA_EDEFER:
003f20 01dc          .dw XT_DOCREATE
003f21 3cb3          .dw XT_REVEAL
003f22 0203          .dw XT_COMPILE
003f23 0832          .dw PFA_DODEFER
                 
003f24 01bf          .dw XT_EDP
003f25 38ac          .dw XT_DUP
003f26 020e          .dw XT_COMMA
003f27 0203          .dw XT_COMPILE
003f28 07f6          .dw XT_EDEFERFETCH
003f29 0203          .dw XT_COMPILE
003f2a 07fb          .dw XT_EDEFERSTORE
003f2b 0168          .dw XT_CELLPLUS
003f2c 07ea          .dw XT_DOTO
003f2d 01c0          .dw PFA_EDP
003f2e 381a          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
003f2f ff06          .dw $ff06
003f30 6452
003f31 6665
003f32 7265          .db "Rdefer"
003f33 3f1a          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
003f34 3800          .dw DO_COLON
                 PFA_RDEFER:
003f35 01dc          .dw XT_DOCREATE
003f36 3cb3          .dw XT_REVEAL
                 
003f37 0203          .dw XT_COMPILE
003f38 0832          .dw PFA_DODEFER
                 
003f39 01c7          .dw XT_HERE
003f3a 020e          .dw XT_COMMA
003f3b 3837          .dw XT_DOLITERAL
003f3c 0002          .dw 2
003f3d 01d0          .dw XT_ALLOT
                 
003f3e 0203          .dw XT_COMPILE
003f3f 0800          .dw XT_RDEFERFETCH
003f40 0203          .dw XT_COMPILE
003f41 0805          .dw XT_RDEFERSTORE
003f42 381a          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
003f43 0002          .dw $0002
003f44 7369          .db "is"
003f45 3f2f          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
003f46 3800          .dw DO_COLON
                 PFA_IS:
003f47 0153          .dw XT_STATE
003f48 3874          .dw XT_FETCH
003f49 3830          .dw XT_DOCONDBRANCH
003f4a 3f4f          .dw PFA_IS1
003f4b 021a          .dw XT_BRACKETTICK
003f4c 0203          .dw XT_COMPILE
003f4d 081d          .dw XT_DEFERSTORE
003f4e 381a          .dw XT_EXIT
                 PFA_IS1:
003f4f 0492          .dw XT_TICK
003f50 081d          .dw XT_DEFERSTORE
003f51 381a          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
003f52 ff0b          .dw $ff0b
003f53 7061
003f54 6c70
003f55 7574
003f56 6e72
003f57 656b
003f58 0079          .db "applturnkey",0
003f59 3f43          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
003f5a 3800          .dw DO_COLON
                 PFA_APPLTURNKEY:
003f5b 00d2          .dw XT_USART
003f5c 00fa          .dw XT_INTON
003f5d 07b2          .dw XT_VER
003f5e 046b          .dw XT_SPACE
003f5f 03f3          .dw XT_DOSLITERAL
003f60 000a          .dw 10
003f61 6f46
003f62 7472
003f63 6468
003f64 6975
003f65 6f6e          .db "Forthduino"
003f66 042a          .dw XT_ITYPE
                 
003f67 381a          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
003f68 ff03          .dw $ff03
003f69 6d31
003f6a 0073          .db "1ms",0
003f6b 3f52          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
003f6c 3f6d          .dw PFA_1MS
                 PFA_1MS:
003f6d eae0
003f6e e0ff
003f6f 9731
003f70 f7f1          delay 1000
003f71 c892          jmp_ DO_NEXT
                 .include "words/ms.asm"
                 
                 ; Time
                 ; busy waits the specified amount of milliseconds
                 VE_MS:
003f72 ff02          .dw $ff02
003f73 736d          .db "ms"
003f74 3f68          .dw VE_HEAD
                     .set VE_HEAD = VE_MS
                 XT_MS:
003f75 3800          .dw DO_COLON
                 PFA_MS:
003f76 3934          .dw XT_ZERO
003f77 3aaa          .dw XT_DOQDO
003f78 3f7c          .dw PFA_MS2
                 PFA_MS1:
003f79 3f6c          .dw XT_1MS
003f7a 3ad8          .dw XT_DOLOOP
003f7b 3f79          .dw PFA_MS1
                 PFA_MS2:
003f7c 381a          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
003f7d ff0d          .dw $ff0d
003f7e 6873
003f7f 776f
003f80 772d
003f81 726f
003f82 6c64
003f83 7369
003f84 0074          .db "show-wordlist",0
003f85 3f72          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
003f86 3800          .dw DO_COLON
                 PFA_SHOWWORDLIST:
003f87 3837          .dw XT_DOLITERAL
003f88 3f8c          .dw XT_SHOWWORD
003f89 38bf          .dw XT_SWAP
003f8a 088c          .dw XT_TRAVERSEWORDLIST
003f8b 381a          .dw XT_EXIT
                 
                 XT_SHOWWORD:
003f8c 3800          .dw DO_COLON
                 PFA_SHOWWORD:
003f8d 087b          .dw XT_NAME2STRING
003f8e 042a          .dw XT_ITYPE
003f8f 046b          .dw XT_SPACE         ; ( -- addr n)
003f90 393d          .dw XT_TRUE
003f91 381a          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
003f92 ff05          .dw $ff05
003f93 6f77
003f94 6472
003f95 0073          .db "words",0
003f96 3f7d          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
003f97 3800          .dw DO_COLON
                 PFA_WORDS:
003f98 3837          .dw XT_DOLITERAL
003f99 0016          .dw EE_ORDERLIST
003f9a 3b5b          .dw XT_FETCHE
003f9b 3f86          .dw XT_SHOWWORDLIST
003f9c 381a          .dw XT_EXIT
                 ;.include "device.inc"
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 97 09         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 03 02         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 5a 3f         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 7a 3b         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 14 3e         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 92 3f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 7e 07         .dw XT_REC_FIND
00002a 61 07         .dw XT_REC_INTNUMBER
00002c 9a 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 51 3e         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 0a         .dw rstackstart  ; USER_RP
00003e af 0a         .dw stackstart   ; USER_SP0
000040 af 0a         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 ae 00         .dw XT_TX  ; USER_EMIT
000048 bc 00         .dw XT_TXQ ; USER_EMITQ
00004a 84 00         .dw XT_RX  ; USER_KEY
00004c 9e 00         .dw XT_RXQ ; USER_KEYQ
00004e 5c 09         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 48 09         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 19 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 24
000058 f4 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32U4" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  76 r17:  57 r18:  58 r19:  42 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 164 r25: 117 r26:  45 r27:  22 r28:   6 r29:   4 r30:  66 r31:  33 
x  :   4 y  : 181 z  :  42 
Registers used: 29 out of 35 (82.9%)

"ATmega32U4" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :   9 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  11 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   2 jmp   :  14 
ld    : 127 ldd   :   4 ldi   :  22 lds   :   2 lpm   :  20 lsl   :  16 
lsr   :   1 mov   :  10 movw  :  64 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  48 
push  :  34 rcall :  55 ret   :   6 reti  :   2 rjmp  :  95 rol   :  25 
ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  58 std   :   8 sts   :   3 
sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega32U4" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007f3a   1826  10802  12628   32768  38.5%
[.dseg] 0x000100 0x000203      0    259    259    2560  10.1%
[.eseg] 0x000000 0x00005a      0     90     90    1024   8.8%

Assembly complete, 0 errors, 2 warnings
