
AVRASM ver. 2.1.51  atmega256.asm Mon Dec 23 20:35:31 2013

atmega256.asm(11): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
atmega256.asm(12): Including file '../../core/devices/atmega2561\device.asm'
../../core/devices/atmega2561\device.asm(5): Including file '../../Atmel/Appnotes2\m2561def.inc'
atmega256.asm(23): Including file '../../core\drivers/usart_1.asm'
../../core\drivers/usart_1.asm(31): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
atmega256.asm(29): Including file '../../core\amforth-low.asm'
../../core\amforth-low.asm(11): Including file '../../core\amforth-interpreter.asm'
../../core\amforth-low.asm(12): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth-low.asm(15): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(2): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl_core.inc(4): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(8): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(9): Including file 'words/store-i_big.asm'
../../core\amforth-low.asm(16): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(4): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(8): Including file '../../core\words/udot.asm'
dict_appl.inc(9): Including file '../../core\words/dot-s.asm'
dict_appl.inc(11): Including file '../../core\words/dotstring.asm'
dict_appl.inc(12): Including file '../../core\words/squote.asm'
dict_appl.inc(14): Including file '../../core\words/words.asm'
dict_appl.inc(15): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(17): Including file '../../core\words/edefer.asm'
dict_appl.inc(18): Including file '../../core\words/rdefer.asm'
dict_appl.inc(19): Including file '../../core\words/is.asm'
dict_appl.inc(21): Including file '../../core\words/d-invert.asm'
dict_appl.inc(22): Including file '../../core\words/d-plus.asm'
dict_appl.inc(23): Including file '../../core\words/d-minus.asm'
../../core\amforth-low.asm(24): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 ; both a 24bit address space and they need a special
                 ; flash store placement in the NRWW section, way outside
                 ; of the standard 16bit jump distance.
                 
                 ; note that dict_appl_core includes a store-i_big.asm
                 ; instead if the normal store-i.asm file. This file
                 ; has all the magic needed for the large address space.
                 ; *everything else* is identical to other controllers.
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .equ intvecsize = 2 ; please verify; flash size: 262144 bytes
                 .equ pclen = 3 ; please verify
                 .overlap
                 .org 2
000002 d11e      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d11c      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d11a      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d118      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d116      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d114      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d112      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d110      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d10e      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d10c      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d10a      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d108      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d106      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d104      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d102      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d100      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d0fe      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d0fc      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d0fa      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d0f8      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d0f6      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d0f4      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d0f2      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d0f0      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d0ee      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d0ec      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d0ea      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d0e8      	 rcall isr ; Analog Comparator
                 .org 58
00003a d0e6      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d0e4      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d0e2      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0e0      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0de      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0dc      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d0da      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d0d8      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d0d6      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d0d4      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d0d2      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d0d0      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d0ce      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d0cc      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d0ca      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d0c8      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d0c6      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d0c4      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d0c2      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d0c0      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d0be      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d0bc      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d0ba      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0b8      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0b6      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0b4      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0b2      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0b0      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3532
00007a 3136      	.db "ATmega2561"
                 .set codestart=pc
                 
                 .equ TIBSIZE  = $64 ; 80 characters is one line...
                 .equ APPUSERSIZE = 2  ; size of user area
                 
                 .equ NUMWORDLISTS = 8
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 14745600
                 ; baud rate of terminal
                 .equ BAUD = 9600
                 .include "drivers/usart_1.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR1H
                   .equ USART_C = UCSR1C
                   .equ USART_B = UCSR1B
                   .equ USART_A = UCSR1A
                   .equ USART_DATA = UDR1
                 
                 .equ URXCaddr = URXC1addr
                 .equ UDREaddr = UDRE1addr
                 
                 .equ bm_USART_RXRD = 1 << RXC1
                 .equ bm_USART_TXRD = 1 << UDRE1
                 .equ bm_ENABLE_TX  = 1 << TXEN1
                 .equ bm_ENABLE_RX  = 1 << RXEN1
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE1
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE1
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000048 940c 007b   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200           usart_rx_in: .byte 1
000201           usart_rx_out: .byte 1
000202           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00007b 93af        push xl
00007c b7af        in xl, SREG
00007d 93af        push xl
00007e 93bf        push xh
00007f 93ef        push zl
000080 93ff        push zh
                 
000081 91b0 00ce   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
000083 91a0 0200   lds xl,usart_rx_in
000085 e0e2        ldi zl, low(usart_rx_data)
000086 e0f2        ldi zh, high(usart_rx_data)
000087 0fea        add zl, xl
000088 1df3        adc zh, zeroh
000089 83b0        st Z, xh
                 
00008a 95a3        inc xl
00008b 70af        andi xl,usart_rx_mask
                 
00008c 93a0 0200   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00008e 91ff        pop zh
00008f 91ef        pop zl
000090 91bf        pop xh
000091 91af        pop xl
000092 bfaf        out SREG, xl
000093 91af        pop xl
000094 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000095 0105        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000096 0259        .dw XT_ZERO
000097 0153        .dw XT_DOLITERAL
000098 0200        .dw usart_rx_in
000099 01a1        .dw XT_STORE
                 
00009a 0133        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00009b ff06          .dw $ff06
00009c 7872
00009d 692d
00009e 7273          .db "rx-isr"
00009f 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000a0 0105          .dw DO_COLON
                 PFA_RX_ISR:
0000a1 00ba        .dw XT_RXQ_ISR
0000a2 014c        .dw XT_DOCONDBRANCH
0000a3 00a1        .dw PFA_RX_ISR
0000a4 0153        .dw XT_DOLITERAL
0000a5 0201        .dw usart_rx_out
0000a6 01b8        .dw XT_CFETCH
0000a7 01d1        .dw XT_DUP
0000a8 035d        .dw XT_1PLUS
0000a9 0153        .dw XT_DOLITERAL
0000aa 000f        .dw usart_rx_mask
0000ab 0341        .dw XT_AND
0000ac 0153        .dw XT_DOLITERAL
0000ad 0201        .dw usart_rx_out
0000ae 01ad        .dw XT_CSTORE
0000af 0153        .dw XT_DOLITERAL
0000b0 0202        .dw usart_rx_data
0000b1 02cb        .dw XT_PLUS
0000b2 01b8        .dw XT_CFETCH
0000b3 0133        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
0000b4 ff07          .dw $ff07
0000b5 7872
0000b6 2d3f
0000b7 7369
0000b8 0072          .db "rx?-isr",0
0000b9 009b          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
0000ba 0105          .dw DO_COLON
                 PFA_RXQ_ISR:
0000bb 0a9b        .dw XT_PAUSE
0000bc 0153        .dw XT_DOLITERAL
0000bd 0201        .dw usart_rx_out
0000be 01b8        .dw XT_CFETCH
0000bf 0153        .dw XT_DOLITERAL
0000c0 0200        .dw usart_rx_in
0000c1 01b8        .dw XT_CFETCH
0000c2 022c        .dw XT_NOTEQUAL
0000c3 0133        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000c4 ff07          .dw $ff07
0000c5 7874
0000c6 702d
0000c7 6c6f
0000c8 006c          .db "tx-poll",0
0000c9 00b4          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ca 0105          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000cb 00d8        .dw XT_TXQ_POLL
0000cc 014c        .dw XT_DOCONDBRANCH
0000cd 00cb        .dw PFA_TX_POLL
                   ; send to usart
0000ce 0153        .dw XT_DOLITERAL
0000cf 00ce        .dw USART_DATA
0000d0 01ad        .dw XT_CSTORE
0000d1 0133        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000d2 ff08          .dw $ff08
0000d3 7874
0000d4 2d3f
0000d5 6f70
0000d6 6c6c          .db "tx?-poll"
0000d7 00c4          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000d8 0105          .dw DO_COLON
                 PFA_TXQ_POLL:
0000d9 0a9b        .dw XT_PAUSE
0000da 0153        .dw XT_DOLITERAL
0000db 00c8        .dw USART_A
0000dc 01b8        .dw XT_CFETCH
0000dd 0153        .dw XT_DOLITERAL
0000de 0020        .dw bm_USART_TXRD
0000df 0341        .dw XT_AND
0000e0 0133        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000e1 ff04        .dw $ff04
0000e2 6275
0000e3 7272        .db "ubrr"
0000e4 00d2        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000e5 018e        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000e6 0054        .dw EE_UBRRVAL
0000e7 0ed1        .dw XT_EVALUEFETCH
0000e8 0ed5        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000e9 ff06        .dw $ff06
0000ea 752b
0000eb 6173
0000ec 7472        .db "+usart"
0000ed 00e1        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000ee 0105        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000ef 0153        .dw XT_DOLITERAL
0000f0 0098        .dw USART_B_VALUE
0000f1 0153        .dw XT_DOLITERAL
0000f2 00c9        .dw USART_B
0000f3 01ad        .dw XT_CSTORE
                 
0000f4 0153        .dw XT_DOLITERAL
0000f5 0006        .dw USART_C_VALUE
0000f6 0153        .dw XT_DOLITERAL
0000f7 00ca        .dw USART_C | bm_USARTC_en
0000f8 01ad        .dw XT_CSTORE
                 
0000f9 00e5        .dw XT_UBRR
0000fa 01d1        .dw XT_DUP
0000fb 0439        .dw XT_BYTESWAP
0000fc 0153        .dw XT_DOLITERAL
0000fd 00cd        .dw BAUDRATE_HIGH
0000fe 01ad        .dw XT_CSTORE
0000ff 0153        .dw XT_DOLITERAL
000100 00cc        .dw BAUDRATE_LOW
000101 01ad        .dw XT_CSTORE
                 
000102 0095        .dw XT_USART_INIT_RX
000103 0b95        .dw XT_USART_INIT_TX
000104 0133        .dw XT_EXIT
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 ; all of amforth is in one segment
                 .include "amforth-low.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 
                 .org $0000
000000 940c 0aa4   jmp_ PFA_COLD
                 .org pc_
                 
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
000105 93bf          push XH
000106 93af          push XL          ; PUSH IP
000107 01db          movw XL, wl
000108 9611          adiw xl, 1
                 DO_NEXT:
000109 f09e          brts DO_INTERRUPT
00010a 01fd          movw zl, XL        ; READ IP
00010b 2755
00010c 0fee
00010d 1fff
00010e 1f55
00010f bf5b
000110 9167
000111 9177          readflashcell wl, wh
000112 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
000113 01fb          movw zl, wl
000114 2755
000115 0fee
000116 1fff
000117 1f55
000118 bf5b
000119 9107
00011a 9117          readflashcell temp0,temp1
00011b 01f8          movw zl, temp0
00011c 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00011d 94e8          clt
00011e e86e          ldi wl, LOW(XT_ISREXEC)
00011f e074          ldi wh, HIGH(XT_ISREXEC)
000120 cff2          rjmp DO_EXECUTE
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000214           intcur: .byte 1
000215           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000121 920a          st -Y, r0
000122 b60f          in r0, SREG
000123 920a          st -Y, r0
                 .if (pclen==3)
000124 900f          pop r0 ; some 128+K Flash devices use 3 cells for call/ret
                 .endif
000125 900f          pop r0
000126 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000127 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000128 9200 0214     sts intcur, r0
00012a 9009          ld r0, Y+
00012b be0f          out SREG, r0
00012c 9009          ld r0, Y+
00012d 9468          set ; set the interrupt flag for the inner interpreter
00012e 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 
                 ; lower part of the dictionary
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00012f ff04          .dw $ff04
000130 7865
000131 7469          .db "exit"
000132 00e9          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
000133 0134          .dw PFA_EXIT
                 PFA_EXIT:
000134 91af          pop XL
000135 91bf          pop XH
000136 cfd2          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
000137 ff07          .dw $ff07
000138 7865
000139 6365
00013a 7475
00013b 0065          .db "execute",0
00013c 012f          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00013d 013e          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00013e 01bc          movw wl, tosl
00013f 9189
000140 9199          loadtos
000141 cfd1          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
000142 0143          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
000143 01fd          movw zl, XL
000144 2755
000145 0fee
000146 1fff
000147 1f55
000148 bf5b
000149 91a7
00014a 91b7          readflashcell XL,XH
00014b cfbd          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00014c 014d          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00014d 2b98          or tosh, tosl
00014e 9189
00014f 9199          loadtos
000150 f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
000151 9611          adiw XL, 1
000152 cfb6          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
000153 0154          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
000154 939a
000155 938a          savetos
000156 01fd          movw zl, xl
000157 2755
000158 0fee
000159 1fff
00015a 1f55
00015b bf5b
00015c 9187
00015d 9197          readflashcell tosl,tosh
00015e 9611          adiw xl, 1
00015f cfa9          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
000160 0161          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
000161 939a
000162 938a          savetos
000163 01fb          movw zl, wl
000164 9631          adiw zl,1
000165 2755
000166 0fee
000167 1fff
000168 1f55
000169 bf5b
00016a 9187
00016b 9197          readflashcell tosl,tosh
00016c cf9c          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00016d 016e          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00016e 939a
00016f 938a          savetos
000170 01cb          movw tosl, wl
000171 9601          adiw tosl, 1
000172 cf96          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
000173 0174          .dw PFA_DOUSER
                 PFA_DOUSER:
000174 939a
000175 938a          savetos
000176 01fb          movw zl, wl
000177 9631          adiw zl, 1
000178 2755
000179 0fee
00017a 1fff
00017b 1f55
00017c bf5b
00017d 9187
00017e 9197          readflashcell tosl,tosh
00017f 0d84          add tosl, upl
000180 1d95          adc tosh, uph
000181 cf87          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
000182 ff07          .dw $ff07
000183 7628
000184 6c61
000185 6575
000186 0029          .db "(value)", 0
000187 0137          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
000188 0105          .dw DO_COLON
                 PFA_DOVALUE:
000189 05a4          .dw XT_DOCREATE
00018a 0e28          .dw XT_REVEAL
00018b 05cb          .dw XT_COMPILE
00018c 018e          .dw PFA_DOVALUE1
00018d 0133          .dw XT_EXIT
                 PFA_DOVALUE1:
00018e 940e 0e4c     call_ DO_DODOES
000190 01d1          .dw XT_DUP
000191 01e4          .dw XT_SWAP
000192 035d          .dw XT_1PLUS
000193 04df          .dw XT_FETCHI
000194 013d          .dw XT_EXECUTE
000195 0133          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
000196 ff01          .dw $ff01
000197 0040          .db "@",0
000198 0182          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
000199 019a          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00019a 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00019b 9181          ld tosl, z+
00019c 9191          ld tosh, z+
00019d cf6b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00019e ff01          .dw $ff01
00019f 0021          .db "!",0
0001a0 0196          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
0001a1 01a2          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
0001a2 01fc          movw zl, tosl
0001a3 9189
0001a4 9199          loadtos
                     ; the high byte is written before the low byte
0001a5 8391          std Z+1, tosh
0001a6 8380          std Z+0, tosl
0001a7 9189
0001a8 9199          loadtos
0001a9 cf5f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
0001aa ff02          .dw $ff02
0001ab 2163          .db "c!"
0001ac 019e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
0001ad 01ae          .dw PFA_CSTORE
                 PFA_CSTORE:
0001ae 01fc          movw zl, tosl
0001af 9189
0001b0 9199          loadtos
0001b1 8380          st Z, tosl
0001b2 9189
0001b3 9199          loadtos
0001b4 cf54          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
0001b5 ff02          .dw $ff02
0001b6 4063          .db "c@"
0001b7 01aa          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
0001b8 01b9          .dw PFA_CFETCH
                 PFA_CFETCH:
0001b9 01fc          movw zl, tosl
0001ba 2799          clr tosh
0001bb 8180          ld tosl, Z
0001bc cf4c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
0001bd ff02          .dw $ff02
0001be 7540          .db "@u"
0001bf 01b5          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
0001c0 0105          .dw DO_COLON
                 PFA_FETCHU:
0001c1 0442          .dw XT_UP_FETCH
0001c2 02cb          .dw XT_PLUS
0001c3 0199          .dw XT_FETCH
0001c4 0133          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
0001c5 ff02          .dw $ff02
0001c6 7521          .db "!u"
0001c7 01bd          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0001c8 0105          .dw DO_COLON
                 PFA_STOREU:
0001c9 0442          .dw XT_UP_FETCH
0001ca 02cb          .dw XT_PLUS
0001cb 01a1          .dw XT_STORE
0001cc 0133          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0001cd ff03          .dw $ff03
0001ce 7564
0001cf 0070          .db "dup",0
0001d0 01c5          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0001d1 01d2          .dw PFA_DUP
                 PFA_DUP:
0001d2 939a
0001d3 938a          savetos
0001d4 cf34          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0001d5 ff04          .dw $ff04
0001d6 643f
0001d7 7075          .db "?dup"
0001d8 01cd          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0001d9 01da          .dw PFA_QDUP
                 PFA_QDUP:
0001da 2f08          mov temp0, tosl
0001db 2b09          or temp0, tosh
0001dc f011          breq PFA_QDUP1
0001dd 939a
0001de 938a          savetos
                 PFA_QDUP1:
0001df cf29          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0001e0 ff04          .dw $ff04
0001e1 7773
0001e2 7061          .db "swap"
0001e3 01d5          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0001e4 01e5          .dw PFA_SWAP
                 PFA_SWAP:
0001e5 018c          movw temp0, tosl
0001e6 9189
0001e7 9199          loadtos
0001e8 931a          st -Y, temp1
0001e9 930a          st -Y, temp0
0001ea cf1e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0001eb ff04          .dw $ff04
0001ec 766f
0001ed 7265          .db "over"
0001ee 01e0          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0001ef 01f0          .dw PFA_OVER
                 PFA_OVER:
0001f0 939a
0001f1 938a          savetos
0001f2 818a          ldd tosl, Y+2
0001f3 819b          ldd tosh, Y+3
                 
0001f4 cf14          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0001f5 ff04          .dw $ff04
0001f6 7264
0001f7 706f          .db "drop"
0001f8 01eb          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0001f9 01fa          .dw PFA_DROP
                 PFA_DROP:
0001fa 9189
0001fb 9199          loadtos
0001fc cf0c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0001fd ff03          .dw $ff03
0001fe 6f72
0001ff 0074          .db "rot",0
000200 01f5          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
000201 0202          .dw PFA_ROT
                 PFA_ROT:
000202 018c          movw temp0, tosl
000203 9129          ld temp2, Y+
000204 9139          ld temp3, Y+ 
000205 9189
000206 9199          loadtos
                         
000207 933a          st -Y, temp3
000208 932a          st -Y, temp2
000209 931a          st -Y, temp1
00020a 930a          st -Y, temp0
                 
00020b cefd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00020c ff02          .dw $ff02
00020d 3e72          .db "r>"
00020e 01fd          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00020f 0210          .dw PFA_R_FROM
                 PFA_R_FROM:
000210 939a
000211 938a          savetos
000212 918f          pop tosl
000213 919f          pop tosh
000214 cef4          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
000215 ff02          .dw $ff02
000216 723e          .db ">r"
000217 020c          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
000218 0219          .dw PFA_TO_R
                 PFA_TO_R:
000219 939f          push tosh
00021a 938f          push tosl
00021b 9189
00021c 9199          loadtos
00021d ceeb          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00021e ff02          .dw $ff02
00021f 4072          .db "r@"
000220 0215          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
000221 0222          .dw PFA_R_FETCH
                 PFA_R_FETCH:
000222 939a
000223 938a          savetos
000224 918f          pop tosl
000225 919f          pop tosh
000226 939f          push tosh
000227 938f          push tosl
000228 cee0          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
000229 ff02          .dw $ff02
00022a 3e3c          .db "<>"
00022b 021e          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00022c 022d          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
00022d 9129          ld temp2, Y+
00022e 9139          ld temp3, Y+
00022f 1782          cp tosl, temp2
000230 0793          cpc tosh, temp3
000231 f151          breq PFA_ZERO1
000232 c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
000233 ff01          .dw $ff01
000234 003d          .db "=",0
000235 0229          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
000236 0105          .dw DO_COLON
                 PFA_EQUAL:
000237 02c1          .dw XT_MINUS
000238 023d          .dw XT_EQUALZERO
000239 0133          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
00023a ff02          .dw $ff02
00023b 3d30          .db "0="
00023c 0233          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
00023d 023e          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
00023e 2b98          or tosh, tosl
00023f f4e1          brne PFA_ZERO1
000240 c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
000241 ff01          .dw $ff01
000242 003c          .db "<",0
000243 023a          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
000244 0105          .dw DO_COLON
                 PFA_LESS:
000245 02c1          .dw XT_MINUS
000246 0252          .dw XT_LESSZERO
000247 0133          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
000248 ff01          .dw $ff01
000249 003e          .db ">",0
00024a 0241          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00024b 0105          .dw DO_COLON
                 PFA_GREATER:
00024c 02c1          .dw XT_MINUS
00024d 0281          .dw XT_GREATERZERO
00024e 0133          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00024f ff02          .dw $ff02
000250 3c30          .db "0<"
000251 0248          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
000252 0253          .dw PFA_LESSZERO
                 PFA_LESSZERO:
000253 fd97          sbrc tosh,7
000254 c010          rjmp PFA_TRUE1
000255 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
000256 ff01          .dw $ff01
000257 0030          .db "0",0
000258 024f          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
000259 025a          .dw PFA_ZERO
                 PFA_ZERO:
00025a 939a
00025b 938a          savetos
                 PFA_ZERO1:
00025c 01c1          movw tosl, zerol
00025d ceab          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00025e ff04          .dw $ff04
00025f 7274
000260 6575          .db "true"
000261 0256          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
000262 0263          .dw PFA_TRUE
                 PFA_TRUE:
000263 939a
000264 938a          savetos
                 PFA_TRUE1:
000265 ef8f          ser tosl
000266 ef9f          ser tosh
000267 cea1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
000268 ff02          .dw $ff02
000269 3c75          .db "u<"
00026a 025e          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00026b 026c          .dw PFA_ULESS
                 PFA_ULESS:
00026c 9129          ld temp2, Y+
00026d 9139          ld temp3, Y+
00026e 1782          cp tosl, temp2
00026f 0793          cpc tosh, temp3
000270 f358          brlo PFA_ZERO1
000271 f351          brbs 1, PFA_ZERO1
000272 cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
000273 ff02          .dw $ff02
000274 3e75          .db "u>"
000275 0268          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
000276 0277          .dw PFA_UGREATER
                 PFA_UGREATER:
000277 9129          ld temp2, Y+
000278 9139          ld temp3, Y+
000279 1728          cp temp2, tosl
00027a 0739          cpc temp3, tosh
00027b f300          brlo PFA_ZERO1
00027c f2f9          brbs 1, PFA_ZERO1
00027d cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00027e ff02          .dw $ff02
00027f 3e30          .db "0>"
000280 0273          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
000281 0282          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
000282 1582          cp tosl, zerol
000283 0593          cpc tosh, zeroh
000284 f2bc          brlt PFA_ZERO1
000285 f2b1          brbs 1, PFA_ZERO1
000286 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
000287 ff02          .dw $ff02
000288 3e64          .db "d>"
000289 027e          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
00028a 0105          .dw DO_COLON
                 PFA_DGREATER:
00028b 10d8          .dw XT_DMINUS
00028c 0292          .dw XT_DGREATERZERO
00028d 0133          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00028e ff03          .dw $ff03
00028f 3064
000290 003e          .db "d0>",0
000291 0287          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
000292 0293          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
000293 1582          cp tosl, zerol
000294 0593          cpc tosh, zeroh
000295 9189
000296 9199          loadtos
000297 0582          cpc tosl, zerol
000298 0593          cpc tosh, zeroh
000299 f214          brlt PFA_ZERO1
00029a f209          brbs 1, PFA_ZERO1
00029b cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
00029c ff02          .dw $ff02
00029d 3c64          .db "d<"
00029e 028e          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00029f 0105          .dw DO_COLON
                 PFA_DLESS:
0002a0 10d8          .dw XT_DMINUS
0002a1 02a7          .dw XT_DLESSZERO
0002a2 0133          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
0002a3 ff03          .dw $ff03
0002a4 3064
0002a5 003c          .db "d0<",0
0002a6 029c          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
0002a7 02a8          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
0002a8 9622          adiw Y,2
0002a9 fd97          sbrc tosh,7
0002aa 940c 0265     jmp PFA_TRUE1
0002ac 940c 025c     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
0002ae ff04          .dw $ff04
0002af 6f6c
0002b0 3267          .db "log2"
0002b1 02a3          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
0002b2 02b3          .dw PFA_LOG2
                 PFA_LOG2:
0002b3 01fc          movw zl, tosl
0002b4 2799          clr tosh
0002b5 e180          ldi tosl, 16
                 PFA_LOG2_1:
0002b6 958a          dec tosl
0002b7 f022          brmi PFA_LOG2_2 ; wrong data
0002b8 0fee          lsl  zl
0002b9 1fff          rol  zh
0002ba f7d8          brcc PFA_LOG2_1
0002bb ce4d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
0002bc 959a          dec tosh
0002bd ce4b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
0002be ff01          .dw $ff01
0002bf 002d          .db "-",0
0002c0 02ae          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
0002c1 02c2          .dw PFA_MINUS
                 PFA_MINUS:
0002c2 9109          ld temp0, Y+
0002c3 9119          ld temp1, Y+
0002c4 1b08          sub temp0, tosl
0002c5 0b19          sbc temp1, tosh
0002c6 01c8          movw tosl, temp0
0002c7 ce41          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
0002c8 ff01          .dw $ff01
0002c9 002b          .db "+",0
0002ca 02be          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
0002cb 02cc          .dw PFA_PLUS
                 PFA_PLUS:
0002cc 9109          ld temp0, Y+
0002cd 9119          ld temp1, Y+
0002ce 0f80          add tosl, temp0
0002cf 1f91          adc tosh, temp1
0002d0 ce38          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0002d1 ff02          .dw $ff02
0002d2 2a6d          .db "m*"
0002d3 02c8          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0002d4 02d5          .dw PFA_MSTAR
                 PFA_MSTAR:
0002d5 018c          movw temp0, tosl
0002d6 9189
0002d7 9199          loadtos
0002d8 019c          movw temp2, tosl
                     ; high cell ah*bh
0002d9 0231          muls temp3, temp1
0002da 0170          movw temp4, r0
                     ; low cell  al*bl
0002db 9f20          mul  temp2, temp0
0002dc 01c0          movw tosl, r0
                     ; signed ah*bl
0002dd 0330          mulsu temp3, temp0
0002de 08f3          sbc   temp5, zeroh
0002df 0d90          add   tosh,  r0
0002e0 1ce1          adc   temp4, r1
0002e1 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0002e2 0312          mulsu temp1, temp2
0002e3 08f3          sbc   temp5, zeroh
0002e4 0d90          add   tosh,  r0
0002e5 1ce1          adc   temp4, r1
0002e6 1cf3          adc   temp5, zeroh
                 
0002e7 939a
0002e8 938a          savetos
0002e9 01c7          movw tosl, temp4
0002ea ce1e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0002eb ff06          .dw $ff06
0002ec 6d75
0002ed 6d2f
0002ee 646f          .db "um/mod"
0002ef 02d1          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0002f0 02f1          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0002f1 017c          movw temp4, tosl
                 
0002f2 9129          ld temp2, Y+
0002f3 9139          ld temp3, Y+
                   
0002f4 9109          ld temp0, Y+
0002f5 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0002f6 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0002f7 2755          clr temp7
0002f8 0f00          lsl temp0
0002f9 1f11          rol temp1
0002fa 1f22          rol temp2
0002fb 1f33          rol temp3
0002fc 1f55          rol temp7
                 
                   ; try subtracting divisor
0002fd 152e          cp temp2, temp4
0002fe 053f          cpc temp3, temp5
0002ff 0552          cpc temp7,zerol
                 
000300 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
000301 9503          inc temp0
000302 192e          sub temp2, temp4
000303 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
000304 954a          dec  temp6
000305 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
000306 933a          st -Y,temp3
000307 932a          st -Y,temp2
                 
                     ; put quotient on stack
000308 01c8          movw tosl, temp0
000309 cdff          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00030a ff03          .dw $ff03
00030b 6d75
00030c 002a          .db "um*",0
00030d 02eb          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00030e 030f          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00030f 018c          movw temp0, tosl
000310 9189
000311 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
000312 9f80          mul tosl,temp0
000313 01f0          movw zl, r0
000314 2722          clr temp2
000315 2733          clr temp3
                     ; middle bytes
000316 9f90          mul tosh, temp0
000317 0df0          add zh, r0
000318 1d21          adc temp2, r1
000319 1d33          adc temp3, zeroh
                         
00031a 9f81          mul tosl, temp1
00031b 0df0          add zh, r0
00031c 1d21          adc temp2, r1
00031d 1d33          adc temp3, zeroh
                     
00031e 9f91          mul tosh, temp1
00031f 0d20          add temp2, r0
000320 1d31          adc temp3, r1
000321 01cf          movw tosl, zl
000322 939a
000323 938a          savetos
000324 01c9          movw tosl, temp2
000325 cde3          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
000326 ff06          .dw $ff06
000327 6e69
000328 6576
000329 7472          .db "invert"
00032a 030a          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00032b 032c          .dw PFA_INVERT
                 PFA_INVERT:
00032c 9580          com tosl
00032d 9590          com tosh
00032e cdda          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00032f ff02          .dw $ff02
000330 2f32          .db "2/"
000331 0326          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
000332 0333          .dw PFA_2SLASH
                 PFA_2SLASH:
000333 9595          asr tosh
000334 9587          ror tosl
000335 cdd3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
000336 ff02          .dw $ff02
000337 2a32          .db "2*"
000338 032f          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
000339 033a          .dw PFA_2STAR
                 PFA_2STAR:
00033a 0f88          lsl tosl
00033b 1f99          rol tosh
00033c cdcc          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00033d ff03          .dw $ff03
00033e 6e61
00033f 0064          .db "and",0
000340 0336          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
000341 0342          .dw PFA_AND
                 PFA_AND:
000342 9109          ld temp0, Y+
000343 9119          ld temp1, Y+
000344 2380          and tosl, temp0
000345 2391          and tosh, temp1
000346 cdc2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
000347 ff02          .dw $ff02
000348 726f          .db "or"
000349 033d          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00034a 034b          .dw PFA_OR
                 PFA_OR:
00034b 9109          ld temp0, Y+
00034c 9119          ld temp1, Y+
00034d 2b80          or tosl, temp0
00034e 2b91          or tosh, temp1
00034f cdb9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
000350 ff03          .dw $ff03
000351 6f78
000352 0072          .db "xor",0
000353 0347          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
000354 0355          .dw PFA_XOR
                 PFA_XOR:
000355 9109          ld temp0, Y+
000356 9119          ld temp1, Y+
000357 2780          eor tosl, temp0
000358 2791          eor tosh, temp1
000359 cdaf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00035a ff02          .dw $ff02
00035b 2b31          .db "1+"
00035c 0350          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00035d 035e          .dw PFA_1PLUS
                 PFA_1PLUS:
00035e 9601          adiw tosl,1
00035f cda9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
000360 ff02          .dw $ff02 
000361 2d31          .db "1-"
000362 035a          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
000363 0364          .dw PFA_1MINUS
                 PFA_1MINUS:
000364 9701          sbiw tosl, 1
000365 cda3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
000366 ff06          .dw $ff06
000367 736c
000368 6968
000369 7466          .db "lshift"
00036a 0360          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00036b 036c          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00036c 01fc          movw zl, tosl
00036d 9189
00036e 9199          loadtos
                 PFA_LSHIFT1:
00036f 9731          sbiw zl, 1
000370 f01a          brmi PFA_LSHIFT2
000371 0f88          lsl tosl
000372 1f99          rol tosh
000373 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
000374 cd94          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
000375 ff06          .dw $ff06
000376 7372
000377 6968
000378 7466          .db "rshift"
000379 0366          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00037a 037b          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00037b 01fc          movw zl, tosl
00037c 9189
00037d 9199          loadtos
                 PFA_RSHIFT1:
00037e 9731          sbiw zl, 1
00037f f01a          brmi PFA_RSHIFT2
000380 9596          lsr tosh
000381 9587          ror tosl
000382 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
000383 cd85          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
000384 ff02          .dw $ff02
000385 212b          .db "+!"
000386 0375          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
000387 0388          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
000388 01fc          movw zl, tosl
000389 9189
00038a 9199          loadtos
00038b 8120          ldd temp2, Z+0
00038c 8131          ldd temp3, Z+1
00038d 0f82          add tosl, temp2
00038e 1f93          adc tosh, temp3
00038f 8380          std Z+0, tosl
000390 8391          std Z+1, tosh
000391 9189
000392 9199          loadtos
000393 cd75          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
000394 ff03          .dw $ff03
000395 7072
000396 0040          .db "rp@",0
000397 0384          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
000398 0399          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
000399 939a
00039a 938a          savetos
00039b b78d          in tosl, SPL
00039c b79e          in tosh, SPH
00039d cd6b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00039e ff03          .dw $ff03
00039f 7072
0003a0 0021          .db "rp!",0
0003a1 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
0003a2 03a3          .dw PFA_RP_STORE
                 PFA_RP_STORE:
0003a3 b72f          in temp2, SREG
0003a4 94f8          cli
0003a5 bf8d          out SPL, tosl
0003a6 bf9e          out SPH, tosh
0003a7 bf2f          out SREG, temp2
0003a8 9189
0003a9 9199          loadtos
0003aa cd5e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
0003ab ff03          .dw $ff03
0003ac 7073
0003ad 0040          .db "sp@",0
0003ae 039e          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
0003af 03b0          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
0003b0 939a
0003b1 938a          savetos
0003b2 01ce          movw tosl, yl
0003b3 cd55          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
0003b4 ff03          .dw $ff03
0003b5 7073
0003b6 0021          .db "sp!",0
0003b7 03ab          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
0003b8 03b9          .dw PFA_SP_STORE
                 PFA_SP_STORE:
0003b9 01ec          movw yl, tosl
0003ba 9189
0003bb 9199          loadtos
0003bc cd4c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
0003bd 03be          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
0003be 01fd          movw zl, xl
0003bf 2755
0003c0 0fee
0003c1 1fff
0003c2 1f55
0003c3 bf5b
0003c4 9107
0003c5 9117          readflashcell temp0,temp1
0003c6 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
0003c7 9129          ld temp2, Y+
0003c8 9139          ld temp3, Y+
                 PFA_DODO1:
0003c9 931f          push temp1
0003ca 930f          push temp0
0003cb 933f          push temp3
0003cc 932f          push temp2
0003cd 939f          push tosh
0003ce 938f          push tosl
0003cf 9189
0003d0 9199          loadtos
0003d1 cd37          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
0003d2 03d3          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
0003d3 01fd          movw zl, xl
0003d4 2755
0003d5 0fee
0003d6 1fff
0003d7 1f55
0003d8 bf5b
0003d9 9107
0003da 9117          readflashcell temp0,temp1
0003db 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
0003dc 9129          ld temp2, Y+
0003dd 9139          ld temp3, Y+
                     ; now check for equality
0003de 1782          cp tosl, temp2
0003df 0793          cpc tosh, temp3
0003e0 f741          brne PFA_DODO1
                     ; both values are the same -> skip loop
0003e1 01d8          movw xl, temp0
0003e2 9189
0003e3 9199          loadtos
0003e4 cd24          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
0003e5 ff01          .dw $FF01
0003e6 0069          .db "i",0
0003e7 03b4          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
0003e8 0222          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
0003e9 03ea          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
0003ea 91ef          pop zl
0003eb 91ff          pop zh
0003ec 0fe8          add zl, tosl
0003ed 1ff9          adc zh, tosh
0003ee 2f19          mov temp1, tosh
0003ef 9189
0003f0 9199          loadtos
                 PFA_DOPLUSLOOP4: 
0003f1 912f          pop temp2
0003f2 913f          pop temp3
0003f3 17e2          cp zl, temp2
0003f4 07f3          cpc zh, temp3
0003f5 ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
0003f6 c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
0003f7 f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
0003f8 c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
0003f9 f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
0003fa 933f          push temp3
0003fb 932f          push temp2
0003fc 93ff          push zh
0003fd 93ef          push zl
0003fe cd44          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
0003ff 910f          pop  temp0
000400 911f          pop  temp1  ; remove leave destination
000401 9611          adiw xl, 1 ; skip branch-back address
000402 cd06          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
000403 0404          .dw PFA_DOLOOP
                 PFA_DOLOOP:
000404 91ef          pop zl
000405 91ff          pop zh
000406 9631          adiw zl,1
000407 912f          pop temp2
000408 913f          pop temp3
000409 17e2          cp zl, temp2
00040a 07f3          cpc zh, temp3
00040b f399          breq PFA_DOPLUSLOOP1
00040c cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00040d ff06          .dw $ff06
00040e 6e75
00040f 6f6c
000410 706f          .db "unloop"
000411 03e5          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
000412 0413          .dw PFA_UNLOOP
                 PFA_UNLOOP:
000413 911f          pop temp1
000414 910f          pop temp0
000415 911f          pop temp1
000416 910f          pop temp0
000417 911f          pop temp1
000418 910f          pop temp0
000419 ccef          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00041a ff06          .dw $ff06
00041b 6d63
00041c 766f
00041d 3e65          .db "cmove>"
00041e 040d          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00041f 0420          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
000420 93bf          push xh
000421 93af          push xl
000422 91e9          ld zl, Y+
000423 91f9          ld zh, Y+ ; addr-to
000424 91a9          ld xl, Y+
000425 91b9          ld xh, Y+ ; addr-from
000426 2f09          mov temp0, tosh
000427 2b08          or temp0, tosl
000428 f041          brbs 1, PFA_CMOVE_G1
000429 0fe8          add zl, tosl
00042a 1ff9          adc zh, tosh
00042b 0fa8          add xl, tosl
00042c 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00042d 911e          ld temp1, -X
00042e 9312          st -Z, temp1
00042f 9701          sbiw tosl, 1
000430 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
000431 91af          pop xl
000432 91bf          pop xh
000433 9189
000434 9199          loadtos
000435 ccd3          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
000436 ff02          .dw $ff02
000437 3c3e          .db "><"
000438 041a          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
000439 043a          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00043a 2f09          mov temp0, tosh
00043b 2f98          mov tosh, tosl
00043c 2f80          mov tosl, temp0
00043d cccb          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00043e ff03          .dw $ff03
00043f 7075
000440 0040          .db "up@",0
000441 0436          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
000442 0443          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
000443 939a
000444 938a          savetos
000445 01c2          movw tosl, upl
000446 ccc2          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
000447 ff03          .dw $ff03
000448 7075
000449 0021          .db "up!",0
00044a 043e          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00044b 044c          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00044c 012c          movw upl, tosl
00044d 9189
00044e 9199          loadtos
00044f ccb9          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
000450 ff03          .dw $ff03
000451 3e73
000452 0064          .db "s>d",0
000453 0447          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
000454 0105          .dw DO_COLON
                 PFA_S2D:
000455 01d1          .dw XT_DUP
000456 0252          .dw XT_LESSZERO
                 .include "words/not.asm"
000457 0133      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
000458 ff03          .dw $ff03
000459 6f6e
00045a 0074          .db "not",0
00045b 0450          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
00045c 0105          .dw DO_COLON
                 PFA_NOT:
00045d 023d          .dw XT_EQUALZERO
00045e 0133          .dw XT_EXIT
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00045f ff04          .dw $ff04
000460 692b
000461 746e          .db "+int"
000462 0458          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000463 0464          .dw PFA_INTON
                 PFA_INTON:
000464 9478          sei
000465 cca3          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000466 ff04          .dw $ff04
000467 692d
000468 746e          .db "-int"
000469 045f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00046a 046b          .dw PFA_INTOFF
                 PFA_INTOFF:
00046b 94f8          cli
00046c cc9c          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00046d ff04          .dw $ff04
00046e 6e69
00046f 2174          .db "int!"
000470 0466          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000471 0105          .dw DO_COLON
                 PFA_INTSTORE:
000472 0153          .dw XT_DOLITERAL
000473 0215          .dw intvec
000474 02cb          .dw XT_PLUS
000475 01a1          .dw XT_STORE
000476 0133          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000477 ff04          .dw $ff04
000478 6e69
000479 4074          .db "int@"
00047a 046d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00047b 0105          .dw DO_COLON
                 PFA_INTFETCH:
00047c 0153          .dw XT_DOLITERAL
00047d 0215          .dw intvec
00047e 02cb          .dw XT_PLUS
00047f 0199          .dw XT_FETCH
000480 0133          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000481 ff08          .dw $ff08
000482 6e69
000483 2d74
000484 7274
000485 7061          .db "int-trap"
000486 0477          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000487 0488          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000488 9380 0214     sts intcur, tosl
00048a 9189
00048b 9199          loadtos
00048c 9468          set ; set the interrupt flag for the inner interpreter
00048d cc7b          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00048e 0105          .dw DO_COLON
                 PFA_ISREXEC:
00048f 0153          .dw XT_DOLITERAL
000490 0214          .dw intcur
000491 01b8          .dw XT_CFETCH
000492 0153          .dw XT_DOLITERAL
000493 0215          .dw intvec
000494 02cb          .dw XT_PLUS
000495 0199          .dw XT_FETCH
000496 013d          .dw XT_EXECUTE
000497 0499          .dw XT_ISREND
000498 0133          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000499 049a          .dw PFA_ISREND
                 PFA_ISREND:
00049a d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00049b cc6d          jmp_ DO_NEXT
                 PFA_ISREND1:
00049c 9518          reti
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00049d ff02          .dw $ff02
00049e 6521          .db "!e"
00049f 0481          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
0004a0 04a1          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
0004a1 01fc          movw zl, tosl
0004a2 9189
0004a3 9199          loadtos
0004a4 b72f          in_ temp2, SREG
0004a5 94f8          cli
0004a6 d028          rcall PFA_FETCHE2
0004a7 b500          in_  temp0, EEDR
0004a8 1708          cp temp0,tosl
0004a9 f009          breq PFA_STOREE3
0004aa d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
0004ab 9631          adiw zl,1
0004ac d022          rcall PFA_FETCHE2
0004ad b500          in_  temp0, EEDR
0004ae 1709          cp temp0,tosh
0004af f011          breq PFA_STOREE4
0004b0 2f89          mov tosl, tosh
0004b1 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
0004b2 bf2f          out_ SREG, temp2
0004b3 9189
0004b4 9199          loadtos
0004b5 cc53          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
0004b6 99f9          sbic EECR, EEPE
0004b7 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
0004b8 b707          in_ temp0, SPMCSR
0004b9 fd00          sbrc temp0,SPMEN
0004ba cffd          rjmp PFA_STOREE2
                 
0004bb bdf2          out_ EEARH,zh
0004bc bde1          out_ EEARL,zl
0004bd bd80          out_ EEDR, tosl
0004be 9afa          sbi EECR,EEMPE
0004bf 9af9          sbi EECR,EEPE
                 
0004c0 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
0004c1 ff02          .dw $ff02
0004c2 6540          .db "@e"
0004c3 049d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
0004c4 04c5          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
0004c5 b72f          in_ temp2, SREG
0004c6 94f8          cli
0004c7 01fc          movw zl, tosl
0004c8 d006          rcall PFA_FETCHE2
0004c9 b580          in_ tosl, EEDR
                 
0004ca 9631          adiw zl,1
                 
0004cb d003          rcall PFA_FETCHE2
0004cc b590          in_  tosh, EEDR
0004cd bf2f          out_ SREG, temp2
0004ce cc3a          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
0004cf 99f9          sbic EECR, EEPE
0004d0 cffe          rjmp PFA_FETCHE2
                 
0004d1 bdf2          out_ EEARH,zh
0004d2 bde1          out_ EEARL,zl
                 
0004d3 9af8          sbi EECR,EERE
0004d4 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
0004d5 ff02          .dw $ff02
0004d6 6921          .db "!i"
0004d7 04c1          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
0004d8 0bf8          .dw PFA_DODEFER
                 PFA_STOREI:
0004d9 000a          .dw EE_STOREI
0004da 0bbc          .dw XT_EDEFERFETCH
0004db 0bc1          .dw XT_EDEFERSTORE
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
0004dc ff02          .dw $ff02
0004dd 6940          .db "@i"
0004de 04d5          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
0004df 04e0          .dw PFA_FETCHI
                 PFA_FETCHI:
0004e0 01fc          movw zl, tosl
0004e1 2755
0004e2 0fee
0004e3 1fff
0004e4 1f55
0004e5 bf5b
0004e6 9187
0004e7 9197          readflashcell tosl,tosh
0004e8 cc20          jmp_ DO_NEXT
                 .include "words/store-i_big.asm"
                 
                 ; R( -- )
                 ; writes a cell in flash
                 VE_DO_STOREI:
0004e9 ff04          .dw $ff04
0004ea 6928
0004eb 2921          .db "(i!)"
0004ec 04dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI
                 XT_DO_STOREI:
0004ed 04ee          .dw PFA_DO_STOREI
                 PFA_DO_STOREI:
0004ee 019c        movw temp2, tosl ; save the (word) address
0004ef 9189
0004f0 9199        loadtos          ; get the new value for the flash cell
0004f1 93af        push xl
0004f2 93bf        push xh
0004f3 93cf        push yl
0004f4 93df        push yh
0004f5 e0e1        ldi zl, byte3(DO_ISTORE_atmega)
0004f6 bfeb        out_ rampz, zl
0004f7 eff0        ldi zh, byte2(DO_ISTORE_atmega)
0004f8 e0e0        ldi zl, byte1(DO_ISTORE_atmega)
0004f9 9519        eicall 
0004fa 91df        pop yh
0004fb 91cf        pop yl
0004fc 91bf        pop xh
0004fd 91af        pop xl
                   ; finally clear the stack
0004fe 9189
0004ff 9199        loadtos
000500 cc08        jmp_ DO_NEXT
                 
                 ;
                 .set _pc = pc
                 .org NRWW_START_ADDR
                 DO_ISTORE_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
01f000 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
01f001 94e0        com temp4
01f002 94f0        com temp5
01f003 218e        and tosl, temp4
01f004 219f        and tosh, temp5
01f005 2b98        or tosh, tosl
01f006 f019        breq DO_ISTORE_writepage 
                 
01f007 01f9          movw zl, temp2
01f008 e003          ldi temp0,(1<<PGERS|1<<SPMEN)
01f009 d023          rcall dospm
                 
                 DO_ISTORE_writepage:
                   ; write page
01f00a 01f9        movw zl, temp2
01f00b e005        ldi temp0,(1<<PGWRT|1<<SPMEN)
01f00c d020        rcall dospm
                 
                   ; reenable RWW section
01f00d 01f9        movw zl, temp2
01f00e e101        ldi temp0,(1<<RWWSRE|1<<SPMEN)
01f00f d01d        rcall dospm
01f010 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
01f011 01f9        movw zl, temp2
                   ; get the beginning of page
01f012 78e0        andi zl,low(pagemask)
01f013 7fff        andi zh,high(pagemask)
01f014 01ef        movw y, z
                   ; loop counter (in words)
01f015 e8a0        ldi xl,low(pagesize)
01f016 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
01f017 01fe        movw z, y
01f018 2755
01f019 0fee
01f01a 1fff
01f01b 1f55
01f01c bf5b
01f01d 9147
01f01e 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
01f01f 01fe        movw z, y
01f020 17e2        cp zl, temp2
01f021 07f3        cpc zh, temp3
01f022 f011        breq pageload_newdata
01f023 010a          movw r0, temp6
01f024 c002          rjmp pageload_cont
                 pageload_newdata:
01f025 017a          movw temp4, temp6
01f026 010c          movw r0, tosl
                 pageload_cont:
01f027 e001        ldi temp0,(1<<SPMEN)
01f028 d004        rcall dospm
01f029 9621        adiw y, 1
01f02a 9711        sbiw x, 1
01f02b f759        brne pageload_loop
                 
                 pageload_done:
01f02c 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                   ; store status register
01f02d b71f        in temp1,SREG
01f02e 931f        push temp1
01f02f 94f8        cli
                 Wait_ee:
01f030 99f9        sbic EECR, EEPE
01f031 cffe        rjmp Wait_ee
                 wait_spm:
01f032 b717        in   temp1, SPMCSR
01f033 fd10        sbrc temp1, SPMEN
01f034 cffd        rjmp Wait_spm
                 
                   ; turn the word addres into a byte address
01f035 2755
01f036 0fee
01f037 1fff
01f038 1f55
01f039 bf5b        writeflashcell
                   ; execute spm
01f03a bf07        out SPMCSR,temp0
01f03b 95e8        spm
01f03c 911f        pop temp1
                   ; restore status register
01f03d bf1f        out SREG,temp1
01f03e 9508        ret
                 
                 .org _pc
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
000501 ff05          .dw $ff05
000502 5f66
000503 7063
000504 0075          .db "f_cpu",0
000505 04e9          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000506 018e          .dw PFA_DOVALUE1
                 PFA_F_CPU:
000507 0056          .dw EE_FCPU
000508 050a          .dw XT_FETCH2E
000509 0513          .dw XT_STORE2E
                 
                 XT_FETCH2E:
00050a 0105          .dw DO_COLON
                 PFA_FETCH2E:
00050b 04df          .dw XT_FETCHI
00050c 01d1          .dw XT_DUP
00050d 0531          .dw XT_CELLPLUS
00050e 04c4          .dw XT_FETCHE
00050f 01e4          .dw XT_SWAP
000510 04c4          .dw XT_FETCHE
000511 01e4          .dw XT_SWAP
000512 0133          .dw XT_EXIT
                 
                 XT_STORE2E:
000513 0105          .dw DO_COLON
                 PFA_STORE2E:
000514 0153          .dw XT_DOLITERAL
000515 ffeb          .dw -21
000516 0885          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
000517 ff05          .dw $ff05
000518 7473
000519 7461
00051a 0065          .db "state",0
00051b 0501          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00051c 0161          .dw PFA_DOVARIABLE
                 PFA_STATE:
00051d 0287          .dw ram_state
                 
                 .dseg
000287           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
00051e ff04          .dw $ff04
00051f 6162
000520 6573          .db "base"
000521 0517          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000522 0174          .dw PFA_DOUSER
                 PFA_BASE:
000523 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
000524 ff05          .dw $ff05
000525 6563
000526 6c6c
000527 0073          .db "cells",0
000528 051e          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
000529 0105          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
00052a 0339          .dw XT_2STAR
                 .else
                 .endif
00052b 0133          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00052c ff05          .dw $ff05
00052d 6563
00052e 6c6c
00052f 002b          .db "cell+",0
000530 0524          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000531 0532          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000532 9602          adiw tosl, CELLSIZE
000533 cbd5          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
000534 ff04          .dw $ff04
000535 6432
000536 7075          .db "2dup"
000537 052c          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000538 0105          .dw DO_COLON
                 PFA_2DUP:
000539 01ef          .dw XT_OVER
00053a 01ef          .dw XT_OVER
00053b 0133          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
00053c ff05          .dw $ff05
00053d 6432
00053e 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
00053f 0070          .db "2drop"
000540 0534          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000541 0105          .dw DO_COLON
                 PFA_2DROP:
000542 01f9          .dw XT_DROP
000543 01f9          .dw XT_DROP
000544 0133          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
000545 ff03          .dw $ff03
000546 693e
000547 006e          .db ">in",0
000548 053c          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000549 0174          .dw PFA_DOUSER
                 PFA_G_IN:
00054a 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
00054b ff04          .dw $ff04
00054c 7423
00054d 6269          .db "#tib"
00054e 0545          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00054f 0161          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000550 0289          .dw ram_sharptib
                 
                 .dseg
000289           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000551 ff03          .dw $ff03
000552 6170
000553 0064          .db "pad",0
000554 054b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
000555 0105          .dw DO_COLON
                 PFA_PAD:
000556 058f          .dw XT_HERE
000557 0153          .dw XT_DOLITERAL
000558 0064          .dw 100
000559 02cb          .dw XT_PLUS
00055a 0133          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
00055b ff04          .dw $ff04
00055c 6d65
00055d 7469          .db "emit"
00055e 0551          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00055f 0bf8          .dw PFA_DODEFER
                 PFA_EMIT:
000560 000e          .dw USER_EMIT
000561 0bd0          .dw XT_UDEFERFETCH
000562 0bd7          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
000563 ff05          .dw $ff05
000564 6d65
000565 7469
000566 003f          .db "emit?",0
000567 055b          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000568 0bf8          .dw PFA_DODEFER
                 PFA_EMITQ:
000569 0010          .dw USER_EMITQ
00056a 0bd0          .dw XT_UDEFERFETCH
00056b 0bd7          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
00056c ff03          .dw $ff03
00056d 656b
00056e 0079          .db "key",0
00056f 0563          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000570 0bf8          .dw PFA_DODEFER
                 PFA_KEY:
000571 0012          .dw USER_KEY
000572 0bd0          .dw XT_UDEFERFETCH
000573 0bd7          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
000574 ff04          .dw $ff04
000575 656b
000576 3f79          .db "key?"
000577 056c          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000578 0bf8          .dw PFA_DODEFER
                 PFA_KEYQ:
000579 0014          .dw USER_KEYQ
00057a 0bd0          .dw XT_UDEFERFETCH
00057b 0bd7          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00057c ff02          .dw $ff02
00057d 7064          .db "dp"
00057e 0574          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00057f 018e          .dw PFA_DOVALUE1
                 PFA_DP:
000580 0002          .dw EE_DP
000581 0ed1          .dw XT_EVALUEFETCH
000582 0ed5          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
000583 ff03          .dw $ff03
000584 6465
000585 0070          .db "edp",0
000586 057c          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
000587 018e          .dw PFA_DOVALUE1
                 PFA_EDP:
000588 0006          .dw EE_EDP
000589 0ed1          .dw XT_EVALUEFETCH
00058a 0ed5          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00058b ff04          .dw $ff04
00058c 6568
00058d 6572          .db "here"
00058e 0583          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00058f 018e          .dw PFA_DOVALUE1
                 PFA_HERE:
000590 0004          .dw EE_HERE
000591 0ed1          .dw XT_EVALUEFETCH
000592 0ed5          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000593 ff05          .dw $ff05
000594 6c61
000595 6f6c
000596 0074          .db "allot",0
000597 058b          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000598 0105          .dw DO_COLON
                 PFA_ALLOT:
000599 058f          .dw XT_HERE
00059a 02cb          .dw XT_PLUS
00059b 0bb0          .dw XT_DOTO
00059c 0590          .dw PFA_HERE
00059d 0133          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
00059e ff08          .dw $ff08
00059f 6328
0005a0 6572
0005a1 7461
0005a2 2965          .db "(create)"
0005a3 0593          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0005a4 0105          .dw DO_COLON
                 PFA_DOCREATE:
0005a5 0a15          .dw XT_PARSENAME
0005a6 0e1f          .dw XT_WLSCOPE
0005a7 01d1          .dw XT_DUP
0005a8 0218          .dw XT_TO_R
0005a9 0e04          .dw XT_HEADER
0005aa 020f          .dw XT_R_FROM
                 .dseg
00028b           COLON_SMUDGE: .byte 4
                 .cseg
0005ab 0153          .dw XT_DOLITERAL
0005ac 028d          .dw COLON_SMUDGE+2
0005ad 01a1          .dw XT_STORE		; save wid
0005ae 0153          .dw XT_DOLITERAL
0005af 028b          .dw COLON_SMUDGE+0
0005b0 01a1          .dw XT_STORE		; save NFA
                 
0005b1 0133          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
0005b2 0001          .dw $0001
0005b3 005c          .db "\",0
0005b4 059e          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0005b5 0105          .dw DO_COLON
                 PFA_BACKSLASH:
0005b6 09fa          .dw XT_SOURCE
0005b7 01e4          .dw XT_SWAP
0005b8 01f9          .dw XT_DROP
0005b9 0549          .dw XT_G_IN
0005ba 01a1          .dw XT_STORE
0005bb 0133          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
0005bc 0001          .dw $0001
0005bd 0028          .db "(" ,0
0005be 05b2          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
0005bf 0105          .dw DO_COLON
                 PFA_LPARENTHESIS:
0005c0 0153          .dw XT_DOLITERAL
0005c1 0029          .dw $29
0005c2 09c6          .dw XT_PARSE
0005c3 0541          .dw XT_2DROP
0005c4 0133          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
0005c5 ff07          .dw $ff07
0005c6 6f63
0005c7 706d
0005c8 6c69
0005c9 0065          .db "compile",0
0005ca 05bc          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0005cb 0105          .dw DO_COLON
                 PFA_COMPILE:
0005cc 020f          .dw XT_R_FROM
0005cd 01d1          .dw XT_DUP
0005ce 035d          .dw XT_1PLUS
0005cf 0218          .dw XT_TO_R
0005d0 04df          .dw XT_FETCHI
0005d1 05d6          .dw XT_COMMA
0005d2 0133          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0005d3 ff01          .dw $ff01
0005d4 002c          .db ',',0 ; ,
0005d5 05c5          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0005d6 0105          .dw DO_COLON
                 PFA_COMMA:
0005d7 057f          .dw XT_DP
0005d8 04d8          .dw XT_STOREI
0005d9 057f          .dw XT_DP
0005da 035d          .dw XT_1PLUS
0005db 0bb0          .dw XT_DOTO
0005dc 0580          .dw PFA_DP
0005dd 0133          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0005de 0003          .dw $0003
0005df 275b
0005e0 005d          .db "[']",0
0005e1 05d3          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0005e2 0105          .dw DO_COLON
                 PFA_BRACKETTICK:
0005e3 05cb          .dw XT_COMPILE
0005e4 0153          .dw XT_DOLITERAL
0005e5 0858          .dw XT_TICK
0005e6 05d6          .dw XT_COMMA
0005e7 0133          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
0005e8 ff03          .dw $ff03
0005e9 6962
0005ea 006e          .db "bin",0
0005eb 05de          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0005ec 0105          .dw DO_COLON
                 PFA_BIN:
0005ed 0153          .dw XT_DOLITERAL
0005ee 0002          .dw 2
0005ef 0522          .dw XT_BASE
0005f0 01a1          .dw XT_STORE
0005f1 0133          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
0005f2 ff07          .dw $ff07
0005f3 6564
0005f4 6963
0005f5 616d
0005f6 006c          .db "decimal",0
0005f7 05e8          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0005f8 0105          .dw DO_COLON
                 PFA_DECIMAL:
0005f9 0153          .dw XT_DOLITERAL
0005fa 000a          .dw 10
0005fb 0522          .dw XT_BASE
0005fc 01a1          .dw XT_STORE
0005fd 0133          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
0005fe ff03          .dw $ff03
0005ff 6568
000600 0078          .db "hex",0
000601 05f2          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000602 0105          .dw DO_COLON
                 PFA_HEX:
000603 0153          .dw XT_DOLITERAL
000604 0010          .dw 16
000605 0522          .dw XT_BASE
000606 01a1          .dw XT_STORE
000607 0133          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
000608 ff02          .dw $ff02
000609 6c62          .db "bl"
00060a 05fe          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00060b 0161          .dw PFA_DOVARIABLE
                 PFA_BL:
00060c 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00060d ff07          .dw $ff07
00060e 7574
00060f 6e72
000610 656b
000611 0079          .db "turnkey",0
000612 0608          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000613 0bf8          .dw PFA_DODEFER
                 PFA_TURNKEY:
000614 0008          .dw EE_TURNKEY
000615 0bbc          .dw XT_EDEFERFETCH
000616 0bc1          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
000617 ff05          .dw $ff05
000618 2f2a
000619 6f6d
00061a 0064          .db "*/mod",0
00061b 060d          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
00061c 0105          .dw DO_COLON
                 PFA_STARSLASHMOD:
00061d 0218          .dw XT_TO_R
00061e 02d4          .dw XT_MSTAR
00061f 020f          .dw XT_R_FROM
000620 02f0          .dw XT_UMSLASHMOD
000621 0133          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000622 ff04          .dw $ff04
000623 6d2f
000624 646f          .db "/mod"
000625 0617          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000626 0627          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000627 019c          movw temp2, tosl
                     
000628 9109          ld temp0, Y+
000629 9119          ld temp1, Y+
                 
00062a 2f41          mov	temp6,temp1	;move dividend High to sign register
00062b 2743          eor	temp6,temp3	;xor divisor High with sign register
00062c ff17          sbrs	temp1,7	;if MSB in dividend set
00062d c004          rjmp	PFA_SLASHMOD_1
00062e 9510          com	temp1		;    change sign of dividend
00062f 9500          com	temp0		
000630 5f0f          subi	temp0,low(-1)
000631 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000632 ff37          sbrs	temp3,7	;if MSB in divisor set
000633 c004          rjmp	PFA_SLASHMOD_2
000634 9530          com	temp3		;    change sign of divisor
000635 9520          com	temp2		
000636 5f2f          subi	temp2,low(-1)
000637 4f3f          sbci	temp3,high(-1)
000638 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000639 18ff          sub	temp5,temp5;clear remainder High byte and carry
00063a e151          ldi	temp7,17	;init loop counter
                 
00063b 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00063c 1f11          rol	temp1
00063d 955a          dec	temp7		;decrement counter
00063e f439          brne	PFA_SLASHMOD_5		;if done
00063f ff47          sbrs	temp6,7		;    if MSB in sign register set
000640 c004          rjmp	PFA_SLASHMOD_4
000641 9510          com	temp1	;        change sign of result
000642 9500          com	temp0
000643 5f0f          subi	temp0,low(-1)
000644 4f1f          sbci	temp1,high(-1)
000645 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000646 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000647 1cff          rol	temp5
000648 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000649 0af3          sbc	temp5,temp3	;
00064a f420          brcc	PFA_SLASHMOD_6		;if result negative
00064b 0ee2          add	temp4,temp2	;    restore remainder
00064c 1ef3          adc	temp5,temp3
00064d 9488          clc			;    clear carry to be shifted into result
00064e cfec          rjmp	PFA_SLASHMOD_3		;else
00064f 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000650 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000651 92fa          st -Y,temp5
000652 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000653 01c8          movw tosl, temp0
000654 cab4          jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
000655 ff02          .dw $ff02
000656 2f2a          .db "*/"
000657 0622          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000658 0105          .dw DO_COLON
                 PFA_STARSLASH:
000659 061c          .dw XT_STARSLASHMOD
00065a 01e4          .dw XT_SWAP
00065b 01f9          .dw XT_DROP
00065c 0133          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00065d ff05          .dw $ff05
00065e 2f75
00065f 6f6d
000660 0064          .db "u/mod",0
000661 0655          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000662 0105          .dw DO_COLON
                 PFA_USLASHMOD:
000663 0218          .dw XT_TO_R
000664 0259          .dw XT_ZERO
000665 020f          .dw XT_R_FROM
000666 02f0          .dw XT_UMSLASHMOD
000667 0133          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000668 ff06          .dw $ff06
000669 656e
00066a 6167
00066b 6574          .db "negate"
00066c 065d          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00066d 0105          .dw DO_COLON
                 PFA_NEGATE:
00066e 032b          .dw XT_INVERT
00066f 035d          .dw XT_1PLUS
000670 0133          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
000671 ff01          .dw $ff01
000672 002f          .db "/",0
000673 0668          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000674 0105          .dw DO_COLON
                 PFA_SLASH:
000675 0626          .dw XT_SLASHMOD
000676 01e4          .dw XT_SWAP
000677 01f9          .dw XT_DROP
000678 0133          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
000679 ff03          .dw $ff03
00067a 6f6d
00067b 0064          .db "mod",0
00067c 0671          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00067d 0105          .dw DO_COLON
                 PFA_MOD:
00067e 0626          .dw XT_SLASHMOD
00067f 01f9          .dw XT_DROP
000680 0133          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000681 ff03          .dw $ff03
000682 6261
000683 0073          .db "abs",0
000684 0679          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000685 0686          .dw PFA_ABS
                 PFA_ABS:
000686 2399          tst tosh
000687 f41a          brpl PFA_ABS1
000688 9580          com tosl
000689 9590          com tosh
00068a 9601          adiw tosl, 1
                 PFA_ABS1:
00068b ca7d          jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
00068c ff03          .dw $ff03
00068d 696d
00068e 006e          .db "min",0
00068f 0681          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000690 0105          .dw DO_COLON
                 PFA_MIN:
000691 0538          .dw XT_2DUP
000692 024b          .dw XT_GREATER
000693 014c          .dw XT_DOCONDBRANCH
000694 0696          .dw PFA_MIN1
000695 01e4          .dw XT_SWAP
                 PFA_MIN1:
000696 01f9          .dw XT_DROP
000697 0133          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
000698 ff03          .dw $ff03
000699 616d
00069a 0078          .db "max",0
00069b 068c          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00069c 0105          .dw DO_COLON
                 PFA_MAX:
00069d 0538          .dw XT_2DUP
00069e 0244          .dw XT_LESS
00069f 014c          .dw XT_DOCONDBRANCH
0006a0 06a2          .dw PFA_MAX1
0006a1 01e4          .dw XT_SWAP
                 PFA_MAX1:
0006a2 01f9          .dw XT_DROP
0006a3 0133          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
0006a4 ff06          .dw $ff06
0006a5 6977
0006a6 6874
0006a7 6e69          .db "within"
0006a8 0698          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
0006a9 0105          .dw DO_COLON
                 PFA_WITHIN:
0006aa 01ef          .dw XT_OVER
0006ab 02c1          .dw XT_MINUS
0006ac 0218          .dw XT_TO_R
0006ad 02c1          .dw XT_MINUS
0006ae 020f          .dw XT_R_FROM
0006af 026b          .dw XT_ULESS
0006b0 0133          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
0006b1 ff07          .dw $ff07 
0006b2 6f74
0006b3 7075
0006b4 6570
0006b5 0072          .db "toupper",0
0006b6 06a4          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0006b7 0105          .dw DO_COLON 
                 PFA_TOUPPER:
0006b8 01d1          .dw XT_DUP 
0006b9 0153          .dw XT_DOLITERAL 
0006ba 0061          .dw 'a' 
0006bb 0153          .dw XT_DOLITERAL 
0006bc 007b          .dw 'z'+1
0006bd 06a9          .dw XT_WITHIN 
0006be 014c          .dw XT_DOCONDBRANCH
0006bf 06c3          .dw PFA_TOUPPER0 
0006c0 0153          .dw XT_DOLITERAL
0006c1 00df          .dw $df ; inverse of 0x20
0006c2 0341          .dw XT_AND 
                 PFA_TOUPPER0:
0006c3 0133          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
0006c4 ff07          .dw $ff07
0006c5 6f74
0006c6 6f6c
0006c7 6577
0006c8 0072          .db "tolower",0
0006c9 06b1          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0006ca 0105          .dw DO_COLON
                 PFA_TOLOWER:
0006cb 01d1          .dw XT_DUP
0006cc 0153          .dw XT_DOLITERAL
0006cd 0041          .dw 'A'
0006ce 0153          .dw XT_DOLITERAL
0006cf 005b          .dw 'Z'+1
0006d0 06a9          .dw XT_WITHIN
0006d1 014c          .dw XT_DOCONDBRANCH
0006d2 06d6          .dw PFA_TOLOWER0 
0006d3 0153          .dw XT_DOLITERAL
0006d4 0020          .dw $20 
0006d5 034a          .dw XT_OR 
                 PFA_TOLOWER0:
0006d6 0133          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0006d7 ff03          .dw $ff03
0006d8 6c68
0006d9 0064          .db "hld",0
0006da 06c4          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0006db 0161          .dw PFA_DOVARIABLE
                 PFA_HLD:
0006dc 028f          .dw ram_hld
                 
                 .dseg
00028f           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0006dd ff04          .dw $ff04
0006de 6f68
0006df 646c          .db "hold"
0006e0 06d7          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0006e1 0105          .dw DO_COLON
                 PFA_HOLD:
0006e2 06db          .dw XT_HLD
0006e3 01d1          .dw XT_DUP
0006e4 0199          .dw XT_FETCH
0006e5 0363          .dw XT_1MINUS
0006e6 01d1          .dw XT_DUP
0006e7 0218          .dw XT_TO_R
0006e8 01e4          .dw XT_SWAP
0006e9 01a1          .dw XT_STORE
0006ea 020f          .dw XT_R_FROM
0006eb 01ad          .dw XT_CSTORE
0006ec 0133          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
0006ed ff02          .dw $ff02
0006ee 233c          .db "<#"
0006ef 06dd          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0006f0 0105          .dw DO_COLON
                 PFA_L_SHARP:
0006f1 0555          .dw XT_PAD
0006f2 06db          .dw XT_HLD
0006f3 01a1          .dw XT_STORE
0006f4 0133          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
0006f5 ff01          .dw $ff01
0006f6 0023          .db "#",0
0006f7 06ed          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0006f8 0105          .dw DO_COLON
                 PFA_SHARP:
0006f9 0522          .dw XT_BASE
0006fa 0199          .dw XT_FETCH
0006fb 0777          .dw XT_UDSLASHMOD
0006fc 0201          .dw XT_ROT
0006fd 0153          .dw XT_DOLITERAL
0006fe 0009          .dw 9
0006ff 01ef          .dw XT_OVER
000700 0244          .dw XT_LESS
000701 014c          .dw XT_DOCONDBRANCH
000702 0706          .dw PFA_SHARP1
000703 0153          .dw XT_DOLITERAL
000704 0007          .dw 7
000705 02cb          .dw XT_PLUS
                 PFA_SHARP1:
000706 0153          .dw XT_DOLITERAL
000707 0030          .dw $30
000708 02cb          .dw XT_PLUS
000709 06e1          .dw XT_HOLD
00070a 0133          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
00070b ff02          .dw $ff02
00070c 7323          .db "#s"
00070d 06f5          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00070e 0105          .dw DO_COLON
                 PFA_SHARP_S:
00070f 06f8          .dw XT_SHARP
000710 0538          .dw XT_2DUP
000711 034a          .dw XT_OR
000712 023d          .dw XT_EQUALZERO
000713 014c          .dw XT_DOCONDBRANCH
000714 070f          .dw PFA_SHARP_S
000715 0133          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
000716 ff02          .dw $ff02
000717 3e23          .db "#>"
000718 070b          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000719 0105          .dw DO_COLON
                 PFA_SHARP_G:
00071a 0541          .dw XT_2DROP
00071b 06db          .dw XT_HLD
00071c 0199          .dw XT_FETCH
00071d 01d1          .dw XT_DUP
00071e 0555          .dw XT_PAD
00071f 01e4          .dw XT_SWAP
000720 02c1          .dw XT_MINUS
000721 0133          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
000722 ff04          .dw $ff04
000723 6973
000724 6e67          .db "sign"
000725 0716          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000726 0105          .dw DO_COLON
                 PFA_SIGN:
000727 0252          .dw XT_LESSZERO
000728 014c          .dw XT_DOCONDBRANCH
000729 072d          .dw PFA_SIGN1
00072a 0153          .dw XT_DOLITERAL
00072b 002d          .dw $2d
00072c 06e1          .dw XT_HOLD
                 PFA_SIGN1:
00072d 0133          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
00072e ff03          .dw $ff03
00072f 2e64
000730 0072          .db "d.r",0
000731 0722          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000732 0105          .dw DO_COLON
                 PFA_DDOTR:
000733 0218          .dw XT_TO_R
000734 01e4          .dw XT_SWAP
000735 01ef          .dw XT_OVER
000736 0cb8          .dw XT_DABS
000737 06f0          .dw XT_L_SHARP
000738 070e          .dw XT_SHARP_S
000739 0201          .dw XT_ROT
00073a 0726          .dw XT_SIGN
00073b 0719          .dw XT_SHARP_G
00073c 020f          .dw XT_R_FROM
00073d 01ef          .dw XT_OVER
00073e 02c1          .dw XT_MINUS
00073f 083a          .dw XT_SPACES
000740 0849          .dw XT_TYPE
000741 0133          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
000742 ff02          .dw $ff02
000743 722e          .db ".r"
000744 072e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000745 0105          .dw DO_COLON
                 PFA_DOTR:
000746 0218          .dw XT_TO_R
000747 0454          .dw XT_S2D
000748 020f          .dw XT_R_FROM
000749 0732          .dw XT_DDOTR
00074a 0133          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
00074b ff02          .dw $ff02
00074c 2e64          .db "d."
00074d 0742          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00074e 0105          .dw DO_COLON
                 PFA_DDOT:
00074f 0259          .dw XT_ZERO
000750 0732          .dw XT_DDOTR
000751 0831          .dw XT_SPACE
000752 0133          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
000753 ff01          .dw $ff01
000754 002e          .db ".",0
000755 074b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000756 0105          .dw DO_COLON
                 PFA_DOT:
000757 0454          .dw XT_S2D
000758 074e          .dw XT_DDOT
000759 0133          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
00075a ff03          .dw $ff03
00075b 6475
00075c 002e          .db "ud.",0
00075d 0753          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00075e 0105          .dw DO_COLON
                 PFA_UDDOT:
00075f 0259          .dw XT_ZERO
000760 0767          .dw XT_UDDOTR
000761 0831          .dw XT_SPACE
000762 0133          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
000763 ff04          .dw $ff04
000764 6475
000765 722e          .db "ud.r"
000766 075a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000767 0105          .dw DO_COLON
                 PFA_UDDOTR:
000768 0218          .dw XT_TO_R
000769 06f0          .dw XT_L_SHARP
00076a 070e          .dw XT_SHARP_S
00076b 0719          .dw XT_SHARP_G
00076c 020f          .dw XT_R_FROM
00076d 01ef          .dw XT_OVER
00076e 02c1          .dw XT_MINUS
00076f 083a          .dw XT_SPACES
000770 0849          .dw XT_TYPE
000771 0133          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
000772 ff06          .dw $ff06
000773 6475
000774 6d2f
000775 646f          .db "ud/mod"
000776 0763          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000777 0105          .dw DO_COLON
                 PFA_UDSLASHMOD:
000778 0218          .dw XT_TO_R
000779 0259          .dw XT_ZERO
00077a 0221          .dw XT_R_FETCH
00077b 02f0          .dw XT_UMSLASHMOD
00077c 020f          .dw XT_R_FROM
00077d 01e4          .dw XT_SWAP
00077e 0218          .dw XT_TO_R
00077f 02f0          .dw XT_UMSLASHMOD
000780 020f          .dw XT_R_FROM
000781 0133          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
000782 ff06          .dw $ff06 
000783 6964
000784 6967
000785 3f74          .db "digit?"
000786 0772          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000787 0105          .dw DO_COLON 
                 PFA_DIGITQ:
000788 06b7          .dw XT_TOUPPER
000789 0153          .dw XT_DOLITERAL 
00078a 0030          .dw $30 
00078b 02c1          .dw XT_MINUS 
00078c 01d1          .dw XT_DUP 
00078d 0153          .dw XT_DOLITERAL
00078e 0009          .dw $09 
00078f 0276          .dw XT_UGREATER 
000790 014c          .dw XT_DOCONDBRANCH
000791 079e          .dw PFA_DIGITQ0 
000792 0153          .dw XT_DOLITERAL
000793 0007          .dw $07 
000794 02c1          .dw XT_MINUS 
000795 01d1          .dw XT_DUP 
000796 0153          .dw XT_DOLITERAL
000797 0009          .dw $09 
000798 07ad          .dw XT_ULESSEQUAL
000799 014c          .dw XT_DOCONDBRANCH
00079a 079e          .dw PFA_DIGITQ1 
00079b 01f9          .dw XT_DROP 
00079c 0259          .dw XT_ZERO
00079d 0133          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
00079e 01d1          .dw XT_DUP 
00079f 0522          .dw XT_BASE 
0007a0 0199          .dw XT_FETCH 
0007a1 07b5          .dw XT_UGREATEREQUAL
0007a2 014c          .dw XT_DOCONDBRANCH
0007a3 07a7          .dw PFA_DIGITQ2 
0007a4 01f9          .dw XT_DROP 
0007a5 0259          .dw XT_ZERO
0007a6 0133          .dw XT_EXIT 
                 PFA_DIGITQ2:
0007a7 0262          .dw XT_TRUE
0007a8 0133          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
0007a9 ff03          .dw $ff03 
0007aa 3c75
0007ab 003d          .db "u<=",0
0007ac 0782          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
0007ad 0105          .dw DO_COLON 
                 PFA_ULESSEQUAL:
0007ae 0276          .dw XT_UGREATER 
0007af 032b          .dw XT_INVERT 
0007b0 0133          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
0007b1 ff03          .dw $ff03 
0007b2 3e75
0007b3 003d          .db "u>=",0
0007b4 07a9          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
0007b5 0105          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
0007b6 026b          .dw XT_ULESS 
0007b7 032b          .dw XT_INVERT 
0007b8 0133          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0007b9 0105        .dw DO_COLON
                 PFA_DOSLITERAL:
0007ba 020f        .dw XT_R_FROM   ; ( -- addr )
0007bb 01d1        .dw XT_DUP      ; ( -- addr addr )
0007bc 01d1        .dw XT_DUP
0007bd 04df        .dw XT_FETCHI   ; ( -- addr addr n )
0007be 01e4        .dw XT_SWAP
0007bf 035d        .dw XT_1PLUS
0007c0 01e4        .dw XT_SWAP
0007c1 0201        .dw XT_ROT      ; ( -- addr' n addr )
0007c2 01ef        .dw XT_OVER     ; ( -- addr' n addr n)
0007c3 035d        .dw XT_1PLUS
0007c4 0332        .dw XT_2SLASH   ; ( -- addr' n addr k )
0007c5 02cb        .dw XT_PLUS     ; ( -- addr' n addr'' )
0007c6 035d        .dw XT_1PLUS
0007c7 0218        .dw XT_TO_R     ; ( -- )
0007c8 0133        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0007c9 ff02        .dw $ff02
0007ca 2c73        .db "s",$2c
0007cb 07b1        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0007cc 0105          .dw DO_COLON
                 PFA_SCOMMA:
0007cd 01d1          .dw XT_DUP
0007ce 07d0          .dw XT_DOSCOMMA
0007cf 0133          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0007d0 0105          .dw DO_COLON
                 PFA_DOSCOMMA:
0007d1 05d6          .dw XT_COMMA
0007d2 01d1          .dw XT_DUP   ; ( --addr len len)
0007d3 0332          .dw XT_2SLASH ; ( -- addr len len/2
0007d4 01e4          .dw XT_SWAP   ; ( -- addr len/2 len
0007d5 01ef          .dw XT_OVER   ; ( -- addr len/2 len len/2
0007d6 0339          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007d7 02c1          .dw XT_MINUS  ; ( -- addr len/2 rem
0007d8 0218          .dw XT_TO_R
0007d9 0259          .dw XT_ZERO
0007da 03d2          .dw XT_DOQDO
0007db 07e2          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0007dc 01d1          .dw XT_DUP         ; ( -- addr addr )
0007dd 0199          .dw XT_FETCH       ; ( -- addr c1c2 )
0007de 05d6          .dw XT_COMMA       ; ( -- addr )
0007df 0531          .dw XT_CELLPLUS    ; ( -- addr+cell )
0007e0 0403          .dw XT_DOLOOP
0007e1 07dc          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0007e2 020f          .dw XT_R_FROM
0007e3 0281          .dw XT_GREATERZERO
0007e4 014c          .dw XT_DOCONDBRANCH
0007e5 07e9          .dw PFA_SCOMMA3
0007e6 01d1            .dw XT_DUP     ; well, tricky
0007e7 01b8            .dw XT_CFETCH
0007e8 05d6            .dw XT_COMMA
                 PFA_SCOMMA3:
0007e9 01f9          .dw XT_DROP        ; ( -- )
0007ea 0133          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0007eb ff05          .dw $ff05
0007ec 7469
0007ed 7079
0007ee 0065          .db "itype",0
0007ef 07c9          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0007f0 0105          .dw DO_COLON
                 PFA_ITYPE:
0007f1 01d1          .dw XT_DUP    ; ( --addr len len)
0007f2 0332          .dw XT_2SLASH ; ( -- addr len len/2
0007f3 01e4          .dw XT_SWAP   ; ( -- addr len/2 len
0007f4 01ef          .dw XT_OVER   ; ( -- addr len/2 len len/2
0007f5 0339          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007f6 02c1          .dw XT_MINUS  ; ( -- addr len/2 rem
0007f7 0218          .dw XT_TO_R
0007f8 0259          .dw XT_ZERO
0007f9 03d2          .dw XT_DOQDO
0007fa 0803          .dw PFA_ITYPE2
                 PFA_ITYPE1:
0007fb 01d1          .dw XT_DUP         ; ( -- addr addr )
0007fc 04df          .dw XT_FETCHI      ; ( -- addr c1c2 )
0007fd 01d1          .dw XT_DUP
0007fe 0810          .dw XT_LOWEMIT
0007ff 080c          .dw XT_HIEMIT
000800 035d          .dw XT_1PLUS    ; ( -- addr+cell )
000801 0403          .dw XT_DOLOOP
000802 07fb          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000803 020f          .dw XT_R_FROM
000804 0281          .dw XT_GREATERZERO
000805 014c          .dw XT_DOCONDBRANCH
000806 080a          .dw PFA_ITYPE3
000807 01d1            .dw XT_DUP     ; make sure the drop below has always something to do
000808 04df            .dw XT_FETCHI
000809 0810            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00080a 01f9          .dw XT_DROP
00080b 0133          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00080c 0105          .dw DO_COLON
                 PFA_HIEMIT:
00080d 0439          .dw XT_BYTESWAP
00080e 0810          .dw XT_LOWEMIT
00080f 0133          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000810 0105          .dw DO_COLON
                 PFA_LOWEMIT:
000811 0153          .dw XT_DOLITERAL
000812 00ff          .dw $00ff
000813 0341          .dw XT_AND
000814 055f          .dw XT_EMIT
000815 0133          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000816 ff06          .dw $ff06
000817 6369
000818 756f
000819 746e          .db "icount"
00081a 07eb          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00081b 0105          .dw DO_COLON
                 PFA_ICOUNT:
00081c 01d1          .dw XT_DUP
00081d 035d          .dw XT_1PLUS
00081e 01e4          .dw XT_SWAP
00081f 04df          .dw XT_FETCHI
000820 0133          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
000821 ff02          .dw $ff02
000822 7263          .db "cr"
000823 0816          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000824 0105          .dw DO_COLON
                 PFA_CR:
000825 0153          .dw XT_DOLITERAL
000826 000d          .dw 13
000827 055f          .dw XT_EMIT
000828 0153          .dw XT_DOLITERAL
000829 000a          .dw 10
00082a 055f          .dw XT_EMIT
00082b 0133          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
00082c ff05          .dw $ff05
00082d 7073
00082e 6361
00082f 0065          .db "space",0
000830 0821          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000831 0105          .dw DO_COLON
                 PFA_SPACE:
000832 060b          .dw XT_BL
000833 055f          .dw XT_EMIT
000834 0133          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
000835 ff06          .dw $ff06
000836 7073
000837 6361
000838 7365          .db "spaces"
000839 082c          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00083a 0105          .dw DO_COLON
                 PFA_SPACES:
00083b 01d1          .dw XT_DUP
00083c 0281          .dw XT_GREATERZERO
00083d 0341          .dw XT_AND
00083e 0259          .dw XT_ZERO
00083f 03d2          .dw XT_DOQDO
000840 0844          .dw PFA_SPACES2
                 PFA_SPACES1:
000841 0831          .dw XT_SPACE
000842 0403          .dw XT_DOLOOP
000843 0841          .dw PFA_SPACES1
                 PFA_SPACES2:
000844 0133          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
000845 ff04          .dw $ff04
000846 7974
000847 6570          .db "type"
000848 0835          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000849 0105          .dw DO_COLON
                 PFA_TYPE:
00084a 01ef          .dw XT_OVER
00084b 02cb          .dw XT_PLUS
00084c 01e4          .dW XT_SWAP
00084d 03d2          .dw XT_DOQDO
00084e 0854          .dw PFA_TYPE2
                 PFA_TYPE1:
00084f 03e8          .dw XT_I
000850 01b8          .dw XT_CFETCH
000851 055f          .dw XT_EMIT
000852 0403          .dw XT_DOLOOP
000853 084f          .dw PFA_TYPE1
                 PFA_TYPE2:
000854 0133          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
000855 ff01          .dw $ff01
000856 0027          .db "'",0
000857 0845          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000858 0105          .dw DO_COLON
                 PFA_TICK:
000859 0a15          .dw XT_PARSENAME
00085a 0a32          .dw XT_FINDNAME
00085b 023d          .dw XT_EQUALZERO
00085c 014c          .dw XT_DOCONDBRANCH
00085d 0861          .dw PFA_TICK1
00085e 0153          .dw XT_DOLITERAL
00085f fff3          .dw -13
000860 0885          .dw XT_THROW
                 PFA_TICK1:
000861 0133          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
000862 ff07          .dw $ff07
000863 6168
000864 646e
000865 656c
000866 0072          .db "handler",0
000867 0855          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000868 0174          .dw PFA_DOUSER
                 PFA_HANDLER:
000869 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
00086a ff05          .dw $ff05
00086b 6163
00086c 6374
00086d 0068          .db "catch",0
00086e 0862          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00086f 0105          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
000870 03af          .dw XT_SP_FETCH
000871 0218          .dw XT_TO_R
                     ; handler @ >r
000872 0868          .dw XT_HANDLER
000873 0199          .dw XT_FETCH
000874 0218          .dw XT_TO_R
                     ; rp@ handler !
000875 0398          .dw XT_RP_FETCH
000876 0868          .dw XT_HANDLER
000877 01a1          .dw XT_STORE
000878 013d          .dw XT_EXECUTE
                     ; r> handler !
000879 020f          .dw XT_R_FROM
00087a 0868          .dw XT_HANDLER
00087b 01a1          .dw XT_STORE
00087c 020f          .dw XT_R_FROM
00087d 01f9          .dw XT_DROP
00087e 0259          .dw XT_ZERO
00087f 0133          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
000880 ff05          .dw $ff05
000881 6874
000882 6f72
000883 0077          .db "throw",0
000884 086a          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000885 0105          .dw DO_COLON
                 PFA_THROW:
000886 01d1          .dw XT_DUP
000887 023d          .dw XT_EQUALZERO
000888 014c          .dw XT_DOCONDBRANCH
000889 088c          .dw PFA_THROW1
00088a 01f9      	.dw XT_DROP
00088b 0133      	.dw XT_EXIT
                 PFA_THROW1:
00088c 0868          .dw XT_HANDLER
00088d 0199          .dw XT_FETCH
00088e 03a2          .dw XT_RP_STORE
00088f 020f          .dw XT_R_FROM
000890 0868          .dw XT_HANDLER
000891 01a1          .dw XT_STORE
000892 020f          .dw XT_R_FROM
000893 01e4          .dw XT_SWAP
000894 0218          .dw XT_TO_R
000895 03b8          .dw XT_SP_STORE
000896 01f9          .dw XT_DROP
000897 020f          .dw XT_R_FROM    
000898 0133          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
000899 ff05          .dw $ff05
00089a 7363
00089b 696b
00089c 0070          .db "cskip",0
00089d 0880          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00089e 0105          .dw DO_COLON
                 PFA_CSKIP:
00089f 0218          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0008a0 01d1          .dw XT_DUP            ; ( -- addr' n' n' )
0008a1 014c          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008a2 08ae          .dw PFA_CSKIP2
0008a3 01ef          .dw XT_OVER           ; ( -- addr' n' addr' )
0008a4 01b8          .dw XT_CFETCH         ; ( -- addr' n' c' )
0008a5 0221          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0008a6 0236          .dw XT_EQUAL          ; ( -- addr' n' f )
0008a7 014c          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008a8 08ae          .dw PFA_CSKIP2
0008a9 0153          .dw XT_DOLITERAL
0008aa 0001          .dw 1
0008ab 0a04          .dw XT_SLASHSTRING
0008ac 0142          .dw XT_DOBRANCH
0008ad 08a0          .dw PFA_CSKIP1
                 PFA_CSKIP2:
0008ae 020f          .dw XT_R_FROM
0008af 01f9          .dw XT_DROP           ; ( -- addr2 n2)
0008b0 0133          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
0008b1 ff06          .dw $ff06
0008b2 6361
0008b3 6563
0008b4 7470          .db "accept"
0008b5 0899          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0008b6 0105          .dw DO_COLON
                 PFA_ACCEPT:
0008b7 01d1          .dw XT_DUP        ; ( -- addr n1 n1)
0008b8 0218          .dw XT_TO_R
0008b9 0218          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
0008ba 0570          .dw XT_KEY        ; ( -- addr k )
0008bb 01d1          .dw XT_DUP        ; ( -- addr k k )
0008bc 0153          .dw XT_DOLITERAL
0008bd 000a          .dw 10
0008be 022c          .dw XT_NOTEQUAL
0008bf 014c          .dw XT_DOCONDBRANCH
0008c0 08f4          .dw PFA_ACCEPT2
0008c1 01d1          .dw XT_DUP
0008c2 0153          .dw XT_DOLITERAL
0008c3 000d          .dw 13
0008c4 022c          .dw XT_NOTEQUAL
0008c5 014c          .dw XT_DOCONDBRANCH
0008c6 08f4          .dw PFA_ACCEPT2
                     ; check backspace
0008c7 01d1          .dw XT_DUP
0008c8 0153          .dw XT_DOLITERAL
0008c9 0008          .dw 8
0008ca 0236          .dw XT_EQUAL
0008cb 014c          .dw XT_DOCONDBRANCH
0008cc 08e0          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
0008cd 020f          .dw XT_R_FROM             ; ( -- addr k n1 )
0008ce 0221          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
0008cf 01ef          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
0008d0 0218          .dw XT_TO_R
0008d1 0236          .dw XT_EQUAL              ; ( -- addr k f )
0008d2 014c          .dw XT_DOCONDBRANCH
0008d3 08d7          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
0008d4 01f9          .dw XT_DROP               ; ( -- addr )
0008d5 0142          .dw XT_DOBRANCH
0008d6 08ba          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0008d7 01d1          .dw XT_DUP                ; ( -- addr k k )
0008d8 055f          .dw XT_EMIT               ; ( -- addr k )
0008d9 0831          .dw XT_SPACE              ; ( -- addr k )
0008da 055f          .dw XT_EMIT               ; ( -- addr )
0008db 0363          .dw XT_1MINUS             ; ( -- addr--)
0008dc 020f          .dw XT_R_FROM
0008dd 035d          .dw XT_1PLUS
0008de 0142          .dw XT_DOBRANCH
0008df 08ee          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
0008e0 01d1          .dw XT_DUP            ; ( -- addr k k )
0008e1 060b          .dw XT_BL
0008e2 0244          .dw XT_LESS
0008e3 014c          .dw XT_DOCONDBRANCH
0008e4 08e7          .dw PFA_ACCEPT6
0008e5 01f9          .dw XT_DROP
0008e6 060b          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
0008e7 01d1          .dw XT_DUP            ; ( -- addr k k)
0008e8 055f          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
0008e9 01ef          .dw XT_OVER           ; ( -- addr k addr
0008ea 01ad          .dw XT_CSTORE         ; ( -- addr)
0008eb 035d          .dw XT_1PLUS          ; ( -- addr++)
0008ec 020f          .dw XT_R_FROM         ; ( -- addr n1)
0008ed 0363          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
0008ee 01d1          .dw XT_DUP
0008ef 0218          .dw XT_TO_R
0008f0 023d          .dw XT_EQUALZERO
0008f1 014c          .dw XT_DOCONDBRANCH
0008f2 08ba          .dw PFA_ACCEPT1
0008f3 01d1          .dw XT_DUP
                 PFA_ACCEPT2:
0008f4 0541          .dw XT_2DROP
0008f5 020f          .dw XT_R_FROM
0008f6 020f          .dw XT_R_FROM
0008f7 01e4          .dw XT_SWAP
0008f8 02c1          .dw XT_MINUS
0008f9 0824          .dw XT_CR
0008fa 0133          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0008fb ff06          .dw $ff06
0008fc 6572
0008fd 6966
0008fe 6c6c          .db "refill"
0008ff 08b1          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000900 0bf8          .dw PFA_DODEFER
                 PFA_REFILL:
000901 001a          .dw USER_REFILL
000902 0bd0          .dw XT_UDEFERFETCH
000903 0bd7          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
000904 ff04          .dw $ff04
000905 6863
000906 7261          .db "char"
000907 08fb          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000908 0105          .dw DO_COLON
                 PFA_CHAR:
000909 0a15          .dw XT_PARSENAME
00090a 01f9          .dw XT_DROP
00090b 01b8          .dw XT_CFETCH
00090c 0133          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
00090d ff06          .dw $ff06
00090e 756e
00090f 626d
000910 7265          .db "number"
000911 0904          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000912 0105          .dw DO_COLON
                 PFA_NUMBER:
000913 0522          .dw XT_BASE
000914 0199          .dw XT_FETCH
000915 0218          .dw XT_TO_R
000916 0983          .dw XT_NUMBERSIGN
000917 0218          .dw XT_TO_R
000918 094f          .dw XT_PRAEFIX
000919 0983          .dw XT_NUMBERSIGN
00091a 020f          .dw XT_R_FROM
00091b 034a          .dw XT_OR
00091c 0218          .dw XT_TO_R
00091d 0218          .dw XT_TO_R
00091e 0218          .dw XT_TO_R
00091f 0259          .dw XT_ZERO       ; starting value
000920 0259          .dw XT_ZERO
000921 020f          .dw XT_R_FROM
000922 020f          .dw XT_R_FROM
000923 09a2          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000924 01d9          .dw XT_QDUP
000925 014c              .dw XT_DOCONDBRANCH
000926 0943      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
000927 0153          .dw XT_DOLITERAL
000928 0001          .dw 1
000929 0236          .dw XT_EQUAL
00092a 014c          .dw XT_DOCONDBRANCH
00092b 093a          .dw PFA_NUMBER2
                 	; excatly one character is left
00092c 01b8      	.dw XT_CFETCH
00092d 0153      	.dw XT_DOLITERAL
00092e 002e      	.dw $2e ; .
00092f 0236      	.dw XT_EQUAL
000930 014c      	.dw XT_DOCONDBRANCH
000931 093a      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
000932 020f      	.dw XT_R_FROM
000933 014c              .dw XT_DOCONDBRANCH
000934 0936      	.dw PFA_NUMBER3
000935 0cc5              .dw XT_DNEGATE
                 PFA_NUMBER3:
000936 0153      	.dw XT_DOLITERAL
000937 0002      	.dw 2
000938 0142      	.dw XT_DOBRANCH
000939 094a      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
00093a 0541      	.dw XT_2DROP
00093b 01f9      	.dw XT_DROP
00093c 020f      	.dw XT_R_FROM
00093d 01f9      	.dw XT_DROP
00093e 020f              .dw XT_R_FROM
00093f 0522              .dw XT_BASE
000940 01a1              .dw XT_STORE
000941 0259      	.dw XT_ZERO
000942 0133      	.dw XT_EXIT
                 PFA_NUMBER1:
000943 0541          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000944 020f          .dw XT_R_FROM
000945 014c          .dw XT_DOCONDBRANCH
000946 0948          .dw PFA_NUMBER4
000947 066d          .dw XT_NEGATE
                 PFA_NUMBER4:
000948 0153          .dw XT_DOLITERAL
000949 0001          .dw 1
                 PFA_NUMBER5:
00094a 020f          .dw XT_R_FROM
00094b 0522          .dw XT_BASE
00094c 01a1          .dw XT_STORE
00094d 0262          .dw XT_TRUE
00094e 0133          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
00094f 0105          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
000950 01ef          .dw XT_OVER 
000951 01b8          .dw XT_CFETCH 
000952 0153          .dw XT_DOLITERAL
000953 0029          .dw $29 
000954 024b          .dw XT_GREATER 
000955 014c          .dw XT_DOCONDBRANCH
000956 0958          .dw PFA_PRAEFIX0 
000957 0133          .dw XT_EXIT 
                 PFA_PRAEFIX0:
000958 01ef          .dw XT_OVER 
000959 01b8          .dw XT_CFETCH 
00095a 095f          .dw XT_SETBASE
00095b 0153          .dw XT_DOLITERAL
00095c 0001          .dw $1 
00095d 0a04          .dw XT_SLASHSTRING 
00095e 0133          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
00095f 0105          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000960 01d1          .dw XT_DUP 
000961 0153          .dw XT_DOLITERAL
000962 0024          .dw '$' 
000963 0236          .dw XT_EQUAL 
000964 014c          .dw XT_DOCONDBRANCH
000965 0969          .dw PFA_SETBASE0 
000966 01f9          .dw XT_DROP 
000967 0602          .dw XT_HEX 
000968 0133          .dw XT_EXIT 
                 PFA_SETBASE0:
000969 01d1          .dw XT_DUP 
00096a 0153          .dw XT_DOLITERAL
00096b 0025          .dw '%' 
00096c 0236          .dw XT_EQUAL 
00096d 014c          .dw XT_DOCONDBRANCH
00096e 0972          .dw PFA_SETBASE1 
00096f 01f9          .dw XT_DROP 
000970 05ec          .dw XT_BIN
000971 0133          .dw XT_EXIT 
                 PFA_SETBASE1:
000972 01d1          .dw XT_DUP 
000973 0153          .dw XT_DOLITERAL
000974 0026          .dw '&'
000975 0236          .dw XT_EQUAL 
000976 014c          .dw XT_DOCONDBRANCH
000977 097b          .dw PFA_SETBASE2 
000978 01f9          .dw XT_DROP
000979 05f8          .dw XT_DECIMAL 
00097a 0133          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
00097b 0153          .dw XT_DOLITERAL
00097c 0023          .dw '#'
00097d 0236          .dw XT_EQUAL 
00097e 014c          .dw XT_DOCONDBRANCH
00097f 0982          .dw PFA_SETBASE3 
000980 05f8          .dw XT_DECIMAL 
000981 0133          .dw XT_EXIT 
                 PFA_SETBASE3:
000982 0133          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
000983 0105          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
000984 01ef          .dw XT_OVER
000985 01b8          .dw XT_CFETCH
000986 0153          .dw XT_DOLITERAL
000987 002b          .dw '+'
000988 0236          .dw XT_EQUAL
000989 014c          .dw XT_DOCONDBRANCH
00098a 098e          .dw PFA_NUMBERSIGN_MINUS
00098b 0153            .dw XT_DOLITERAL
00098c 0001            .dw 1
00098d 0a04            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
00098e 01ef          .dw XT_OVER    ; ( -- addr len addr )
00098f 01b8          .dw XT_CFETCH
000990 0153          .dw XT_DOLITERAL
000991 002d          .dw '-'
000992 0236          .dw XT_EQUAL  ; ( -- addr len flag )
000993 01d1          .dw XT_DUP
000994 0218          .dw XT_TO_R
000995 014c          .dw XT_DOCONDBRANCH
000996 099a          .dw PFA_NUMBERSIGN_PLUS
000997 0153          .dw XT_DOLITERAL      ; skip sign character
000998 0001          .dw 1
000999 0a04          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
00099a 020f          .dw XT_R_FROM
00099b 0133          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
00099c ff07          .dw $ff07
00099d 6e3e
00099e 6d75
00099f 6562
0009a0 0072          .db ">number",0
0009a1 090d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0009a2 0105          .dw DO_COLON
                 PFA_TO_NUMBER:
0009a3 01d1          .dw XT_DUP
0009a4 014c          .dw XT_DOCONDBRANCH
0009a5 09c0          .dw PFA_TO_NUMBER1
0009a6 01ef              .dw XT_OVER
0009a7 01b8              .dw XT_CFETCH
0009a8 0787              .dw XT_DIGITQ
0009a9 023d              .dw XT_EQUALZERO
0009aa 014c              .dw XT_DOCONDBRANCH
0009ab 09ad              .dw PFA_TO_NUMBER2
0009ac 0133                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
0009ad 0218              .dw XT_TO_R
0009ae 0cea              .dw XT_2SWAP
0009af 020f              .dw XT_R_FROM
0009b0 01e4              .dw XT_SWAP
0009b1 0522              .dw XT_BASE
0009b2 0199              .dw XT_FETCH
0009b3 030e              .dw XT_UMSTAR
0009b4 01f9              .dw XT_DROP
0009b5 0201              .dw XT_ROT
0009b6 0522              .dw XT_BASE
0009b7 0199              .dw XT_FETCH
0009b8 030e              .dw XT_UMSTAR
0009b9 10c6              .dw XT_DPLUS
0009ba 0cea              .dw XT_2SWAP
0009bb 0153              .dw XT_DOLITERAL
0009bc 0001              .dw 1
0009bd 0a04              .dw XT_SLASHSTRING
0009be 0142          .dw XT_DOBRANCH
0009bf 09a3          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
0009c0 0133          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
0009c1 ff05          .dw $ff05
0009c2 6170
0009c3 7372
0009c4 0065          .db "parse",0
0009c5 099c          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0009c6 0105          .dw DO_COLON
                 PFA_PARSE:
0009c7 0218          .dw XT_TO_R     ; ( -- )
0009c8 09fa          .dw XT_SOURCE   ; ( -- addr len)
0009c9 0549          .dw XT_G_IN     ; ( -- addr len >in)
0009ca 0199          .dw XT_FETCH
0009cb 0a04          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0009cc 020f          .dw XT_R_FROM      ; ( -- addr' len' c)
0009cd 09db          .dw XT_CSCAN       ; ( -- addr' len'')
0009ce 01d1          .dw XT_DUP         ; ( -- addr' len'' len'')
0009cf 035d          .dw XT_1PLUS
0009d0 0549          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
0009d1 0387          .dw XT_PLUSSTORE   ; ( -- addr' len')
0009d2 0153          .dw XT_DOLITERAL
0009d3 0001          .dw 1
0009d4 0a04          .dw XT_SLASHSTRING
0009d5 0133          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0009d6 ff05          .dw $ff05
0009d7 7363
0009d8 6163
0009d9 006e          .db "cscan",0
0009da 09c1          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0009db 0105          .dw DO_COLON
                 PFA_CSCAN:
0009dc 01e4          .dw XT_SWAP         ; ( -- addr1 c n1 )
0009dd 01d1          .dw XT_DUP          ; ( -- addr1 c n1 n1)
0009de 0218          .dw XT_TO_R         ; ( -- addr1 c n1)
0009df 0259          .dw XT_ZERO         ; ( -- addr1 c n1 0)
0009e0 03d2          .dw XT_DOQDO        ; ( -- addr1 c)
0009e1 09f2          .dw PFA_CSCAN3
                 PFA_CSCAN1:
0009e2 01ef          .dw XT_OVER         ; ( -- addr1 c addr1 )
0009e3 03e8          .dw XT_I            ; ( -- addr1 c addr1 i)
0009e4 02cb          .dw XT_PLUS         ; ( -- addr1 c addr')
0009e5 01b8          .dw XT_CFETCH       ; ( -- addr1 c c')
0009e6 01ef          .dw XT_OVER         ; ( -- addr1 c c' c)
0009e7 0236          .dw XT_EQUAL        ; ( -- addr1 c f)
0009e8 014c          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
0009e9 09f0          .dw PFA_CSCAN2
0009ea 01f9          .dw XT_DROP         ; ( -- addr1 )
0009eb 03e8          .dw XT_I            ; ( -- addr1 n2)
0009ec 0412          .dw XT_UNLOOP       ; ( -- addr1 n2)
0009ed 020f          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
0009ee 01f9          .dw XT_DROP         ; ( -- addr1 n2)
0009ef 0133          .dw XT_EXIT
                 PFA_CSCAN2:
0009f0 0403          .dw XT_DOLOOP
0009f1 09e2          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
0009f2 01f9          .dw XT_DROP         ; ( -- addr1)
0009f3 020f          .dw XT_R_FROM       ; ( -- addr1 n1)
0009f4 0133          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0009f5 ff06          .dw $FF06
0009f6 6f73
0009f7 7275
0009f8 6563          .db "source"
0009f9 09d6          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0009fa 0bf8          .dw PFA_DODEFER
                 PFA_SOURCE:
0009fb 0016          .dw USER_SOURCE
0009fc 0bd0          .dw XT_UDEFERFETCH
0009fd 0bd7          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0009fe ff07          .dw $ff07
0009ff 732f
000a00 7274
000a01 6e69
000a02 0067          .db "/string",0
000a03 09f5          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000a04 0105          .dw DO_COLON
                 PFA_SLASHSTRING:
000a05 01ef          .dw XT_OVER    ; ( -- addr1 u1 n u1)
000a06 0690          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
000a07 0201          .dw XT_ROT     ; ( -- u1 n addr1 )
000a08 01ef          .dw XT_OVER    ; ( -- u1 n addr1 n)
000a09 02cb          .dw XT_PLUS    ; ( -- u1 n addr2 )
000a0a 0201          .dw XT_ROT     ; ( -- n addr2 u1)
000a0b 0201          .dw XT_ROT     ; ( -- addr2 u1 n)
000a0c 02c1          .dw XT_MINUS   ; ( -- addr2 u2)
000a0d 0133          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
000a0e ff0a          .dw $FF0A 
000a0f 6170
000a10 7372
000a11 2d65
000a12 616e
000a13 656d          .db "parse-name"
000a14 09fe          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000a15 0105          .dw DO_COLON 
                 PFA_PARSENAME:
000a16 060b          .dw XT_BL
000a17 0a19          .dw XT_SKIPSCANCHAR
000a18 0133          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000a19 0105          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
000a1a 0218          .dw XT_TO_R
000a1b 09fa          .dw XT_SOURCE 
000a1c 0549          .dw XT_G_IN 
000a1d 0199          .dw XT_FETCH 
000a1e 0a04          .dw XT_SLASHSTRING 
                 
000a1f 0221          .dw XT_R_FETCH
000a20 089e          .dw XT_CSKIP
000a21 020f          .dw XT_R_FROM
000a22 09db          .dw XT_CSCAN
                 
                     ; adjust >IN
000a23 0538          .dw XT_2DUP
000a24 02cb          .dw XT_PLUS
000a25 09fa          .dw XT_SOURCE 
000a26 01f9          .dw XT_DROP
000a27 02c1          .dw XT_MINUS
000a28 0549          .dw XT_G_IN
000a29 01a1          .dw XT_STORE
000a2a 0133          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
000a2b ff09          .dw $ff09
000a2c 6966
000a2d 646e
000a2e 6e2d
000a2f 6d61
000a30 0065          .db "find-name",0
000a31 0a0e          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000a32 0105          .dw DO_COLON
                 PFA_FINDNAME:
000a33 0153          .dw XT_DOLITERAL
000a34 0014          .dw EE_ORDERLISTLEN
000a35 04c4          .dw XT_FETCHE
000a36 0259          .dw XT_ZERO
000a37 03d2          .dw XT_DOQDO
000a38 0a4d          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
000a39 0538          .dw XT_2DUP
000a3a 0153          .dw XT_DOLITERAL
000a3b 0016          .dw EE_ORDERLIST
000a3c 03e8          .dw XT_I
000a3d 0529          .dw XT_CELLS
000a3e 02cb          .dw XT_PLUS  
000a3f 04c4          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
000a40 0c0c          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
000a41 01d9          .dw XT_QDUP
000a42 014c          .dw XT_DOCONDBRANCH
000a43 0a4b          .dw PFA_FINDNAME4
000a44 0218      	.dw XT_TO_R
000a45 0218      	.dw XT_TO_R
000a46 0541      	.dw XT_2DROP
000a47 020f      	.dw XT_R_FROM
000a48 020f      	.dw XT_R_FROM
000a49 0412      	.dw XT_UNLOOP
000a4a 0133      	.dw XT_EXIT
                 PFA_FINDNAME4:
000a4b 0403          .dw XT_DOLOOP
000a4c 0a39          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000a4d 0541          .dw XT_2DROP
000a4e 0259          .dw XT_ZERO
000a4f 0133          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
000a50 ff04          .dw $ff04
000a51 7571
000a52 7469          .db "quit"
000a53 0a2b          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000a54 0105          .dw DO_COLON
                 PFA_QUIT:
000a55 0acc          .dw XT_SP0
000a56 03b8          .dw XT_SP_STORE
000a57 0ae1          .dw XT_RP0
000a58 03a2          .dw XT_RP_STORE
000a59 0e92          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000a5a 051c          .dw XT_STATE
000a5b 0199          .dw XT_FETCH
000a5c 023d          .dw XT_EQUALZERO
000a5d 014c          .dw XT_DOCONDBRANCH
000a5e 0a60          .dw PFA_QUIT4
000a5f 0a76          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000a60 0900          .dw XT_REFILL
000a61 014c          .dw XT_DOCONDBRANCH
000a62 0a5a          .dw PFA_QUIT2
000a63 0153          .dw XT_DOLITERAL
000a64 0afa          .dw XT_INTERPRET
000a65 086f          .dw XT_CATCH
000a66 01d9          .dw XT_QDUP
000a67 014c          .dw XT_DOCONDBRANCH
000a68 0a72          .dw PFA_QUIT3
000a69 01d1      	.dw XT_DUP
000a6a 0153      	.dw XT_DOLITERAL
000a6b fffe      	.dw -2
000a6c 0244      	.dw XT_LESS
000a6d 014c      	.dw XT_DOCONDBRANCH
000a6e 0a70      	.dw PFA_QUIT5
000a6f 0a84      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000a70 0142      	.dw XT_DOBRANCH
000a71 0a55      	.dw PFA_QUIT
                 PFA_QUIT3:
000a72 0a7d          .dw XT_PROMPTOK
000a73 0142          .dw XT_DOBRANCH
000a74 0a5a          .dw PFA_QUIT2
000a75 0133          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000a76 0105          .dw DO_COLON
                 PFA_PROMPTRDY:
000a77 0824          .dw XT_CR
000a78 07b9          .dw XT_DOSLITERAL
000a79 0002          .dw 2
000a7a 203e          .db "> "
000a7b 07f0          .dw XT_ITYPE
000a7c 0133          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000a7d 0105          .dw DO_COLON
                 PFA_PROMPTOK:
000a7e 07b9          .dw XT_DOSLITERAL
000a7f 0003          .dw 3
000a80 6f20
000a81 006b          .db " ok",0
000a82 07f0          .dw XT_ITYPE
000a83 0133          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000a84 0105          .dw DO_COLON
                 PFA_PROMPTERROR:
000a85 07b9      	.dw XT_DOSLITERAL
000a86 0004      	.dw 4
000a87 3f20
000a88 203f      	.db  " ?? "
000a89 07f0          .dw XT_ITYPE
000a8a 0522      	.dw XT_BASE
000a8b 0199      	.dw XT_FETCH
000a8c 0218      	.dw XT_TO_R
000a8d 05f8      	.dw XT_DECIMAL
000a8e 0756      	.dw XT_DOT
000a8f 0549      	.dw XT_G_IN
000a90 0199      	.dw XT_FETCH
000a91 0756      	.dw XT_DOT
000a92 020f      	.dw XT_R_FROM
000a93 0522      	.dw XT_BASE
000a94 01a1      	.dw XT_STORE
000a95 0133          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000a96 ff05          .dw $ff05
000a97 6170
000a98 7375
000a99 0065          .db "pause",0
000a9a 0a50          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000a9b 0bf8          .dw PFA_DODEFER
                 PFA_PAUSE:
000a9c 0291          .dw ram_pause
000a9d 0bc6          .dw XT_RDEFERFETCH
000a9e 0bcb          .dw XT_RDEFERSTORE
                 
                 .dseg
000291           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000a9f ff04          .dw $ff04
000aa0 6f63
000aa1 646c          .db "cold"
000aa2 0a96          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000aa3 0aa4          .dw PFA_COLD
                 PFA_COLD:
000aa4 b6a4          in_ r10, MCUSR
000aa5 24bb          clr r11
000aa6 2422          clr zerol
000aa7 2433          clr zeroh
000aa8 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000293           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000aa9 e9e3          ldi zl, low(ram_user1)
000aaa e0f2          ldi zh, high(ram_user1)
000aab 012f          movw upl, zl
                     ; init return stack pointer
000aac ef0f          ldi temp0,low(rstackstart)
000aad bf0d          out_ SPL,temp0
000aae 8304          std Z+4, temp0
000aaf e211          ldi temp1,high(rstackstart)
000ab0 bf1e          out_ SPH,temp1
000ab1 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000ab2 eacf          ldi yl,low(stackstart)
000ab3 83c6          std Z+6, yl
000ab4 e2d1          ldi yh,high(stackstart)
000ab5 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000ab6 ebaf          ldi XL, low(PFA_WARM)
000ab7 e0ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000ab8 940c 0109     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000aba ff04          .dw $ff04
000abb 6177
000abc 6d72          .db "warm"
000abd 0a9f          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000abe 0105          .dw DO_COLON
                 PFA_WARM:
000abf 0d3a          .dw XT_INITUSER
000ac0 0153          .dw XT_DOLITERAL
000ac1 0b95          .dw XT_NOOP
000ac2 0153          .dw XT_DOLITERAL
000ac3 0a9b          .dw XT_PAUSE
000ac4 0be3          .dw XT_DEFERSTORE
000ac5 0613          .dw XT_TURNKEY
000ac6 0a54          .dw XT_QUIT
000ac7 0133          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000ac8 ff03          .dw $ff03
000ac9 7073
000aca 0030          .db "sp0",0
000acb 0aba          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000acc 018e          .dw PFA_DOVALUE1
                 PFA_SP0:
000acd 0006          .dw USER_SP0
000ace 0ad5          .dw XT_UVALUEFETCH
000acf 0ad9          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000ad0 ff02          .dw $ff02
000ad1 7073          .db "sp"
000ad2 0ac8          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000ad3 0174          .dw PFA_DOUSER
                 PFA_SP:
000ad4 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
000ad5 0105          .dw DO_COLON
                 PFA_UVALUEFETCH:
000ad6 04df          .dw XT_FETCHI
000ad7 01c0          .dw XT_FETCHU
000ad8 0133          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
000ad9 0105          .dw DO_COLON
                 PFA_UVALUESTORE:
000ada 04df          .dw XT_FETCHI
000adb 01c8          .dw XT_STOREU
000adc 0133          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000add ff03          .dw $ff03
000ade 7072
000adf 0030          .db "rp0",0
000ae0 0ad0          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000ae1 0105          .dw DO_COLON
                 PFA_RP0:
000ae2 0ae5          .dw XT_DORP0
000ae3 0199          .dw XT_FETCH
000ae4 0133          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000ae5 0174          .dw PFA_DOUSER
                 PFA_DORP0:
000ae6 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
000ae7 ff05          .dw $ff05
000ae8 6564
000ae9 7470
000aea 0068          .db "depth",0
000aeb 0add          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000aec 0105          .dw DO_COLON
                 PFA_DEPTH:
000aed 0acc          .dw XT_SP0
000aee 03af          .dw XT_SP_FETCH
000aef 02c1          .dw XT_MINUS
000af0 0332          .dw XT_2SLASH
000af1 0363          .dw XT_1MINUS
000af2 0133          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
000af3 ff09          .dw $ff09
000af4 6e69
000af5 6574
000af6 7072
000af7 6572
000af8 0074          .db "interpret",0
000af9 0ae7          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000afa 0105          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
000afb 0a15          .dw XT_PARSENAME ; ( -- addr len )
000afc 01d9          .dw XT_QDUP   ; ( -- addr len len )
000afd 0281          .dw XT_GREATERZERO
000afe 014c          .dw XT_DOCONDBRANCH
000aff 0b1e          .dw PFA_INTERPRET5
000b00 0153          .dw XT_DOLITERAL
000b01 0026          .dw EE_RECOGNIZERLISTLEN
000b02 04c4          .dw XT_FETCHE       ; ( addr len rec # -- )
000b03 0259          .dw XT_ZERO
                 
000b04 03d2          .dw XT_DOQDO
000b05 0b1a          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
000b06 0538          .dw XT_2DUP ; ( -- addr len addr len  )
000b07 03e8          .dw XT_I    ; ( -- addr len addr len i )
000b08 0201          .dw XT_ROT  ; ( -- addr len len i addr )
000b09 0201          .dw XT_ROT  ; ( -- addr len i addr len )
000b0a 0218          .dw XT_TO_R
000b0b 0218          .dw XT_TO_R
                 
000b0c 0529          .dw XT_CELLS
000b0d 0153          .dw XT_DOLITERAL
000b0e 0028          .dw EE_RECOGNIZERLIST
000b0f 02cb          .dw XT_PLUS
000b10 04c4          .dw XT_FETCHE
                 
000b11 013d          .dw XT_EXECUTE
000b12 020f          .dw XT_R_FROM
000b13 020f          .dw XT_R_FROM
000b14 0201          .dw XT_ROT
000b15 014c          .dw XT_DOCONDBRANCH
000b16 0b18          .dw PFA_INTERPRET3
000b17 0de1            .dw XT_LEAVE
                 PFA_INTERPRET3:
000b18 0403          .dw XT_DOLOOP
000b19 0b06          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
000b1a 0541          .dw XT_2DROP
000b1b 0b6b          .dw XT_QSTACK
000b1c 0142          .dw XT_DOBRANCH
000b1d 0afb          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
000b1e 01f9          .dw xT_DROP
000b1f 0133          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
000b20 ff0a          .dw $ff0a
000b21 6572
000b22 2d63
000b23 6e69
000b24 6e74
000b25 6d75          .db "rec-intnum"
000b26 0af3          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
000b27 0105          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
000b28 0912          .dw XT_NUMBER 
000b29 014c          .dw XT_DOCONDBRANCH 
000b2a 0b3c          .dw PFA_REC_NONUMBER
                 
000b2b 051c          .dw XT_STATE
000b2c 0199          .dw XT_FETCH
000b2d 014c          .dw XT_DOCONDBRANCH
000b2e 0b39          .dw PFA_REC_NUMBER_DONE
000b2f 0153      	.dw XT_DOLITERAL
000b30 0002      	.dw 2
000b31 0236      	.dw XT_EQUAL
000b32 014c      	.dw XT_DOCONDBRANCH
000b33 0b36      	.dw PFA_REC_NUMBER_SINGLE
000b34 01e4      	.dw XT_SWAP
000b35 0d48              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
000b36 0d48              .dw XT_LITERAL
000b37 0142              .dw XT_DOBRANCH
000b38 0b3a              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
000b39 01f9          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000b3a 0262          .dw XT_TRUE
000b3b 0133          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000b3c 0259          .dw XT_ZERO
000b3d 0133          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000b3e ff08          .dw $ff08
000b3f 6572
000b40 2d63
000b41 6966
000b42 646e          .db "rec-find"
000b43 0b20          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
000b44 0105          .dw DO_COLON
                 PFA_REC_FIND:
000b45 0a32          .dw XT_FINDNAME
000b46 01d1          .dw XT_DUP
000b47 014c          .dw XT_DOCONDBRANCH 
000b48 0b57          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
000b49 0281      	.dw XT_GREATERZERO
000b4a 014c      	.dw XT_DOCONDBRANCH
000b4b 0b4e      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000b4c 0142      	    .dw XT_DOBRANCH
000b4d 0b55      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000b4e 051c      	    .dw XT_STATE
000b4f 0199      	    .dw XT_FETCH
000b50 014c      	    .dw XT_DOCONDBRANCH
000b51 0b55      	    .dw PFA_REC_FIND_EXECUTE
000b52 05d6      	    .dw XT_COMMA
000b53 0142      	    .dw XT_DOBRANCH
000b54 0b56      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
000b55 013d          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
000b56 0262          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000b57 0133          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
000b58 ff0c          .dw $ff0c
000b59 6572
000b5a 2d63
000b5b 6f6e
000b5c 6674
000b5d 756f
000b5e 646e          .db "rec-notfound"
000b5f 0b3e          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000b60 0105          .dw DO_COLON
                 PFA_REC_NOTFOUND:
000b61 0849          .dw XT_TYPE
000b62 0153          .dw XT_DOLITERAL
000b63 fff3          .dw -13
000b64 0885          .dw XT_THROW
000b65 0133          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
000b66 ff06          .dw $ff06
000b67 733f
000b68 6174
000b69 6b63          .db "?stack"
000b6a 0b58          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000b6b 0105          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
000b6c 0aec          .dw XT_DEPTH
000b6d 0252          .dw XT_LESSZERO
000b6e 014c          .dw XT_DOCONDBRANCH
000b6f 0b73          .dw PFA_QSTACK1
000b70 0153            .dw XT_DOLITERAL
000b71 fffc            .dw -4
000b72 0885            .dw XT_THROW
                 PFA_QSTACK1:
000b73 0133          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
000b74 ff03          .dw $ff03
000b75 6576
000b76 0072          .db "ver",0
000b77 0b66          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
000b78 0105          .dw DO_COLON
                 PFA_VER:
000b79 0f66          .dw XT_ENV_FORTHNAME
000b7a 07f0          .dw XT_ITYPE
000b7b 0831          .dw XT_SPACE
000b7c 0522          .dw XT_BASE
000b7d 0199          .dw XT_FETCH
000b7e 0218          .dw XT_TO_R
000b7f 05f8          .dw XT_DECIMAL
                 
000b80 0f74          .dw XT_ENV_FORTHVERSION
000b81 0454          .dw XT_S2D
000b82 06f0          .dw XT_L_SHARP
000b83 06f8          .dw XT_SHARP
000b84 0153          .dw XT_DOLITERAL
000b85 002e          .dw '.'
000b86 06e1          .dw XT_HOLD
000b87 070e          .dw XT_SHARP_S
000b88 0719          .dw XT_SHARP_G
000b89 020f          .dw XT_R_FROM
000b8a 0522          .dw XT_BASE
000b8b 01a1          .dw XT_STORE
                 
000b8c 0849          .dw XT_TYPE
000b8d 0831          .dw XT_SPACE
000b8e 0f7c          .dw XT_ENV_CPU
000b8f 07f0          .dw XT_ITYPE
000b90 0133          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000b91 ff04          .dw $ff04
000b92 6f6e
000b93 706f          .db "noop"
000b94 0b74          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000b95 0b96          .dw PFA_NOOP
                 PFA_NOOP:
000b96 940c 0109     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000b98 ff06          .dw $ff06
000b99 6e75
000b9a 7375
000b9b 6465          .db "unused"
000b9c 0b91          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000b9d 0105          .dw DO_COLON
                 PFA_UNUSED:
000b9e 0acc          .dw XT_SP0
000b9f 058f          .dw XT_HERE
000ba0 02c1          .dw XT_MINUS
000ba1 0133          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
000ba2 0002          .dw $0002
000ba3 6f74          .db "to"
000ba4 0b98          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000ba5 0105          .dw DO_COLON
                 PFA_TO:
000ba6 0858          .dw XT_TICK
000ba7 035d          .dw XT_1PLUS  		; to body
000ba8 051c          .dw XT_STATE
000ba9 0199          .dw XT_FETCH
000baa 014c          .dw XT_DOCONDBRANCH
000bab 0bb6          .dw PFA_TO1
000bac 05cb          .dw XT_COMPILE
000bad 0bb0          .dw XT_DOTO
000bae 05d6          .dw XT_COMMA
000baf 0133          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
000bb0 0105          .dw DO_COLON
                 PFA_DOTO:
000bb1 020f          .dw XT_R_FROM
000bb2 01d1          .dw XT_DUP
000bb3 035d          .dw XT_1PLUS
000bb4 0218          .dw XT_TO_R
000bb5 04df          .dw XT_FETCHI
                 PFA_TO1:
000bb6 01d1          .dw XT_DUP
000bb7 035d          .dw XT_1PLUS
000bb8 035d          .dw XT_1PLUS
000bb9 04df          .dw XT_FETCHI
000bba 013d          .dw XT_EXECUTE
000bbb 0133          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000bbc 0105          .dw DO_COLON
                 PFA_EDEFERFETCH:
000bbd 035d          .dw XT_1PLUS ; >body
000bbe 04df          .dw XT_FETCHI
000bbf 04c4          .dw XT_FETCHE
000bc0 0133          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000bc1 0105          .dw DO_COLON
                 PFA_EDEFERSTORE:
000bc2 035d          .dw XT_1PLUS
000bc3 04df          .dw XT_FETCHI
000bc4 04a0          .dw XT_STOREE
000bc5 0133          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000bc6 0105          .dw DO_COLON
                 PFA_RDEFERFETCH:
000bc7 035d          .dw XT_1PLUS ; >body
000bc8 04df          .dw XT_FETCHI
000bc9 0199          .dw XT_FETCH
000bca 0133          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000bcb 0105          .dw DO_COLON
                 PFA_RDEFERSTORE:
000bcc 035d          .dw XT_1PLUS
000bcd 04df          .dw XT_FETCHI
000bce 01a1          .dw XT_STORE
000bcf 0133          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000bd0 0105          .dw DO_COLON
                 PFA_UDEFERFETCH:
000bd1 035d          .dw XT_1PLUS ; >body
000bd2 04df          .dw XT_FETCHI
000bd3 0442          .dw XT_UP_FETCH
000bd4 02cb          .dw XT_PLUS
000bd5 0199          .dw XT_FETCH
000bd6 0133          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000bd7 0105          .dw DO_COLON
                 PFA_UDEFERSTORE:
000bd8 035d          .dw XT_1PLUS
000bd9 04df          .dw XT_FETCHI
000bda 0442          .dw XT_UP_FETCH
000bdb 02cb          .dw XT_PLUS
000bdc 01a1          .dw XT_STORE
000bdd 0133          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
000bde ff06          .dw $ff06
000bdf 6564
000be0 6566
000be1 2172          .db "defer!"
000be2 0ba2          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000be3 0105          .dw DO_COLON
                 PFA_DEFERSTORE:
000be4 01d1          .dw XT_DUP
000be5 0153          .dw XT_DOLITERAL
000be6 0003          .dw 3
000be7 02cb          .dw XT_PLUS   ; >body 2 +
000be8 04df          .dw XT_FETCHI
000be9 013d          .dw XT_EXECUTE
000bea 0133          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
000beb ff06          .dw $ff06
000bec 6564
000bed 6566
000bee 4072          .db "defer@"
000bef 0bde          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000bf0 0105          .dw DO_COLON
                 PFA_DEFERFETCH:
000bf1 01d1          .dw XT_DUP
000bf2 035d          .dw XT_1PLUS ; >body
000bf3 035d          .dw XT_1PLUS 
000bf4 04df          .dw XT_FETCHI
000bf5 013d          .dw XT_EXECUTE
000bf6 0133          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
000bf7 0bf8          .dw PFA_DODEFER
                 PFA_DODEFER:
000bf8 940e 0e4c     call_ DO_DODOES
000bfa 01d1          .dw XT_DUP
000bfb 0363          .dw XT_1MINUS
000bfc 01e4          .dw XT_SWAP
000bfd 035d          .dw XT_1PLUS
000bfe 04df          .dw XT_FETCHI
000bff 013d          .dw XT_EXECUTE 
000c00 013d          .dw XT_EXECUTE
000c01 0133          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
000c02 ff0f          .dw $ff0f
000c03 6573
000c04 7261
000c05 6863
000c06 772d
000c07 726f
000c08 6c64
000c09 7369
000c0a 0074          .db "search-wordlist",0
000c0b 0beb          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000c0c 0105          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
000c0d 0259          .dw XT_ZERO
000c0e 01e4          .dw XT_SWAP
000c0f 0153          .dw XT_DOLITERAL
000c10 0c1b          .dw XT_ISWORD
000c11 01e4          .dw XT_SWAP
000c12 0c52          .dw XT_TRAVERSEWORDLIST
000c13 01d1          .dw XT_DUP
000c14 023d          .dw XT_EQUALZERO
000c15 014c          .dw XT_DOCONDBRANCH
000c16 0c1a          .dw PFA_SEARCH_WORDLIST1
000c17 0541             .dw XT_2DROP
000c18 01f9             .dw XT_DROP
000c19 0259             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
000c1a 0133          .dw XT_EXIT
                 
                 XT_ISWORD:
000c1b 0105          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
000c1c 0218          .dw XT_TO_R
000c1d 0218          .dw XT_TO_R
000c1e 0538          .dw XT_2DUP
000c1f 020f          .dw XT_R_FROM
000c20 0201          .dw XT_ROT
000c21 0201          .dw XT_ROT
000c22 0221          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
000c23 0c41          .dw XT_NAME2STRING
000c24 0c6d          .dw XT_ICOMPARE      ; (-- addr len 0 f )
000c25 014c          .dw XT_DOCONDBRANCH
000c26 0c35          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
000c27 0541            .dw XT_2DROP
000c28 01f9            .dw XT_DROP
                       ; ... get the XT ...
000c29 0221            .dw XT_R_FETCH
000c2a 1007            .dw XT_NFA2LFA
000c2b 035d            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
000c2c 0262            .dw XT_TRUE
000c2d 020f            .dw XT_R_FROM
000c2e 04df            .dw XT_FETCHI
000c2f 0281            .dw XT_GREATERZERO
000c30 014c            .dw XT_DOCONDBRANCH
000c31 0c33            .dw PFA_ISWORD1
000c32 066d               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
000c33 0259            .dw XT_ZERO       ; finish traverse-wordlist
000c34 0133            .dw XT_EXIT
                 PFA_ISWORD3:
000c35 020f          .dw XT_R_FROM
000c36 01f9          .dw XT_DROP
000c37 0262          .dw XT_TRUE         ; maybe next word
000c38 0133          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
000c39 ff0b          .dw $ff0b
000c3a 616e
000c3b 656d
000c3c 733e
000c3d 7274
000c3e 6e69
000c3f 0067          .db "name>string",0
000c40 0c02          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000c41 0105          .dw DO_COLON
                 PFA_NAME2STRING:
000c42 081b          .dw XT_ICOUNT   ; ( -- addr n )
000c43 0153          .dw XT_DOLITERAL
000c44 00ff          .dw $00FF
000c45 0341          .dw XT_AND      ; mask immediate bit
000c46 0133          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000c47 ff11          .dw $ff11
000c48 7274
000c49 7661
000c4a 7265
000c4b 6573
000c4c 772d
000c4d 726f
000c4e 6c64
000c4f 7369
000c50 0074          .db "traverse-wordlist",0
000c51 0c39          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000c52 0105          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
000c53 04c4          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000c54 01d1          .dw XT_DUP           ; ( -- xt nt nt )
000c55 014c          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000c56 0c65          .dw PFA_TRAVERSEWORDLIST2       ;
000c57 0538          .dw XT_2DUP
000c58 0218          .dw XT_TO_R
000c59 0218          .dw XT_TO_R
000c5a 01e4          .dw XT_SWAP
000c5b 013d          .dw XT_EXECUTE
000c5c 020f          .dw XT_R_FROM
000c5d 020f          .dw XT_R_FROM
000c5e 0201          .dw XT_ROT
000c5f 014c          .dw XT_DOCONDBRANCH
000c60 0c65          .dw PFA_TRAVERSEWORDLIST2
000c61 1007          .dw XT_NFA2LFA
000c62 04df          .dw XT_FETCHI        ; ( -- addr )
000c63 0142          .dw XT_DOBRANCH      ; ( -- addr )
000c64 0c54          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000c65 0541          .dw XT_2DROP
000c66 0133          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
000c67 ff08          .dw $ff08
000c68 6369
000c69 6d6f
000c6a 6170
000c6b 6572          .db "icompare"
000c6c 0c47          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000c6d 0105          .dw DO_COLON
                 PFA_ICOMPARE:
000c6e 0218          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000c6f 01ef          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000c70 020f          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000c71 022c          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000c72 014c          .dw XT_DOCONDBRANCH
000c73 0c78          .dw PFA_ICOMPARE_SAMELEN
000c74 0541            .dw XT_2DROP
000c75 01f9            .dw XT_DROP
000c76 0259            .dw XT_ZERO
000c77 0133            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000c78 01e4          .dw XT_SWAP ; ( -- r-addr f-addr len )
000c79 0259          .dw XT_ZERO
000c7a 03d2          .dw XT_DOQDO
000c7b 0c99          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000c7c 01ef          .dw XT_OVER
000c7d 0199          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000c7e 01ef          .dw XT_OVER
000c7f 04df          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000c80 01d1          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000c81 0153          .dw XT_DOLITERAL
000c82 0100          .dw $100
000c83 026b          .dw XT_ULESS
000c84 014c          .dw XT_DOCONDBRANCH
000c85 0c8a          .dw PFA_ICOMPARE_LASTCELL
000c86 01e4          .dw XT_SWAP
000c87 0153          .dw XT_DOLITERAL
000c88 00ff          .dw $00FF
000c89 0341          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000c8a 022c          .dw XT_NOTEQUAL
000c8b 014c          .dw XT_DOCONDBRANCH
000c8c 0c91          .dw PFA_ICOMPARE_NEXTLOOP
000c8d 0541          .dw XT_2DROP
000c8e 0259          .dw XT_ZERO
000c8f 0412          .dw XT_UNLOOP
000c90 0133          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000c91 035d          .dw XT_1PLUS
000c92 01e4          .dw XT_SWAP
000c93 0531          .dw XT_CELLPLUS
000c94 01e4          .dw XT_SWAP
000c95 0153          .dw XT_DOLITERAL
000c96 0002          .dw 2
000c97 03e9          .dw XT_DOPLUSLOOP
000c98 0c7c          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000c99 0541          .dw XT_2DROP
000c9a 0262          .dw XT_TRUE
000c9b 0133          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000c9c ff01          .dw $ff01
000c9d 002a          .db "*",0
000c9e 0c67          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000c9f 0105          .dw DO_COLON
                 PFA_STAR:
000ca0 02d4          .dw XT_MSTAR
000ca1 0cb1          .dw XT_D2S
000ca2 0133          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000ca3 ff01          .dw $FF01
000ca4 006a          .db "j",0
000ca5 0c9c          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000ca6 0105          .dw DO_COLON
                 PFA_J:
000ca7 0398          .dw XT_RP_FETCH
000ca8 0153          .dw XT_DOLITERAL
000ca9 0009          .dw 9
000caa 02cb          .dw XT_PLUS
000cab 0199          .dw XT_FETCH
000cac 0133          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000cad ff03          .dw $ff03
000cae 3e64
000caf 0073          .db "d>s",0
000cb0 0ca3          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
000cb1 0105          .dw DO_COLON
                 PFA_D2S:
000cb2 01f9          .dw XT_DROP
000cb3 0133          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000cb4 ff04          .dw $ff04
000cb5 6164
000cb6 7362          .db "dabs"
000cb7 0cad          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000cb8 0105          .dw DO_COLON
                 PFA_DABS:
000cb9 01d1          .dw XT_DUP
000cba 0252          .dw XT_LESSZERO
000cbb 014c          .dw XT_DOCONDBRANCH
000cbc 0cbe          .dw PFA_DABS1
000cbd 0cc5          .dw XT_DNEGATE
                 PFA_DABS1:
000cbe 0133          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000cbf ff07          .dw $ff07
000cc0 6e64
000cc1 6765
000cc2 7461
000cc3 0065          .db "dnegate",0
000cc4 0cb4          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000cc5 0105          .dw DO_COLON
                 PFA_DNEGATE:
000cc6 10b8          .dw XT_DINVERT
000cc7 0153          .dw XT_DOLITERAL
000cc8 0001          .dw 1
000cc9 0259          .dw XT_ZERO
000cca 10c6          .dw XT_DPLUS
000ccb 0133          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000ccc ff05          .dw $ff05
000ccd 6d63
000cce 766f
000ccf 0065          .db "cmove",0
000cd0 0cbf          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000cd1 0cd2          .dw PFA_CMOVE
                 PFA_CMOVE:
000cd2 93bf          push xh
000cd3 93af          push xl
000cd4 91e9          ld zl, Y+
000cd5 91f9          ld zh, Y+ ; addr-to
000cd6 91a9          ld xl, Y+
000cd7 91b9          ld xh, Y+ ; addr-from
000cd8 2f09          mov temp0, tosh
000cd9 2b08          or temp0, tosl
000cda f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000cdb 911d          ld temp1, X+
000cdc 9311          st Z+, temp1
000cdd 9701          sbiw tosl, 1
000cde f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000cdf 91af          pop xl
000ce0 91bf          pop xh
000ce1 9189
000ce2 9199          loadtos
000ce3 940c 0109     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
000ce5 ff05          .dw $ff05
000ce6 7332
000ce7 6177
000ce8 0070          .db "2swap",0
000ce9 0ccc          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000cea 0105          .dw DO_COLON
                 PFA_2SWAP:
000ceb 0201          .dw XT_ROT
000cec 0218          .dw XT_TO_R
000ced 0201          .dw XT_ROT
000cee 020f          .dw XT_R_FROM
000cef 0133          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000cf0 ff03          .dw $ff03
000cf1 6974
000cf2 0062          .db "tib",0
000cf3 0ce5          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000cf4 0161          .dw PFA_DOVARIABLE
                 PFA_TIB:
000cf5 02b1          .dw ram_tib
                     
                 .dseg
0002b1           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
000cf6 ff0a          .dw $ff0a
000cf7 6572
000cf8 6966
000cf9 6c6c
000cfa 742d
000cfb 6269          .db "refill-tib"
000cfc 0cf0          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000cfd 0105          .dw DO_COLON
                 PFA_REFILLTIB:
000cfe 0cf4          .dw XT_TIB
000cff 0153          .dw XT_DOLITERAL
000d00 0064          .dw TIBSIZE
000d01 08b6          .dw XT_ACCEPT
000d02 054f          .dw XT_NUMBERTIB
000d03 01a1          .dw XT_STORE
000d04 0259          .dw XT_ZERO
000d05 0549          .dw XT_G_IN
000d06 01a1          .dw XT_STORE
000d07 0153          .dw XT_DOLITERAL
000d08 ffff          .dw -1
000d09 0133          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
000d0a ff0a          .dw $FF0A
000d0b 6f73
000d0c 7275
000d0d 6563
000d0e 742d
000d0f 6269          .db "source-tib"
000d10 0cf6          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000d11 0105          .dw DO_COLON
                 PFA_SOURCETIB:
000d12 0cf4          .dw XT_TIB
000d13 054f          .dw XT_NUMBERTIB
000d14 0199          .dw XT_FETCH
000d15 0133          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
000d16 ff07        .dw $ff07
000d17 6565
000d18 752d
000d19 6573
000d1a 0072        .db "ee-user",0
000d1b 0d0a        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
000d1c 0161        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
000d1d 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000d1e ff06        .dw $ff06
000d1f 6565
000d20 723e
000d21 6d61        .db "ee>ram"
000d22 0d16        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000d23 0105        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000d24 0259          .dw XT_ZERO
000d25 03d2          .dw XT_DOQDO
000d26 0d31          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000d27 01ef          .dw XT_OVER
000d28 04c4          .dw XT_FETCHE
000d29 01ef          .dw XT_OVER
000d2a 01a1          .dw XT_STORE
000d2b 0531          .dw XT_CELLPLUS
000d2c 01e4          .dw XT_SWAP
000d2d 0531          .dw XT_CELLPLUS
000d2e 01e4          .dw XT_SWAP
000d2f 0403          .dw XT_DOLOOP
000d30 0d27          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000d31 0541          .dw XT_2DROP
000d32 0133          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000d33 ff09        .dw $ff09
000d34 6e69
000d35 7469
000d36 752d
000d37 6573
000d38 0072        .db "init-user",0
000d39 0d1e        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000d3a 0105        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000d3b 0d1c          .dw XT_EEUSER
000d3c 0442          .dw XT_UP_FETCH
000d3d 0153          .dw XT_DOLITERAL
000d3e 001c          .dw SYSUSERSIZE
000d3f 0332          .dw XT_2SLASH
000d40 0d23          .dw XT_EE2RAM
000d41 0133          .dw XT_EXIT
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
000d42 0007          .dw $0007
000d43 696c
000d44 6574
000d45 6172
000d46 006c          .db "literal",0
000d47 0d33          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000d48 0105          .dw DO_COLON
                 PFA_LITERAL:
000d49 05cb          .dw XT_COMPILE
000d4a 0153          .dw XT_DOLITERAL
000d4b 05d6          .dw XT_COMMA
000d4c 0133          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000d4d 0008        .dw $0008
000d4e 6c73
000d4f 7469
000d50 7265
000d51 6c61        .db "sliteral"
000d52 0d42        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000d53 0105          .dw DO_COLON
                 PFA_SLITERAL:
000d54 05cb          .dw XT_COMPILE
000d55 07b9          .dw XT_DOSLITERAL    ; ( -- addr n)
000d56 07cc          .dw XT_SCOMMA
000d57 0133          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000d58 0105          .dw DO_COLON
                 PFA_GMARK:
000d59 057f          .dw XT_DP
000d5a 05cb          .dw XT_COMPILE
000d5b ffff          .dw -1           ; ffff does not erase flash
000d5c 0133          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000d5d 0105          .dw DO_COLON
                 PFA_GRESOLVE:
000d5e 0b6b          .dw XT_QSTACK
000d5f 057f          .dw XT_DP
000d60 01e4          .dw XT_SWAP
000d61 04d8          .dw XT_STOREI
000d62 0133          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000d63 0105          .dw DO_COLON
                 PFA_LMARK:
000d64 057f          .dw XT_DP
000d65 0133          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000d66 0105          .dw DO_COLON
                 PFA_LRESOLVE:
000d67 0b6b          .dw XT_QSTACK
000d68 05d6          .dw XT_COMMA
000d69 0133          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000d6a 0005          .dw $0005
000d6b 6861
000d6c 6165
000d6d 0064          .db "ahead",0
000d6e 0d4d          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000d6f 0105          .dw DO_COLON
                 PFA_AHEAD:
000d70 05cb          .dw XT_COMPILE
000d71 0142          .dw XT_DOBRANCH
000d72 0d58          .dw XT_GMARK
000d73 0133          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
000d74 0002          .dw $0002
000d75 6669          .db "if"
000d76 0d6a          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000d77 0105          .dw DO_COLON
                 PFA_IF:
000d78 05cb          .dw XT_COMPILE
000d79 014c          .dw XT_DOCONDBRANCH
000d7a 0d58          .dw XT_GMARK
000d7b 0133          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000d7c 0004          .dw $0004
000d7d 6c65
000d7e 6573          .db "else"
000d7f 0d74          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000d80 0105          .dw DO_COLON
                 PFA_ELSE:
000d81 05cb          .dw XT_COMPILE
000d82 0142          .dw XT_DOBRANCH
000d83 0d58          .dw XT_GMARK
000d84 01e4          .dw XT_SWAP
000d85 0d5d          .dw XT_GRESOLVE
000d86 0133          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000d87 0004          .dw $0004
000d88 6874
000d89 6e65          .db "then"
000d8a 0d7c          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000d8b 0105          .dw DO_COLON
                 PFA_THEN:
000d8c 0d5d          .dw XT_GRESOLVE
000d8d 0133          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000d8e 0005          .dw $0005
000d8f 6562
000d90 6967
000d91 006e          .db "begin",0
000d92 0d87          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000d93 0105          .dw DO_COLON
                 PFA_BEGIN:
000d94 0d63          .dw XT_LMARK
000d95 0133          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
000d96 0005          .dw $0005
000d97 6877
000d98 6c69
000d99 0065          .db "while",0
000d9a 0d8e          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000d9b 0105          .dw DO_COLON
                 PFA_WHILE:
000d9c 05cb          .dw XT_COMPILE
000d9d 014c          .dw XT_DOCONDBRANCH
000d9e 0d58          .dw XT_GMARK
000d9f 01e4          .dw XT_SWAP
000da0 0133          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
000da1 0006          .dw $0006
000da2 6572
000da3 6570
000da4 7461          .db "repeat"
000da5 0d96          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000da6 0105          .dw DO_COLON
                 PFA_REPEAT:
000da7 0db9          .dw XT_AGAIN
000da8 0d5d          .dw XT_GRESOLVE
000da9 0133          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000daa 0005          .dw $0005
000dab 6e75
000dac 6974
000dad 006c          .db "until",0
000dae 0da1          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000daf 0105          .dw DO_COLON
                 PFA_UNTIL:
000db0 05cb          .dw XT_COMPILE
000db1 014c          .dw XT_DOCONDBRANCH
000db2 0d66          .dw XT_LRESOLVE
000db3 0133          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
000db4 0005          .dw $0005
000db5 6761
000db6 6961
000db7 006e          .db "again",0
000db8 0daa          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000db9 0105          .dw DO_COLON
                 PFA_AGAIN:
000dba 05cb          .dw XT_COMPILE
000dbb 0142          .dw XT_DOBRANCH
000dbc 0d66          .dw XT_LRESOLVE
000dbd 0133          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
000dbe 0002          .dw $0002
000dbf 6f64          .db "do"
000dc0 0db4          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000dc1 0105          .dw DO_COLON
                 PFA_DO:
000dc2 05cb          .dw XT_COMPILE
000dc3 03bd          .dw XT_DODO
000dc4 0d58          .dw XT_GMARK
000dc5 0d63          .dw XT_LMARK
000dc6 0133          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
000dc7 0004          .dw $0004
000dc8 6f6c
000dc9 706f          .db "loop"
000dca 0dbe          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000dcb 0105          .dw DO_COLON
                 PFA_LOOP:
000dcc 05cb          .dw XT_COMPILE
000dcd 0403          .dw XT_DOLOOP
000dce 0d66          .dw XT_LRESOLVE
000dcf 0d5d          .dw XT_GRESOLVE
000dd0 0133          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
000dd1 0005          .dw $0005
000dd2 6c2b
000dd3 6f6f
000dd4 0070          .db "+loop",0
000dd5 0dc7          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000dd6 0105          .dw DO_COLON
                 PFA_PLUSLOOP:
000dd7 05cb          .dw XT_COMPILE
000dd8 03e9          .dw XT_DOPLUSLOOP
000dd9 0d66          .dw XT_LRESOLVE
000dda 0d5d          .dw XT_GRESOLVE
000ddb 0133          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
000ddc ff05         .dw $FF05
000ddd 656c
000dde 7661
000ddf 0065         .db "leave",0
000de0 0dd1         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000de1 0de2          .dw PFA_LEAVE
                 PFA_LEAVE:
000de2 910f          pop temp0  ; drop limit and counter from returnstack
000de3 911f          pop temp1
000de4 910f          pop temp0
000de5 911f          pop temp1
000de6 91af          pop xl
000de7 91bf          pop xh
000de8 940c 0109     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
000dea 0003          .dw $0003
000deb 643f
000dec 006f          .db "?do",0
000ded 0ddc          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000dee 0105          .dw DO_COLON
                 PFA_QDO:
000def 05cb          .dw XT_COMPILE
000df0 03d2          .dw XT_DOQDO
000df1 0d58          .dw XT_GMARK
000df2 0d63          .dw XT_LMARK
000df3 0133          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000df4 ff06          .dw $ff06
000df5 7263
000df6 6165
000df7 6574          .db "create"
000df8 0dea          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000df9 0105          .dw DO_COLON
                 PFA_CREATE:
000dfa 05a4          .dw XT_DOCREATE
000dfb 0e28          .dw XT_REVEAL
000dfc 05cb          .dw XT_COMPILE
000dfd 016e          .dw PFA_DOCONSTANT
000dfe 0133          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000dff ff06          .dw $ff06
000e00 6568
000e01 6461
000e02 7265          .db "header"
000e03 0df4          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000e04 0105          .dw DO_COLON
                 PFA_HEADER:
000e05 057f          .dw XT_DP           ; the new Name Field
000e06 0218          .dw XT_TO_R
000e07 0218          .dw XT_TO_R		; ( R: NFA WID )
000e08 01d1          .dw XT_DUP    
000e09 0281          .dw XT_GREATERZERO 
000e0a 014c          .dw XT_DOCONDBRANCH
000e0b 0e16          .dw PFA_HEADER1
000e0c 01d1          .dw XT_DUP
000e0d 0153          .dw XT_DOLITERAL
000e0e ff00          .dw $ff00           ; all flags are off (e.g. immediate)
000e0f 034a          .dw XT_OR
000e10 07d0          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
000e11 020f          .dw XT_R_FROM
000e12 04c4          .dw XT_FETCHE
000e13 05d6          .dw XT_COMMA
000e14 020f          .dw XT_R_FROM
000e15 0133          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000e16 0153          .dw XT_DOLITERAL
000e17 fff0          .dw -16
000e18 0885          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000e19 ff07          .dw $ff07
000e1a 6c77
000e1b 6373
000e1c 706f
000e1d 0065          .db "wlscope",0
000e1e 0dff          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000e1f 0bf8          .dw PFA_DODEFER
                 PFA_WLSCOPE:
000e20 0034          .dw EE_WLSCOPE
000e21 0bbc          .dw XT_EDEFERFETCH
000e22 0bc1          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000e23 ff06          .dw $ff06
000e24 6572
000e25 6576
000e26 6c61          .db "reveal"
000e27 0e19          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000e28 0105          .dw DO_COLON
                 PFA_REVEAL:
000e29 0153          .dw XT_DOLITERAL
000e2a 028b          .dw COLON_SMUDGE+0
000e2b 0199          .dw XT_FETCH
000e2c 01d9          .dw XT_QDUP
000e2d 014c          .dw XT_DOCONDBRANCH
000e2e 0e37          .dw PFA_REVEAL1
                 ;
000e2f 0153          .dw XT_DOLITERAL
000e30 028d          .dw COLON_SMUDGE+2
000e31 0199          .dw XT_FETCH		; ( NFA WID )
000e32 04a0          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000e33 0259          .dw XT_ZERO
000e34 0153          .dw XT_DOLITERAL
000e35 028b          .dw COLON_SMUDGE+0
000e36 01a1          .dw XT_STORE
                 PFA_REVEAL1:
000e37 0133          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000e38 ff06          .dw $ff06
000e39 616c
000e3a 6574
000e3b 7473          .db "latest"
000e3c 0e23          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000e3d 0161          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000e3e 0315          .dw ram_LATEST
                 
                 .dseg
000315           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000e3f 0005          .dw $0005
000e40 6f64
000e41 7365
000e42 003e          .db "does>",0
000e43 0e38          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000e44 0105          .dw DO_COLON
                 PFA_DOES:
000e45 05cb          .dw XT_COMPILE
000e46 0e58          .dw XT_DODOES
000e47 05cb          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000e48 940e          .dw $940e       ; the address of this compiled
000e49 05cb          .dw XT_COMPILE  ; code will replace the XT of the 
000e4a 0e4c          .dw DO_DODOES   ; word that CREATE created
000e4b 0133          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000e4c 939a
000e4d 938a          savetos
000e4e 01cb          movw tosl, wl
000e4f 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
000e50 917f          pop wh ; some 128K Flash devices use 3 cells for call/ret
                 .endif
000e51 917f          pop wh
000e52 916f          pop wl
                 
000e53 93bf          push XH
000e54 93af          push XL
000e55 01db          movw XL, wl
000e56 940c 0109     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000e58 0105          .dw DO_COLON
                 PFA_DODOES:
000e59 020f          .dw XT_R_FROM
000e5a 0153          .dw XT_DOLITERAL
000e5b 028d          .dw COLON_SMUDGE+2
000e5c 0199          .dw XT_FETCH
000e5d 04c4          .dw XT_FETCHE
000e5e 1007          .dw XT_NFA2LFA
000e5f 035d          .dw XT_1PLUS   ; lfa>xt
                 
000e60 04d8          .dw XT_STOREI
000e61 0133          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000e62 ff01          .dw $ff01
000e63 003a          .db ":",0
000e64 0e3f          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000e65 0105          .dw DO_COLON
                 PFA_COLON:
000e66 05a4          .dw XT_DOCREATE
000e67 057f          .dw XT_DP
000e68 0e3d          .dw XT_LATEST
000e69 01a1          .dw XT_STORE
000e6a 05cb          .dw XT_COMPILE
000e6b 0105          .dw DO_COLON
000e6c 0e89          .dw XT_RBRACKET
000e6d 0133          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000e6e ff07          .dw $ff07
000e6f 6e3a
000e70 6e6f
000e71 6d61
000e72 0065          .db ":noname",0
000e73 0e62          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000e74 0105          .dw DO_COLON
                 PFA_COLONNONAME:
000e75 057f          .dw XT_DP
000e76 01d1          .dw XT_DUP
000e77 0e3d          .dw XT_LATEST
000e78 01a1          .dw XT_STORE
                 
000e79 05cb          .dw XT_COMPILE
000e7a 0105          .dw DO_COLON
                 
000e7b 0e89          .dw XT_RBRACKET
000e7c 0133          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000e7d 0001          .dw $0001
000e7e 003b          .db $3b,0
000e7f 0e6e          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000e80 0105          .dw DO_COLON
                 PFA_SEMICOLON:
000e81 05cb          .dw XT_COMPILE
000e82 0133          .dw XT_EXIT
000e83 0e92          .dw XT_LBRACKET
000e84 0e28          .dw XT_REVEAL
000e85 0133          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000e86 ff01          .dw $ff01
000e87 005d          .db "]",0
000e88 0e7d          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000e89 0105          .dw DO_COLON
                 PFA_RBRACKET:
000e8a 0153          .dw XT_DOLITERAL
000e8b 0001          .dw 1
000e8c 051c          .dw XT_STATE
000e8d 01a1          .dw XT_STORE
000e8e 0133          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000e8f 0001          .dw $0001
000e90 005b          .db "[",0
000e91 0e86          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000e92 0105          .dw DO_COLON
                 PFA_LBRACKET:
000e93 0259          .dw XT_ZERO
000e94 051c          .dw XT_STATE
000e95 01a1          .dw XT_STORE
000e96 0133          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000e97 ff08          .dw $ff08
000e98 6176
000e99 6972
000e9a 6261
000e9b 656c          .db "variable"
000e9c 0e8f          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000e9d 0105          .dw DO_COLON
                 PFA_VARIABLE:
000e9e 058f          .dw XT_HERE
000e9f 0eaa          .dw XT_CONSTANT
000ea0 0153          .dw XT_DOLITERAL
000ea1 0002          .dw 2
000ea2 0598          .dw XT_ALLOT
000ea3 0133          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000ea4 ff08          .dw $ff08
000ea5 6f63
000ea6 736e
000ea7 6174
000ea8 746e          .db "constant"
000ea9 0e97          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000eaa 0105          .dw DO_COLON
                 PFA_CONSTANT:
000eab 05a4          .dw XT_DOCREATE
000eac 0e28          .dw XT_REVEAL
000ead 05cb          .dw XT_COMPILE
000eae 0161          .dw PFA_DOVARIABLE
000eaf 05d6          .dw XT_COMMA
000eb0 0133          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000eb1 ff04          .dw $ff04
000eb2 7375
000eb3 7265          .db "user"
000eb4 0ea4          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000eb5 0105          .dw DO_COLON
                 PFA_USER:
000eb6 05a4          .dw XT_DOCREATE
000eb7 0e28          .dw XT_REVEAL
                 
000eb8 05cb          .dw XT_COMPILE
000eb9 0174          .dw PFA_DOUSER
000eba 05d6          .dw XT_COMMA
000ebb 0133          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000ebc ff05          .dw $ff05
000ebd 6176
000ebe 756c
000ebf 0065          .db "value",0
000ec0 0eb1          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000ec1 0105          .dw DO_COLON
                 PFA_VALUE:
000ec2 0188          .dw XT_DOVALUE
000ec3 0587          .dw XT_EDP
000ec4 05d6          .dw XT_COMMA
000ec5 05cb          .dw XT_COMPILE
000ec6 0ed1          .dw XT_EVALUEFETCH
000ec7 05cb          .dw XT_COMPILE
000ec8 0ed5          .dw XT_EVALUESTORE
000ec9 0587          .dw XT_EDP
000eca 01d1          .dw XT_DUP
000ecb 035d          .dw XT_1PLUS
000ecc 035d          .dw XT_1PLUS
000ecd 0bb0          .dw XT_DOTO
000ece 0588          .dw PFA_EDP
000ecf 04a0          .dw XT_STOREE
000ed0 0133          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000ed1 0105          .dw DO_COLON
                 PFA_EVALUEFETCH:
000ed2 04df          .dw XT_FETCHI
000ed3 04c4          .dw XT_FETCHE
000ed4 0133          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000ed5 0105          .dw DO_COLON
                 PFA_EVALUESTORE:
000ed6 04df          .dw XT_FETCHI
000ed7 04a0          .dw XT_STOREE
000ed8 0133          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000ed9 0007          .dw $0007
000eda 6572
000edb 7563
000edc 7372
000edd 0065          .db "recurse",0
000ede 0ebc          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000edf 0105          .dw DO_COLON
                 PFA_RECURSE:
000ee0 0e3d          .dw XT_LATEST
000ee1 0199          .dw XT_FETCH
000ee2 05d6          .dw XT_COMMA
000ee3 0133          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000ee4 ff09          .dw $ff09
000ee5 6d69
000ee6 656d
000ee7 6964
000ee8 7461
000ee9 0065          .db "immediate",0
000eea 0ed9          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000eeb 0105          .dw DO_COLON
                 PFA_IMMEDIATE:
000eec 0fc8          .dw XT_GET_CURRENT
000eed 04c4          .dw XT_FETCHE
000eee 01d1          .dw XT_DUP
000eef 04df          .dw XT_FETCHI
000ef0 0153          .dw XT_DOLITERAL
000ef1 7fff          .dw $7fff
000ef2 0341          .dw XT_AND
000ef3 01e4          .dw XT_SWAP
000ef4 04d8          .dw XT_STOREI
000ef5 0133          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000ef6 0006          .dw $0006
000ef7 635b
000ef8 6168
000ef9 5d72          .db "[char]"
000efa 0ee4          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000efb 0105          .dw DO_COLON
                 PFA_BRACKETCHAR:
000efc 05cb          .dw XT_COMPILE
000efd 0153          .dw XT_DOLITERAL
000efe 0908          .dw XT_CHAR
000eff 05d6          .dw XT_COMMA
000f00 0133          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000f01 0006          .dw $0006
000f02 6261
000f03 726f
000f04 2274          .db "abort", $22
000f05 0ef6          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000f06 0105          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000f07 05cb          .dw XT_COMPILE
000f08 014c          .dw XT_DOCONDBRANCH
000f09 057f          .dw XT_DP
000f0a 05cb          .dw XT_COMPILE
000f0b ffff          .dw -1
                     
000f0c 1046          .dw XT_DOTSTRING
                     
000f0d 05cb          .dw XT_COMPILE
000f0e 0153          .dw XT_DOLITERAL
                     
000f0f 05cb          .dw XT_COMPILE
000f10 fffe          .dw -2
000f11 05cb          .dw XT_COMPILE
000f12 0885          .dw XT_THROW
                     ; then
000f13 057f          .dw XT_DP
000f14 01e4          .dw XT_SWAP
000f15 04d8          .dw XT_STOREI
000f16 0133          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000f17 ff05          .dw $ff05
000f18 6261
000f19 726f
000f1a 0074          .db "abort",0
000f1b 0f01          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000f1c 0105          .dw DO_COLON
                 PFA_ABORT:
000f1d 0153          .dw XT_DOLITERAL
000f1e ffff          .dw -1
000f1f 0885          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000f20 ff04          .dw $ff04
000f21 6f63
000f22 6564          .db "code"
000f23 0f17          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000f24 0105          .dw DO_COLON
                 PFA_CODE:
000f25 05a4          .dw XT_DOCREATE
000f26 0e28          .dw XT_REVEAL
000f27 057f          .dw XT_DP
000f28 035d          .dw XT_1PLUS
000f29 05d6          .dw XT_COMMA
000f2a 0133          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000f2b ff08          .dw $ff08
000f2c 6e65
000f2d 2d64
000f2e 6f63
000f2f 6564          .db "end-code"
000f30 0f20          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000f31 0105          .dw DO_COLON
                 PFA_ENDCODE:
000f32 05cb          .dw XT_COMPILE
000f33 940c          .dw $940c
000f34 05cb          .dw XT_COMPILE
000f35 0109          .dw DO_NEXT
000f36 0133          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000f37 ff0b          .dw $ff0b
000f38 6e65
000f39 6976
000f3a 6f72
000f3b 6d6e
000f3c 6e65
000f3d 0074          .db "environment",0
000f3e 0f2b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000f3f 0161          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000f40 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000f41 ff09          .dw $ff09
000f42 6f77
000f43 6472
000f44 696c
000f45 7473
000f46 0073          .db "wordlists",0
000f47 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000f48 0105          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000f49 0153          .dw XT_DOLITERAL
000f4a 0008          .dw NUMWORDLISTS
000f4b 0133          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000f4c ff04          .dw $ff04
000f4d 702f
000f4e 6461          .db "/pad"
000f4f 0f41          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000f50 0105          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000f51 03af          .dw XT_SP_FETCH
000f52 0555          .dw XT_PAD
000f53 02c1          .dw XT_MINUS
000f54 0133          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000f55 ff05          .dw $ff05
000f56 682f
000f57 6c6f
000f58 0064          .db "/hold",0
000f59 0f4c          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000f5a 0105          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000f5b 0555          .dw XT_PAD
000f5c 058f          .dw XT_HERE
000f5d 02c1          .dw XT_MINUS
000f5e 0133          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000f5f ff0a          .dw $ff0a
000f60 6f66
000f61 7472
000f62 2d68
000f63 616e
000f64 656d          .db "forth-name"
000f65 0f55          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000f66 0105          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000f67 07b9          .dw XT_DOSLITERAL
000f68 0007          .dw 7
000f69 6d61
000f6a 6f66
000f6b 7472
000f6c 0068          .db "amforth",0
000f6d 0133          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000f6e ff07          .dw $ff07
000f6f 6576
000f70 7372
000f71 6f69
000f72 006e          .db "version",0
000f73 0f5f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000f74 0105          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000f75 0153          .dw XT_DOLITERAL
000f76 0034          .dw 52
000f77 0133          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000f78 ff03          .dw $ff03
000f79 7063
000f7a 0075          .db "cpu",0
000f7b 0f6e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000f7c 0105          .dw DO_COLON
                 PFA_EN_CPU:
000f7d 0153          .dw XT_DOLITERAL
000f7e 0075          .dw mcu_name
000f7f 081b          .dw XT_ICOUNT
000f80 0133          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000f81 ff08          .dw $ff08
000f82 636d
000f83 2d75
000f84 6e69
000f85 6f66          .db "mcu-info"
000f86 0f78          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000f87 0105          .dw DO_COLON
                 PFA_EN_MCUINFO:
000f88 0153          .dw XT_DOLITERAL
000f89 0071          .dw mcu_info
000f8a 0133          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000f8b ff05          .dw $ff05
000f8c 752f
000f8d 6573
000f8e 0072          .db "/user",0
000f8f 0f81          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000f90 0105          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000f91 0153          .dw XT_DOLITERAL
000f92 001e          .dw SYSUSERSIZE + APPUSERSIZE
000f93 0133          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000f94 ff04          .dw $ff04
000f95 6540
000f96 5d5b          .db "@e[]"
000f97 0f37          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000f98 0105          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000f99 01d1          .dw XT_DUP
000f9a 04c4          .dw XT_FETCHE
000f9b 0218          .dw XT_TO_R    ; save the counter to r-stack
000f9c 0221          .dw XT_R_FETCH
000f9d 0259          .dw XT_ZERO
000f9e 01e4          .dw XT_SWAP    ; go from bigger to smaller addresses
000f9f 03d2          .dw XT_DOQDO
000fa0 0faa          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000fa1 03e8          .dw XT_I
000fa2 0529          .dw XT_CELLS ; ( -- ee-addr i*2 )
000fa3 01ef          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000fa4 02cb          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000fa5 04c4          .dw XT_FETCHE ;( -- ee-addr item_i )
000fa6 01e4          .dw XT_SWAP   ;( -- item_i ee-addr )
000fa7 0262          .dw XT_TRUE  ; shortcut for -1
000fa8 03e9          .dw XT_DOPLUSLOOP
000fa9 0fa1          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000faa 0541          .dw XT_2DROP
000fab 020f          .dw XT_R_FROM ; get the counter from r-stack
000fac 0133          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000fad ff04          .dw $ff04
000fae 6521
000faf 5d5b          .db "!e[]"
000fb0 0f94          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000fb1 0105          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000fb2 0538          .dw XT_2DUP
000fb3 04a0          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000fb4 01e4          .dw XT_SWAP    
000fb5 0259          .dw XT_ZERO
000fb6 03d2          .dw XT_DOQDO
000fb7 0fbe          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000fb8 0531          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000fb9 01e4          .dw XT_SWAP
000fba 01ef          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000fbb 04a0          .dw XT_STOREE
000fbc 0403          .dw XT_DOLOOP
000fbd 0fb8          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000fbe 01f9          .dw XT_DROP
000fbf 0133          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000fc0 ff0b          .dw $ff0b
000fc1 6567
000fc2 2d74
000fc3 7563
000fc4 7272
000fc5 6e65
000fc6 0074          .db "get-current",0
000fc7 0fad          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000fc8 0105          .dw DO_COLON
                 PFA_GET_CURRENT:
000fc9 0153          .dw XT_DOLITERAL
000fca 0010          .dw EE_CURRENT
000fcb 04c4          .dw XT_FETCHE
000fcc 0133          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000fcd ff09          .dw $ff09
000fce 6567
000fcf 2d74
000fd0 726f
000fd1 6564
000fd2 0072          .db "get-order",0
000fd3 0fc0          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000fd4 0105          .dw DO_COLON
                 PFA_GET_ORDER:
000fd5 0153          .dw XT_DOLITERAL
000fd6 0014          .dw EE_ORDERLISTLEN
000fd7 0f98          .dw XT_FETCH_EE_ARRAY
000fd8 0133          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000fd9 ff07          .dw $ff07
000fda 6f63
000fdb 706d
000fdc 7261
000fdd 0065          .db "compare",0
000fde 0fcd          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000fdf 0fe0          .dw PFA_COMPARE
                 PFA_COMPARE:
000fe0 93bf          push xh
000fe1 93af          push xl
000fe2 018c          movw temp0, tosl
000fe3 9189
000fe4 9199          loadtos
000fe5 01dc          movw xl, tosl
000fe6 9189
000fe7 9199          loadtos
000fe8 019c          movw temp2, tosl
000fe9 9189
000fea 9199          loadtos
000feb 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000fec 90ed          ld temp4, X+
000fed 90f1          ld temp5, Z+
000fee 14ef          cp temp4, temp5
000fef f451          brne PFA_COMPARE_NOTEQUAL
000ff0 950a          dec temp0
000ff1 f019          breq PFA_COMPARE_ENDREACHED2
000ff2 952a          dec temp2
000ff3 f7c1          brne PFA_COMPARE_LOOP
000ff4 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000ff5 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000ff6 2b02          or temp0, temp2
000ff7 f411          brne PFA_COMPARE_CHECKLASTCHAR
000ff8 2788          clr tosl
000ff9 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000ffa ef8f          ser tosl
000ffb c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000ffc 2f98          mov tosh, tosl
000ffd 91af          pop xl
000ffe 91bf          pop xh
000fff 940c 0109     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
001001 ff07         .dw $ff07
001002 666e
001003 3e61
001004 666c
001005 0061         .db "nfa>lfa",0
001006 0fd9         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
001007 0105          .dw DO_COLON
                 PFA_NFA2LFA:
001008 081b          .dw XT_ICOUNT 
001009 0153          .dw XT_DOLITERAL
00100a 00ff          .dw $00ff
00100b 0341          .dw XT_AND
00100c 035d          .dw XT_1PLUS
00100d 0332          .dw XT_2SLASH
00100e 02cb          .dw XT_PLUS
00100f 0133          .dw XT_EXIT
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
001010 ff0b          .dw $ff0b
001011 7061
001012 6c70
001013 7574
001014 6e72
001015 656b
001016 0079          .db "applturnkey",0
001017 1001          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
001018 0105          .dw DO_COLON
                 PFA_APPLTURNKEY:
001019 00ee          .dw XT_USART
                 
00101a 0463          .dw XT_INTON
00101b 0b78          .dw XT_VER
00101c 0831          .dw XT_SPACE
00101d 0506          .dw XT_F_CPU
00101e 0153          .dw XT_DOLITERAL
00101f 03e8          .dw 1000
001020 02f0          .dw XT_UMSLASHMOD
001021 01e4          .dw XT_SWAP
001022 01f9          .dw XT_DROP
001023 05f8          .dw XT_DECIMAL
001024 0756          .dw XT_DOT
001025 07b9          .dw XT_DOSLITERAL
001026 0004          .dw 4
001027 486b
001028 207a          .db "kHz "
001029 07f0          .dw XT_ITYPE
                     
00102a 0133          .dw XT_EXIT
                 
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
00102b ff02          .dw $ff02
00102c 2e75          .db "u."
00102d 1010          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00102e 0105          .dw DO_COLON
                 PFA_UDOT:
00102f 0259          .dw XT_ZERO
001030 075e          .dw XT_UDDOT
001031 0133          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
001032 ff02          .dw $ff02
001033 732e          .db ".s"
001034 102b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
001035 0105          .dw DO_COLON
                 PFA_DOTS:
001036 0acc          .dw XT_SP0
001037 03af          .dw XT_SP_FETCH
001038 0531          .dw XT_CELLPLUS
001039 03d2          .dw XT_DOQDO
00103a 1042          .dw PFA_DOTS2
                 PFA_DOTS1:
00103b 03e8          .dw XT_I
00103c 0199          .dw XT_FETCH 
00103d 102e          .dw XT_UDOT
00103e 0153          .dw XT_DOLITERAL
00103f 0002          .dw 2
001040 03e9          .dw XT_DOPLUSLOOP
001041 103b          .dw PFA_DOTS1
                 PFA_DOTS2:
001042 0133          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
001043 0002          .dw $0002
001044 222e          .db ".",$22
001045 1032          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
001046 0105          .dw DO_COLON
                 PFA_DOTSTRING:
001047 104e          .dw XT_SQUOTE
001048 05cb          .dw XT_COMPILE
001049 07f0          .dw XT_ITYPE
00104a 0133          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
00104b 0002        .dw $0002
00104c 2273        .db "s",$22
00104d 1043        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00104e 0105          .dw DO_COLON
                 PFA_SQUOTE:
00104f 0153          .dw XT_DOLITERAL
001050 0022          .dw $22
001051 09c6          .dw XT_PARSE       ; ( -- addr n)
001052 051c          .dw XT_STATE
001053 0199          .dw XT_FETCH
001054 014c          .dw XT_DOCONDBRANCH
001055 1059          .dw PFA_SQUOTE1
001056 05cb            .dw XT_COMPILE
001057 07b9            .dw XT_DOSLITERAL    ; ( -- addr n)
001058 07cc            .dw XT_SCOMMA
                 PFA_SQUOTE1:
001059 0133          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
00105a ff05          .dw $ff05
00105b 6f77
00105c 6472
00105d 0073          .db "words",0
00105e 104b          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00105f 0105          .dw DO_COLON
                 PFA_WORDS:
001060 0153          .dw XT_DOLITERAL
001061 0016          .dw EE_ORDERLIST
001062 04c4          .dw XT_FETCHE
001063 106e          .dw XT_SHOWWORDLIST
001064 0133          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
001065 ff0d          .dw $ff0d
001066 6873
001067 776f
001068 772d
001069 726f
00106a 6c64
00106b 7369
00106c 0074          .db "show-wordlist",0
00106d 105a          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00106e 0105          .dw DO_COLON
                 PFA_SHOWWORDLIST:
00106f 0153          .dw XT_DOLITERAL
001070 1074          .dw XT_SHOWWORD
001071 01e4          .dw XT_SWAP
001072 0c52          .dw XT_TRAVERSEWORDLIST
001073 0133          .dw XT_EXIT
                 
                 XT_SHOWWORD:
001074 0105          .dw DO_COLON
                 PFA_SHOWWORD:
001075 0c41          .dw XT_NAME2STRING
001076 07f0          .dw XT_ITYPE
001077 0831          .dw XT_SPACE         ; ( -- addr n)
001078 0262          .dw XT_TRUE
001079 0133          .dw XT_EXIT
                 
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
00107a ff06          .dw $ff06
00107b 6445
00107c 6665
00107d 7265          .db "Edefer"
00107e 1065          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
00107f 0105          .dw DO_COLON
                 PFA_EDEFER:
001080 05a4          .dw XT_DOCREATE
001081 0e28          .dw XT_REVEAL
001082 05cb          .dw XT_COMPILE
001083 0bf8          .dw PFA_DODEFER
                 
001084 0587          .dw XT_EDP
001085 01d1          .dw XT_DUP
001086 05d6          .dw XT_COMMA
001087 05cb          .dw XT_COMPILE
001088 0bbc          .dw XT_EDEFERFETCH
001089 05cb          .dw XT_COMPILE
00108a 0bc1          .dw XT_EDEFERSTORE
00108b 0531          .dw XT_CELLPLUS
00108c 0bb0          .dw XT_DOTO
00108d 0588          .dw PFA_EDP
00108e 0133          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
00108f ff06          .dw $ff06
001090 6452
001091 6665
001092 7265          .db "Rdefer"
001093 107a          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
001094 0105          .dw DO_COLON
                 PFA_RDEFER:
001095 05a4          .dw XT_DOCREATE
001096 0e28          .dw XT_REVEAL
                 
001097 05cb          .dw XT_COMPILE
001098 0bf8          .dw PFA_DODEFER
                 
001099 058f          .dw XT_HERE
00109a 05d6          .dw XT_COMMA
00109b 0153          .dw XT_DOLITERAL
00109c 0002          .dw 2
00109d 0598          .dw XT_ALLOT
                 
00109e 05cb          .dw XT_COMPILE
00109f 0bc6          .dw XT_RDEFERFETCH
0010a0 05cb          .dw XT_COMPILE
0010a1 0bcb          .dw XT_RDEFERSTORE
0010a2 0133          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
0010a3 0002          .dw $0002
0010a4 7369          .db "is"
0010a5 108f          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
0010a6 0105          .dw DO_COLON
                 PFA_IS:
0010a7 051c          .dw XT_STATE
0010a8 0199          .dw XT_FETCH
0010a9 014c          .dw XT_DOCONDBRANCH
0010aa 10af          .dw PFA_IS1
0010ab 05e2          .dw XT_BRACKETTICK
0010ac 05cb          .dw XT_COMPILE
0010ad 0be3          .dw XT_DEFERSTORE
0010ae 0133          .dw XT_EXIT
                 PFA_IS1:
0010af 0858          .dw XT_TICK
0010b0 0be3          .dw XT_DEFERSTORE
0010b1 0133          .dw XT_EXIT
                 
                 
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0010b2 ff07          .dw $ff07
0010b3 6964
0010b4 766e
0010b5 7265
0010b6 0074          .db "dinvert",0
0010b7 10a3          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0010b8 10b9          .dw PFA_DINVERT
                 PFA_DINVERT:
0010b9 9109          ld temp0, Y+
0010ba 9119          ld temp1, Y+
0010bb 9580          com tosl
0010bc 9590          com tosh
0010bd 9500          com temp0
0010be 9510          com temp1
0010bf 931a          st -Y, temp1
0010c0 930a          st -Y, temp0
0010c1 940c 0109     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
0010c3 ff02          .dw $ff02
0010c4 2b64          .db "d+"
0010c5 10b2          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
0010c6 10c7          .dw PFA_DPLUS
                 PFA_DPLUS:
0010c7 9129          ld temp2, Y+
0010c8 9139          ld temp3, Y+
                 
0010c9 90e9          ld temp4, Y+
0010ca 90f9          ld temp5, Y+
0010cb 9149          ld temp6, Y+
0010cc 9159          ld temp7, Y+
                 
0010cd 0f24          add temp2, temp6
0010ce 1f35          adc temp3, temp7
0010cf 1d8e          adc tosl, temp4
0010d0 1d9f          adc tosh, temp5
                     
0010d1 933a          st -Y, temp3
0010d2 932a          st -Y, temp2
0010d3 940c 0109     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
0010d5 ff02          .dw $ff02
0010d6 2d64          .db "d-"
0010d7 10c3          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
0010d8 10d9          .dw PFA_DMINUS
                 PFA_DMINUS:
0010d9 9129          ld temp2, Y+
0010da 9139          ld temp3, Y+
                 
0010db 90e9          ld temp4, Y+
0010dc 90f9          ld temp5, Y+
0010dd 9149          ld temp6, Y+
0010de 9159          ld temp7, Y+
                 
0010df 1b42          sub temp6, temp2
0010e0 0b53          sbc temp7, temp3
0010e1 0ae8          sbc temp4, tosl
0010e2 0af9          sbc temp5, tosh
                 
0010e3 935a          st -Y, temp7
0010e4 934a          st -Y, temp6
0010e5 01c7          movw tosl, temp4
0010e6 940c 0109     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .set flashlast = pc
                 
                 .dseg
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 e8 10         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 17 03         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 18 10         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a ed 04         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 8b 0f         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 d5 10         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 44 0b         .dw XT_REC_FIND
00002a 27 0b         .dw XT_REC_INTNUMBER
00002c 60 0b         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 c8 0f         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 21         .dw rstackstart  ; USER_RP
00003e af 21         .dw stackstart   ; USER_SP0
000040 af 21         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 ca 00         .dw XT_TX  ; USER_EMIT
000048 d8 00         .dw XT_TXQ ; USER_EMITQ
00004a a0 00         .dw XT_RX  ; USER_KEY
00004c ba 00         .dw XT_RXQ ; USER_KEYQ
00004e 11 0d         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 fd 0c         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 5f 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 00
000058 e1 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2561" register use summary:
r0 :  21 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  72 r17:  54 r18:  58 r19:  42 r20:  13 r21:  44 r22:  11 r23:   4 
r24: 163 r25: 116 r26:  45 r27:  22 r28:   6 r29:   4 r30:  68 r31:  33 
x  :   4 y  : 177 z  :  41 
Registers used: 29 out of 35 (82.9%)

"ATmega2561" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :   8 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  21 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :   8 eicall:   1 eijmp :   0 elpm  :  20 
eor   :   3 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 
in    :  15 inc   :   2 jmp   :  13 ld    : 125 ldd   :   4 ldi   :  24 
lds   :   2 lpm   :   0 lsl   :  15 lsr   :   1 mov   :  10 movw  :  64 
mul   :   5 muls  :   1 mulsu :   2 neg   :   0 nop   :   0 or    :   9 
ori   :   0 out   :  29 pop   :  50 push  :  34 rcall :  68 ret   :   6 
reti  :   2 rjmp  :  94 rol   :  33 ror   :   2 sbc   :   8 sbci  :   3 
sbi   :   3 sbic  :   3 sbis  :   0 sbiw  :   6 sbr   :   0 sbrc  :   4 
sbrs  :   4 sec   :   1 seh   :   0 sei   :   1 sen   :   0 ser   :   3 
ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   0 spm   :   2 
st    :  56 std   :   8 sts   :   3 sub   :   5 subi  :   3 swap  :   0 
tst   :   1 wdr   :   0 
Instructions used: 73 out of 116 (62.9%)

"ATmega2561" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x03e07e   1900  12870  14770  262144   5.6%
[.dseg] 0x000200 0x000317      0    279    279    8192   3.4%
[.eseg] 0x000000 0x00005a      0     90     90    4096   2.2%

Assembly complete, 0 errors, 2 warnings
