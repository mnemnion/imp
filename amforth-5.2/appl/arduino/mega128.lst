
AVRASM ver. 2.1.51  mega128.asm Mon Dec 23 20:35:18 2013

mega128.asm(8): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
mega128.asm(12): Including file '../../core/devices/atmega1280\device.asm'
../../core/devices/atmega1280\device.asm(5): Including file '../../Atmel/Appnotes2\m1280def.inc'
mega128.asm(37): Including file '../../core\drivers/1wire.asm'
mega128.asm(41): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
mega128.asm(44): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(5): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(6): Including file '../../core\words/marker.asm'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(10): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl_core.inc(16): Including file '../../core\words/fill.asm'
dict_appl_core.inc(17): Including file '../../core\words/d-2star.asm'
dict_appl_core.inc(18): Including file '../../core\words/d-plus.asm'
dict_appl_core.inc(19): Including file '../../core\words/d-minus.asm'
dict_appl_core.inc(20): Including file '../../core\words/d-invert.asm'
dict_appl_core.inc(21): Including file '../../core\words/udot.asm'
dict_appl_core.inc(22): Including file '../../core\words/dot-s.asm'
dict_appl_core.inc(24): Including file '../../core\words/dotstring.asm'
dict_appl_core.inc(25): Including file '../../core\words/squote.asm'
dict_appl_core.inc(27): Including file '../../core\words/edefer.asm'
dict_appl_core.inc(28): Including file '../../core\words/rdefer.asm'
dict_appl_core.inc(29): Including file '../../core\words/is.asm'
dict_appl_core.inc(31): Including file 'words/applturnkey.asm'
dict_appl_core.inc(32): Including file '../../core\words/1ms.asm'
dict_appl_core.inc(33): Including file '../../core\words/ms.asm'
dict_appl_core.inc(34): Including file '../../core\words/show-wordlist.asm'
dict_appl_core.inc(35): Including file '../../core\words/words.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 ; The order of the entries (esp the include order) must not be
                 ; changed since it is very important that the settings are in the
                 ; right order
                 ;
                 ; first is to include the macros from the amforth
                 ; directory
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; include the amforth device definition file. These
                 ; files include the *def.inc from atmel internally.
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_PORTH = 0
                 .set WANT_PORTJ = 0
                 .set WANT_PORTK = 0
                 .set WANT_PORTL = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_USART2 = 0
                 .set WANT_USART3 = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d14f      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d14d      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d14b      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d149      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d147      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d145      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d143      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d141      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d13f      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d13d      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d13b      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d139      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d137      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d135      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d133      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d131      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d12f      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d12d      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d12b      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d129      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d127      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d125      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d123      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d121      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d11f      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d11d      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d11b      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d119      	 rcall isr ; Analog Comparator
                 .org 58
00003a d117      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d115      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d113      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d111      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d10f      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d10d      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d10b      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d109      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d107      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d105      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d103      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d101      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d0ff      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d0fd      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d0fb      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d0f9      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d0f7      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d0f5      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d0f3      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d0f1      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d0ef      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d0ed      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d0eb      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0e9      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0e7      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0e5      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0e3      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0e1      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3231
00007a 3038      	.db "ATmega1280"
                 .set codestart=pc
                 
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; the dictionary search treats lowercase and uppercase
                 ; letters the same. Set to 0 if you do not want it
                 .set WANT_IGNORECASE = 1
                 
                 ; amforth needs two essential parameters
                 ; cpu clock in hertz, 1MHz is factory default
                 .equ F_CPU = 16000000
                 
                 
                 .equ TIBSIZE  = $64    ; ANS94 needs at least 80 characters per line
                 .equ APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .equ NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 
                 ; settings for 1wire interface, if desired
                 .equ OW_PORT=PORTE
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
00007b ff08          .dw $ff08
00007c 7731
00007d 722e
00007e 7365
00007f 7465          .db "1w.reset"
000080 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
000081 0082          .dw PFA_OW_RESET
                 PFA_OW_RESET:
000082 939a
000083 938a          savetos
000084 2799          clr tosh
                     ; setup to output
000085 9a6c          sbi OW_DDR, OW_BIT
                     ; Pull output low
000086 9874          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
000087 e8e0
000088 e0f7
000089 9731
00008a f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
00008b b71f          in temp1, SREG
00008c 94f8          cli
                     ; Pull output high
00008d 9a74          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
00008e 986c          cbi OW_DDR, OW_BIT 
00008f e0e0
000090 e0f1
000091 9731
000092 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
000093 b18c          in tosl, OW_PIN
000094 ff84          sbrs tosl, OW_BIT
000095 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
000096 bf1f          out SREG, temp1
                     ; release bus
000097 986c          cbi OW_DDR, OW_BIT
000098 9874          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
000099 e8e0
00009a e0f6
00009b 9731
00009c f7f1          DELAY   416
                     ; we now have the result flag in TOS        
00009d 2f89          mov tosl, tosh
00009e 940c f004     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000a0 ff07          .dw $ff07
0000a1 7731
0000a2 732e
0000a3 6f6c
0000a4 0074          .db "1w.slot",0
0000a5 007b          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000a6 00a7          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000a7 9a6c          sbi OW_DDR, OW_BIT
0000a8 9874          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000a9 b71f          in temp1, SREG
0000aa 94f8          cli
0000ab e1e8
0000ac e0f0
0000ad 9731
0000ae f7f1          DELAY   6 ; DELAY A
                     ; check bit
0000af 9488          clc
0000b0 9587          ror tosl
0000b1 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
0000b2 986c            cbi OW_DDR, OW_BIT
0000b3 9a74            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
0000b4 e2e4
0000b5 e0f0
0000b6 9731
0000b7 f7f1          DELAY 9   ; wait DELAY E to sample
0000b8 b10c          in temp0, OW_PIN
0000b9 fd04          sbrc temp0, OW_BIT
0000ba 6880          ori tosl, $80
                 
0000bb ecec
0000bc e0f0
0000bd 9731
0000be f7f1          DELAY   51 ; DELAY B
0000bf 986c          cbi OW_DDR, OW_BIT
0000c0 9a74          sbi OW_PORT, OW_BIT ; release bus
0000c1 e0e8
0000c2 e0f0
0000c3 9731
0000c4 f7f1          delay 2
                     ; re-enable interrupts
0000c5 bf1f          out SREG, temp1
0000c6 940c f004     jmp_ DO_NEXT
                 
                 ; initial baud rate of terminal
                 .equ BAUD = 38400
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000032 940c 00c8   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200           usart_rx_in: .byte 1
000201           usart_rx_out: .byte 1
000202           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
0000c8 93af        push xl
0000c9 b7af        in xl, SREG
0000ca 93af        push xl
0000cb 93bf        push xh
0000cc 93ef        push zl
0000cd 93ff        push zh
                 
0000ce 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
0000d0 91a0 0200   lds xl,usart_rx_in
0000d2 e0e2        ldi zl, low(usart_rx_data)
0000d3 e0f2        ldi zh, high(usart_rx_data)
0000d4 0fea        add zl, xl
0000d5 1df3        adc zh, zeroh
0000d6 83b0        st Z, xh
                 
0000d7 95a3        inc xl
0000d8 70af        andi xl,usart_rx_mask
                 
0000d9 93a0 0200   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
0000db 91ff        pop zh
0000dc 91ef        pop zl
0000dd 91bf        pop xh
0000de 91af        pop xl
0000df bfaf        out SREG, xl
0000e0 91af        pop xl
0000e1 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
0000e2 f000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
0000e3 f146        .dw XT_ZERO
0000e4 f040        .dw XT_DOLITERAL
0000e5 0200        .dw usart_rx_in
0000e6 f08e        .dw XT_STORE
                 
0000e7 f020        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
0000e8 ff06          .dw $ff06
0000e9 7872
0000ea 692d
0000eb 7273          .db "rx-isr"
0000ec 00a0          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000ed f000          .dw DO_COLON
                 PFA_RX_ISR:
0000ee 0107        .dw XT_RXQ_ISR
0000ef f039        .dw XT_DOCONDBRANCH
0000f0 00ee        .dw PFA_RX_ISR
0000f1 f040        .dw XT_DOLITERAL
0000f2 0201        .dw usart_rx_out
0000f3 f0a5        .dw XT_CFETCH
0000f4 f0be        .dw XT_DUP
0000f5 f24a        .dw XT_1PLUS
0000f6 f040        .dw XT_DOLITERAL
0000f7 000f        .dw usart_rx_mask
0000f8 f22e        .dw XT_AND
0000f9 f040        .dw XT_DOLITERAL
0000fa 0201        .dw usart_rx_out
0000fb f09a        .dw XT_CSTORE
0000fc f040        .dw XT_DOLITERAL
0000fd 0202        .dw usart_rx_data
0000fe f1b8        .dw XT_PLUS
0000ff f0a5        .dw XT_CFETCH
000100 f020        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000101 ff07          .dw $ff07
000102 7872
000103 2d3f
000104 7369
000105 0072          .db "rx?-isr",0
000106 00e8          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000107 f000          .dw DO_COLON
                 PFA_RXQ_ISR:
000108 073e        .dw XT_PAUSE
000109 f040        .dw XT_DOLITERAL
00010a 0201        .dw usart_rx_out
00010b f0a5        .dw XT_CFETCH
00010c f040        .dw XT_DOLITERAL
00010d 0200        .dw usart_rx_in
00010e f0a5        .dw XT_CFETCH
00010f f119        .dw XT_NOTEQUAL
000110 f020        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000111 ff07          .dw $ff07
000112 7874
000113 702d
000114 6c6f
000115 006c          .db "tx-poll",0
000116 0101          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000117 f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000118 0125        .dw XT_TXQ_POLL
000119 f039        .dw XT_DOCONDBRANCH
00011a 0118        .dw PFA_TX_POLL
                   ; send to usart
00011b f040        .dw XT_DOLITERAL
00011c 00c6        .dw USART_DATA
00011d f09a        .dw XT_CSTORE
00011e f020        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00011f ff08          .dw $ff08
000120 7874
000121 2d3f
000122 6f70
000123 6c6c          .db "tx?-poll"
000124 0111          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
000125 f000          .dw DO_COLON
                 PFA_TXQ_POLL:
000126 073e        .dw XT_PAUSE
000127 f040        .dw XT_DOLITERAL
000128 00c0        .dw USART_A
000129 f0a5        .dw XT_CFETCH
00012a f040        .dw XT_DOLITERAL
00012b 0020        .dw bm_USART_TXRD
00012c f22e        .dw XT_AND
00012d f020        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
00012e ff04        .dw $ff04
00012f 6275
000130 7272        .db "ubrr"
000131 011f        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
000132 f07b        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
000133 0054        .dw EE_UBRRVAL
000134 f57b        .dw XT_EVALUEFETCH
000135 f57f        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
000136 ff06        .dw $ff06
000137 752b
000138 6173
000139 7472        .db "+usart"
00013a 012e        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
00013b f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
00013c f040        .dw XT_DOLITERAL
00013d 0098        .dw USART_B_VALUE
00013e f040        .dw XT_DOLITERAL
00013f 00c1        .dw USART_B
000140 f09a        .dw XT_CSTORE
                 
000141 f040        .dw XT_DOLITERAL
000142 0006        .dw USART_C_VALUE
000143 f040        .dw XT_DOLITERAL
000144 00c2        .dw USART_C | bm_USARTC_en
000145 f09a        .dw XT_CSTORE
                 
000146 0132        .dw XT_UBRR
000147 f0be        .dw XT_DUP
000148 f326        .dw XT_BYTESWAP
000149 f040        .dw XT_DOLITERAL
00014a 00c5        .dw BAUDRATE_HIGH
00014b f09a        .dw XT_CSTORE
00014c f040        .dw XT_DOLITERAL
00014d 00c4        .dw BAUDRATE_LOW
00014e f09a        .dw XT_CSTORE
                 
00014f 00e2        .dw XT_USART_INIT_RX
000150 0838        .dw XT_USART_INIT_TX
000151 f020        .dw XT_EXIT
                 
                 ; include the whole source tree.
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 0747   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000214           intcur: .byte 1
000215           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000152 920a          st -Y, r0
000153 b60f          in r0, SREG
000154 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
000155 900f          pop r0
000156 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000157 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000158 9200 0214     sts intcur, r0
00015a 9009          ld r0, Y+
00015b be0f          out SREG, r0
00015c 9009          ld r0, Y+
00015d 9468          set ; set the interrupt flag for the inner interpreter
00015e 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00015f ff04          .dw $ff04
000160 692b
000161 746e          .db "+int"
000162 0136          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000163 0164          .dw PFA_INTON
                 PFA_INTON:
000164 9478          sei
000165 940c f004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000167 ff04          .dw $ff04
000168 692d
000169 746e          .db "-int"
00016a 015f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00016b 016c          .dw PFA_INTOFF
                 PFA_INTOFF:
00016c 94f8          cli
00016d 940c f004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00016f ff04          .dw $ff04
000170 6e69
000171 2174          .db "int!"
000172 0167          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000173 f000          .dw DO_COLON
                 PFA_INTSTORE:
000174 f040          .dw XT_DOLITERAL
000175 0215          .dw intvec
000176 f1b8          .dw XT_PLUS
000177 f08e          .dw XT_STORE
000178 f020          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000179 ff04          .dw $ff04
00017a 6e69
00017b 4074          .db "int@"
00017c 016f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00017d f000          .dw DO_COLON
                 PFA_INTFETCH:
00017e f040          .dw XT_DOLITERAL
00017f 0215          .dw intvec
000180 f1b8          .dw XT_PLUS
000181 f086          .dw XT_FETCH
000182 f020          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000183 ff08          .dw $ff08
000184 6e69
000185 2d74
000186 7274
000187 7061          .db "int-trap"
000188 0179          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000189 018a          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00018a 9380 0214     sts intcur, tosl
00018c 9189
00018d 9199          loadtos
00018e 9468          set ; set the interrupt flag for the inner interpreter
00018f 940c f004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000191 f000          .dw DO_COLON
                 PFA_ISREXEC:
000192 f040          .dw XT_DOLITERAL
000193 0214          .dw intcur
000194 f0a5          .dw XT_CFETCH
000195 f040          .dw XT_DOLITERAL
000196 0215          .dw intvec
000197 f1b8          .dw XT_PLUS
000198 f086          .dw XT_FETCH
000199 f02a          .dw XT_EXECUTE
00019a 019c          .dw XT_ISREND
00019b f020          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00019c 019d          .dw PFA_ISREND
                 PFA_ISREND:
00019d d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00019e 940c f004     jmp_ DO_NEXT
                 PFA_ISREND1:
0001a0 9518          reti
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
0001a1 ff05          .dw $ff05
0001a2 5f66
0001a3 7063
0001a4 0075          .db "f_cpu",0
0001a5 0183          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0001a6 f07b          .dw PFA_DOVALUE1
                 PFA_F_CPU:
0001a7 0056          .dw EE_FCPU
0001a8 01aa          .dw XT_FETCH2E
0001a9 01b3          .dw XT_STORE2E
                 
                 XT_FETCH2E:
0001aa f000          .dw DO_COLON
                 PFA_FETCH2E:
0001ab f3e5          .dw XT_FETCHI
0001ac f0be          .dw XT_DUP
0001ad 01d1          .dw XT_CELLPLUS
0001ae f373          .dw XT_FETCHE
0001af f0d1          .dw XT_SWAP
0001b0 f373          .dw XT_FETCHE
0001b1 f0d1          .dw XT_SWAP
0001b2 f020          .dw XT_EXIT
                 
                 XT_STORE2E:
0001b3 f000          .dw DO_COLON
                 PFA_STORE2E:
0001b4 f040          .dw XT_DOLITERAL
0001b5 ffeb          .dw -21
0001b6 0528          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0001b7 ff05          .dw $ff05
0001b8 7473
0001b9 7461
0001ba 0065          .db "state",0
0001bb 01a1          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0001bc f04e          .dw PFA_DOVARIABLE
                 PFA_STATE:
0001bd 0287          .dw ram_state
                 
                 .dseg
000287           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
0001be ff04          .dw $ff04
0001bf 6162
0001c0 6573          .db "base"
0001c1 01b7          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0001c2 f061          .dw PFA_DOUSER
                 PFA_BASE:
0001c3 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0001c4 ff05          .dw $ff05
0001c5 6563
0001c6 6c6c
0001c7 0073          .db "cells",0
0001c8 01be          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0001c9 f000          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
0001ca f226          .dw XT_2STAR
                 .else
                 .endif
0001cb f020          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0001cc ff05          .dw $ff05
0001cd 6563
0001ce 6c6c
0001cf 002b          .db "cell+",0
0001d0 01c4          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0001d1 01d2          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0001d2 9602          adiw tosl, CELLSIZE
0001d3 940c f004     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
0001d5 ff04          .dw $ff04
0001d6 6432
0001d7 7075          .db "2dup"
0001d8 01cc          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
0001d9 f000          .dw DO_COLON
                 PFA_2DUP:
0001da f0dc          .dw XT_OVER
0001db f0dc          .dw XT_OVER
0001dc f020          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
0001dd ff05          .dw $ff05
0001de 6432
0001df 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
0001e0 0070          .db "2drop"
0001e1 01d5          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
0001e2 f000          .dw DO_COLON
                 PFA_2DROP:
0001e3 f0e6          .dw XT_DROP
0001e4 f0e6          .dw XT_DROP
0001e5 f020          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
0001e6 ff03          .dw $ff03
0001e7 693e
0001e8 006e          .db ">in",0
0001e9 01dd          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
0001ea f061          .dw PFA_DOUSER
                 PFA_G_IN:
0001eb 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
0001ec ff04          .dw $ff04
0001ed 7423
0001ee 6269          .db "#tib"
0001ef 01e6          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
0001f0 f04e          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
0001f1 0289          .dw ram_sharptib
                 
                 .dseg
000289           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
0001f2 ff03          .dw $ff03
0001f3 6170
0001f4 0064          .db "pad",0
0001f5 01ec          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0001f6 f000          .dw DO_COLON
                 PFA_PAD:
0001f7 0230          .dw XT_HERE
0001f8 f040          .dw XT_DOLITERAL
0001f9 0064          .dw 100
0001fa f1b8          .dw XT_PLUS
0001fb f020          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
0001fc ff04          .dw $ff04
0001fd 6d65
0001fe 7469          .db "emit"
0001ff 01f2          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000200 089b          .dw PFA_DODEFER
                 PFA_EMIT:
000201 000e          .dw USER_EMIT
000202 0873          .dw XT_UDEFERFETCH
000203 087a          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
000204 ff05          .dw $ff05
000205 6d65
000206 7469
000207 003f          .db "emit?",0
000208 01fc          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000209 089b          .dw PFA_DODEFER
                 PFA_EMITQ:
00020a 0010          .dw USER_EMITQ
00020b 0873          .dw XT_UDEFERFETCH
00020c 087a          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
00020d ff03          .dw $ff03
00020e 656b
00020f 0079          .db "key",0
000210 0204          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000211 089b          .dw PFA_DODEFER
                 PFA_KEY:
000212 0012          .dw USER_KEY
000213 0873          .dw XT_UDEFERFETCH
000214 087a          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
000215 ff04          .dw $ff04
000216 656b
000217 3f79          .db "key?"
000218 020d          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000219 089b          .dw PFA_DODEFER
                 PFA_KEYQ:
00021a 0014          .dw USER_KEYQ
00021b 0873          .dw XT_UDEFERFETCH
00021c 087a          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00021d ff02          .dw $ff02
00021e 7064          .db "dp"
00021f 0215          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000220 f07b          .dw PFA_DOVALUE1
                 PFA_DP:
000221 0002          .dw EE_DP
000222 f57b          .dw XT_EVALUEFETCH
000223 f57f          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
000224 ff03          .dw $ff03
000225 6465
000226 0070          .db "edp",0
000227 021d          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
000228 f07b          .dw PFA_DOVALUE1
                 PFA_EDP:
000229 0006          .dw EE_EDP
00022a f57b          .dw XT_EVALUEFETCH
00022b f57f          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00022c ff04          .dw $ff04
00022d 6568
00022e 6572          .db "here"
00022f 0224          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000230 f07b          .dw PFA_DOVALUE1
                 PFA_HERE:
000231 0004          .dw EE_HERE
000232 f57b          .dw XT_EVALUEFETCH
000233 f57f          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000234 ff05          .dw $ff05
000235 6c61
000236 6f6c
000237 0074          .db "allot",0
000238 022c          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000239 f000          .dw DO_COLON
                 PFA_ALLOT:
00023a 0230          .dw XT_HERE
00023b f1b8          .dw XT_PLUS
00023c 0853          .dw XT_DOTO
00023d 0231          .dw PFA_HERE
00023e f020          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
00023f ff08          .dw $ff08
000240 6328
000241 6572
000242 7461
000243 2965          .db "(create)"
000244 0234          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000245 f000          .dw DO_COLON
                 PFA_DOCREATE:
000246 06b8          .dw XT_PARSENAME
000247 f4cb          .dw XT_WLSCOPE
000248 f0be          .dw XT_DUP
000249 f105          .dw XT_TO_R
00024a f4b0          .dw XT_HEADER
00024b f0fc          .dw XT_R_FROM
                 .dseg
00028b           COLON_SMUDGE: .byte 4
                 .cseg
00024c f040          .dw XT_DOLITERAL
00024d 028d          .dw COLON_SMUDGE+2
00024e f08e          .dw XT_STORE		; save wid
00024f f040          .dw XT_DOLITERAL
000250 028b          .dw COLON_SMUDGE+0
000251 f08e          .dw XT_STORE		; save NFA
                 
000252 f020          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
000253 0001          .dw $0001
000254 005c          .db "\",0
000255 023f          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000256 f000          .dw DO_COLON
                 PFA_BACKSLASH:
000257 069d          .dw XT_SOURCE
000258 f0d1          .dw XT_SWAP
000259 f0e6          .dw XT_DROP
00025a 01ea          .dw XT_G_IN
00025b f08e          .dw XT_STORE
00025c f020          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
00025d 0001          .dw $0001
00025e 0028          .db "(" ,0
00025f 0253          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
000260 f000          .dw DO_COLON
                 PFA_LPARENTHESIS:
000261 f040          .dw XT_DOLITERAL
000262 0029          .dw $29
000263 0669          .dw XT_PARSE
000264 01e2          .dw XT_2DROP
000265 f020          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
000266 ff07          .dw $ff07
000267 6f63
000268 706d
000269 6c69
00026a 0065          .db "compile",0
00026b 025d          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
00026c f000          .dw DO_COLON
                 PFA_COMPILE:
00026d f0fc          .dw XT_R_FROM
00026e f0be          .dw XT_DUP
00026f f24a          .dw XT_1PLUS
000270 f105          .dw XT_TO_R
000271 f3e5          .dw XT_FETCHI
000272 0277          .dw XT_COMMA
000273 f020          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
000274 ff01          .dw $ff01
000275 002c          .db ',',0 ; ,
000276 0266          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000277 f000          .dw DO_COLON
                 PFA_COMMA:
000278 0220          .dw XT_DP
000279 f387          .dw XT_STOREI
00027a 0220          .dw XT_DP
00027b f24a          .dw XT_1PLUS
00027c 0853          .dw XT_DOTO
00027d 0221          .dw PFA_DP
00027e f020          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
00027f 0003          .dw $0003
000280 275b
000281 005d          .db "[']",0
000282 0274          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000283 f000          .dw DO_COLON
                 PFA_BRACKETTICK:
000284 026c          .dw XT_COMPILE
000285 f040          .dw XT_DOLITERAL
000286 04fb          .dw XT_TICK
000287 0277          .dw XT_COMMA
000288 f020          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
000289 ff03          .dw $ff03
00028a 6962
00028b 006e          .db "bin",0
00028c 027f          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00028d f000          .dw DO_COLON
                 PFA_BIN:
00028e f040          .dw XT_DOLITERAL
00028f 0002          .dw 2
000290 01c2          .dw XT_BASE
000291 f08e          .dw XT_STORE
000292 f020          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
000293 ff07          .dw $ff07
000294 6564
000295 6963
000296 616d
000297 006c          .db "decimal",0
000298 0289          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000299 f000          .dw DO_COLON
                 PFA_DECIMAL:
00029a f040          .dw XT_DOLITERAL
00029b 000a          .dw 10
00029c 01c2          .dw XT_BASE
00029d f08e          .dw XT_STORE
00029e f020          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
00029f ff03          .dw $ff03
0002a0 6568
0002a1 0078          .db "hex",0
0002a2 0293          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0002a3 f000          .dw DO_COLON
                 PFA_HEX:
0002a4 f040          .dw XT_DOLITERAL
0002a5 0010          .dw 16
0002a6 01c2          .dw XT_BASE
0002a7 f08e          .dw XT_STORE
0002a8 f020          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
0002a9 ff02          .dw $ff02
0002aa 6c62          .db "bl"
0002ab 029f          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0002ac f04e          .dw PFA_DOVARIABLE
                 PFA_BL:
0002ad 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0002ae ff07          .dw $ff07
0002af 7574
0002b0 6e72
0002b1 656b
0002b2 0079          .db "turnkey",0
0002b3 02a9          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0002b4 089b          .dw PFA_DODEFER
                 PFA_TURNKEY:
0002b5 0008          .dw EE_TURNKEY
0002b6 085f          .dw XT_EDEFERFETCH
0002b7 0864          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
0002b8 ff05          .dw $ff05
0002b9 2f2a
0002ba 6f6d
0002bb 0064          .db "*/mod",0
0002bc 02ae          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
0002bd f000          .dw DO_COLON
                 PFA_STARSLASHMOD:
0002be f105          .dw XT_TO_R
0002bf f1c1          .dw XT_MSTAR
0002c0 f0fc          .dw XT_R_FROM
0002c1 f1dd          .dw XT_UMSLASHMOD
0002c2 f020          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0002c3 ff04          .dw $ff04
0002c4 6d2f
0002c5 646f          .db "/mod"
0002c6 02b8          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0002c7 02c8          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0002c8 019c          movw temp2, tosl
                     
0002c9 9109          ld temp0, Y+
0002ca 9119          ld temp1, Y+
                 
0002cb 2f41          mov	temp6,temp1	;move dividend High to sign register
0002cc 2743          eor	temp6,temp3	;xor divisor High with sign register
0002cd ff17          sbrs	temp1,7	;if MSB in dividend set
0002ce c004          rjmp	PFA_SLASHMOD_1
0002cf 9510          com	temp1		;    change sign of dividend
0002d0 9500          com	temp0		
0002d1 5f0f          subi	temp0,low(-1)
0002d2 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
0002d3 ff37          sbrs	temp3,7	;if MSB in divisor set
0002d4 c004          rjmp	PFA_SLASHMOD_2
0002d5 9530          com	temp3		;    change sign of divisor
0002d6 9520          com	temp2		
0002d7 5f2f          subi	temp2,low(-1)
0002d8 4f3f          sbci	temp3,high(-1)
0002d9 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
0002da 18ff          sub	temp5,temp5;clear remainder High byte and carry
0002db e151          ldi	temp7,17	;init loop counter
                 
0002dc 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
0002dd 1f11          rol	temp1
0002de 955a          dec	temp7		;decrement counter
0002df f439          brne	PFA_SLASHMOD_5		;if done
0002e0 ff47          sbrs	temp6,7		;    if MSB in sign register set
0002e1 c004          rjmp	PFA_SLASHMOD_4
0002e2 9510          com	temp1	;        change sign of result
0002e3 9500          com	temp0
0002e4 5f0f          subi	temp0,low(-1)
0002e5 4f1f          sbci	temp1,high(-1)
0002e6 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
0002e7 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
0002e8 1cff          rol	temp5
0002e9 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
0002ea 0af3          sbc	temp5,temp3	;
0002eb f420          brcc	PFA_SLASHMOD_6		;if result negative
0002ec 0ee2          add	temp4,temp2	;    restore remainder
0002ed 1ef3          adc	temp5,temp3
0002ee 9488          clc			;    clear carry to be shifted into result
0002ef cfec          rjmp	PFA_SLASHMOD_3		;else
0002f0 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
0002f1 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
0002f2 92fa          st -Y,temp5
0002f3 92ea          st -Y,temp4
                 
                     ; put quotient on stack
0002f4 01c8          movw tosl, temp0
0002f5 940c f004     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
0002f7 ff02          .dw $ff02
0002f8 2f2a          .db "*/"
0002f9 02c3          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
0002fa f000          .dw DO_COLON
                 PFA_STARSLASH:
0002fb 02bd          .dw XT_STARSLASHMOD
0002fc f0d1          .dw XT_SWAP
0002fd f0e6          .dw XT_DROP
0002fe f020          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
0002ff ff05          .dw $ff05
000300 2f75
000301 6f6d
000302 0064          .db "u/mod",0
000303 02f7          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000304 f000          .dw DO_COLON
                 PFA_USLASHMOD:
000305 f105          .dw XT_TO_R
000306 f146          .dw XT_ZERO
000307 f0fc          .dw XT_R_FROM
000308 f1dd          .dw XT_UMSLASHMOD
000309 f020          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00030a ff06          .dw $ff06
00030b 656e
00030c 6167
00030d 6574          .db "negate"
00030e 02ff          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00030f f000          .dw DO_COLON
                 PFA_NEGATE:
000310 f218          .dw XT_INVERT
000311 f24a          .dw XT_1PLUS
000312 f020          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
000313 ff01          .dw $ff01
000314 002f          .db "/",0
000315 030a          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000316 f000          .dw DO_COLON
                 PFA_SLASH:
000317 02c7          .dw XT_SLASHMOD
000318 f0d1          .dw XT_SWAP
000319 f0e6          .dw XT_DROP
00031a f020          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
00031b ff03          .dw $ff03
00031c 6f6d
00031d 0064          .db "mod",0
00031e 0313          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00031f f000          .dw DO_COLON
                 PFA_MOD:
000320 02c7          .dw XT_SLASHMOD
000321 f0e6          .dw XT_DROP
000322 f020          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000323 ff03          .dw $ff03
000324 6261
000325 0073          .db "abs",0
000326 031b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000327 0328          .dw PFA_ABS
                 PFA_ABS:
000328 2399          tst tosh
000329 f41a          brpl PFA_ABS1
00032a 9580          com tosl
00032b 9590          com tosh
00032c 9601          adiw tosl, 1
                 PFA_ABS1:
00032d 940c f004     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
00032f ff03          .dw $ff03
000330 696d
000331 006e          .db "min",0
000332 0323          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000333 f000          .dw DO_COLON
                 PFA_MIN:
000334 01d9          .dw XT_2DUP
000335 f138          .dw XT_GREATER
000336 f039          .dw XT_DOCONDBRANCH
000337 0339          .dw PFA_MIN1
000338 f0d1          .dw XT_SWAP
                 PFA_MIN1:
000339 f0e6          .dw XT_DROP
00033a f020          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
00033b ff03          .dw $ff03
00033c 616d
00033d 0078          .db "max",0
00033e 032f          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00033f f000          .dw DO_COLON
                 PFA_MAX:
000340 01d9          .dw XT_2DUP
000341 f131          .dw XT_LESS
000342 f039          .dw XT_DOCONDBRANCH
000343 0345          .dw PFA_MAX1
000344 f0d1          .dw XT_SWAP
                 PFA_MAX1:
000345 f0e6          .dw XT_DROP
000346 f020          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
000347 ff06          .dw $ff06
000348 6977
000349 6874
00034a 6e69          .db "within"
00034b 033b          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00034c f000          .dw DO_COLON
                 PFA_WITHIN:
00034d f0dc          .dw XT_OVER
00034e f1ae          .dw XT_MINUS
00034f f105          .dw XT_TO_R
000350 f1ae          .dw XT_MINUS
000351 f0fc          .dw XT_R_FROM
000352 f158          .dw XT_ULESS
000353 f020          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
000354 ff07          .dw $ff07 
000355 6f74
000356 7075
000357 6570
000358 0072          .db "toupper",0
000359 0347          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00035a f000          .dw DO_COLON 
                 PFA_TOUPPER:
00035b f0be          .dw XT_DUP 
00035c f040          .dw XT_DOLITERAL 
00035d 0061          .dw 'a' 
00035e f040          .dw XT_DOLITERAL 
00035f 007b          .dw 'z'+1
000360 034c          .dw XT_WITHIN 
000361 f039          .dw XT_DOCONDBRANCH
000362 0366          .dw PFA_TOUPPER0 
000363 f040          .dw XT_DOLITERAL
000364 00df          .dw $df ; inverse of 0x20
000365 f22e          .dw XT_AND 
                 PFA_TOUPPER0:
000366 f020          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
000367 ff07          .dw $ff07
000368 6f74
000369 6f6c
00036a 6577
00036b 0072          .db "tolower",0
00036c 0354          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00036d f000          .dw DO_COLON
                 PFA_TOLOWER:
00036e f0be          .dw XT_DUP
00036f f040          .dw XT_DOLITERAL
000370 0041          .dw 'A'
000371 f040          .dw XT_DOLITERAL
000372 005b          .dw 'Z'+1
000373 034c          .dw XT_WITHIN
000374 f039          .dw XT_DOCONDBRANCH
000375 0379          .dw PFA_TOLOWER0 
000376 f040          .dw XT_DOLITERAL
000377 0020          .dw $20 
000378 f237          .dw XT_OR 
                 PFA_TOLOWER0:
000379 f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00037a ff03          .dw $ff03
00037b 6c68
00037c 0064          .db "hld",0
00037d 0367          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00037e f04e          .dw PFA_DOVARIABLE
                 PFA_HLD:
00037f 028f          .dw ram_hld
                 
                 .dseg
00028f           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
000380 ff04          .dw $ff04
000381 6f68
000382 646c          .db "hold"
000383 037a          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000384 f000          .dw DO_COLON
                 PFA_HOLD:
000385 037e          .dw XT_HLD
000386 f0be          .dw XT_DUP
000387 f086          .dw XT_FETCH
000388 f250          .dw XT_1MINUS
000389 f0be          .dw XT_DUP
00038a f105          .dw XT_TO_R
00038b f0d1          .dw XT_SWAP
00038c f08e          .dw XT_STORE
00038d f0fc          .dw XT_R_FROM
00038e f09a          .dw XT_CSTORE
00038f f020          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
000390 ff02          .dw $ff02
000391 233c          .db "<#"
000392 0380          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000393 f000          .dw DO_COLON
                 PFA_L_SHARP:
000394 01f6          .dw XT_PAD
000395 037e          .dw XT_HLD
000396 f08e          .dw XT_STORE
000397 f020          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
000398 ff01          .dw $ff01
000399 0023          .db "#",0
00039a 0390          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00039b f000          .dw DO_COLON
                 PFA_SHARP:
00039c 01c2          .dw XT_BASE
00039d f086          .dw XT_FETCH
00039e 041a          .dw XT_UDSLASHMOD
00039f f0ee          .dw XT_ROT
0003a0 f040          .dw XT_DOLITERAL
0003a1 0009          .dw 9
0003a2 f0dc          .dw XT_OVER
0003a3 f131          .dw XT_LESS
0003a4 f039          .dw XT_DOCONDBRANCH
0003a5 03a9          .dw PFA_SHARP1
0003a6 f040          .dw XT_DOLITERAL
0003a7 0007          .dw 7
0003a8 f1b8          .dw XT_PLUS
                 PFA_SHARP1:
0003a9 f040          .dw XT_DOLITERAL
0003aa 0030          .dw $30
0003ab f1b8          .dw XT_PLUS
0003ac 0384          .dw XT_HOLD
0003ad f020          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
0003ae ff02          .dw $ff02
0003af 7323          .db "#s"
0003b0 0398          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0003b1 f000          .dw DO_COLON
                 PFA_SHARP_S:
0003b2 039b          .dw XT_SHARP
0003b3 01d9          .dw XT_2DUP
0003b4 f237          .dw XT_OR
0003b5 f12a          .dw XT_EQUALZERO
0003b6 f039          .dw XT_DOCONDBRANCH
0003b7 03b2          .dw PFA_SHARP_S
0003b8 f020          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
0003b9 ff02          .dw $ff02
0003ba 3e23          .db "#>"
0003bb 03ae          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0003bc f000          .dw DO_COLON
                 PFA_SHARP_G:
0003bd 01e2          .dw XT_2DROP
0003be 037e          .dw XT_HLD
0003bf f086          .dw XT_FETCH
0003c0 f0be          .dw XT_DUP
0003c1 01f6          .dw XT_PAD
0003c2 f0d1          .dw XT_SWAP
0003c3 f1ae          .dw XT_MINUS
0003c4 f020          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
0003c5 ff04          .dw $ff04
0003c6 6973
0003c7 6e67          .db "sign"
0003c8 03b9          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0003c9 f000          .dw DO_COLON
                 PFA_SIGN:
0003ca f13f          .dw XT_LESSZERO
0003cb f039          .dw XT_DOCONDBRANCH
0003cc 03d0          .dw PFA_SIGN1
0003cd f040          .dw XT_DOLITERAL
0003ce 002d          .dw $2d
0003cf 0384          .dw XT_HOLD
                 PFA_SIGN1:
0003d0 f020          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
0003d1 ff03          .dw $ff03
0003d2 2e64
0003d3 0072          .db "d.r",0
0003d4 03c5          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
0003d5 f000          .dw DO_COLON
                 PFA_DDOTR:
0003d6 f105          .dw XT_TO_R
0003d7 f0d1          .dw XT_SWAP
0003d8 f0dc          .dw XT_OVER
0003d9 096c          .dw XT_DABS
0003da 0393          .dw XT_L_SHARP
0003db 03b1          .dw XT_SHARP_S
0003dc f0ee          .dw XT_ROT
0003dd 03c9          .dw XT_SIGN
0003de 03bc          .dw XT_SHARP_G
0003df f0fc          .dw XT_R_FROM
0003e0 f0dc          .dw XT_OVER
0003e1 f1ae          .dw XT_MINUS
0003e2 04dd          .dw XT_SPACES
0003e3 04ec          .dw XT_TYPE
0003e4 f020          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
0003e5 ff02          .dw $ff02
0003e6 722e          .db ".r"
0003e7 03d1          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
0003e8 f000          .dw DO_COLON
                 PFA_DOTR:
0003e9 f105          .dw XT_TO_R
0003ea f341          .dw XT_S2D
0003eb f0fc          .dw XT_R_FROM
0003ec 03d5          .dw XT_DDOTR
0003ed f020          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
0003ee ff02          .dw $ff02
0003ef 2e64          .db "d."
0003f0 03e5          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
0003f1 f000          .dw DO_COLON
                 PFA_DDOT:
0003f2 f146          .dw XT_ZERO
0003f3 03d5          .dw XT_DDOTR
0003f4 04d4          .dw XT_SPACE
0003f5 f020          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
0003f6 ff01          .dw $ff01
0003f7 002e          .db ".",0
0003f8 03ee          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
0003f9 f000          .dw DO_COLON
                 PFA_DOT:
0003fa f341          .dw XT_S2D
0003fb 03f1          .dw XT_DDOT
0003fc f020          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
0003fd ff03          .dw $ff03
0003fe 6475
0003ff 002e          .db "ud.",0
000400 03f6          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000401 f000          .dw DO_COLON
                 PFA_UDDOT:
000402 f146          .dw XT_ZERO
000403 040a          .dw XT_UDDOTR
000404 04d4          .dw XT_SPACE
000405 f020          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
000406 ff04          .dw $ff04
000407 6475
000408 722e          .db "ud.r"
000409 03fd          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00040a f000          .dw DO_COLON
                 PFA_UDDOTR:
00040b f105          .dw XT_TO_R
00040c 0393          .dw XT_L_SHARP
00040d 03b1          .dw XT_SHARP_S
00040e 03bc          .dw XT_SHARP_G
00040f f0fc          .dw XT_R_FROM
000410 f0dc          .dw XT_OVER
000411 f1ae          .dw XT_MINUS
000412 04dd          .dw XT_SPACES
000413 04ec          .dw XT_TYPE
000414 f020          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
000415 ff06          .dw $ff06
000416 6475
000417 6d2f
000418 646f          .db "ud/mod"
000419 0406          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00041a f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
00041b f105          .dw XT_TO_R
00041c f146          .dw XT_ZERO
00041d f10e          .dw XT_R_FETCH
00041e f1dd          .dw XT_UMSLASHMOD
00041f f0fc          .dw XT_R_FROM
000420 f0d1          .dw XT_SWAP
000421 f105          .dw XT_TO_R
000422 f1dd          .dw XT_UMSLASHMOD
000423 f0fc          .dw XT_R_FROM
000424 f020          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
000425 ff06          .dw $ff06 
000426 6964
000427 6967
000428 3f74          .db "digit?"
000429 0415          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00042a f000          .dw DO_COLON 
                 PFA_DIGITQ:
00042b 035a          .dw XT_TOUPPER
00042c f040          .dw XT_DOLITERAL 
00042d 0030          .dw $30 
00042e f1ae          .dw XT_MINUS 
00042f f0be          .dw XT_DUP 
000430 f040          .dw XT_DOLITERAL
000431 0009          .dw $09 
000432 f163          .dw XT_UGREATER 
000433 f039          .dw XT_DOCONDBRANCH
000434 0441          .dw PFA_DIGITQ0 
000435 f040          .dw XT_DOLITERAL
000436 0007          .dw $07 
000437 f1ae          .dw XT_MINUS 
000438 f0be          .dw XT_DUP 
000439 f040          .dw XT_DOLITERAL
00043a 0009          .dw $09 
00043b 0450          .dw XT_ULESSEQUAL
00043c f039          .dw XT_DOCONDBRANCH
00043d 0441          .dw PFA_DIGITQ1 
00043e f0e6          .dw XT_DROP 
00043f f146          .dw XT_ZERO
000440 f020          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
000441 f0be          .dw XT_DUP 
000442 01c2          .dw XT_BASE 
000443 f086          .dw XT_FETCH 
000444 0458          .dw XT_UGREATEREQUAL
000445 f039          .dw XT_DOCONDBRANCH
000446 044a          .dw PFA_DIGITQ2 
000447 f0e6          .dw XT_DROP 
000448 f146          .dw XT_ZERO
000449 f020          .dw XT_EXIT 
                 PFA_DIGITQ2:
00044a f14f          .dw XT_TRUE
00044b f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
00044c ff03          .dw $ff03 
00044d 3c75
00044e 003d          .db "u<=",0
00044f 0425          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
000450 f000          .dw DO_COLON 
                 PFA_ULESSEQUAL:
000451 f163          .dw XT_UGREATER 
000452 f218          .dw XT_INVERT 
000453 f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
000454 ff03          .dw $ff03 
000455 3e75
000456 003d          .db "u>=",0
000457 044c          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
000458 f000          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
000459 f158          .dw XT_ULESS 
00045a f218          .dw XT_INVERT 
00045b f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00045c f000        .dw DO_COLON
                 PFA_DOSLITERAL:
00045d f0fc        .dw XT_R_FROM   ; ( -- addr )
00045e f0be        .dw XT_DUP      ; ( -- addr addr )
00045f f0be        .dw XT_DUP
000460 f3e5        .dw XT_FETCHI   ; ( -- addr addr n )
000461 f0d1        .dw XT_SWAP
000462 f24a        .dw XT_1PLUS
000463 f0d1        .dw XT_SWAP
000464 f0ee        .dw XT_ROT      ; ( -- addr' n addr )
000465 f0dc        .dw XT_OVER     ; ( -- addr' n addr n)
000466 f24a        .dw XT_1PLUS
000467 f21f        .dw XT_2SLASH   ; ( -- addr' n addr k )
000468 f1b8        .dw XT_PLUS     ; ( -- addr' n addr'' )
000469 f24a        .dw XT_1PLUS
00046a f105        .dw XT_TO_R     ; ( -- )
00046b f020        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00046c ff02        .dw $ff02
00046d 2c73        .db "s",$2c
00046e 0454        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00046f f000          .dw DO_COLON
                 PFA_SCOMMA:
000470 f0be          .dw XT_DUP
000471 0473          .dw XT_DOSCOMMA
000472 f020          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
000473 f000          .dw DO_COLON
                 PFA_DOSCOMMA:
000474 0277          .dw XT_COMMA
000475 f0be          .dw XT_DUP   ; ( --addr len len)
000476 f21f          .dw XT_2SLASH ; ( -- addr len len/2
000477 f0d1          .dw XT_SWAP   ; ( -- addr len/2 len
000478 f0dc          .dw XT_OVER   ; ( -- addr len/2 len len/2
000479 f226          .dw XT_2STAR  ; ( -- addr len/2 len len'
00047a f1ae          .dw XT_MINUS  ; ( -- addr len/2 rem
00047b f105          .dw XT_TO_R
00047c f146          .dw XT_ZERO
00047d f2bf          .dw XT_DOQDO
00047e 0485          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
00047f f0be          .dw XT_DUP         ; ( -- addr addr )
000480 f086          .dw XT_FETCH       ; ( -- addr c1c2 )
000481 0277          .dw XT_COMMA       ; ( -- addr )
000482 01d1          .dw XT_CELLPLUS    ; ( -- addr+cell )
000483 f2f0          .dw XT_DOLOOP
000484 047f          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000485 f0fc          .dw XT_R_FROM
000486 f16e          .dw XT_GREATERZERO
000487 f039          .dw XT_DOCONDBRANCH
000488 048c          .dw PFA_SCOMMA3
000489 f0be            .dw XT_DUP     ; well, tricky
00048a f0a5            .dw XT_CFETCH
00048b 0277            .dw XT_COMMA
                 PFA_SCOMMA3:
00048c f0e6          .dw XT_DROP        ; ( -- )
00048d f020          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00048e ff05          .dw $ff05
00048f 7469
000490 7079
000491 0065          .db "itype",0
000492 046c          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000493 f000          .dw DO_COLON
                 PFA_ITYPE:
000494 f0be          .dw XT_DUP    ; ( --addr len len)
000495 f21f          .dw XT_2SLASH ; ( -- addr len len/2
000496 f0d1          .dw XT_SWAP   ; ( -- addr len/2 len
000497 f0dc          .dw XT_OVER   ; ( -- addr len/2 len len/2
000498 f226          .dw XT_2STAR  ; ( -- addr len/2 len len'
000499 f1ae          .dw XT_MINUS  ; ( -- addr len/2 rem
00049a f105          .dw XT_TO_R
00049b f146          .dw XT_ZERO
00049c f2bf          .dw XT_DOQDO
00049d 04a6          .dw PFA_ITYPE2
                 PFA_ITYPE1:
00049e f0be          .dw XT_DUP         ; ( -- addr addr )
00049f f3e5          .dw XT_FETCHI      ; ( -- addr c1c2 )
0004a0 f0be          .dw XT_DUP
0004a1 04b3          .dw XT_LOWEMIT
0004a2 04af          .dw XT_HIEMIT
0004a3 f24a          .dw XT_1PLUS    ; ( -- addr+cell )
0004a4 f2f0          .dw XT_DOLOOP
0004a5 049e          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0004a6 f0fc          .dw XT_R_FROM
0004a7 f16e          .dw XT_GREATERZERO
0004a8 f039          .dw XT_DOCONDBRANCH
0004a9 04ad          .dw PFA_ITYPE3
0004aa f0be            .dw XT_DUP     ; make sure the drop below has always something to do
0004ab f3e5            .dw XT_FETCHI
0004ac 04b3            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0004ad f0e6          .dw XT_DROP
0004ae f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0004af f000          .dw DO_COLON
                 PFA_HIEMIT:
0004b0 f326          .dw XT_BYTESWAP
0004b1 04b3          .dw XT_LOWEMIT
0004b2 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0004b3 f000          .dw DO_COLON
                 PFA_LOWEMIT:
0004b4 f040          .dw XT_DOLITERAL
0004b5 00ff          .dw $00ff
0004b6 f22e          .dw XT_AND
0004b7 0200          .dw XT_EMIT
0004b8 f020          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0004b9 ff06          .dw $ff06
0004ba 6369
0004bb 756f
0004bc 746e          .db "icount"
0004bd 048e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0004be f000          .dw DO_COLON
                 PFA_ICOUNT:
0004bf f0be          .dw XT_DUP
0004c0 f24a          .dw XT_1PLUS
0004c1 f0d1          .dw XT_SWAP
0004c2 f3e5          .dw XT_FETCHI
0004c3 f020          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
0004c4 ff02          .dw $ff02
0004c5 7263          .db "cr"
0004c6 04b9          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0004c7 f000          .dw DO_COLON
                 PFA_CR:
0004c8 f040          .dw XT_DOLITERAL
0004c9 000d          .dw 13
0004ca 0200          .dw XT_EMIT
0004cb f040          .dw XT_DOLITERAL
0004cc 000a          .dw 10
0004cd 0200          .dw XT_EMIT
0004ce f020          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
0004cf ff05          .dw $ff05
0004d0 7073
0004d1 6361
0004d2 0065          .db "space",0
0004d3 04c4          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
0004d4 f000          .dw DO_COLON
                 PFA_SPACE:
0004d5 02ac          .dw XT_BL
0004d6 0200          .dw XT_EMIT
0004d7 f020          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
0004d8 ff06          .dw $ff06
0004d9 7073
0004da 6361
0004db 7365          .db "spaces"
0004dc 04cf          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
0004dd f000          .dw DO_COLON
                 PFA_SPACES:
0004de f0be          .dw XT_DUP
0004df f16e          .dw XT_GREATERZERO
0004e0 f22e          .dw XT_AND
0004e1 f146          .dw XT_ZERO
0004e2 f2bf          .dw XT_DOQDO
0004e3 04e7          .dw PFA_SPACES2
                 PFA_SPACES1:
0004e4 04d4          .dw XT_SPACE
0004e5 f2f0          .dw XT_DOLOOP
0004e6 04e4          .dw PFA_SPACES1
                 PFA_SPACES2:
0004e7 f020          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
0004e8 ff04          .dw $ff04
0004e9 7974
0004ea 6570          .db "type"
0004eb 04d8          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
0004ec f000          .dw DO_COLON
                 PFA_TYPE:
0004ed f0dc          .dw XT_OVER
0004ee f1b8          .dw XT_PLUS
0004ef f0d1          .dW XT_SWAP
0004f0 f2bf          .dw XT_DOQDO
0004f1 04f7          .dw PFA_TYPE2
                 PFA_TYPE1:
0004f2 f2d5          .dw XT_I
0004f3 f0a5          .dw XT_CFETCH
0004f4 0200          .dw XT_EMIT
0004f5 f2f0          .dw XT_DOLOOP
0004f6 04f2          .dw PFA_TYPE1
                 PFA_TYPE2:
0004f7 f020          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
0004f8 ff01          .dw $ff01
0004f9 0027          .db "'",0
0004fa 04e8          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
0004fb f000          .dw DO_COLON
                 PFA_TICK:
0004fc 06b8          .dw XT_PARSENAME
0004fd 06d5          .dw XT_FINDNAME
0004fe f12a          .dw XT_EQUALZERO
0004ff f039          .dw XT_DOCONDBRANCH
000500 0504          .dw PFA_TICK1
000501 f040          .dw XT_DOLITERAL
000502 fff3          .dw -13
000503 0528          .dw XT_THROW
                 PFA_TICK1:
000504 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
000505 ff07          .dw $ff07
000506 6168
000507 646e
000508 656c
000509 0072          .db "handler",0
00050a 04f8          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00050b f061          .dw PFA_DOUSER
                 PFA_HANDLER:
00050c 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
00050d ff05          .dw $ff05
00050e 6163
00050f 6374
000510 0068          .db "catch",0
000511 0505          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000512 f000          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
000513 f29c          .dw XT_SP_FETCH
000514 f105          .dw XT_TO_R
                     ; handler @ >r
000515 050b          .dw XT_HANDLER
000516 f086          .dw XT_FETCH
000517 f105          .dw XT_TO_R
                     ; rp@ handler !
000518 f285          .dw XT_RP_FETCH
000519 050b          .dw XT_HANDLER
00051a f08e          .dw XT_STORE
00051b f02a          .dw XT_EXECUTE
                     ; r> handler !
00051c f0fc          .dw XT_R_FROM
00051d 050b          .dw XT_HANDLER
00051e f08e          .dw XT_STORE
00051f f0fc          .dw XT_R_FROM
000520 f0e6          .dw XT_DROP
000521 f146          .dw XT_ZERO
000522 f020          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
000523 ff05          .dw $ff05
000524 6874
000525 6f72
000526 0077          .db "throw",0
000527 050d          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000528 f000          .dw DO_COLON
                 PFA_THROW:
000529 f0be          .dw XT_DUP
00052a f12a          .dw XT_EQUALZERO
00052b f039          .dw XT_DOCONDBRANCH
00052c 052f          .dw PFA_THROW1
00052d f0e6      	.dw XT_DROP
00052e f020      	.dw XT_EXIT
                 PFA_THROW1:
00052f 050b          .dw XT_HANDLER
000530 f086          .dw XT_FETCH
000531 f28f          .dw XT_RP_STORE
000532 f0fc          .dw XT_R_FROM
000533 050b          .dw XT_HANDLER
000534 f08e          .dw XT_STORE
000535 f0fc          .dw XT_R_FROM
000536 f0d1          .dw XT_SWAP
000537 f105          .dw XT_TO_R
000538 f2a5          .dw XT_SP_STORE
000539 f0e6          .dw XT_DROP
00053a f0fc          .dw XT_R_FROM    
00053b f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
00053c ff05          .dw $ff05
00053d 7363
00053e 696b
00053f 0070          .db "cskip",0
000540 0523          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000541 f000          .dw DO_COLON
                 PFA_CSKIP:
000542 f105          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000543 f0be          .dw XT_DUP            ; ( -- addr' n' n' )
000544 f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000545 0551          .dw PFA_CSKIP2
000546 f0dc          .dw XT_OVER           ; ( -- addr' n' addr' )
000547 f0a5          .dw XT_CFETCH         ; ( -- addr' n' c' )
000548 f10e          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000549 f123          .dw XT_EQUAL          ; ( -- addr' n' f )
00054a f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00054b 0551          .dw PFA_CSKIP2
00054c f040          .dw XT_DOLITERAL
00054d 0001          .dw 1
00054e 06a7          .dw XT_SLASHSTRING
00054f f02f          .dw XT_DOBRANCH
000550 0543          .dw PFA_CSKIP1
                 PFA_CSKIP2:
000551 f0fc          .dw XT_R_FROM
000552 f0e6          .dw XT_DROP           ; ( -- addr2 n2)
000553 f020          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
000554 ff06          .dw $ff06
000555 6361
000556 6563
000557 7470          .db "accept"
000558 053c          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000559 f000          .dw DO_COLON
                 PFA_ACCEPT:
00055a f0be          .dw XT_DUP        ; ( -- addr n1 n1)
00055b f105          .dw XT_TO_R
00055c f105          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
00055d 0211          .dw XT_KEY        ; ( -- addr k )
00055e f0be          .dw XT_DUP        ; ( -- addr k k )
00055f f040          .dw XT_DOLITERAL
000560 000a          .dw 10
000561 f119          .dw XT_NOTEQUAL
000562 f039          .dw XT_DOCONDBRANCH
000563 0597          .dw PFA_ACCEPT2
000564 f0be          .dw XT_DUP
000565 f040          .dw XT_DOLITERAL
000566 000d          .dw 13
000567 f119          .dw XT_NOTEQUAL
000568 f039          .dw XT_DOCONDBRANCH
000569 0597          .dw PFA_ACCEPT2
                     ; check backspace
00056a f0be          .dw XT_DUP
00056b f040          .dw XT_DOLITERAL
00056c 0008          .dw 8
00056d f123          .dw XT_EQUAL
00056e f039          .dw XT_DOCONDBRANCH
00056f 0583          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
000570 f0fc          .dw XT_R_FROM             ; ( -- addr k n1 )
000571 f10e          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
000572 f0dc          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
000573 f105          .dw XT_TO_R
000574 f123          .dw XT_EQUAL              ; ( -- addr k f )
000575 f039          .dw XT_DOCONDBRANCH
000576 057a          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
000577 f0e6          .dw XT_DROP               ; ( -- addr )
000578 f02f          .dw XT_DOBRANCH
000579 055d          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
00057a f0be          .dw XT_DUP                ; ( -- addr k k )
00057b 0200          .dw XT_EMIT               ; ( -- addr k )
00057c 04d4          .dw XT_SPACE              ; ( -- addr k )
00057d 0200          .dw XT_EMIT               ; ( -- addr )
00057e f250          .dw XT_1MINUS             ; ( -- addr--)
00057f f0fc          .dw XT_R_FROM
000580 f24a          .dw XT_1PLUS
000581 f02f          .dw XT_DOBRANCH
000582 0591          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
000583 f0be          .dw XT_DUP            ; ( -- addr k k )
000584 02ac          .dw XT_BL
000585 f131          .dw XT_LESS
000586 f039          .dw XT_DOCONDBRANCH
000587 058a          .dw PFA_ACCEPT6
000588 f0e6          .dw XT_DROP
000589 02ac          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
00058a f0be          .dw XT_DUP            ; ( -- addr k k)
00058b 0200          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
00058c f0dc          .dw XT_OVER           ; ( -- addr k addr
00058d f09a          .dw XT_CSTORE         ; ( -- addr)
00058e f24a          .dw XT_1PLUS          ; ( -- addr++)
00058f f0fc          .dw XT_R_FROM         ; ( -- addr n1)
000590 f250          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
000591 f0be          .dw XT_DUP
000592 f105          .dw XT_TO_R
000593 f12a          .dw XT_EQUALZERO
000594 f039          .dw XT_DOCONDBRANCH
000595 055d          .dw PFA_ACCEPT1
000596 f0be          .dw XT_DUP
                 PFA_ACCEPT2:
000597 01e2          .dw XT_2DROP
000598 f0fc          .dw XT_R_FROM
000599 f0fc          .dw XT_R_FROM
00059a f0d1          .dw XT_SWAP
00059b f1ae          .dw XT_MINUS
00059c 04c7          .dw XT_CR
00059d f020          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
00059e ff06          .dw $ff06
00059f 6572
0005a0 6966
0005a1 6c6c          .db "refill"
0005a2 0554          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0005a3 089b          .dw PFA_DODEFER
                 PFA_REFILL:
0005a4 001a          .dw USER_REFILL
0005a5 0873          .dw XT_UDEFERFETCH
0005a6 087a          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
0005a7 ff04          .dw $ff04
0005a8 6863
0005a9 7261          .db "char"
0005aa 059e          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0005ab f000          .dw DO_COLON
                 PFA_CHAR:
0005ac 06b8          .dw XT_PARSENAME
0005ad f0e6          .dw XT_DROP
0005ae f0a5          .dw XT_CFETCH
0005af f020          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
0005b0 ff06          .dw $ff06
0005b1 756e
0005b2 626d
0005b3 7265          .db "number"
0005b4 05a7          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0005b5 f000          .dw DO_COLON
                 PFA_NUMBER:
0005b6 01c2          .dw XT_BASE
0005b7 f086          .dw XT_FETCH
0005b8 f105          .dw XT_TO_R
0005b9 0626          .dw XT_NUMBERSIGN
0005ba f105          .dw XT_TO_R
0005bb 05f2          .dw XT_PRAEFIX
0005bc 0626          .dw XT_NUMBERSIGN
0005bd f0fc          .dw XT_R_FROM
0005be f237          .dw XT_OR
0005bf f105          .dw XT_TO_R
0005c0 f105          .dw XT_TO_R
0005c1 f105          .dw XT_TO_R
0005c2 f146          .dw XT_ZERO       ; starting value
0005c3 f146          .dw XT_ZERO
0005c4 f0fc          .dw XT_R_FROM
0005c5 f0fc          .dw XT_R_FROM
0005c6 0645          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0005c7 f0c6          .dw XT_QDUP
0005c8 f039              .dw XT_DOCONDBRANCH
0005c9 05e6      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
0005ca f040          .dw XT_DOLITERAL
0005cb 0001          .dw 1
0005cc f123          .dw XT_EQUAL
0005cd f039          .dw XT_DOCONDBRANCH
0005ce 05dd          .dw PFA_NUMBER2
                 	; excatly one character is left
0005cf f0a5      	.dw XT_CFETCH
0005d0 f040      	.dw XT_DOLITERAL
0005d1 002e      	.dw $2e ; .
0005d2 f123      	.dw XT_EQUAL
0005d3 f039      	.dw XT_DOCONDBRANCH
0005d4 05dd      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
0005d5 f0fc      	.dw XT_R_FROM
0005d6 f039              .dw XT_DOCONDBRANCH
0005d7 05d9      	.dw PFA_NUMBER3
0005d8 0979              .dw XT_DNEGATE
                 PFA_NUMBER3:
0005d9 f040      	.dw XT_DOLITERAL
0005da 0002      	.dw 2
0005db f02f      	.dw XT_DOBRANCH
0005dc 05ed      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
0005dd 01e2      	.dw XT_2DROP
0005de f0e6      	.dw XT_DROP
0005df f0fc      	.dw XT_R_FROM
0005e0 f0e6      	.dw XT_DROP
0005e1 f0fc              .dw XT_R_FROM
0005e2 01c2              .dw XT_BASE
0005e3 f08e              .dw XT_STORE
0005e4 f146      	.dw XT_ZERO
0005e5 f020      	.dw XT_EXIT
                 PFA_NUMBER1:
0005e6 01e2          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
0005e7 f0fc          .dw XT_R_FROM
0005e8 f039          .dw XT_DOCONDBRANCH
0005e9 05eb          .dw PFA_NUMBER4
0005ea 030f          .dw XT_NEGATE
                 PFA_NUMBER4:
0005eb f040          .dw XT_DOLITERAL
0005ec 0001          .dw 1
                 PFA_NUMBER5:
0005ed f0fc          .dw XT_R_FROM
0005ee 01c2          .dw XT_BASE
0005ef f08e          .dw XT_STORE
0005f0 f14f          .dw XT_TRUE
0005f1 f020          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
0005f2 f000          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
0005f3 f0dc          .dw XT_OVER 
0005f4 f0a5          .dw XT_CFETCH 
0005f5 f040          .dw XT_DOLITERAL
0005f6 0029          .dw $29 
0005f7 f138          .dw XT_GREATER 
0005f8 f039          .dw XT_DOCONDBRANCH
0005f9 05fb          .dw PFA_PRAEFIX0 
0005fa f020          .dw XT_EXIT 
                 PFA_PRAEFIX0:
0005fb f0dc          .dw XT_OVER 
0005fc f0a5          .dw XT_CFETCH 
0005fd 0602          .dw XT_SETBASE
0005fe f040          .dw XT_DOLITERAL
0005ff 0001          .dw $1 
000600 06a7          .dw XT_SLASHSTRING 
000601 f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000602 f000          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000603 f0be          .dw XT_DUP 
000604 f040          .dw XT_DOLITERAL
000605 0024          .dw '$' 
000606 f123          .dw XT_EQUAL 
000607 f039          .dw XT_DOCONDBRANCH
000608 060c          .dw PFA_SETBASE0 
000609 f0e6          .dw XT_DROP 
00060a 02a3          .dw XT_HEX 
00060b f020          .dw XT_EXIT 
                 PFA_SETBASE0:
00060c f0be          .dw XT_DUP 
00060d f040          .dw XT_DOLITERAL
00060e 0025          .dw '%' 
00060f f123          .dw XT_EQUAL 
000610 f039          .dw XT_DOCONDBRANCH
000611 0615          .dw PFA_SETBASE1 
000612 f0e6          .dw XT_DROP 
000613 028d          .dw XT_BIN
000614 f020          .dw XT_EXIT 
                 PFA_SETBASE1:
000615 f0be          .dw XT_DUP 
000616 f040          .dw XT_DOLITERAL
000617 0026          .dw '&'
000618 f123          .dw XT_EQUAL 
000619 f039          .dw XT_DOCONDBRANCH
00061a 061e          .dw PFA_SETBASE2 
00061b f0e6          .dw XT_DROP
00061c 0299          .dw XT_DECIMAL 
00061d f020          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
00061e f040          .dw XT_DOLITERAL
00061f 0023          .dw '#'
000620 f123          .dw XT_EQUAL 
000621 f039          .dw XT_DOCONDBRANCH
000622 0625          .dw PFA_SETBASE3 
000623 0299          .dw XT_DECIMAL 
000624 f020          .dw XT_EXIT 
                 PFA_SETBASE3:
000625 f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
000626 f000          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
000627 f0dc          .dw XT_OVER
000628 f0a5          .dw XT_CFETCH
000629 f040          .dw XT_DOLITERAL
00062a 002b          .dw '+'
00062b f123          .dw XT_EQUAL
00062c f039          .dw XT_DOCONDBRANCH
00062d 0631          .dw PFA_NUMBERSIGN_MINUS
00062e f040            .dw XT_DOLITERAL
00062f 0001            .dw 1
000630 06a7            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
000631 f0dc          .dw XT_OVER    ; ( -- addr len addr )
000632 f0a5          .dw XT_CFETCH
000633 f040          .dw XT_DOLITERAL
000634 002d          .dw '-'
000635 f123          .dw XT_EQUAL  ; ( -- addr len flag )
000636 f0be          .dw XT_DUP
000637 f105          .dw XT_TO_R
000638 f039          .dw XT_DOCONDBRANCH
000639 063d          .dw PFA_NUMBERSIGN_PLUS
00063a f040          .dw XT_DOLITERAL      ; skip sign character
00063b 0001          .dw 1
00063c 06a7          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
00063d f0fc          .dw XT_R_FROM
00063e f020          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
00063f ff07          .dw $ff07
000640 6e3e
000641 6d75
000642 6562
000643 0072          .db ">number",0
000644 05b0          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000645 f000          .dw DO_COLON
                 PFA_TO_NUMBER:
000646 f0be          .dw XT_DUP
000647 f039          .dw XT_DOCONDBRANCH
000648 0663          .dw PFA_TO_NUMBER1
000649 f0dc              .dw XT_OVER
00064a f0a5              .dw XT_CFETCH
00064b 042a              .dw XT_DIGITQ
00064c f12a              .dw XT_EQUALZERO
00064d f039              .dw XT_DOCONDBRANCH
00064e 0650              .dw PFA_TO_NUMBER2
00064f f020                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
000650 f105              .dw XT_TO_R
000651 099e              .dw XT_2SWAP
000652 f0fc              .dw XT_R_FROM
000653 f0d1              .dw XT_SWAP
000654 01c2              .dw XT_BASE
000655 f086              .dw XT_FETCH
000656 f1fb              .dw XT_UMSTAR
000657 f0e6              .dw XT_DROP
000658 f0ee              .dw XT_ROT
000659 01c2              .dw XT_BASE
00065a f086              .dw XT_FETCH
00065b f1fb              .dw XT_UMSTAR
00065c f6dc              .dw XT_DPLUS
00065d 099e              .dw XT_2SWAP
00065e f040              .dw XT_DOLITERAL
00065f 0001              .dw 1
000660 06a7              .dw XT_SLASHSTRING
000661 f02f          .dw XT_DOBRANCH
000662 0646          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
000663 f020          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
000664 ff05          .dw $ff05
000665 6170
000666 7372
000667 0065          .db "parse",0
000668 063f          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000669 f000          .dw DO_COLON
                 PFA_PARSE:
00066a f105          .dw XT_TO_R     ; ( -- )
00066b 069d          .dw XT_SOURCE   ; ( -- addr len)
00066c 01ea          .dw XT_G_IN     ; ( -- addr len >in)
00066d f086          .dw XT_FETCH
00066e 06a7          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00066f f0fc          .dw XT_R_FROM      ; ( -- addr' len' c)
000670 067e          .dw XT_CSCAN       ; ( -- addr' len'')
000671 f0be          .dw XT_DUP         ; ( -- addr' len'' len'')
000672 f24a          .dw XT_1PLUS
000673 01ea          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
000674 f274          .dw XT_PLUSSTORE   ; ( -- addr' len')
000675 f040          .dw XT_DOLITERAL
000676 0001          .dw 1
000677 06a7          .dw XT_SLASHSTRING
000678 f020          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
000679 ff05          .dw $ff05
00067a 7363
00067b 6163
00067c 006e          .db "cscan",0
00067d 0664          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00067e f000          .dw DO_COLON
                 PFA_CSCAN:
00067f f0d1          .dw XT_SWAP         ; ( -- addr1 c n1 )
000680 f0be          .dw XT_DUP          ; ( -- addr1 c n1 n1)
000681 f105          .dw XT_TO_R         ; ( -- addr1 c n1)
000682 f146          .dw XT_ZERO         ; ( -- addr1 c n1 0)
000683 f2bf          .dw XT_DOQDO        ; ( -- addr1 c)
000684 0695          .dw PFA_CSCAN3
                 PFA_CSCAN1:
000685 f0dc          .dw XT_OVER         ; ( -- addr1 c addr1 )
000686 f2d5          .dw XT_I            ; ( -- addr1 c addr1 i)
000687 f1b8          .dw XT_PLUS         ; ( -- addr1 c addr')
000688 f0a5          .dw XT_CFETCH       ; ( -- addr1 c c')
000689 f0dc          .dw XT_OVER         ; ( -- addr1 c c' c)
00068a f123          .dw XT_EQUAL        ; ( -- addr1 c f)
00068b f039          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
00068c 0693          .dw PFA_CSCAN2
00068d f0e6          .dw XT_DROP         ; ( -- addr1 )
00068e f2d5          .dw XT_I            ; ( -- addr1 n2)
00068f f2ff          .dw XT_UNLOOP       ; ( -- addr1 n2)
000690 f0fc          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
000691 f0e6          .dw XT_DROP         ; ( -- addr1 n2)
000692 f020          .dw XT_EXIT
                 PFA_CSCAN2:
000693 f2f0          .dw XT_DOLOOP
000694 0685          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
000695 f0e6          .dw XT_DROP         ; ( -- addr1)
000696 f0fc          .dw XT_R_FROM       ; ( -- addr1 n1)
000697 f020          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
000698 ff06          .dw $FF06
000699 6f73
00069a 7275
00069b 6563          .db "source"
00069c 0679          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00069d 089b          .dw PFA_DODEFER
                 PFA_SOURCE:
00069e 0016          .dw USER_SOURCE
00069f 0873          .dw XT_UDEFERFETCH
0006a0 087a          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0006a1 ff07          .dw $ff07
0006a2 732f
0006a3 7274
0006a4 6e69
0006a5 0067          .db "/string",0
0006a6 0698          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0006a7 f000          .dw DO_COLON
                 PFA_SLASHSTRING:
0006a8 f0dc          .dw XT_OVER    ; ( -- addr1 u1 n u1)
0006a9 0333          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
0006aa f0ee          .dw XT_ROT     ; ( -- u1 n addr1 )
0006ab f0dc          .dw XT_OVER    ; ( -- u1 n addr1 n)
0006ac f1b8          .dw XT_PLUS    ; ( -- u1 n addr2 )
0006ad f0ee          .dw XT_ROT     ; ( -- n addr2 u1)
0006ae f0ee          .dw XT_ROT     ; ( -- addr2 u1 n)
0006af f1ae          .dw XT_MINUS   ; ( -- addr2 u2)
0006b0 f020          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
0006b1 ff0a          .dw $FF0A 
0006b2 6170
0006b3 7372
0006b4 2d65
0006b5 616e
0006b6 656d          .db "parse-name"
0006b7 06a1          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0006b8 f000          .dw DO_COLON 
                 PFA_PARSENAME:
0006b9 02ac          .dw XT_BL
0006ba 06bc          .dw XT_SKIPSCANCHAR
0006bb f020          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0006bc f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
0006bd f105          .dw XT_TO_R
0006be 069d          .dw XT_SOURCE 
0006bf 01ea          .dw XT_G_IN 
0006c0 f086          .dw XT_FETCH 
0006c1 06a7          .dw XT_SLASHSTRING 
                 
0006c2 f10e          .dw XT_R_FETCH
0006c3 0541          .dw XT_CSKIP
0006c4 f0fc          .dw XT_R_FROM
0006c5 067e          .dw XT_CSCAN
                 
                     ; adjust >IN
0006c6 01d9          .dw XT_2DUP
0006c7 f1b8          .dw XT_PLUS
0006c8 069d          .dw XT_SOURCE 
0006c9 f0e6          .dw XT_DROP
0006ca f1ae          .dw XT_MINUS
0006cb 01ea          .dw XT_G_IN
0006cc f08e          .dw XT_STORE
0006cd f020          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
0006ce ff09          .dw $ff09
0006cf 6966
0006d0 646e
0006d1 6e2d
0006d2 6d61
0006d3 0065          .db "find-name",0
0006d4 06b1          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0006d5 f000          .dw DO_COLON
                 PFA_FINDNAME:
0006d6 f040          .dw XT_DOLITERAL
0006d7 0014          .dw EE_ORDERLISTLEN
0006d8 f373          .dw XT_FETCHE
0006d9 f146          .dw XT_ZERO
0006da f2bf          .dw XT_DOQDO
0006db 06f0          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
0006dc 01d9          .dw XT_2DUP
0006dd f040          .dw XT_DOLITERAL
0006de 0016          .dw EE_ORDERLIST
0006df f2d5          .dw XT_I
0006e0 01c9          .dw XT_CELLS
0006e1 f1b8          .dw XT_PLUS  
0006e2 f373          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
0006e3 08af          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
0006e4 f0c6          .dw XT_QDUP
0006e5 f039          .dw XT_DOCONDBRANCH
0006e6 06ee          .dw PFA_FINDNAME4
0006e7 f105      	.dw XT_TO_R
0006e8 f105      	.dw XT_TO_R
0006e9 01e2      	.dw XT_2DROP
0006ea f0fc      	.dw XT_R_FROM
0006eb f0fc      	.dw XT_R_FROM
0006ec f2ff      	.dw XT_UNLOOP
0006ed f020      	.dw XT_EXIT
                 PFA_FINDNAME4:
0006ee f2f0          .dw XT_DOLOOP
0006ef 06dc          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
0006f0 01e2          .dw XT_2DROP
0006f1 f146          .dw XT_ZERO
0006f2 f020          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
0006f3 ff04          .dw $ff04
0006f4 7571
0006f5 7469          .db "quit"
0006f6 06ce          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
0006f7 f000          .dw DO_COLON
                 PFA_QUIT:
0006f8 076f          .dw XT_SP0
0006f9 f2a5          .dw XT_SP_STORE
0006fa 0784          .dw XT_RP0
0006fb f28f          .dw XT_RP_STORE
0006fc f53c          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
0006fd 01bc          .dw XT_STATE
0006fe f086          .dw XT_FETCH
0006ff f12a          .dw XT_EQUALZERO
000700 f039          .dw XT_DOCONDBRANCH
000701 0703          .dw PFA_QUIT4
000702 0719          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000703 05a3          .dw XT_REFILL
000704 f039          .dw XT_DOCONDBRANCH
000705 06fd          .dw PFA_QUIT2
000706 f040          .dw XT_DOLITERAL
000707 079d          .dw XT_INTERPRET
000708 0512          .dw XT_CATCH
000709 f0c6          .dw XT_QDUP
00070a f039          .dw XT_DOCONDBRANCH
00070b 0715          .dw PFA_QUIT3
00070c f0be      	.dw XT_DUP
00070d f040      	.dw XT_DOLITERAL
00070e fffe      	.dw -2
00070f f131      	.dw XT_LESS
000710 f039      	.dw XT_DOCONDBRANCH
000711 0713      	.dw PFA_QUIT5
000712 0727      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000713 f02f      	.dw XT_DOBRANCH
000714 06f8      	.dw PFA_QUIT
                 PFA_QUIT3:
000715 0720          .dw XT_PROMPTOK
000716 f02f          .dw XT_DOBRANCH
000717 06fd          .dw PFA_QUIT2
000718 f020          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000719 f000          .dw DO_COLON
                 PFA_PROMPTRDY:
00071a 04c7          .dw XT_CR
00071b 045c          .dw XT_DOSLITERAL
00071c 0002          .dw 2
00071d 203e          .db "> "
00071e 0493          .dw XT_ITYPE
00071f f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000720 f000          .dw DO_COLON
                 PFA_PROMPTOK:
000721 045c          .dw XT_DOSLITERAL
000722 0003          .dw 3
000723 6f20
000724 006b          .db " ok",0
000725 0493          .dw XT_ITYPE
000726 f020          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000727 f000          .dw DO_COLON
                 PFA_PROMPTERROR:
000728 045c      	.dw XT_DOSLITERAL
000729 0004      	.dw 4
00072a 3f20
00072b 203f      	.db  " ?? "
00072c 0493          .dw XT_ITYPE
00072d 01c2      	.dw XT_BASE
00072e f086      	.dw XT_FETCH
00072f f105      	.dw XT_TO_R
000730 0299      	.dw XT_DECIMAL
000731 03f9      	.dw XT_DOT
000732 01ea      	.dw XT_G_IN
000733 f086      	.dw XT_FETCH
000734 03f9      	.dw XT_DOT
000735 f0fc      	.dw XT_R_FROM
000736 01c2      	.dw XT_BASE
000737 f08e      	.dw XT_STORE
000738 f020          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000739 ff05          .dw $ff05
00073a 6170
00073b 7375
00073c 0065          .db "pause",0
00073d 06f3          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00073e 089b          .dw PFA_DODEFER
                 PFA_PAUSE:
00073f 0291          .dw ram_pause
000740 0869          .dw XT_RDEFERFETCH
000741 086e          .dw XT_RDEFERSTORE
                 
                 .dseg
000291           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000742 ff04          .dw $ff04
000743 6f63
000744 646c          .db "cold"
000745 0739          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000746 0747          .dw PFA_COLD
                 PFA_COLD:
000747 b6a4          in_ r10, MCUSR
000748 24bb          clr r11
000749 2422          clr zerol
00074a 2433          clr zeroh
00074b be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000293           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00074c e9e3          ldi zl, low(ram_user1)
00074d e0f2          ldi zh, high(ram_user1)
00074e 012f          movw upl, zl
                     ; init return stack pointer
00074f ef0f          ldi temp0,low(rstackstart)
000750 bf0d          out_ SPL,temp0
000751 8304          std Z+4, temp0
000752 e211          ldi temp1,high(rstackstart)
000753 bf1e          out_ SPH,temp1
000754 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000755 eacf          ldi yl,low(stackstart)
000756 83c6          std Z+6, yl
000757 e2d1          ldi yh,high(stackstart)
000758 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000759 e6a2          ldi XL, low(PFA_WARM)
00075a e0b7          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00075b 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
00075d ff04          .dw $ff04
00075e 6177
00075f 6d72          .db "warm"
000760 0742          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000761 f000          .dw DO_COLON
                 PFA_WARM:
000762 09ee          .dw XT_INITUSER
000763 f040          .dw XT_DOLITERAL
000764 0838          .dw XT_NOOP
000765 f040          .dw XT_DOLITERAL
000766 073e          .dw XT_PAUSE
000767 0886          .dw XT_DEFERSTORE
000768 02b4          .dw XT_TURNKEY
000769 06f7          .dw XT_QUIT
00076a f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00076b ff03          .dw $ff03
00076c 7073
00076d 0030          .db "sp0",0
00076e 075d          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00076f f07b          .dw PFA_DOVALUE1
                 PFA_SP0:
000770 0006          .dw USER_SP0
000771 0778          .dw XT_UVALUEFETCH
000772 077c          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000773 ff02          .dw $ff02
000774 7073          .db "sp"
000775 076b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000776 f061          .dw PFA_DOUSER
                 PFA_SP:
000777 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
000778 f000          .dw DO_COLON
                 PFA_UVALUEFETCH:
000779 f3e5          .dw XT_FETCHI
00077a f0ad          .dw XT_FETCHU
00077b f020          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
00077c f000          .dw DO_COLON
                 PFA_UVALUESTORE:
00077d f3e5          .dw XT_FETCHI
00077e f0b5          .dw XT_STOREU
00077f f020          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000780 ff03          .dw $ff03
000781 7072
000782 0030          .db "rp0",0
000783 0773          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000784 f000          .dw DO_COLON
                 PFA_RP0:
000785 0788          .dw XT_DORP0
000786 f086          .dw XT_FETCH
000787 f020          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000788 f061          .dw PFA_DOUSER
                 PFA_DORP0:
000789 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
00078a ff05          .dw $ff05
00078b 6564
00078c 7470
00078d 0068          .db "depth",0
00078e 0780          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00078f f000          .dw DO_COLON
                 PFA_DEPTH:
000790 076f          .dw XT_SP0
000791 f29c          .dw XT_SP_FETCH
000792 f1ae          .dw XT_MINUS
000793 f21f          .dw XT_2SLASH
000794 f250          .dw XT_1MINUS
000795 f020          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
000796 ff09          .dw $ff09
000797 6e69
000798 6574
000799 7072
00079a 6572
00079b 0074          .db "interpret",0
00079c 078a          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00079d f000          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
00079e 06b8          .dw XT_PARSENAME ; ( -- addr len )
00079f f0c6          .dw XT_QDUP   ; ( -- addr len len )
0007a0 f16e          .dw XT_GREATERZERO
0007a1 f039          .dw XT_DOCONDBRANCH
0007a2 07c1          .dw PFA_INTERPRET5
0007a3 f040          .dw XT_DOLITERAL
0007a4 0026          .dw EE_RECOGNIZERLISTLEN
0007a5 f373          .dw XT_FETCHE       ; ( addr len rec # -- )
0007a6 f146          .dw XT_ZERO
                 
0007a7 f2bf          .dw XT_DOQDO
0007a8 07bd          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
0007a9 01d9          .dw XT_2DUP ; ( -- addr len addr len  )
0007aa f2d5          .dw XT_I    ; ( -- addr len addr len i )
0007ab f0ee          .dw XT_ROT  ; ( -- addr len len i addr )
0007ac f0ee          .dw XT_ROT  ; ( -- addr len i addr len )
0007ad f105          .dw XT_TO_R
0007ae f105          .dw XT_TO_R
                 
0007af 01c9          .dw XT_CELLS
0007b0 f040          .dw XT_DOLITERAL
0007b1 0028          .dw EE_RECOGNIZERLIST
0007b2 f1b8          .dw XT_PLUS
0007b3 f373          .dw XT_FETCHE
                 
0007b4 f02a          .dw XT_EXECUTE
0007b5 f0fc          .dw XT_R_FROM
0007b6 f0fc          .dw XT_R_FROM
0007b7 f0ee          .dw XT_ROT
0007b8 f039          .dw XT_DOCONDBRANCH
0007b9 07bb          .dw PFA_INTERPRET3
0007ba f48e            .dw XT_LEAVE
                 PFA_INTERPRET3:
0007bb f2f0          .dw XT_DOLOOP
0007bc 07a9          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
0007bd 01e2          .dw XT_2DROP
0007be 080e          .dw XT_QSTACK
0007bf f02f          .dw XT_DOBRANCH
0007c0 079e          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
0007c1 f0e6          .dw xT_DROP
0007c2 f020          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
0007c3 ff0a          .dw $ff0a
0007c4 6572
0007c5 2d63
0007c6 6e69
0007c7 6e74
0007c8 6d75          .db "rec-intnum"
0007c9 0796          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
0007ca f000          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
0007cb 05b5          .dw XT_NUMBER 
0007cc f039          .dw XT_DOCONDBRANCH 
0007cd 07df          .dw PFA_REC_NONUMBER
                 
0007ce 01bc          .dw XT_STATE
0007cf f086          .dw XT_FETCH
0007d0 f039          .dw XT_DOCONDBRANCH
0007d1 07dc          .dw PFA_REC_NUMBER_DONE
0007d2 f040      	.dw XT_DOLITERAL
0007d3 0002      	.dw 2
0007d4 f123      	.dw XT_EQUAL
0007d5 f039      	.dw XT_DOCONDBRANCH
0007d6 07d9      	.dw PFA_REC_NUMBER_SINGLE
0007d7 f0d1      	.dw XT_SWAP
0007d8 f3f5              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
0007d9 f3f5              .dw XT_LITERAL
0007da f02f              .dw XT_DOBRANCH
0007db 07dd              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
0007dc f0e6          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
0007dd f14f          .dw XT_TRUE
0007de f020          .dw XT_EXIT
                 PFA_REC_NONUMBER:
0007df f146          .dw XT_ZERO
0007e0 f020          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
0007e1 ff08          .dw $ff08
0007e2 6572
0007e3 2d63
0007e4 6966
0007e5 646e          .db "rec-find"
0007e6 07c3          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
0007e7 f000          .dw DO_COLON
                 PFA_REC_FIND:
0007e8 06d5          .dw XT_FINDNAME
0007e9 f0be          .dw XT_DUP
0007ea f039          .dw XT_DOCONDBRANCH 
0007eb 07fa          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
0007ec f16e      	.dw XT_GREATERZERO
0007ed f039      	.dw XT_DOCONDBRANCH
0007ee 07f1      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
0007ef f02f      	    .dw XT_DOBRANCH
0007f0 07f8      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
0007f1 01bc      	    .dw XT_STATE
0007f2 f086      	    .dw XT_FETCH
0007f3 f039      	    .dw XT_DOCONDBRANCH
0007f4 07f8      	    .dw PFA_REC_FIND_EXECUTE
0007f5 0277      	    .dw XT_COMMA
0007f6 f02f      	    .dw XT_DOBRANCH
0007f7 07f9      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
0007f8 f02a          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
0007f9 f14f          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
0007fa f020          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
0007fb ff0c          .dw $ff0c
0007fc 6572
0007fd 2d63
0007fe 6f6e
0007ff 6674
000800 756f
000801 646e          .db "rec-notfound"
000802 07e1          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000803 f000          .dw DO_COLON
                 PFA_REC_NOTFOUND:
000804 04ec          .dw XT_TYPE
000805 f040          .dw XT_DOLITERAL
000806 fff3          .dw -13
000807 0528          .dw XT_THROW
000808 f020          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
000809 ff06          .dw $ff06
00080a 733f
00080b 6174
00080c 6b63          .db "?stack"
00080d 07fb          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00080e f000          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
00080f 078f          .dw XT_DEPTH
000810 f13f          .dw XT_LESSZERO
000811 f039          .dw XT_DOCONDBRANCH
000812 0816          .dw PFA_QSTACK1
000813 f040            .dw XT_DOLITERAL
000814 fffc            .dw -4
000815 0528            .dw XT_THROW
                 PFA_QSTACK1:
000816 f020          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
000817 ff03          .dw $ff03
000818 6576
000819 0072          .db "ver",0
00081a 0809          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
00081b f000          .dw DO_COLON
                 PFA_VER:
00081c f610          .dw XT_ENV_FORTHNAME
00081d 0493          .dw XT_ITYPE
00081e 04d4          .dw XT_SPACE
00081f 01c2          .dw XT_BASE
000820 f086          .dw XT_FETCH
000821 f105          .dw XT_TO_R
000822 0299          .dw XT_DECIMAL
                 
000823 f61e          .dw XT_ENV_FORTHVERSION
000824 f341          .dw XT_S2D
000825 0393          .dw XT_L_SHARP
000826 039b          .dw XT_SHARP
000827 f040          .dw XT_DOLITERAL
000828 002e          .dw '.'
000829 0384          .dw XT_HOLD
00082a 03b1          .dw XT_SHARP_S
00082b 03bc          .dw XT_SHARP_G
00082c f0fc          .dw XT_R_FROM
00082d 01c2          .dw XT_BASE
00082e f08e          .dw XT_STORE
                 
00082f 04ec          .dw XT_TYPE
000830 04d4          .dw XT_SPACE
000831 f626          .dw XT_ENV_CPU
000832 0493          .dw XT_ITYPE
000833 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000834 ff04          .dw $ff04
000835 6f6e
000836 706f          .db "noop"
000837 0817          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000838 0839          .dw PFA_NOOP
                 PFA_NOOP:
000839 940c f004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00083b ff06          .dw $ff06
00083c 6e75
00083d 7375
00083e 6465          .db "unused"
00083f 0834          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000840 f000          .dw DO_COLON
                 PFA_UNUSED:
000841 076f          .dw XT_SP0
000842 0230          .dw XT_HERE
000843 f1ae          .dw XT_MINUS
000844 f020          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
000845 0002          .dw $0002
000846 6f74          .db "to"
000847 083b          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000848 f000          .dw DO_COLON
                 PFA_TO:
000849 04fb          .dw XT_TICK
00084a f24a          .dw XT_1PLUS  		; to body
00084b 01bc          .dw XT_STATE
00084c f086          .dw XT_FETCH
00084d f039          .dw XT_DOCONDBRANCH
00084e 0859          .dw PFA_TO1
00084f 026c          .dw XT_COMPILE
000850 0853          .dw XT_DOTO
000851 0277          .dw XT_COMMA
000852 f020          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
000853 f000          .dw DO_COLON
                 PFA_DOTO:
000854 f0fc          .dw XT_R_FROM
000855 f0be          .dw XT_DUP
000856 f24a          .dw XT_1PLUS
000857 f105          .dw XT_TO_R
000858 f3e5          .dw XT_FETCHI
                 PFA_TO1:
000859 f0be          .dw XT_DUP
00085a f24a          .dw XT_1PLUS
00085b f24a          .dw XT_1PLUS
00085c f3e5          .dw XT_FETCHI
00085d f02a          .dw XT_EXECUTE
00085e f020          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00085f f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
000860 f24a          .dw XT_1PLUS ; >body
000861 f3e5          .dw XT_FETCHI
000862 f373          .dw XT_FETCHE
000863 f020          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000864 f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
000865 f24a          .dw XT_1PLUS
000866 f3e5          .dw XT_FETCHI
000867 f34f          .dw XT_STOREE
000868 f020          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000869 f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
00086a f24a          .dw XT_1PLUS ; >body
00086b f3e5          .dw XT_FETCHI
00086c f086          .dw XT_FETCH
00086d f020          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00086e f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
00086f f24a          .dw XT_1PLUS
000870 f3e5          .dw XT_FETCHI
000871 f08e          .dw XT_STORE
000872 f020          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000873 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
000874 f24a          .dw XT_1PLUS ; >body
000875 f3e5          .dw XT_FETCHI
000876 f32f          .dw XT_UP_FETCH
000877 f1b8          .dw XT_PLUS
000878 f086          .dw XT_FETCH
000879 f020          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00087a f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
00087b f24a          .dw XT_1PLUS
00087c f3e5          .dw XT_FETCHI
00087d f32f          .dw XT_UP_FETCH
00087e f1b8          .dw XT_PLUS
00087f f08e          .dw XT_STORE
000880 f020          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
000881 ff06          .dw $ff06
000882 6564
000883 6566
000884 2172          .db "defer!"
000885 0845          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000886 f000          .dw DO_COLON
                 PFA_DEFERSTORE:
000887 f0be          .dw XT_DUP
000888 f040          .dw XT_DOLITERAL
000889 0003          .dw 3
00088a f1b8          .dw XT_PLUS   ; >body 2 +
00088b f3e5          .dw XT_FETCHI
00088c f02a          .dw XT_EXECUTE
00088d f020          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
00088e ff06          .dw $ff06
00088f 6564
000890 6566
000891 4072          .db "defer@"
000892 0881          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000893 f000          .dw DO_COLON
                 PFA_DEFERFETCH:
000894 f0be          .dw XT_DUP
000895 f24a          .dw XT_1PLUS ; >body
000896 f24a          .dw XT_1PLUS 
000897 f3e5          .dw XT_FETCHI
000898 f02a          .dw XT_EXECUTE
000899 f020          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
00089a 089b          .dw PFA_DODEFER
                 PFA_DODEFER:
00089b 940e f4f8     call_ DO_DODOES
00089d f0be          .dw XT_DUP
00089e f250          .dw XT_1MINUS
00089f f0d1          .dw XT_SWAP
0008a0 f24a          .dw XT_1PLUS
0008a1 f3e5          .dw XT_FETCHI
0008a2 f02a          .dw XT_EXECUTE 
0008a3 f02a          .dw XT_EXECUTE
0008a4 f020          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0008a5 ff0f          .dw $ff0f
0008a6 6573
0008a7 7261
0008a8 6863
0008a9 772d
0008aa 726f
0008ab 6c64
0008ac 7369
0008ad 0074          .db "search-wordlist",0
0008ae 088e          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0008af f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0008b0 f146          .dw XT_ZERO
0008b1 f0d1          .dw XT_SWAP
0008b2 f040          .dw XT_DOLITERAL
0008b3 08be          .dw XT_ISWORD
0008b4 f0d1          .dw XT_SWAP
0008b5 08f5          .dw XT_TRAVERSEWORDLIST
0008b6 f0be          .dw XT_DUP
0008b7 f12a          .dw XT_EQUALZERO
0008b8 f039          .dw XT_DOCONDBRANCH
0008b9 08bd          .dw PFA_SEARCH_WORDLIST1
0008ba 01e2             .dw XT_2DROP
0008bb f0e6             .dw XT_DROP
0008bc f146             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
0008bd f020          .dw XT_EXIT
                 
                 XT_ISWORD:
0008be f000          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
0008bf f105          .dw XT_TO_R
0008c0 f105          .dw XT_TO_R
0008c1 01d9          .dw XT_2DUP
0008c2 f0fc          .dw XT_R_FROM
0008c3 f0ee          .dw XT_ROT
0008c4 f0ee          .dw XT_ROT
0008c5 f10e          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
0008c6 08e4          .dw XT_NAME2STRING
0008c7 0910          .dw XT_ICOMPARE      ; (-- addr len 0 f )
0008c8 f039          .dw XT_DOCONDBRANCH
0008c9 08d8          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
0008ca 01e2            .dw XT_2DROP
0008cb f0e6            .dw XT_DROP
                       ; ... get the XT ...
0008cc f10e            .dw XT_R_FETCH
0008cd f6b0            .dw XT_NFA2LFA
0008ce f24a            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
0008cf f14f            .dw XT_TRUE
0008d0 f0fc            .dw XT_R_FROM
0008d1 f3e5            .dw XT_FETCHI
0008d2 f16e            .dw XT_GREATERZERO
0008d3 f039            .dw XT_DOCONDBRANCH
0008d4 08d6            .dw PFA_ISWORD1
0008d5 030f               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
0008d6 f146            .dw XT_ZERO       ; finish traverse-wordlist
0008d7 f020            .dw XT_EXIT
                 PFA_ISWORD3:
0008d8 f0fc          .dw XT_R_FROM
0008d9 f0e6          .dw XT_DROP
0008da f14f          .dw XT_TRUE         ; maybe next word
0008db f020          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
0008dc ff0b          .dw $ff0b
0008dd 616e
0008de 656d
0008df 733e
0008e0 7274
0008e1 6e69
0008e2 0067          .db "name>string",0
0008e3 08a5          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
0008e4 f000          .dw DO_COLON
                 PFA_NAME2STRING:
0008e5 04be          .dw XT_ICOUNT   ; ( -- addr n )
0008e6 f040          .dw XT_DOLITERAL
0008e7 00ff          .dw $00FF
0008e8 f22e          .dw XT_AND      ; mask immediate bit
0008e9 f020          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
0008ea ff11          .dw $ff11
0008eb 7274
0008ec 7661
0008ed 7265
0008ee 6573
0008ef 772d
0008f0 726f
0008f1 6c64
0008f2 7369
0008f3 0074          .db "traverse-wordlist",0
0008f4 08dc          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0008f5 f000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
0008f6 f373          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0008f7 f0be          .dw XT_DUP           ; ( -- xt nt nt )
0008f8 f039          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0008f9 0908          .dw PFA_TRAVERSEWORDLIST2       ;
0008fa 01d9          .dw XT_2DUP
0008fb f105          .dw XT_TO_R
0008fc f105          .dw XT_TO_R
0008fd f0d1          .dw XT_SWAP
0008fe f02a          .dw XT_EXECUTE
0008ff f0fc          .dw XT_R_FROM
000900 f0fc          .dw XT_R_FROM
000901 f0ee          .dw XT_ROT
000902 f039          .dw XT_DOCONDBRANCH
000903 0908          .dw PFA_TRAVERSEWORDLIST2
000904 f6b0          .dw XT_NFA2LFA
000905 f3e5          .dw XT_FETCHI        ; ( -- addr )
000906 f02f          .dw XT_DOBRANCH      ; ( -- addr )
000907 08f7          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000908 01e2          .dw XT_2DROP
000909 f020          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
00090a ff08          .dw $ff08
00090b 6369
00090c 6d6f
00090d 6170
00090e 6572          .db "icompare"
00090f 08ea          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000910 f000          .dw DO_COLON
                 PFA_ICOMPARE:
000911 f105          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000912 f0dc          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000913 f0fc          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000914 f119          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000915 f039          .dw XT_DOCONDBRANCH
000916 091b          .dw PFA_ICOMPARE_SAMELEN
000917 01e2            .dw XT_2DROP
000918 f0e6            .dw XT_DROP
000919 f146            .dw XT_ZERO
00091a f020            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00091b f0d1          .dw XT_SWAP ; ( -- r-addr f-addr len )
00091c f146          .dw XT_ZERO
00091d f2bf          .dw XT_DOQDO
00091e 093e          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00091f f0dc          .dw XT_OVER
000920 f086          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
000921 0941          .dw XT_ICOMPARE_LC
                 .endif
000922 f0dc          .dw XT_OVER
000923 f3e5          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
000924 0941          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000925 f0be          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000926 f040          .dw XT_DOLITERAL
000927 0100          .dw $100
000928 f158          .dw XT_ULESS
000929 f039          .dw XT_DOCONDBRANCH
00092a 092f          .dw PFA_ICOMPARE_LASTCELL
00092b f0d1          .dw XT_SWAP
00092c f040          .dw XT_DOLITERAL
00092d 00ff          .dw $00FF
00092e f22e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00092f f119          .dw XT_NOTEQUAL
000930 f039          .dw XT_DOCONDBRANCH
000931 0936          .dw PFA_ICOMPARE_NEXTLOOP
000932 01e2          .dw XT_2DROP
000933 f146          .dw XT_ZERO
000934 f2ff          .dw XT_UNLOOP
000935 f020          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000936 f24a          .dw XT_1PLUS
000937 f0d1          .dw XT_SWAP
000938 01d1          .dw XT_CELLPLUS
000939 f0d1          .dw XT_SWAP
00093a f040          .dw XT_DOLITERAL
00093b 0002          .dw 2
00093c f2d6          .dw XT_DOPLUSLOOP
00093d 091f          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00093e 01e2          .dw XT_2DROP
00093f f14f          .dw XT_TRUE
000940 f020          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
000941 f000          .dw DO_COLON
                 PFA_ICOMPARE_LC:
000942 f0be          .dw XT_DUP
000943 f040          .dw XT_DOLITERAL
000944 00ff          .dw $00ff
000945 f22e          .dw XT_AND
000946 036d          .dw XT_TOLOWER
000947 f0d1          .dw XT_SWAP
000948 f326          .dw XT_BYTESWAP
000949 f040          .dw XT_DOLITERAL
00094a 00ff          .dw $00ff
00094b f22e          .dw XT_AND
00094c 036d          .dw XT_TOLOWER
00094d f326          .dw XT_BYTESWAP
00094e f237          .dw XT_OR
00094f f020          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000950 ff01          .dw $ff01
000951 002a          .db "*",0
000952 090a          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000953 f000          .dw DO_COLON
                 PFA_STAR:
000954 f1c1          .dw XT_MSTAR
000955 0965          .dw XT_D2S
000956 f020          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000957 ff01          .dw $FF01
000958 006a          .db "j",0
000959 0950          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00095a f000          .dw DO_COLON
                 PFA_J:
00095b f285          .dw XT_RP_FETCH
00095c f040          .dw XT_DOLITERAL
00095d 0009          .dw 9
00095e f1b8          .dw XT_PLUS
00095f f086          .dw XT_FETCH
000960 f020          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000961 ff03          .dw $ff03
000962 3e64
000963 0073          .db "d>s",0
000964 0957          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
000965 f000          .dw DO_COLON
                 PFA_D2S:
000966 f0e6          .dw XT_DROP
000967 f020          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000968 ff04          .dw $ff04
000969 6164
00096a 7362          .db "dabs"
00096b 0961          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00096c f000          .dw DO_COLON
                 PFA_DABS:
00096d f0be          .dw XT_DUP
00096e f13f          .dw XT_LESSZERO
00096f f039          .dw XT_DOCONDBRANCH
000970 0972          .dw PFA_DABS1
000971 0979          .dw XT_DNEGATE
                 PFA_DABS1:
000972 f020          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000973 ff07          .dw $ff07
000974 6e64
000975 6765
000976 7461
000977 0065          .db "dnegate",0
000978 0968          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000979 f000          .dw DO_COLON
                 PFA_DNEGATE:
00097a f702          .dw XT_DINVERT
00097b f040          .dw XT_DOLITERAL
00097c 0001          .dw 1
00097d f146          .dw XT_ZERO
00097e f6dc          .dw XT_DPLUS
00097f f020          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000980 ff05          .dw $ff05
000981 6d63
000982 766f
000983 0065          .db "cmove",0
000984 0973          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000985 0986          .dw PFA_CMOVE
                 PFA_CMOVE:
000986 93bf          push xh
000987 93af          push xl
000988 91e9          ld zl, Y+
000989 91f9          ld zh, Y+ ; addr-to
00098a 91a9          ld xl, Y+
00098b 91b9          ld xh, Y+ ; addr-from
00098c 2f09          mov temp0, tosh
00098d 2b08          or temp0, tosl
00098e f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00098f 911d          ld temp1, X+
000990 9311          st Z+, temp1
000991 9701          sbiw tosl, 1
000992 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000993 91af          pop xl
000994 91bf          pop xh
000995 9189
000996 9199          loadtos
000997 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
000999 ff05          .dw $ff05
00099a 7332
00099b 6177
00099c 0070          .db "2swap",0
00099d 0980          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00099e f000          .dw DO_COLON
                 PFA_2SWAP:
00099f f0ee          .dw XT_ROT
0009a0 f105          .dw XT_TO_R
0009a1 f0ee          .dw XT_ROT
0009a2 f0fc          .dw XT_R_FROM
0009a3 f020          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
0009a4 ff03          .dw $ff03
0009a5 6974
0009a6 0062          .db "tib",0
0009a7 0999          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0009a8 f04e          .dw PFA_DOVARIABLE
                 PFA_TIB:
0009a9 02b9          .dw ram_tib
                     
                 .dseg
0002b9           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
0009aa ff0a          .dw $ff0a
0009ab 6572
0009ac 6966
0009ad 6c6c
0009ae 742d
0009af 6269          .db "refill-tib"
0009b0 09a4          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
0009b1 f000          .dw DO_COLON
                 PFA_REFILLTIB:
0009b2 09a8          .dw XT_TIB
0009b3 f040          .dw XT_DOLITERAL
0009b4 0064          .dw TIBSIZE
0009b5 0559          .dw XT_ACCEPT
0009b6 01f0          .dw XT_NUMBERTIB
0009b7 f08e          .dw XT_STORE
0009b8 f146          .dw XT_ZERO
0009b9 01ea          .dw XT_G_IN
0009ba f08e          .dw XT_STORE
0009bb f040          .dw XT_DOLITERAL
0009bc ffff          .dw -1
0009bd f020          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0009be ff0a          .dw $FF0A
0009bf 6f73
0009c0 7275
0009c1 6563
0009c2 742d
0009c3 6269          .db "source-tib"
0009c4 09aa          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0009c5 f000          .dw DO_COLON
                 PFA_SOURCETIB:
0009c6 09a8          .dw XT_TIB
0009c7 01f0          .dw XT_NUMBERTIB
0009c8 f086          .dw XT_FETCH
0009c9 f020          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0009ca ff07        .dw $ff07
0009cb 6565
0009cc 752d
0009cd 6573
0009ce 0072        .db "ee-user",0
0009cf 09be        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
0009d0 f04e        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
0009d1 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0009d2 ff06        .dw $ff06
0009d3 6565
0009d4 723e
0009d5 6d61        .db "ee>ram"
0009d6 09ca        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0009d7 f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0009d8 f146          .dw XT_ZERO
0009d9 f2bf          .dw XT_DOQDO
0009da 09e5          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
0009db f0dc          .dw XT_OVER
0009dc f373          .dw XT_FETCHE
0009dd f0dc          .dw XT_OVER
0009de f08e          .dw XT_STORE
0009df 01d1          .dw XT_CELLPLUS
0009e0 f0d1          .dw XT_SWAP
0009e1 01d1          .dw XT_CELLPLUS
0009e2 f0d1          .dw XT_SWAP
0009e3 f2f0          .dw XT_DOLOOP
0009e4 09db          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
0009e5 01e2          .dw XT_2DROP
0009e6 f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
0009e7 ff09        .dw $ff09
0009e8 6e69
0009e9 7469
0009ea 752d
0009eb 6573
0009ec 0072        .db "init-user",0
0009ed 09d2        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
0009ee f000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
0009ef 09d0          .dw XT_EEUSER
0009f0 f32f          .dw XT_UP_FETCH
0009f1 f040          .dw XT_DOLITERAL
0009f2 001c          .dw SYSUSERSIZE
0009f3 f21f          .dw XT_2SLASH
0009f4 09d7          .dw XT_EE2RAM
0009f5 f020          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_MARKER:
0009f6 ff08          .dw $ff08
0009f7 6d28
0009f8 7261
0009f9 656b
0009fa 2972          .db "(marker)"
0009fb 09e7          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
0009fc f07b          .dw PFA_DOVALUE1
                 PFA_MARKER:
0009fd 0036          .dw EE_MARKER
0009fe f57b          .dw XT_EVALUEFETCH
0009ff f57f          .dw XT_EVALUESTORE
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
00f004 f09e          brts DO_INTERRUPT
00f005 01fd          movw zl, XL        ; READ IP
00f006 2755
00f007 0fee
00f008 1fff
00f009 1f55
00f00a bf5b
00f00b 9167
00f00c 9177          readflashcell wl, wh
00f00d 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00e 01fb          movw zl, wl
00f00f 2755
00f010 0fee
00f011 1fff
00f012 1f55
00f013 bf5b
00f014 9107
00f015 9117          readflashcell temp0,temp1
00f016 01f8          movw zl, temp0
00f017 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f018 94e8          clt
00f019 e961          ldi wl, LOW(XT_ISREXEC)
00f01a e071          ldi wh, HIGH(XT_ISREXEC)
00f01b cff2          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f01c ff04          .dw $ff04
00f01d 7865
00f01e 7469          .db "exit"
00f01f 09f6          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f020 f021          .dw PFA_EXIT
                 PFA_EXIT:
00f021 91af          pop XL
00f022 91bf          pop XH
00f023 cfe0          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f024 ff07          .dw $ff07
00f025 7865
00f026 6365
00f027 7475
00f028 0065          .db "execute",0
00f029 f01c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02a f02b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f02b 01bc          movw wl, tosl
00f02c 9189
00f02d 9199          loadtos
00f02e cfdf          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f02f f030          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f030 01fd          movw zl, XL
00f031 2755
00f032 0fee
00f033 1fff
00f034 1f55
00f035 bf5b
00f036 91a7
00f037 91b7          readflashcell XL,XH
00f038 cfcb          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f039 f03a          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03a 2b98          or tosh, tosl
00f03b 9189
00f03c 9199          loadtos
00f03d f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f03e 9611          adiw XL, 1
00f03f cfc4          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f040 f041          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f041 939a
00f042 938a          savetos
00f043 01fd          movw zl, xl
00f044 2755
00f045 0fee
00f046 1fff
00f047 1f55
00f048 bf5b
00f049 9187
00f04a 9197          readflashcell tosl,tosh
00f04b 9611          adiw xl, 1
00f04c cfb7          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f04d f04e          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f04e 939a
00f04f 938a          savetos
00f050 01fb          movw zl, wl
00f051 9631          adiw zl,1
00f052 2755
00f053 0fee
00f054 1fff
00f055 1f55
00f056 bf5b
00f057 9187
00f058 9197          readflashcell tosl,tosh
00f059 cfaa          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05a f05b          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f05b 939a
00f05c 938a          savetos
00f05d 01cb          movw tosl, wl
00f05e 9601          adiw tosl, 1
00f05f cfa4          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f060 f061          .dw PFA_DOUSER
                 PFA_DOUSER:
00f061 939a
00f062 938a          savetos
00f063 01fb          movw zl, wl
00f064 9631          adiw zl, 1
00f065 2755
00f066 0fee
00f067 1fff
00f068 1f55
00f069 bf5b
00f06a 9187
00f06b 9197          readflashcell tosl,tosh
00f06c 0d84          add tosl, upl
00f06d 1d95          adc tosh, uph
00f06e cf95          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f06f ff07          .dw $ff07
00f070 7628
00f071 6c61
00f072 6575
00f073 0029          .db "(value)", 0
00f074 f024          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f075 f000          .dw DO_COLON
                 PFA_DOVALUE:
00f076 0245          .dw XT_DOCREATE
00f077 f4d4          .dw XT_REVEAL
00f078 026c          .dw XT_COMPILE
00f079 f07b          .dw PFA_DOVALUE1
00f07a f020          .dw XT_EXIT
                 PFA_DOVALUE1:
00f07b 940e f4f8     call_ DO_DODOES
00f07d f0be          .dw XT_DUP
00f07e f0d1          .dw XT_SWAP
00f07f f24a          .dw XT_1PLUS
00f080 f3e5          .dw XT_FETCHI
00f081 f02a          .dw XT_EXECUTE
00f082 f020          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f083 ff01          .dw $ff01
00f084 0040          .db "@",0
00f085 f06f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f086 f087          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f087 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f088 9181          ld tosl, z+
00f089 9191          ld tosh, z+
00f08a cf79          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08b ff01          .dw $ff01
00f08c 0021          .db "!",0
00f08d f083          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f08e f08f          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f08f 01fc          movw zl, tosl
00f090 9189
00f091 9199          loadtos
                     ; the high byte is written before the low byte
00f092 8391          std Z+1, tosh
00f093 8380          std Z+0, tosl
00f094 9189
00f095 9199          loadtos
00f096 cf6d          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f097 ff02          .dw $ff02
00f098 2163          .db "c!"
00f099 f08b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09a f09b          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09b 01fc          movw zl, tosl
00f09c 9189
00f09d 9199          loadtos
00f09e 8380          st Z, tosl
00f09f 9189
00f0a0 9199          loadtos
00f0a1 cf62          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a2 ff02          .dw $ff02
00f0a3 4063          .db "c@"
00f0a4 f097          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a5 f0a6          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0a6 01fc          movw zl, tosl
00f0a7 2799          clr tosh
00f0a8 8180          ld tosl, Z
00f0a9 cf5a          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
00f0aa ff02          .dw $ff02
00f0ab 7540          .db "@u"
00f0ac f0a2          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0ad f000          .dw DO_COLON
                 PFA_FETCHU:
00f0ae f32f          .dw XT_UP_FETCH
00f0af f1b8          .dw XT_PLUS
00f0b0 f086          .dw XT_FETCH
00f0b1 f020          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
00f0b2 ff02          .dw $ff02
00f0b3 7521          .db "!u"
00f0b4 f0aa          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b5 f000          .dw DO_COLON
                 PFA_STOREU:
00f0b6 f32f          .dw XT_UP_FETCH
00f0b7 f1b8          .dw XT_PLUS
00f0b8 f08e          .dw XT_STORE
00f0b9 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0ba ff03          .dw $ff03
00f0bb 7564
00f0bc 0070          .db "dup",0
00f0bd f0b2          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0be f0bf          .dw PFA_DUP
                 PFA_DUP:
00f0bf 939a
00f0c0 938a          savetos
00f0c1 cf42          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c2 ff04          .dw $ff04
00f0c3 643f
00f0c4 7075          .db "?dup"
00f0c5 f0ba          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0c6 f0c7          .dw PFA_QDUP
                 PFA_QDUP:
00f0c7 2f08          mov temp0, tosl
00f0c8 2b09          or temp0, tosh
00f0c9 f011          breq PFA_QDUP1
00f0ca 939a
00f0cb 938a          savetos
                 PFA_QDUP1:
00f0cc cf37          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0cd ff04          .dw $ff04
00f0ce 7773
00f0cf 7061          .db "swap"
00f0d0 f0c2          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d1 f0d2          .dw PFA_SWAP
                 PFA_SWAP:
00f0d2 018c          movw temp0, tosl
00f0d3 9189
00f0d4 9199          loadtos
00f0d5 931a          st -Y, temp1
00f0d6 930a          st -Y, temp0
00f0d7 cf2c          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0d8 ff04          .dw $ff04
00f0d9 766f
00f0da 7265          .db "over"
00f0db f0cd          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0dc f0dd          .dw PFA_OVER
                 PFA_OVER:
00f0dd 939a
00f0de 938a          savetos
00f0df 818a          ldd tosl, Y+2
00f0e0 819b          ldd tosh, Y+3
                 
00f0e1 cf22          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e2 ff04          .dw $ff04
00f0e3 7264
00f0e4 706f          .db "drop"
00f0e5 f0d8          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0e6 f0e7          .dw PFA_DROP
                 PFA_DROP:
00f0e7 9189
00f0e8 9199          loadtos
00f0e9 cf1a          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ea ff03          .dw $ff03
00f0eb 6f72
00f0ec 0074          .db "rot",0
00f0ed f0e2          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0ee f0ef          .dw PFA_ROT
                 PFA_ROT:
00f0ef 018c          movw temp0, tosl
00f0f0 9129          ld temp2, Y+
00f0f1 9139          ld temp3, Y+ 
00f0f2 9189
00f0f3 9199          loadtos
                         
00f0f4 933a          st -Y, temp3
00f0f5 932a          st -Y, temp2
00f0f6 931a          st -Y, temp1
00f0f7 930a          st -Y, temp0
                 
00f0f8 cf0b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f0f9 ff02          .dw $ff02
00f0fa 3e72          .db "r>"
00f0fb f0ea          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f0fc f0fd          .dw PFA_R_FROM
                 PFA_R_FROM:
00f0fd 939a
00f0fe 938a          savetos
00f0ff 918f          pop tosl
00f100 919f          pop tosh
00f101 cf02          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f102 ff02          .dw $ff02
00f103 723e          .db ">r"
00f104 f0f9          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f105 f106          .dw PFA_TO_R
                 PFA_TO_R:
00f106 939f          push tosh
00f107 938f          push tosl
00f108 9189
00f109 9199          loadtos
00f10a cef9          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f10b ff02          .dw $ff02
00f10c 4072          .db "r@"
00f10d f102          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f10e f10f          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f10f 939a
00f110 938a          savetos
00f111 918f          pop tosl
00f112 919f          pop tosh
00f113 939f          push tosh
00f114 938f          push tosl
00f115 ceee          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
00f116 ff02          .dw $ff02
00f117 3e3c          .db "<>"
00f118 f10b          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f119 f11a          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
00f11a 9129          ld temp2, Y+
00f11b 9139          ld temp3, Y+
00f11c 1782          cp tosl, temp2
00f11d 0793          cpc tosh, temp3
00f11e f151          breq PFA_ZERO1
00f11f c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f120 ff01          .dw $ff01
00f121 003d          .db "=",0
00f122 f116          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f123 f000          .dw DO_COLON
                 PFA_EQUAL:
00f124 f1ae          .dw XT_MINUS
00f125 f12a          .dw XT_EQUALZERO
00f126 f020          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
00f127 ff02          .dw $ff02
00f128 3d30          .db "0="
00f129 f120          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
00f12a f12b          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
00f12b 2b98          or tosh, tosl
00f12c f4e1          brne PFA_ZERO1
00f12d c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f12e ff01          .dw $ff01
00f12f 003c          .db "<",0
00f130 f127          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f131 f000          .dw DO_COLON
                 PFA_LESS:
00f132 f1ae          .dw XT_MINUS
00f133 f13f          .dw XT_LESSZERO
00f134 f020          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f135 ff01          .dw $ff01
00f136 003e          .db ">",0
00f137 f12e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f138 f000          .dw DO_COLON
                 PFA_GREATER:
00f139 f1ae          .dw XT_MINUS
00f13a f16e          .dw XT_GREATERZERO
00f13b f020          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00f13c ff02          .dw $ff02
00f13d 3c30          .db "0<"
00f13e f135          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00f13f f140          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00f140 fd97          sbrc tosh,7
00f141 c010          rjmp PFA_TRUE1
00f142 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f143 ff01          .dw $ff01
00f144 0030          .db "0",0
00f145 f13c          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f146 f147          .dw PFA_ZERO
                 PFA_ZERO:
00f147 939a
00f148 938a          savetos
                 PFA_ZERO1:
00f149 01c1          movw tosl, zerol
00f14a ceb9          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f14b ff04          .dw $ff04
00f14c 7274
00f14d 6575          .db "true"
00f14e f143          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f14f f150          .dw PFA_TRUE
                 PFA_TRUE:
00f150 939a
00f151 938a          savetos
                 PFA_TRUE1:
00f152 ef8f          ser tosl
00f153 ef9f          ser tosh
00f154 ceaf          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f155 ff02          .dw $ff02
00f156 3c75          .db "u<"
00f157 f14b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f158 f159          .dw PFA_ULESS
                 PFA_ULESS:
00f159 9129          ld temp2, Y+
00f15a 9139          ld temp3, Y+
00f15b 1782          cp tosl, temp2
00f15c 0793          cpc tosh, temp3
00f15d f358          brlo PFA_ZERO1
00f15e f351          brbs 1, PFA_ZERO1
00f15f cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00f160 ff02          .dw $ff02
00f161 3e75          .db "u>"
00f162 f155          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f163 f164          .dw PFA_UGREATER
                 PFA_UGREATER:
00f164 9129          ld temp2, Y+
00f165 9139          ld temp3, Y+
00f166 1728          cp temp2, tosl
00f167 0739          cpc temp3, tosh
00f168 f300          brlo PFA_ZERO1
00f169 f2f9          brbs 1, PFA_ZERO1
00f16a cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f16b ff02          .dw $ff02
00f16c 3e30          .db "0>"
00f16d f160          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f16e f16f          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f16f 1582          cp tosl, zerol
00f170 0593          cpc tosh, zeroh
00f171 f2bc          brlt PFA_ZERO1
00f172 f2b1          brbs 1, PFA_ZERO1
00f173 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
00f174 ff02          .dw $ff02
00f175 3e64          .db "d>"
00f176 f16b          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
00f177 f000          .dw DO_COLON
                 PFA_DGREATER:
00f178 f6ed          .dw XT_DMINUS
00f179 f17f          .dw XT_DGREATERZERO
00f17a f020          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f17b ff03          .dw $ff03
00f17c 3064
00f17d 003e          .db "d0>",0
00f17e f174          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f17f f180          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f180 1582          cp tosl, zerol
00f181 0593          cpc tosh, zeroh
00f182 9189
00f183 9199          loadtos
00f184 0582          cpc tosl, zerol
00f185 0593          cpc tosh, zeroh
00f186 f214          brlt PFA_ZERO1
00f187 f209          brbs 1, PFA_ZERO1
00f188 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
00f189 ff02          .dw $ff02
00f18a 3c64          .db "d<"
00f18b f17b          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00f18c f000          .dw DO_COLON
                 PFA_DLESS:
00f18d f6ed          .dw XT_DMINUS
00f18e f194          .dw XT_DLESSZERO
00f18f f020          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00f190 ff03          .dw $ff03
00f191 3064
00f192 003c          .db "d0<",0
00f193 f189          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
00f194 f195          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
00f195 9622          adiw Y,2
00f196 fd97          sbrc tosh,7
00f197 940c f152     jmp PFA_TRUE1
00f199 940c f149     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f19b ff04          .dw $ff04
00f19c 6f6c
00f19d 3267          .db "log2"
00f19e f190          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f19f f1a0          .dw PFA_LOG2
                 PFA_LOG2:
00f1a0 01fc          movw zl, tosl
00f1a1 2799          clr tosh
00f1a2 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f1a3 958a          dec tosl
00f1a4 f022          brmi PFA_LOG2_2 ; wrong data
00f1a5 0fee          lsl  zl
00f1a6 1fff          rol  zh
00f1a7 f7d8          brcc PFA_LOG2_1
00f1a8 ce5b          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f1a9 959a          dec tosh
00f1aa ce59          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1ab ff01          .dw $ff01
00f1ac 002d          .db "-",0
00f1ad f19b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1ae f1af          .dw PFA_MINUS
                 PFA_MINUS:
00f1af 9109          ld temp0, Y+
00f1b0 9119          ld temp1, Y+
00f1b1 1b08          sub temp0, tosl
00f1b2 0b19          sbc temp1, tosh
00f1b3 01c8          movw tosl, temp0
00f1b4 ce4f          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1b5 ff01          .dw $ff01
00f1b6 002b          .db "+",0
00f1b7 f1ab          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1b8 f1b9          .dw PFA_PLUS
                 PFA_PLUS:
00f1b9 9109          ld temp0, Y+
00f1ba 9119          ld temp1, Y+
00f1bb 0f80          add tosl, temp0
00f1bc 1f91          adc tosh, temp1
00f1bd ce46          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1be ff02          .dw $ff02
00f1bf 2a6d          .db "m*"
00f1c0 f1b5          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1c1 f1c2          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1c2 018c          movw temp0, tosl
00f1c3 9189
00f1c4 9199          loadtos
00f1c5 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1c6 0231          muls temp3, temp1
00f1c7 0170          movw temp4, r0
                     ; low cell  al*bl
00f1c8 9f20          mul  temp2, temp0
00f1c9 01c0          movw tosl, r0
                     ; signed ah*bl
00f1ca 0330          mulsu temp3, temp0
00f1cb 08f3          sbc   temp5, zeroh
00f1cc 0d90          add   tosh,  r0
00f1cd 1ce1          adc   temp4, r1
00f1ce 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1cf 0312          mulsu temp1, temp2
00f1d0 08f3          sbc   temp5, zeroh
00f1d1 0d90          add   tosh,  r0
00f1d2 1ce1          adc   temp4, r1
00f1d3 1cf3          adc   temp5, zeroh
                 
00f1d4 939a
00f1d5 938a          savetos
00f1d6 01c7          movw tosl, temp4
00f1d7 ce2c          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1d8 ff06          .dw $ff06
00f1d9 6d75
00f1da 6d2f
00f1db 646f          .db "um/mod"
00f1dc f1be          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1dd f1de          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1de 017c          movw temp4, tosl
                 
00f1df 9129          ld temp2, Y+
00f1e0 9139          ld temp3, Y+
                   
00f1e1 9109          ld temp0, Y+
00f1e2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1e3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1e4 2755          clr temp7
00f1e5 0f00          lsl temp0
00f1e6 1f11          rol temp1
00f1e7 1f22          rol temp2
00f1e8 1f33          rol temp3
00f1e9 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1ea 152e          cp temp2, temp4
00f1eb 053f          cpc temp3, temp5
00f1ec 0552          cpc temp7,zerol
                 
00f1ed f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1ee 9503          inc temp0
00f1ef 192e          sub temp2, temp4
00f1f0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1f1 954a          dec  temp6
00f1f2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1f3 933a          st -Y,temp3
00f1f4 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1f5 01c8          movw tosl, temp0
00f1f6 ce0d          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1f7 ff03          .dw $ff03
00f1f8 6d75
00f1f9 002a          .db "um*",0
00f1fa f1d8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1fb f1fc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1fc 018c          movw temp0, tosl
00f1fd 9189
00f1fe 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1ff 9f80          mul tosl,temp0
00f200 01f0          movw zl, r0
00f201 2722          clr temp2
00f202 2733          clr temp3
                     ; middle bytes
00f203 9f90          mul tosh, temp0
00f204 0df0          add zh, r0
00f205 1d21          adc temp2, r1
00f206 1d33          adc temp3, zeroh
                         
00f207 9f81          mul tosl, temp1
00f208 0df0          add zh, r0
00f209 1d21          adc temp2, r1
00f20a 1d33          adc temp3, zeroh
                     
00f20b 9f91          mul tosh, temp1
00f20c 0d20          add temp2, r0
00f20d 1d31          adc temp3, r1
00f20e 01cf          movw tosl, zl
00f20f 939a
00f210 938a          savetos
00f211 01c9          movw tosl, temp2
00f212 cdf1          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f213 ff06          .dw $ff06
00f214 6e69
00f215 6576
00f216 7472          .db "invert"
00f217 f1f7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f218 f219          .dw PFA_INVERT
                 PFA_INVERT:
00f219 9580          com tosl
00f21a 9590          com tosh
00f21b cde8          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f21c ff02          .dw $ff02
00f21d 2f32          .db "2/"
00f21e f213          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f21f f220          .dw PFA_2SLASH
                 PFA_2SLASH:
00f220 9595          asr tosh
00f221 9587          ror tosl
00f222 cde1          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f223 ff02          .dw $ff02
00f224 2a32          .db "2*"
00f225 f21c          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f226 f227          .dw PFA_2STAR
                 PFA_2STAR:
00f227 0f88          lsl tosl
00f228 1f99          rol tosh
00f229 cdda          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f22a ff03          .dw $ff03
00f22b 6e61
00f22c 0064          .db "and",0
00f22d f223          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f22e f22f          .dw PFA_AND
                 PFA_AND:
00f22f 9109          ld temp0, Y+
00f230 9119          ld temp1, Y+
00f231 2380          and tosl, temp0
00f232 2391          and tosh, temp1
00f233 cdd0          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f234 ff02          .dw $ff02
00f235 726f          .db "or"
00f236 f22a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f237 f238          .dw PFA_OR
                 PFA_OR:
00f238 9109          ld temp0, Y+
00f239 9119          ld temp1, Y+
00f23a 2b80          or tosl, temp0
00f23b 2b91          or tosh, temp1
00f23c cdc7          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f23d ff03          .dw $ff03
00f23e 6f78
00f23f 0072          .db "xor",0
00f240 f234          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f241 f242          .dw PFA_XOR
                 PFA_XOR:
00f242 9109          ld temp0, Y+
00f243 9119          ld temp1, Y+
00f244 2780          eor tosl, temp0
00f245 2791          eor tosh, temp1
00f246 cdbd          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f247 ff02          .dw $ff02
00f248 2b31          .db "1+"
00f249 f23d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f24a f24b          .dw PFA_1PLUS
                 PFA_1PLUS:
00f24b 9601          adiw tosl,1
00f24c cdb7          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f24d ff02          .dw $ff02 
00f24e 2d31          .db "1-"
00f24f f247          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f250 f251          .dw PFA_1MINUS
                 PFA_1MINUS:
00f251 9701          sbiw tosl, 1
00f252 cdb1          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f253 ff06          .dw $ff06
00f254 736c
00f255 6968
00f256 7466          .db "lshift"
00f257 f24d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f258 f259          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f259 01fc          movw zl, tosl
00f25a 9189
00f25b 9199          loadtos
                 PFA_LSHIFT1:
00f25c 9731          sbiw zl, 1
00f25d f01a          brmi PFA_LSHIFT2
00f25e 0f88          lsl tosl
00f25f 1f99          rol tosh
00f260 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f261 cda2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f262 ff06          .dw $ff06
00f263 7372
00f264 6968
00f265 7466          .db "rshift"
00f266 f253          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f267 f268          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f268 01fc          movw zl, tosl
00f269 9189
00f26a 9199          loadtos
                 PFA_RSHIFT1:
00f26b 9731          sbiw zl, 1
00f26c f01a          brmi PFA_RSHIFT2
00f26d 9596          lsr tosh
00f26e 9587          ror tosl
00f26f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f270 cd93          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f271 ff02          .dw $ff02
00f272 212b          .db "+!"
00f273 f262          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f274 f275          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f275 01fc          movw zl, tosl
00f276 9189
00f277 9199          loadtos
00f278 8120          ldd temp2, Z+0
00f279 8131          ldd temp3, Z+1
00f27a 0f82          add tosl, temp2
00f27b 1f93          adc tosh, temp3
00f27c 8380          std Z+0, tosl
00f27d 8391          std Z+1, tosh
00f27e 9189
00f27f 9199          loadtos
00f280 cd83          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f281 ff03          .dw $ff03
00f282 7072
00f283 0040          .db "rp@",0
00f284 f271          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f285 f286          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f286 939a
00f287 938a          savetos
00f288 b78d          in tosl, SPL
00f289 b79e          in tosh, SPH
00f28a cd79          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f28b ff03          .dw $ff03
00f28c 7072
00f28d 0021          .db "rp!",0
00f28e f281          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f28f f290          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f290 b72f          in temp2, SREG
00f291 94f8          cli
00f292 bf8d          out SPL, tosl
00f293 bf9e          out SPH, tosh
00f294 bf2f          out SREG, temp2
00f295 9189
00f296 9199          loadtos
00f297 cd6c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f298 ff03          .dw $ff03
00f299 7073
00f29a 0040          .db "sp@",0
00f29b f28b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f29c f29d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f29d 939a
00f29e 938a          savetos
00f29f 01ce          movw tosl, yl
00f2a0 cd63          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f2a1 ff03          .dw $ff03
00f2a2 7073
00f2a3 0021          .db "sp!",0
00f2a4 f298          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f2a5 f2a6          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a6 01ec          movw yl, tosl
00f2a7 9189
00f2a8 9199          loadtos
00f2a9 cd5a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2aa f2ab          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2ab 01fd          movw zl, xl
00f2ac 2755
00f2ad 0fee
00f2ae 1fff
00f2af 1f55
00f2b0 bf5b
00f2b1 9107
00f2b2 9117          readflashcell temp0,temp1
00f2b3 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2b4 9129          ld temp2, Y+
00f2b5 9139          ld temp3, Y+
                 PFA_DODO1:
00f2b6 931f          push temp1
00f2b7 930f          push temp0
00f2b8 933f          push temp3
00f2b9 932f          push temp2
00f2ba 939f          push tosh
00f2bb 938f          push tosl
00f2bc 9189
00f2bd 9199          loadtos
00f2be cd45          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
00f2bf f2c0          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2c0 01fd          movw zl, xl
00f2c1 2755
00f2c2 0fee
00f2c3 1fff
00f2c4 1f55
00f2c5 bf5b
00f2c6 9107
00f2c7 9117          readflashcell temp0,temp1
00f2c8 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2c9 9129          ld temp2, Y+
00f2ca 9139          ld temp3, Y+
                     ; now check for equality
00f2cb 1782          cp tosl, temp2
00f2cc 0793          cpc tosh, temp3
00f2cd f741          brne PFA_DODO1
                     ; both values are the same -> skip loop
00f2ce 01d8          movw xl, temp0
00f2cf 9189
00f2d0 9199          loadtos
00f2d1 cd32          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2d2 ff01          .dw $FF01
00f2d3 0069          .db "i",0
00f2d4 f2a1          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2d5 f10f          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2d6 f2d7          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2d7 91ef          pop zl
00f2d8 91ff          pop zh
00f2d9 0fe8          add zl, tosl
00f2da 1ff9          adc zh, tosh
00f2db 2f19          mov temp1, tosh
00f2dc 9189
00f2dd 9199          loadtos
                 PFA_DOPLUSLOOP4: 
00f2de 912f          pop temp2
00f2df 913f          pop temp3
00f2e0 17e2          cp zl, temp2
00f2e1 07f3          cpc zh, temp3
00f2e2 ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
00f2e3 c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
00f2e4 f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
00f2e5 c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
00f2e6 f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
00f2e7 933f          push temp3
00f2e8 932f          push temp2
00f2e9 93ff          push zh
00f2ea 93ef          push zl
00f2eb cd44          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
00f2ec 910f          pop  temp0
00f2ed 911f          pop  temp1  ; remove leave destination
00f2ee 9611          adiw xl, 1 ; skip branch-back address
00f2ef cd14          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2f0 f2f1          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2f1 91ef          pop zl
00f2f2 91ff          pop zh
00f2f3 9631          adiw zl,1
00f2f4 912f          pop temp2
00f2f5 913f          pop temp3
00f2f6 17e2          cp zl, temp2
00f2f7 07f3          cpc zh, temp3
00f2f8 f399          breq PFA_DOPLUSLOOP1
00f2f9 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2fa ff06          .dw $ff06
00f2fb 6e75
00f2fc 6f6c
00f2fd 706f          .db "unloop"
00f2fe f2d2          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2ff f300          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f300 911f          pop temp1
00f301 910f          pop temp0
00f302 911f          pop temp1
00f303 910f          pop temp0
00f304 911f          pop temp1
00f305 910f          pop temp0
00f306 ccfd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f307 ff06          .dw $ff06
00f308 6d63
00f309 766f
00f30a 3e65          .db "cmove>"
00f30b f2fa          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f30c f30d          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f30d 93bf          push xh
00f30e 93af          push xl
00f30f 91e9          ld zl, Y+
00f310 91f9          ld zh, Y+ ; addr-to
00f311 91a9          ld xl, Y+
00f312 91b9          ld xh, Y+ ; addr-from
00f313 2f09          mov temp0, tosh
00f314 2b08          or temp0, tosl
00f315 f041          brbs 1, PFA_CMOVE_G1
00f316 0fe8          add zl, tosl
00f317 1ff9          adc zh, tosh
00f318 0fa8          add xl, tosl
00f319 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f31a 911e          ld temp1, -X
00f31b 9312          st -Z, temp1
00f31c 9701          sbiw tosl, 1
00f31d f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f31e 91af          pop xl
00f31f 91bf          pop xh
00f320 9189
00f321 9199          loadtos
00f322 cce1          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f323 ff02          .dw $ff02
00f324 3c3e          .db "><"
00f325 f307          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f326 f327          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f327 2f09          mov temp0, tosh
00f328 2f98          mov tosh, tosl
00f329 2f80          mov tosl, temp0
00f32a ccd9          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f32b ff03          .dw $ff03
00f32c 7075
00f32d 0040          .db "up@",0
00f32e f323          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f32f f330          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f330 939a
00f331 938a          savetos
00f332 01c2          movw tosl, upl
00f333 ccd0          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f334 ff03          .dw $ff03
00f335 7075
00f336 0021          .db "up!",0
00f337 f32b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f338 f339          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f339 012c          movw upl, tosl
00f33a 9189
00f33b 9199          loadtos
00f33c ccc7          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
00f33d ff03          .dw $ff03
00f33e 3e73
00f33f 0064          .db "s>d",0
00f340 f334          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00f341 f000          .dw DO_COLON
                 PFA_S2D:
00f342 f0be          .dw XT_DUP
00f343 f13f          .dw XT_LESSZERO
                 .include "words/not.asm"
00f344 f020      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
00f345 ff03          .dw $ff03
00f346 6f6e
00f347 0074          .db "not",0
00f348 f33d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
00f349 f000          .dw DO_COLON
                 PFA_NOT:
00f34a f12a          .dw XT_EQUALZERO
00f34b f020          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f34c ff02          .dw $ff02
00f34d 6521          .db "!e"
00f34e f345          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f34f f350          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f350 01fc          movw zl, tosl
00f351 9189
00f352 9199          loadtos
00f353 b72f          in_ temp2, SREG
00f354 94f8          cli
00f355 d028          rcall PFA_FETCHE2
00f356 b500          in_  temp0, EEDR
00f357 1708          cp temp0,tosl
00f358 f009          breq PFA_STOREE3
00f359 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f35a 9631          adiw zl,1
00f35b d022          rcall PFA_FETCHE2
00f35c b500          in_  temp0, EEDR
00f35d 1709          cp temp0,tosh
00f35e f011          breq PFA_STOREE4
00f35f 2f89          mov tosl, tosh
00f360 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f361 bf2f          out_ SREG, temp2
00f362 9189
00f363 9199          loadtos
00f364 cc9f          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f365 99f9          sbic EECR, EEPE
00f366 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f367 b707          in_ temp0, SPMCSR
00f368 fd00          sbrc temp0,SPMEN
00f369 cffd          rjmp PFA_STOREE2
                 
00f36a bdf2          out_ EEARH,zh
00f36b bde1          out_ EEARL,zl
00f36c bd80          out_ EEDR, tosl
00f36d 9afa          sbi EECR,EEMPE
00f36e 9af9          sbi EECR,EEPE
                 
00f36f 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f370 ff02          .dw $ff02
00f371 6540          .db "@e"
00f372 f34c          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f373 f374          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f374 b72f          in_ temp2, SREG
00f375 94f8          cli
00f376 01fc          movw zl, tosl
00f377 d006          rcall PFA_FETCHE2
00f378 b580          in_ tosl, EEDR
                 
00f379 9631          adiw zl,1
                 
00f37a d003          rcall PFA_FETCHE2
00f37b b590          in_  tosh, EEDR
00f37c bf2f          out_ SREG, temp2
00f37d cc86          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f37e 99f9          sbic EECR, EEPE
00f37f cffe          rjmp PFA_FETCHE2
                 
00f380 bdf2          out_ EEARH,zh
00f381 bde1          out_ EEARL,zl
                 
00f382 9af8          sbi EECR,EERE
00f383 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f384 ff02          .dw $ff02
00f385 6921          .db "!i"
00f386 f370          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f387 089b          .dw PFA_DODEFER
                 PFA_STOREI:
00f388 000a          .dw EE_STOREI
00f389 085f          .dw XT_EDEFERFETCH
00f38a 0864          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f38b ff09          .dw $ff09
00f38c 2128
00f38d 2d69
00f38e 726e
00f38f 7777
00f390 0029          .db "(!i-nrww)",0
00f391 f384          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f392 f393          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f393 b71f        in temp1,SREG
00f394 931f        push temp1
00f395 94f8        cli
                 
00f396 019c        movw temp2, tosl ; save the (word) address
00f397 9189
00f398 9199        loadtos          ; get the new value for the flash cell
00f399 93af        push xl
00f39a 93bf        push xh
00f39b 93cf        push yl
00f39c 93df        push yh
00f39d d009        rcall DO_STOREI_atmega
00f39e 91df        pop yh
00f39f 91cf        pop yl
00f3a0 91bf        pop xh
00f3a1 91af        pop xl
                   ; finally clear the stack
00f3a2 9189
00f3a3 9199        loadtos
00f3a4 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f3a5 bf1f        out SREG,temp1
                 
00f3a6 cc5d        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f3a7 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f3a8 94e0        com temp4
00f3a9 94f0        com temp5
00f3aa 218e        and tosl, temp4
00f3ab 219f        and tosh, temp5
00f3ac 2b98        or tosh, tosl
00f3ad f019        breq DO_STOREI_writepage 
                 
00f3ae 01f9          movw zl, temp2
00f3af e002          ldi temp0,(1<<PGERS)
00f3b0 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3b1 01f9        movw zl, temp2
00f3b2 e004        ldi temp0,(1<<PGWRT)
00f3b3 d020        rcall dospm
                 
                   ; reenable RWW section
00f3b4 01f9        movw zl, temp2
00f3b5 e100        ldi temp0,(1<<RWWSRE)
00f3b6 d01d        rcall dospm
00f3b7 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3b8 01f9        movw zl, temp2
                   ; get the beginning of page
00f3b9 78e0        andi zl,low(pagemask)
00f3ba 7fff        andi zh,high(pagemask)
00f3bb 01ef        movw y, z
                   ; loop counter (in words)
00f3bc e8a0        ldi xl,low(pagesize)
00f3bd e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3be 01fe        movw z, y
00f3bf 2755
00f3c0 0fee
00f3c1 1fff
00f3c2 1f55
00f3c3 bf5b
00f3c4 9147
00f3c5 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3c6 01fe        movw z, y
00f3c7 17e2        cp zl, temp2
00f3c8 07f3        cpc zh, temp3
00f3c9 f011        breq pageload_newdata
00f3ca 010a          movw r0, temp6
00f3cb c002          rjmp pageload_cont
                 pageload_newdata:
00f3cc 017a          movw temp4, temp6
00f3cd 010c          movw r0, tosl
                 pageload_cont:
00f3ce 2700        clr temp0
00f3cf d004        rcall dospm
00f3d0 9621        adiw y, 1
00f3d1 9711        sbiw x, 1
00f3d2 f759        brne pageload_loop
                 
                 pageload_done:
00f3d3 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3d4 99f9        sbic EECR, EEPE
00f3d5 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3d6 b717        in_  temp1, SPMCSR
00f3d7 fd10        sbrc temp1, SPMEN
00f3d8 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3d9 2755
00f3da 0fee
00f3db 1fff
00f3dc 1f55
00f3dd bf5b        writeflashcell
                   ; execute spm
00f3de 6001        ori temp0, (1<<SPMEN)
00f3df bf07        out_ SPMCSR,temp0
00f3e0 95e8        spm
00f3e1 9508        ret
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3e2 ff02          .dw $ff02
00f3e3 6940          .db "@i"
00f3e4 f38b          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3e5 f3e6          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3e6 01fc          movw zl, tosl
00f3e7 2755
00f3e8 0fee
00f3e9 1fff
00f3ea 1f55
00f3eb bf5b
00f3ec 9187
00f3ed 9197          readflashcell tosl,tosh
00f3ee cc15          jmp_ DO_NEXT
                 ;.include "dict_interrupt.inc"
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
00f3ef 0007          .dw $0007
00f3f0 696c
00f3f1 6574
00f3f2 6172
00f3f3 006c          .db "literal",0
00f3f4 f3e2          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
00f3f5 f000          .dw DO_COLON
                 PFA_LITERAL:
00f3f6 026c          .dw XT_COMPILE
00f3f7 f040          .dw XT_DOLITERAL
00f3f8 0277          .dw XT_COMMA
00f3f9 f020          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
00f3fa 0008        .dw $0008
00f3fb 6c73
00f3fc 7469
00f3fd 7265
00f3fe 6c61        .db "sliteral"
00f3ff f3ef        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00f400 f000          .dw DO_COLON
                 PFA_SLITERAL:
00f401 026c          .dw XT_COMPILE
00f402 045c          .dw XT_DOSLITERAL    ; ( -- addr n)
00f403 046f          .dw XT_SCOMMA
00f404 f020          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
00f405 f000          .dw DO_COLON
                 PFA_GMARK:
00f406 0220          .dw XT_DP
00f407 026c          .dw XT_COMPILE
00f408 ffff          .dw -1           ; ffff does not erase flash
00f409 f020          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00f40a f000          .dw DO_COLON
                 PFA_GRESOLVE:
00f40b 080e          .dw XT_QSTACK
00f40c 0220          .dw XT_DP
00f40d f0d1          .dw XT_SWAP
00f40e f387          .dw XT_STOREI
00f40f f020          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00f410 f000          .dw DO_COLON
                 PFA_LMARK:
00f411 0220          .dw XT_DP
00f412 f020          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00f413 f000          .dw DO_COLON
                 PFA_LRESOLVE:
00f414 080e          .dw XT_QSTACK
00f415 0277          .dw XT_COMMA
00f416 f020          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
00f417 0005          .dw $0005
00f418 6861
00f419 6165
00f41a 0064          .db "ahead",0
00f41b f3fa          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
00f41c f000          .dw DO_COLON
                 PFA_AHEAD:
00f41d 026c          .dw XT_COMPILE
00f41e f02f          .dw XT_DOBRANCH
00f41f f405          .dw XT_GMARK
00f420 f020          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
00f421 0002          .dw $0002
00f422 6669          .db "if"
00f423 f417          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
00f424 f000          .dw DO_COLON
                 PFA_IF:
00f425 026c          .dw XT_COMPILE
00f426 f039          .dw XT_DOCONDBRANCH
00f427 f405          .dw XT_GMARK
00f428 f020          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
00f429 0004          .dw $0004
00f42a 6c65
00f42b 6573          .db "else"
00f42c f421          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
00f42d f000          .dw DO_COLON
                 PFA_ELSE:
00f42e 026c          .dw XT_COMPILE
00f42f f02f          .dw XT_DOBRANCH
00f430 f405          .dw XT_GMARK
00f431 f0d1          .dw XT_SWAP
00f432 f40a          .dw XT_GRESOLVE
00f433 f020          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
00f434 0004          .dw $0004
00f435 6874
00f436 6e65          .db "then"
00f437 f429          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00f438 f000          .dw DO_COLON
                 PFA_THEN:
00f439 f40a          .dw XT_GRESOLVE
00f43a f020          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
00f43b 0005          .dw $0005
00f43c 6562
00f43d 6967
00f43e 006e          .db "begin",0
00f43f f434          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00f440 f000          .dw DO_COLON
                 PFA_BEGIN:
00f441 f410          .dw XT_LMARK
00f442 f020          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
00f443 0005          .dw $0005
00f444 6877
00f445 6c69
00f446 0065          .db "while",0
00f447 f43b          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00f448 f000          .dw DO_COLON
                 PFA_WHILE:
00f449 026c          .dw XT_COMPILE
00f44a f039          .dw XT_DOCONDBRANCH
00f44b f405          .dw XT_GMARK
00f44c f0d1          .dw XT_SWAP
00f44d f020          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
00f44e 0006          .dw $0006
00f44f 6572
00f450 6570
00f451 7461          .db "repeat"
00f452 f443          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
00f453 f000          .dw DO_COLON
                 PFA_REPEAT:
00f454 f466          .dw XT_AGAIN
00f455 f40a          .dw XT_GRESOLVE
00f456 f020          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
00f457 0005          .dw $0005
00f458 6e75
00f459 6974
00f45a 006c          .db "until",0
00f45b f44e          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00f45c f000          .dw DO_COLON
                 PFA_UNTIL:
00f45d 026c          .dw XT_COMPILE
00f45e f039          .dw XT_DOCONDBRANCH
00f45f f413          .dw XT_LRESOLVE
00f460 f020          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
00f461 0005          .dw $0005
00f462 6761
00f463 6961
00f464 006e          .db "again",0
00f465 f457          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00f466 f000          .dw DO_COLON
                 PFA_AGAIN:
00f467 026c          .dw XT_COMPILE
00f468 f02f          .dw XT_DOBRANCH
00f469 f413          .dw XT_LRESOLVE
00f46a f020          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
00f46b 0002          .dw $0002
00f46c 6f64          .db "do"
00f46d f461          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
00f46e f000          .dw DO_COLON
                 PFA_DO:
00f46f 026c          .dw XT_COMPILE
00f470 f2aa          .dw XT_DODO
00f471 f405          .dw XT_GMARK
00f472 f410          .dw XT_LMARK
00f473 f020          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
00f474 0004          .dw $0004
00f475 6f6c
00f476 706f          .db "loop"
00f477 f46b          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00f478 f000          .dw DO_COLON
                 PFA_LOOP:
00f479 026c          .dw XT_COMPILE
00f47a f2f0          .dw XT_DOLOOP
00f47b f413          .dw XT_LRESOLVE
00f47c f40a          .dw XT_GRESOLVE
00f47d f020          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
00f47e 0005          .dw $0005
00f47f 6c2b
00f480 6f6f
00f481 0070          .db "+loop",0
00f482 f474          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00f483 f000          .dw DO_COLON
                 PFA_PLUSLOOP:
00f484 026c          .dw XT_COMPILE
00f485 f2d6          .dw XT_DOPLUSLOOP
00f486 f413          .dw XT_LRESOLVE
00f487 f40a          .dw XT_GRESOLVE
00f488 f020          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
00f489 ff05         .dw $FF05
00f48a 656c
00f48b 7661
00f48c 0065         .db "leave",0
00f48d f47e         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00f48e f48f          .dw PFA_LEAVE
                 PFA_LEAVE:
00f48f 910f          pop temp0  ; drop limit and counter from returnstack
00f490 911f          pop temp1
00f491 910f          pop temp0
00f492 911f          pop temp1
00f493 91af          pop xl
00f494 91bf          pop xh
00f495 cb6e          jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
00f496 0003          .dw $0003
00f497 643f
00f498 006f          .db "?do",0
00f499 f489          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00f49a f000          .dw DO_COLON
                 PFA_QDO:
00f49b 026c          .dw XT_COMPILE
00f49c f2bf          .dw XT_DOQDO
00f49d f405          .dw XT_GMARK
00f49e f410          .dw XT_LMARK
00f49f f020          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
00f4a0 ff06          .dw $ff06
00f4a1 7263
00f4a2 6165
00f4a3 6574          .db "create"
00f4a4 f496          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
00f4a5 f000          .dw DO_COLON
                 PFA_CREATE:
00f4a6 0245          .dw XT_DOCREATE
00f4a7 f4d4          .dw XT_REVEAL
00f4a8 026c          .dw XT_COMPILE
00f4a9 f05b          .dw PFA_DOCONSTANT
00f4aa f020          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
00f4ab ff06          .dw $ff06
00f4ac 6568
00f4ad 6461
00f4ae 7265          .db "header"
00f4af f4a0          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
00f4b0 f000          .dw DO_COLON
                 PFA_HEADER:
00f4b1 0220          .dw XT_DP           ; the new Name Field
00f4b2 f105          .dw XT_TO_R
00f4b3 f105          .dw XT_TO_R		; ( R: NFA WID )
00f4b4 f0be          .dw XT_DUP    
00f4b5 f16e          .dw XT_GREATERZERO 
00f4b6 f039          .dw XT_DOCONDBRANCH
00f4b7 f4c2          .dw PFA_HEADER1
00f4b8 f0be          .dw XT_DUP
00f4b9 f040          .dw XT_DOLITERAL
00f4ba ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00f4bb f237          .dw XT_OR
00f4bc 0473          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00f4bd f0fc          .dw XT_R_FROM
00f4be f373          .dw XT_FETCHE
00f4bf 0277          .dw XT_COMMA
00f4c0 f0fc          .dw XT_R_FROM
00f4c1 f020          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
00f4c2 f040          .dw XT_DOLITERAL
00f4c3 fff0          .dw -16
00f4c4 0528          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
00f4c5 ff07          .dw $ff07
00f4c6 6c77
00f4c7 6373
00f4c8 706f
00f4c9 0065          .db "wlscope",0
00f4ca f4ab          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00f4cb 089b          .dw PFA_DODEFER
                 PFA_WLSCOPE:
00f4cc 0034          .dw EE_WLSCOPE
00f4cd 085f          .dw XT_EDEFERFETCH
00f4ce 0864          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
00f4cf ff06          .dw $ff06
00f4d0 6572
00f4d1 6576
00f4d2 6c61          .db "reveal"
00f4d3 f4c5          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
00f4d4 f000          .dw DO_COLON
                 PFA_REVEAL:
00f4d5 f040          .dw XT_DOLITERAL
00f4d6 028b          .dw COLON_SMUDGE+0
00f4d7 f086          .dw XT_FETCH
00f4d8 f0c6          .dw XT_QDUP
00f4d9 f039          .dw XT_DOCONDBRANCH
00f4da f4e3          .dw PFA_REVEAL1
                 ;
00f4db f040          .dw XT_DOLITERAL
00f4dc 028d          .dw COLON_SMUDGE+2
00f4dd f086          .dw XT_FETCH		; ( NFA WID )
00f4de f34f          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
00f4df f146          .dw XT_ZERO
00f4e0 f040          .dw XT_DOLITERAL
00f4e1 028b          .dw COLON_SMUDGE+0
00f4e2 f08e          .dw XT_STORE
                 PFA_REVEAL1:
00f4e3 f020          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
00f4e4 ff06          .dw $ff06
00f4e5 616c
00f4e6 6574
00f4e7 7473          .db "latest"
00f4e8 f4cf          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
00f4e9 f04e          .dw PFA_DOVARIABLE
                 PFA_LATEST:
00f4ea 031d          .dw ram_LATEST
                 
                 .dseg
00031d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
00f4eb 0005          .dw $0005
00f4ec 6f64
00f4ed 7365
00f4ee 003e          .db "does>",0
00f4ef f4e4          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
00f4f0 f000          .dw DO_COLON
                 PFA_DOES:
00f4f1 026c          .dw XT_COMPILE
00f4f2 f502          .dw XT_DODOES
00f4f3 026c          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00f4f4 940e          .dw $940e       ; the address of this compiled
00f4f5 026c          .dw XT_COMPILE  ; code will replace the XT of the 
00f4f6 f4f8          .dw DO_DODOES   ; word that CREATE created
00f4f7 f020          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
00f4f8 939a
00f4f9 938a          savetos
00f4fa 01cb          movw tosl, wl
00f4fb 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
00f4fc 917f          pop wh
00f4fd 916f          pop wl
                 
00f4fe 93bf          push XH
00f4ff 93af          push XL
00f500 01db          movw XL, wl
00f501 cb02          jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00f502 f000          .dw DO_COLON
                 PFA_DODOES:
00f503 f0fc          .dw XT_R_FROM
00f504 f040          .dw XT_DOLITERAL
00f505 028d          .dw COLON_SMUDGE+2
00f506 f086          .dw XT_FETCH
00f507 f373          .dw XT_FETCHE
00f508 f6b0          .dw XT_NFA2LFA
00f509 f24a          .dw XT_1PLUS   ; lfa>xt
                 
00f50a f387          .dw XT_STOREI
00f50b f020          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
00f50c ff01          .dw $ff01
00f50d 003a          .db ":",0
00f50e f4eb          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
00f50f f000          .dw DO_COLON
                 PFA_COLON:
00f510 0245          .dw XT_DOCREATE
00f511 0220          .dw XT_DP
00f512 f4e9          .dw XT_LATEST
00f513 f08e          .dw XT_STORE
00f514 026c          .dw XT_COMPILE
00f515 f000          .dw DO_COLON
00f516 f533          .dw XT_RBRACKET
00f517 f020          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00f518 ff07          .dw $ff07
00f519 6e3a
00f51a 6e6f
00f51b 6d61
00f51c 0065          .db ":noname",0
00f51d f50c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
00f51e f000          .dw DO_COLON
                 PFA_COLONNONAME:
00f51f 0220          .dw XT_DP
00f520 f0be          .dw XT_DUP
00f521 f4e9          .dw XT_LATEST
00f522 f08e          .dw XT_STORE
                 
00f523 026c          .dw XT_COMPILE
00f524 f000          .dw DO_COLON
                 
00f525 f533          .dw XT_RBRACKET
00f526 f020          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
00f527 0001          .dw $0001
00f528 003b          .db $3b,0
00f529 f518          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00f52a f000          .dw DO_COLON
                 PFA_SEMICOLON:
00f52b 026c          .dw XT_COMPILE
00f52c f020          .dw XT_EXIT
00f52d f53c          .dw XT_LBRACKET
00f52e f4d4          .dw XT_REVEAL
00f52f f020          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
00f530 ff01          .dw $ff01
00f531 005d          .db "]",0
00f532 f527          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
00f533 f000          .dw DO_COLON
                 PFA_RBRACKET:
00f534 f040          .dw XT_DOLITERAL
00f535 0001          .dw 1
00f536 01bc          .dw XT_STATE
00f537 f08e          .dw XT_STORE
00f538 f020          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
00f539 0001          .dw $0001
00f53a 005b          .db "[",0
00f53b f530          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00f53c f000          .dw DO_COLON
                 PFA_LBRACKET:
00f53d f146          .dw XT_ZERO
00f53e 01bc          .dw XT_STATE
00f53f f08e          .dw XT_STORE
00f540 f020          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
00f541 ff08          .dw $ff08
00f542 6176
00f543 6972
00f544 6261
00f545 656c          .db "variable"
00f546 f539          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00f547 f000          .dw DO_COLON
                 PFA_VARIABLE:
00f548 0230          .dw XT_HERE
00f549 f554          .dw XT_CONSTANT
00f54a f040          .dw XT_DOLITERAL
00f54b 0002          .dw 2
00f54c 0239          .dw XT_ALLOT
00f54d f020          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
00f54e ff08          .dw $ff08
00f54f 6f63
00f550 736e
00f551 6174
00f552 746e          .db "constant"
00f553 f541          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
00f554 f000          .dw DO_COLON
                 PFA_CONSTANT:
00f555 0245          .dw XT_DOCREATE
00f556 f4d4          .dw XT_REVEAL
00f557 026c          .dw XT_COMPILE
00f558 f04e          .dw PFA_DOVARIABLE
00f559 0277          .dw XT_COMMA
00f55a f020          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00f55b ff04          .dw $ff04
00f55c 7375
00f55d 7265          .db "user"
00f55e f54e          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00f55f f000          .dw DO_COLON
                 PFA_USER:
00f560 0245          .dw XT_DOCREATE
00f561 f4d4          .dw XT_REVEAL
                 
00f562 026c          .dw XT_COMPILE
00f563 f061          .dw PFA_DOUSER
00f564 0277          .dw XT_COMMA
00f565 f020          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
00f566 ff05          .dw $ff05
00f567 6176
00f568 756c
00f569 0065          .db "value",0
00f56a f55b          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
00f56b f000          .dw DO_COLON
                 PFA_VALUE:
00f56c f075          .dw XT_DOVALUE
00f56d 0228          .dw XT_EDP
00f56e 0277          .dw XT_COMMA
00f56f 026c          .dw XT_COMPILE
00f570 f57b          .dw XT_EVALUEFETCH
00f571 026c          .dw XT_COMPILE
00f572 f57f          .dw XT_EVALUESTORE
00f573 0228          .dw XT_EDP
00f574 f0be          .dw XT_DUP
00f575 f24a          .dw XT_1PLUS
00f576 f24a          .dw XT_1PLUS
00f577 0853          .dw XT_DOTO
00f578 0229          .dw PFA_EDP
00f579 f34f          .dw XT_STOREE
00f57a f020          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
00f57b f000          .dw DO_COLON
                 PFA_EVALUEFETCH:
00f57c f3e5          .dw XT_FETCHI
00f57d f373          .dw XT_FETCHE
00f57e f020          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
00f57f f000          .dw DO_COLON
                 PFA_EVALUESTORE:
00f580 f3e5          .dw XT_FETCHI
00f581 f34f          .dw XT_STOREE
00f582 f020          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
00f583 0007          .dw $0007
00f584 6572
00f585 7563
00f586 7372
00f587 0065          .db "recurse",0
00f588 f566          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00f589 f000          .dw DO_COLON
                 PFA_RECURSE:
00f58a f4e9          .dw XT_LATEST
00f58b f086          .dw XT_FETCH
00f58c 0277          .dw XT_COMMA
00f58d f020          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00f58e ff09          .dw $ff09
00f58f 6d69
00f590 656d
00f591 6964
00f592 7461
00f593 0065          .db "immediate",0
00f594 f583          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00f595 f000          .dw DO_COLON
                 PFA_IMMEDIATE:
00f596 f672          .dw XT_GET_CURRENT
00f597 f373          .dw XT_FETCHE
00f598 f0be          .dw XT_DUP
00f599 f3e5          .dw XT_FETCHI
00f59a f040          .dw XT_DOLITERAL
00f59b 7fff          .dw $7fff
00f59c f22e          .dw XT_AND
00f59d f0d1          .dw XT_SWAP
00f59e f387          .dw XT_STOREI
00f59f f020          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
00f5a0 0006          .dw $0006
00f5a1 635b
00f5a2 6168
00f5a3 5d72          .db "[char]"
00f5a4 f58e          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
00f5a5 f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
00f5a6 026c          .dw XT_COMPILE
00f5a7 f040          .dw XT_DOLITERAL
00f5a8 05ab          .dw XT_CHAR
00f5a9 0277          .dw XT_COMMA
00f5aa f020          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
00f5ab 0006          .dw $0006
00f5ac 6261
00f5ad 726f
00f5ae 2274          .db "abort", $22
00f5af f5a0          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
00f5b0 f000          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
00f5b1 026c          .dw XT_COMPILE
00f5b2 f039          .dw XT_DOCONDBRANCH
00f5b3 0220          .dw XT_DP
00f5b4 026c          .dw XT_COMPILE
00f5b5 ffff          .dw -1
                     
00f5b6 f727          .dw XT_DOTSTRING
                     
00f5b7 026c          .dw XT_COMPILE
00f5b8 f040          .dw XT_DOLITERAL
                     
00f5b9 026c          .dw XT_COMPILE
00f5ba fffe          .dw -2
00f5bb 026c          .dw XT_COMPILE
00f5bc 0528          .dw XT_THROW
                     ; then
00f5bd 0220          .dw XT_DP
00f5be f0d1          .dw XT_SWAP
00f5bf f387          .dw XT_STOREI
00f5c0 f020          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
00f5c1 ff05          .dw $ff05
00f5c2 6261
00f5c3 726f
00f5c4 0074          .db "abort",0
00f5c5 f5ab          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
00f5c6 f000          .dw DO_COLON
                 PFA_ABORT:
00f5c7 f040          .dw XT_DOLITERAL
00f5c8 ffff          .dw -1
00f5c9 0528          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00f5ca ff04          .dw $ff04
00f5cb 6f63
00f5cc 6564          .db "code"
00f5cd f5c1          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00f5ce f000          .dw DO_COLON
                 PFA_CODE:
00f5cf 0245          .dw XT_DOCREATE
00f5d0 f4d4          .dw XT_REVEAL
00f5d1 0220          .dw XT_DP
00f5d2 f24a          .dw XT_1PLUS
00f5d3 0277          .dw XT_COMMA
00f5d4 f020          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
00f5d5 ff08          .dw $ff08
00f5d6 6e65
00f5d7 2d64
00f5d8 6f63
00f5d9 6564          .db "end-code"
00f5da f5ca          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00f5db f000          .dw DO_COLON
                 PFA_ENDCODE:
00f5dc 026c          .dw XT_COMPILE
00f5dd 940c          .dw $940c
00f5de 026c          .dw XT_COMPILE
00f5df f004          .dw DO_NEXT
00f5e0 f020          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00f5e1 ff0b          .dw $ff0b
00f5e2 6e65
00f5e3 6976
00f5e4 6f72
00f5e5 6d6e
00f5e6 6e65
00f5e7 0074          .db "environment",0
00f5e8 f5d5          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00f5e9 f04e          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00f5ea 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00f5eb ff09          .dw $ff09
00f5ec 6f77
00f5ed 6472
00f5ee 696c
00f5ef 7473
00f5f0 0073          .db "wordlists",0
00f5f1 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
00f5f2 f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00f5f3 f040          .dw XT_DOLITERAL
00f5f4 0008          .dw NUMWORDLISTS
00f5f5 f020          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00f5f6 ff04          .dw $ff04
00f5f7 702f
00f5f8 6461          .db "/pad"
00f5f9 f5eb          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00f5fa f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00f5fb f29c          .dw XT_SP_FETCH
00f5fc 01f6          .dw XT_PAD
00f5fd f1ae          .dw XT_MINUS
00f5fe f020          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
00f5ff ff05          .dw $ff05
00f600 682f
00f601 6c6f
00f602 0064          .db "/hold",0
00f603 f5f6          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00f604 f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
00f605 01f6          .dw XT_PAD
00f606 0230          .dw XT_HERE
00f607 f1ae          .dw XT_MINUS
00f608 f020          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
00f609 ff0a          .dw $ff0a
00f60a 6f66
00f60b 7472
00f60c 2d68
00f60d 616e
00f60e 656d          .db "forth-name"
00f60f f5ff          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00f610 f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00f611 045c          .dw XT_DOSLITERAL
00f612 0007          .dw 7
00f613 6d61
00f614 6f66
00f615 7472
00f616 0068          .db "amforth",0
00f617 f020          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
00f618 ff07          .dw $ff07
00f619 6576
00f61a 7372
00f61b 6f69
00f61c 006e          .db "version",0
00f61d f609          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00f61e f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
00f61f f040          .dw XT_DOLITERAL
00f620 0034          .dw 52
00f621 f020          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
00f622 ff03          .dw $ff03
00f623 7063
00f624 0075          .db "cpu",0
00f625 f618          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00f626 f000          .dw DO_COLON
                 PFA_EN_CPU:
00f627 f040          .dw XT_DOLITERAL
00f628 0075          .dw mcu_name
00f629 04be          .dw XT_ICOUNT
00f62a f020          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00f62b ff08          .dw $ff08
00f62c 636d
00f62d 2d75
00f62e 6e69
00f62f 6f66          .db "mcu-info"
00f630 f622          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00f631 f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
00f632 f040          .dw XT_DOLITERAL
00f633 0071          .dw mcu_info
00f634 f020          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
00f635 ff05          .dw $ff05
00f636 752f
00f637 6573
00f638 0072          .db "/user",0
00f639 f62b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00f63a f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
00f63b f040          .dw XT_DOLITERAL
00f63c 0026          .dw SYSUSERSIZE + APPUSERSIZE
00f63d f020          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
00f63e ff04          .dw $ff04
00f63f 6540
00f640 5d5b          .db "@e[]"
00f641 f5e1          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
00f642 f000          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
00f643 f0be          .dw XT_DUP
00f644 f373          .dw XT_FETCHE
00f645 f105          .dw XT_TO_R    ; save the counter to r-stack
00f646 f10e          .dw XT_R_FETCH
00f647 f146          .dw XT_ZERO
00f648 f0d1          .dw XT_SWAP    ; go from bigger to smaller addresses
00f649 f2bf          .dw XT_DOQDO
00f64a f654          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
00f64b f2d5          .dw XT_I
00f64c 01c9          .dw XT_CELLS ; ( -- ee-addr i*2 )
00f64d f0dc          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
00f64e f1b8          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
00f64f f373          .dw XT_FETCHE ;( -- ee-addr item_i )
00f650 f0d1          .dw XT_SWAP   ;( -- item_i ee-addr )
00f651 f14f          .dw XT_TRUE  ; shortcut for -1
00f652 f2d6          .dw XT_DOPLUSLOOP
00f653 f64b          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
00f654 01e2          .dw XT_2DROP
00f655 f0fc          .dw XT_R_FROM ; get the counter from r-stack
00f656 f020          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
00f657 ff04          .dw $ff04
00f658 6521
00f659 5d5b          .db "!e[]"
00f65a f63e          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
00f65b f000          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
00f65c 01d9          .dw XT_2DUP
00f65d f34f          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00f65e f0d1          .dw XT_SWAP    
00f65f f146          .dw XT_ZERO
00f660 f2bf          .dw XT_DOQDO
00f661 f668          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
00f662 01d1          .dw XT_CELLPLUS ; ( -- i_x e-addr )
00f663 f0d1          .dw XT_SWAP
00f664 f0dc          .dw XT_OVER      ; ( -- e-addr i_x e-addr
00f665 f34f          .dw XT_STOREE
00f666 f2f0          .dw XT_DOLOOP
00f667 f662          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
00f668 f0e6          .dw XT_DROP
00f669 f020          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
00f66a ff0b          .dw $ff0b
00f66b 6567
00f66c 2d74
00f66d 7563
00f66e 7272
00f66f 6e65
00f670 0074          .db "get-current",0
00f671 f657          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00f672 f000          .dw DO_COLON
                 PFA_GET_CURRENT:
00f673 f040          .dw XT_DOLITERAL
00f674 0010          .dw EE_CURRENT
00f675 f373          .dw XT_FETCHE
00f676 f020          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
00f677 ff09          .dw $ff09
00f678 6567
00f679 2d74
00f67a 726f
00f67b 6564
00f67c 0072          .db "get-order",0
00f67d f66a          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
00f67e f000          .dw DO_COLON
                 PFA_GET_ORDER:
00f67f f040          .dw XT_DOLITERAL
00f680 0014          .dw EE_ORDERLISTLEN
00f681 f642          .dw XT_FETCH_EE_ARRAY
00f682 f020          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
00f683 ff07          .dw $ff07
00f684 6f63
00f685 706d
00f686 7261
00f687 0065          .db "compare",0
00f688 f677          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
00f689 f68a          .dw PFA_COMPARE
                 PFA_COMPARE:
00f68a 93bf          push xh
00f68b 93af          push xl
00f68c 018c          movw temp0, tosl
00f68d 9189
00f68e 9199          loadtos
00f68f 01dc          movw xl, tosl
00f690 9189
00f691 9199          loadtos
00f692 019c          movw temp2, tosl
00f693 9189
00f694 9199          loadtos
00f695 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
00f696 90ed          ld temp4, X+
00f697 90f1          ld temp5, Z+
00f698 14ef          cp temp4, temp5
00f699 f451          brne PFA_COMPARE_NOTEQUAL
00f69a 950a          dec temp0
00f69b f019          breq PFA_COMPARE_ENDREACHED2
00f69c 952a          dec temp2
00f69d f7c1          brne PFA_COMPARE_LOOP
00f69e c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00f69f 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
00f6a0 2b02          or temp0, temp2
00f6a1 f411          brne PFA_COMPARE_CHECKLASTCHAR
00f6a2 2788          clr tosl
00f6a3 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
00f6a4 ef8f          ser tosl
00f6a5 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
00f6a6 2f98          mov tosh, tosl
00f6a7 91af          pop xl
00f6a8 91bf          pop xh
00f6a9 c95a          jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00f6aa ff07         .dw $ff07
00f6ab 666e
00f6ac 3e61
00f6ad 666c
00f6ae 0061         .db "nfa>lfa",0
00f6af f683         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
00f6b0 f000          .dw DO_COLON
                 PFA_NFA2LFA:
00f6b1 04be          .dw XT_ICOUNT 
00f6b2 f040          .dw XT_DOLITERAL
00f6b3 00ff          .dw $00ff
00f6b4 f22e          .dw XT_AND
00f6b5 f24a          .dw XT_1PLUS
00f6b6 f21f          .dw XT_2SLASH
00f6b7 f1b8          .dw XT_PLUS
00f6b8 f020          .dw XT_EXIT
                 ;.include "dict_usart.inc"
                 ;.include "dict_wl.inc"
                 ;.include "dict_mcu.inc"
                 ;.include "dict_minimum.inc"
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00f6b9 ff04          .dw $ff04
00f6ba 6966
00f6bb 6c6c          .db "fill"
00f6bc f6aa          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00f6bd f000          .dw DO_COLON
                 PFA_FILL:
00f6be f0ee          .dw XT_ROT
00f6bf f0ee          .dw XT_ROT
00f6c0 f146          .dw XT_ZERO
00f6c1 f2bf          .dw XT_DOQDO
00f6c2 f6c8          .dw PFA_FILL2
                 PFA_FILL1:
00f6c3 01d9          .dw XT_2DUP
00f6c4 f09a          .dw XT_CSTORE  ; ( -- c c-addr)
00f6c5 f24a          .dw XT_1PLUS
00f6c6 f2f0          .dw XT_DOLOOP
00f6c7 f6c3          .dw PFA_FILL1
                 PFA_FILL2:
00f6c8 f0e6          .dw XT_DROP
00f6c9 f0e6          .dw XT_DROP
00f6ca f020          .dw XT_EXIT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00f6cb ff03          .dw $ff03
00f6cc 3264
00f6cd 002a          .db "d2*",0
00f6ce f6b9          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00f6cf f6d0          .dw PFA_D2STAR
                 PFA_D2STAR:
00f6d0 9109          ld temp0, Y+
00f6d1 9119          ld temp1, Y+
00f6d2 0f00          lsl temp0
00f6d3 1f11          rol temp1
00f6d4 1f88          rol tosl
00f6d5 1f99          rol tosh
00f6d6 931a          st -Y, temp1
00f6d7 930a          st -Y, temp0
00f6d8 c92b          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00f6d9 ff02          .dw $ff02
00f6da 2b64          .db "d+"
00f6db f6cb          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00f6dc f6dd          .dw PFA_DPLUS
                 PFA_DPLUS:
00f6dd 9129          ld temp2, Y+
00f6de 9139          ld temp3, Y+
                 
00f6df 90e9          ld temp4, Y+
00f6e0 90f9          ld temp5, Y+
00f6e1 9149          ld temp6, Y+
00f6e2 9159          ld temp7, Y+
                 
00f6e3 0f24          add temp2, temp6
00f6e4 1f35          adc temp3, temp7
00f6e5 1d8e          adc tosl, temp4
00f6e6 1d9f          adc tosh, temp5
                     
00f6e7 933a          st -Y, temp3
00f6e8 932a          st -Y, temp2
00f6e9 c91a          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00f6ea ff02          .dw $ff02
00f6eb 2d64          .db "d-"
00f6ec f6d9          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00f6ed f6ee          .dw PFA_DMINUS
                 PFA_DMINUS:
00f6ee 9129          ld temp2, Y+
00f6ef 9139          ld temp3, Y+
                 
00f6f0 90e9          ld temp4, Y+
00f6f1 90f9          ld temp5, Y+
00f6f2 9149          ld temp6, Y+
00f6f3 9159          ld temp7, Y+
                 
00f6f4 1b42          sub temp6, temp2
00f6f5 0b53          sbc temp7, temp3
00f6f6 0ae8          sbc temp4, tosl
00f6f7 0af9          sbc temp5, tosh
                 
00f6f8 935a          st -Y, temp7
00f6f9 934a          st -Y, temp6
00f6fa 01c7          movw tosl, temp4
00f6fb c908          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00f6fc ff07          .dw $ff07
00f6fd 6964
00f6fe 766e
00f6ff 7265
00f700 0074          .db "dinvert",0
00f701 f6ea          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00f702 f703          .dw PFA_DINVERT
                 PFA_DINVERT:
00f703 9109          ld temp0, Y+
00f704 9119          ld temp1, Y+
00f705 9580          com tosl
00f706 9590          com tosh
00f707 9500          com temp0
00f708 9510          com temp1
00f709 931a          st -Y, temp1
00f70a 930a          st -Y, temp0
00f70b c8f8          jmp_ DO_NEXT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
00f70c ff02          .dw $ff02
00f70d 2e75          .db "u."
00f70e f6fc          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00f70f f000          .dw DO_COLON
                 PFA_UDOT:
00f710 f146          .dw XT_ZERO
00f711 0401          .dw XT_UDDOT
00f712 f020          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
00f713 ff02          .dw $ff02
00f714 732e          .db ".s"
00f715 f70c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
00f716 f000          .dw DO_COLON
                 PFA_DOTS:
00f717 076f          .dw XT_SP0
00f718 f29c          .dw XT_SP_FETCH
00f719 01d1          .dw XT_CELLPLUS
00f71a f2bf          .dw XT_DOQDO
00f71b f723          .dw PFA_DOTS2
                 PFA_DOTS1:
00f71c f2d5          .dw XT_I
00f71d f086          .dw XT_FETCH 
00f71e f70f          .dw XT_UDOT
00f71f f040          .dw XT_DOLITERAL
00f720 0002          .dw 2
00f721 f2d6          .dw XT_DOPLUSLOOP
00f722 f71c          .dw PFA_DOTS1
                 PFA_DOTS2:
00f723 f020          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
00f724 0002          .dw $0002
00f725 222e          .db ".",$22
00f726 f713          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00f727 f000          .dw DO_COLON
                 PFA_DOTSTRING:
00f728 f72f          .dw XT_SQUOTE
00f729 026c          .dw XT_COMPILE
00f72a 0493          .dw XT_ITYPE
00f72b f020          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
00f72c 0002        .dw $0002
00f72d 2273        .db "s",$22
00f72e f724        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00f72f f000          .dw DO_COLON
                 PFA_SQUOTE:
00f730 f040          .dw XT_DOLITERAL
00f731 0022          .dw $22
00f732 0669          .dw XT_PARSE       ; ( -- addr n)
00f733 01bc          .dw XT_STATE
00f734 f086          .dw XT_FETCH
00f735 f039          .dw XT_DOCONDBRANCH
00f736 f73a          .dw PFA_SQUOTE1
00f737 026c            .dw XT_COMPILE
00f738 045c            .dw XT_DOSLITERAL    ; ( -- addr n)
00f739 046f            .dw XT_SCOMMA
                 PFA_SQUOTE1:
00f73a f020          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
00f73b ff06          .dw $ff06
00f73c 6445
00f73d 6665
00f73e 7265          .db "Edefer"
00f73f f72c          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
00f740 f000          .dw DO_COLON
                 PFA_EDEFER:
00f741 0245          .dw XT_DOCREATE
00f742 f4d4          .dw XT_REVEAL
00f743 026c          .dw XT_COMPILE
00f744 089b          .dw PFA_DODEFER
                 
00f745 0228          .dw XT_EDP
00f746 f0be          .dw XT_DUP
00f747 0277          .dw XT_COMMA
00f748 026c          .dw XT_COMPILE
00f749 085f          .dw XT_EDEFERFETCH
00f74a 026c          .dw XT_COMPILE
00f74b 0864          .dw XT_EDEFERSTORE
00f74c 01d1          .dw XT_CELLPLUS
00f74d 0853          .dw XT_DOTO
00f74e 0229          .dw PFA_EDP
00f74f f020          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
00f750 ff06          .dw $ff06
00f751 6452
00f752 6665
00f753 7265          .db "Rdefer"
00f754 f73b          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
00f755 f000          .dw DO_COLON
                 PFA_RDEFER:
00f756 0245          .dw XT_DOCREATE
00f757 f4d4          .dw XT_REVEAL
                 
00f758 026c          .dw XT_COMPILE
00f759 089b          .dw PFA_DODEFER
                 
00f75a 0230          .dw XT_HERE
00f75b 0277          .dw XT_COMMA
00f75c f040          .dw XT_DOLITERAL
00f75d 0002          .dw 2
00f75e 0239          .dw XT_ALLOT
                 
00f75f 026c          .dw XT_COMPILE
00f760 0869          .dw XT_RDEFERFETCH
00f761 026c          .dw XT_COMPILE
00f762 086e          .dw XT_RDEFERSTORE
00f763 f020          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
00f764 0002          .dw $0002
00f765 7369          .db "is"
00f766 f750          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
00f767 f000          .dw DO_COLON
                 PFA_IS:
00f768 01bc          .dw XT_STATE
00f769 f086          .dw XT_FETCH
00f76a f039          .dw XT_DOCONDBRANCH
00f76b f770          .dw PFA_IS1
00f76c 0283          .dw XT_BRACKETTICK
00f76d 026c          .dw XT_COMPILE
00f76e 0886          .dw XT_DEFERSTORE
00f76f f020          .dw XT_EXIT
                 PFA_IS1:
00f770 04fb          .dw XT_TICK
00f771 0886          .dw XT_DEFERSTORE
00f772 f020          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
00f773 ff0b          .dw $ff0b
00f774 7061
00f775 6c70
00f776 7574
00f777 6e72
00f778 656b
00f779 0079          .db "applturnkey",0
00f77a f764          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
00f77b f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
00f77c 013b          .dw XT_USART
00f77d 0163          .dw XT_INTON
00f77e 081b          .dw XT_VER
00f77f 04d4          .dw XT_SPACE
00f780 045c          .dw XT_DOSLITERAL
00f781 000a          .dw 10
00f782 6f46
00f783 7472
00f784 6468
00f785 6975
00f786 6f6e          .db "Forthduino"
00f787 0493          .dw XT_ITYPE
                 
00f788 f020          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00f789 ff03          .dw $ff03
00f78a 6d31
00f78b 0073          .db "1ms",0
00f78c f773          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
00f78d f78e          .dw PFA_1MS
                 PFA_1MS:
00f78e eae0
00f78f e0ff
00f790 9731
00f791 f7f1          delay 1000
00f792 c871          jmp_ DO_NEXT
                 .include "words/ms.asm"
                 
                 ; Time
                 ; busy waits the specified amount of milliseconds
                 VE_MS:
00f793 ff02          .dw $ff02
00f794 736d          .db "ms"
00f795 f789          .dw VE_HEAD
                     .set VE_HEAD = VE_MS
                 XT_MS:
00f796 f000          .dw DO_COLON
                 PFA_MS:
00f797 f146          .dw XT_ZERO
00f798 f2bf          .dw XT_DOQDO
00f799 f79d          .dw PFA_MS2
                 PFA_MS1:
00f79a f78d          .dw XT_1MS
00f79b f2f0          .dw XT_DOLOOP
00f79c f79a          .dw PFA_MS1
                 PFA_MS2:
00f79d f020          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
00f79e ff0d          .dw $ff0d
00f79f 6873
00f7a0 776f
00f7a1 772d
00f7a2 726f
00f7a3 6c64
00f7a4 7369
00f7a5 0074          .db "show-wordlist",0
00f7a6 f793          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00f7a7 f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
00f7a8 f040          .dw XT_DOLITERAL
00f7a9 f7ad          .dw XT_SHOWWORD
00f7aa f0d1          .dw XT_SWAP
00f7ab 08f5          .dw XT_TRAVERSEWORDLIST
00f7ac f020          .dw XT_EXIT
                 
                 XT_SHOWWORD:
00f7ad f000          .dw DO_COLON
                 PFA_SHOWWORD:
00f7ae 08e4          .dw XT_NAME2STRING
00f7af 0493          .dw XT_ITYPE
00f7b0 04d4          .dw XT_SPACE         ; ( -- addr n)
00f7b1 f14f          .dw XT_TRUE
00f7b2 f020          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
00f7b3 ff05          .dw $ff05
00f7b4 6f77
00f7b5 6472
00f7b6 0073          .db "words",0
00f7b7 f79e          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00f7b8 f000          .dw DO_COLON
                 PFA_WORDS:
00f7b9 f040          .dw XT_DOLITERAL
00f7ba 0016          .dw EE_ORDERLIST
00f7bb f373          .dw XT_FETCHE
00f7bc f7a7          .dw XT_SHOWWORDLIST
00f7bd f020          .dw XT_EXIT
                 ;.include "device.inc"
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 00 0a         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 1f 03         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 7b f7         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 92 f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 35 f6         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 b3 f7         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 e7 07         .dw XT_REC_FIND
00002a ca 07         .dw XT_REC_INTNUMBER
00002c 03 08         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 72 f6         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 21         .dw rstackstart  ; USER_RP
00003e af 21         .dw stackstart   ; USER_SP0
000040 af 21         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 17 01         .dw XT_TX  ; USER_EMIT
000048 25 01         .dw XT_TXQ ; USER_EMITQ
00004a ed 00         .dw XT_RX  ; USER_KEY
00004c 07 01         .dw XT_RXQ ; USER_KEYQ
00004e c5 09         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 b1 09         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 19 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 24
000058 f4 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1280" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  61 r18:  58 r19:  42 r20:  13 r21:  44 r22:  11 r23:   3 
r24: 170 r25: 121 r26:  45 r27:  22 r28:   6 r29:   4 r30:  73 r31:  40 
x  :   4 y  : 183 z  :  49 
Registers used: 29 out of 35 (82.9%)

"ATmega1280" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :  16 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   0 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  23 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :   8 elpm  :  20 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  19 inc   :   2 
jmp   :  16 ld    : 127 ldd   :   4 ldi   :  36 lds   :   2 lpm   :   0 
lsl   :  16 lsr   :   1 mov   :  11 movw  :  64 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  30 
pop   :  48 push  :  34 rcall :  69 ret   :   6 reti  :   2 rjmp  :  95 
rol   :  36 ror   :   3 sbc   :   8 sbci  :   3 sbi   :   8 sbic  :   3 
sbis  :   0 sbiw  :  14 sbr   :   0 sbrc  :   5 sbrs  :   5 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  60 std   :   8 
sts   :   3 sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 74 out of 114 (64.9%)

"ATmega1280" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01ef7c   2046  10896  12942  131072   9.9%
[.dseg] 0x000200 0x00031f      0    287    287    8192   3.5%
[.eseg] 0x000000 0x00005a      0     90     90    4096   2.2%

Assembly complete, 0 errors, 2 warnings
