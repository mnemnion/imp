
AVRASM ver. 2.1.51  p16-8.asm Mon Dec 23 20:35:25 2013

p16-8.asm(2): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
p16-8.asm(3): Including file '../../core/devices/atmega16\device.asm'
../../core/devices/atmega16\device.asm(5): Including file '../../Atmel/Appnotes2\m16def.inc'
p16-8.asm(12): Including file '../../core\drivers/usart.asm'
../../core\drivers/usart.asm(30): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
p16-8.asm(18): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(4): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(5): Including file '../../core\dict_wl.inc'
../../core\dict_wl.inc(2): Including file '../../core\words/set-current.asm'
../../core\dict_wl.inc(3): Including file '../../core\words/previous.asm'
../../core\dict_wl.inc(4): Including file '../../core\words/definitions.asm'
../../core\dict_wl.inc(5): Including file '../../core\words/wordlist.asm'
../../core\dict_wl.inc(7): Including file '../../core\words/only.asm'
../../core\dict_wl.inc(8): Including file '../../core\words/forth.asm'
../../core\dict_wl.inc(9): Including file '../../core\words/forth-wordlist.asm'
../../core\dict_wl.inc(10): Including file '../../core\words/also.asm'
../../core\dict_wl.inc(11): Including file '../../core\words/set-order.asm'
../../core\dict_wl.inc(12): Including file '../../core\words/order.asm'
dict_appl.inc(8): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(10): Including file '../../core\words/d-2star.asm'
dict_appl.inc(11): Including file '../../core\words/d-plus.asm'
dict_appl.inc(12): Including file '../../core\words/d-minus.asm'
dict_appl.inc(13): Including file '../../core\words/d-invert.asm'
dict_appl.inc(14): Including file '../../core\words/d-equal.asm'
dict_appl.inc(15): Including file '../../core\words/udot.asm'
dict_appl.inc(16): Including file '../../core\words/udotr.asm'
dict_appl.inc(17): Including file '../../core\words/dot-s.asm'
dict_appl.inc(19): Including file '../../core\words/dotstring.asm'
dict_appl.inc(20): Including file '../../core\words/squote.asm'
dict_appl.inc(22): Including file '../../core\words/edefer.asm'
dict_appl.inc(23): Including file '../../core\words/rdefer.asm'
dict_appl.inc(24): Including file '../../core\words/is.asm'
dict_appl.inc(26): Including file 'words/applturnkey.asm'
dict_appl.inc(28): Including file '../../core\words/fill.asm'
dict_appl.inc(30): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(31): Including file '../../core\words/words.asm'
dict_appl.inc(33): Including file '../../core\words/1ms.asm'
dict_appl.inc(34): Including file '../../core\words/2literal.asm'
dict_appl.inc(35): Including file '../../core/devices/atmega16\device.inc'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/n_to_r.asm'
dict_appl_core.inc(9): Including file '../../core\words/n_r_from.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  96
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_EEPROM = 0
                 .set WANT_CPU = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_SPI = 0
                 .set WANT_USART = 0
                 .set WANT_TWI = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_WATCHDOG = 0
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0b9      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0b7      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0b5      	 rcall isr ; Timer/Counter2 Compare Match
                 .org 8
000008 d0b3      	 rcall isr ; Timer/Counter2 Overflow
                 .org 10
00000a d0b1      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 12
00000c d0af      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 14
00000e d0ad      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 16
000010 d0ab      	 rcall isr ; Timer/Counter1 Overflow
                 .org 18
000012 d0a9      	 rcall isr ; Timer/Counter0 Overflow
                 .org 20
000014 d0a7      	 rcall isr ; Serial Transfer Complete
                 .org 22
000016 d0a5      	 rcall isr ; USART, Rx Complete
                 .org 24
000018 d0a3      	 rcall isr ; USART Data Register Empty
                 .org 26
00001a d0a1      	 rcall isr ; USART, Tx Complete
                 .org 28
00001c d09f      	 rcall isr ; ADC Conversion Complete
                 .org 30
00001e d09d      	 rcall isr ; EEPROM Ready
                 .org 32
000020 d09b      	 rcall isr ; Analog Comparator
                 .org 34
000022 d099      	 rcall isr ; 2-wire Serial Interface
                 .org 36
000024 d097      	 rcall isr ; External Interrupt Request 2
                 .org 38
000026 d095      	 rcall isr ; Timer/Counter0 Compare Match
                 .org 40
000028 d093      	 rcall isr ; Store Program Memory Ready
                 .equ INTVECTORS = 21
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ EEPE = EEWE
                 .equ EEMPE = EEMWE
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000029 0400      	.dw 1024
                 mcu_eepromsize:
00002a 0200      	.dw 512
                 mcu_maxdp:
00002b 3800      	.dw 14336 
                 mcu_numints:
00002c 0015      	.dw 21
                 mcu_name:
00002d 0008      	.dw  8
00002e 5441
00002f 656d
000030 6167
000031 3631      	.db "ATmega16"
                 .set codestart=pc
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64    ; 80 characters is one line...
                 .equ APPUSERSIZE = 10  ; size of user area
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 8000000
                 ; baud rate of terminal
                 .equ BAUD = 9600
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000016 940c 0032   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000060           usart_rx_in: .byte 1
000061           usart_rx_out: .byte 1
000062           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000032 93af        push xl
000033 b7af        in xl, SREG
000034 93af        push xl
000035 93bf        push xh
000036 93ef        push zl
000037 93ff        push zh
                 
000038 91b0 002c   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
00003a 91a0 0060   lds xl,usart_rx_in
00003c e6e2        ldi zl, low(usart_rx_data)
00003d e0f0        ldi zh, high(usart_rx_data)
00003e 0fea        add zl, xl
00003f 1df3        adc zh, zeroh
000040 83b0        st Z, xh
                 
000041 95a3        inc xl
000042 70af        andi xl,usart_rx_mask
                 
000043 93a0 0060   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000045 91ff        pop zh
000046 91ef        pop zl
000047 91bf        pop xh
000048 91af        pop xl
000049 bfaf        out SREG, xl
00004a 91af        pop xl
00004b 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00004c 1c00        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00004d 1d34        .dw XT_ZERO
00004e 1c37        .dw XT_DOLITERAL
00004f 0060        .dw usart_rx_in
000050 1c7c        .dw XT_STORE
                 
000051 1c1a        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000052 ff06          .dw $ff06
000053 7872
000054 692d
000055 7273          .db "rx-isr"
000056 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000057 1c00          .dw DO_COLON
                 PFA_RX_ISR:
000058 0071        .dw XT_RXQ_ISR
000059 1c30        .dw XT_DOCONDBRANCH
00005a 0058        .dw PFA_RX_ISR
00005b 1c37        .dw XT_DOLITERAL
00005c 0061        .dw usart_rx_out
00005d 1c93        .dw XT_CFETCH
00005e 1cac        .dw XT_DUP
00005f 1e38        .dw XT_1PLUS
000060 1c37        .dw XT_DOLITERAL
000061 000f        .dw usart_rx_mask
000062 1e1c        .dw XT_AND
000063 1c37        .dw XT_DOLITERAL
000064 0061        .dw usart_rx_out
000065 1c88        .dw XT_CSTORE
000066 1c37        .dw XT_DOLITERAL
000067 0062        .dw usart_rx_data
000068 1da6        .dw XT_PLUS
000069 1c93        .dw XT_CFETCH
00006a 1c1a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00006b ff07          .dw $ff07
00006c 7872
00006d 2d3f
00006e 7369
00006f 0072          .db "rx?-isr",0
000070 0052          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000071 1c00          .dw DO_COLON
                 PFA_RXQ_ISR:
000072 0666        .dw XT_PAUSE
000073 1c37        .dw XT_DOLITERAL
000074 0061        .dw usart_rx_out
000075 1c93        .dw XT_CFETCH
000076 1c37        .dw XT_DOLITERAL
000077 0060        .dw usart_rx_in
000078 1c93        .dw XT_CFETCH
000079 1d07        .dw XT_NOTEQUAL
00007a 1c1a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00007b ff07          .dw $ff07
00007c 7874
00007d 702d
00007e 6c6f
00007f 006c          .db "tx-poll",0
000080 006b          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000081 1c00          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000082 008f        .dw XT_TXQ_POLL
000083 1c30        .dw XT_DOCONDBRANCH
000084 0082        .dw PFA_TX_POLL
                   ; send to usart
000085 1c37        .dw XT_DOLITERAL
000086 002c        .dw USART_DATA
000087 1c88        .dw XT_CSTORE
000088 1c1a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000089 ff08          .dw $ff08
00008a 7874
00008b 2d3f
00008c 6f70
00008d 6c6c          .db "tx?-poll"
00008e 007b          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
00008f 1c00          .dw DO_COLON
                 PFA_TXQ_POLL:
000090 0666        .dw XT_PAUSE
000091 1c37        .dw XT_DOLITERAL
000092 002b        .dw USART_A
000093 1c93        .dw XT_CFETCH
000094 1c37        .dw XT_DOLITERAL
000095 0020        .dw bm_USART_TXRD
000096 1e1c        .dw XT_AND
000097 1c1a        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
000098 ff04        .dw $ff04
000099 6275
00009a 7272        .db "ubrr"
00009b 0089        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
00009c 1c69        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
00009d 0054        .dw EE_UBRRVAL
00009e 0a9b        .dw XT_EVALUEFETCH
00009f 0a9f        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000a0 ff06        .dw $ff06
0000a1 752b
0000a2 6173
0000a3 7472        .db "+usart"
0000a4 0098        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000a5 1c00        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000a6 1c37        .dw XT_DOLITERAL
0000a7 0098        .dw USART_B_VALUE
0000a8 1c37        .dw XT_DOLITERAL
0000a9 002a        .dw USART_B
0000aa 1c88        .dw XT_CSTORE
                 
0000ab 1c37        .dw XT_DOLITERAL
0000ac 0006        .dw USART_C_VALUE
0000ad 1c37        .dw XT_DOLITERAL
0000ae 00c0        .dw USART_C | bm_USARTC_en
0000af 1c88        .dw XT_CSTORE
                 
0000b0 009c        .dw XT_UBRR
0000b1 1cac        .dw XT_DUP
0000b2 1f0e        .dw XT_BYTESWAP
0000b3 1c37        .dw XT_DOLITERAL
0000b4 0040        .dw BAUDRATE_HIGH
0000b5 1c88        .dw XT_CSTORE
0000b6 1c37        .dw XT_DOLITERAL
0000b7 0029        .dw BAUDRATE_LOW
0000b8 1c88        .dw XT_CSTORE
                 
0000b9 004c        .dw XT_USART_INIT_RX
0000ba 0760        .dw XT_USART_INIT_TX
0000bb 1c1a        .dw XT_EXIT
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 .set NUMWORDLISTS = 8
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 066f   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000074           intcur: .byte 1
000075           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000bc 920a          st -Y, r0
0000bd b60f          in r0, SREG
0000be 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000bf 900f          pop r0
0000c0 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000c1 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000c2 9200 0074     sts intcur, r0
0000c4 9009          ld r0, Y+
0000c5 be0f          out SREG, r0
0000c6 9009          ld r0, Y+
0000c7 9468          set ; set the interrupt flag for the inner interpreter
0000c8 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
0000c9 ff05          .dw $ff05
0000ca 5f66
0000cb 7063
0000cc 0075          .db "f_cpu",0
0000cd 00a0          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0000ce 1c69          .dw PFA_DOVALUE1
                 PFA_F_CPU:
0000cf 0056          .dw EE_FCPU
0000d0 00d2          .dw XT_FETCH2E
0000d1 00db          .dw XT_STORE2E
                 
                 XT_FETCH2E:
0000d2 1c00          .dw DO_COLON
                 PFA_FETCH2E:
0000d3 1f6f          .dw XT_FETCHI
0000d4 1cac          .dw XT_DUP
0000d5 00f9          .dw XT_CELLPLUS
0000d6 1f5b          .dw XT_FETCHE
0000d7 1cbf          .dw XT_SWAP
0000d8 1f5b          .dw XT_FETCHE
0000d9 1cbf          .dw XT_SWAP
0000da 1c1a          .dw XT_EXIT
                 
                 XT_STORE2E:
0000db 1c00          .dw DO_COLON
                 PFA_STORE2E:
0000dc 1c37          .dw XT_DOLITERAL
0000dd ffeb          .dw -21
0000de 0450          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0000df ff05          .dw $ff05
0000e0 7473
0000e1 7461
0000e2 0065          .db "state",0
0000e3 00c9          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0000e4 1c42          .dw PFA_DOVARIABLE
                 PFA_STATE:
0000e5 009f          .dw ram_state
                 
                 .dseg
00009f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
0000e6 ff04          .dw $ff04
0000e7 6162
0000e8 6573          .db "base"
0000e9 00df          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0000ea 1c52          .dw PFA_DOUSER
                 PFA_BASE:
0000eb 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0000ec ff05          .dw $ff05
0000ed 6563
0000ee 6c6c
0000ef 0073          .db "cells",0
0000f0 00e6          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0000f1 1c00          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
0000f2 1e14          .dw XT_2STAR
                 .else
                 .endif
0000f3 1c1a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0000f4 ff05          .dw $ff05
0000f5 6563
0000f6 6c6c
0000f7 002b          .db "cell+",0
0000f8 00ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0000f9 00fa          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0000fa 9602          adiw tosl, CELLSIZE
0000fb 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
0000fd ff04          .dw $ff04
0000fe 6432
0000ff 7075          .db "2dup"
000100 00f4          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000101 1c00          .dw DO_COLON
                 PFA_2DUP:
000102 1cca          .dw XT_OVER
000103 1cca          .dw XT_OVER
000104 1c1a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
000105 ff05          .dw $ff05
000106 6432
000107 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
000108 0070          .db "2drop"
000109 00fd          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00010a 1c00          .dw DO_COLON
                 PFA_2DROP:
00010b 1cd4          .dw XT_DROP
00010c 1cd4          .dw XT_DROP
00010d 1c1a          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
00010e ff03          .dw $ff03
00010f 693e
000110 006e          .db ">in",0
000111 0105          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000112 1c52          .dw PFA_DOUSER
                 PFA_G_IN:
000113 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
000114 ff04          .dw $ff04
000115 7423
000116 6269          .db "#tib"
000117 010e          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000118 1c42          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000119 00a1          .dw ram_sharptib
                 
                 .dseg
0000a1           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
00011a ff03          .dw $ff03
00011b 6170
00011c 0064          .db "pad",0
00011d 0114          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00011e 1c00          .dw DO_COLON
                 PFA_PAD:
00011f 0158          .dw XT_HERE
000120 1c37          .dw XT_DOLITERAL
000121 0064          .dw 100
000122 1da6          .dw XT_PLUS
000123 1c1a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
000124 ff04          .dw $ff04
000125 6d65
000126 7469          .db "emit"
000127 011a          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000128 07c3          .dw PFA_DODEFER
                 PFA_EMIT:
000129 000e          .dw USER_EMIT
00012a 079b          .dw XT_UDEFERFETCH
00012b 07a2          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00012c ff05          .dw $ff05
00012d 6d65
00012e 7469
00012f 003f          .db "emit?",0
000130 0124          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000131 07c3          .dw PFA_DODEFER
                 PFA_EMITQ:
000132 0010          .dw USER_EMITQ
000133 079b          .dw XT_UDEFERFETCH
000134 07a2          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
000135 ff03          .dw $ff03
000136 656b
000137 0079          .db "key",0
000138 012c          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000139 07c3          .dw PFA_DODEFER
                 PFA_KEY:
00013a 0012          .dw USER_KEY
00013b 079b          .dw XT_UDEFERFETCH
00013c 07a2          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
00013d ff04          .dw $ff04
00013e 656b
00013f 3f79          .db "key?"
000140 0135          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000141 07c3          .dw PFA_DODEFER
                 PFA_KEYQ:
000142 0014          .dw USER_KEYQ
000143 079b          .dw XT_UDEFERFETCH
000144 07a2          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000145 ff02          .dw $ff02
000146 7064          .db "dp"
000147 013d          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000148 1c69          .dw PFA_DOVALUE1
                 PFA_DP:
000149 0002          .dw EE_DP
00014a 0a9b          .dw XT_EVALUEFETCH
00014b 0a9f          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
00014c ff03          .dw $ff03
00014d 6465
00014e 0070          .db "edp",0
00014f 0145          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
000150 1c69          .dw PFA_DOVALUE1
                 PFA_EDP:
000151 0006          .dw EE_EDP
000152 0a9b          .dw XT_EVALUEFETCH
000153 0a9f          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000154 ff04          .dw $ff04
000155 6568
000156 6572          .db "here"
000157 014c          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000158 1c69          .dw PFA_DOVALUE1
                 PFA_HERE:
000159 0004          .dw EE_HERE
00015a 0a9b          .dw XT_EVALUEFETCH
00015b 0a9f          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00015c ff05          .dw $ff05
00015d 6c61
00015e 6f6c
00015f 0074          .db "allot",0
000160 0154          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000161 1c00          .dw DO_COLON
                 PFA_ALLOT:
000162 0158          .dw XT_HERE
000163 1da6          .dw XT_PLUS
000164 077b          .dw XT_DOTO
000165 0159          .dw PFA_HERE
000166 1c1a          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000167 ff08          .dw $ff08
000168 6328
000169 6572
00016a 7461
00016b 2965          .db "(create)"
00016c 015c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00016d 1c00          .dw DO_COLON
                 PFA_DOCREATE:
00016e 05e0          .dw XT_PARSENAME
00016f 09ea          .dw XT_WLSCOPE
000170 1cac          .dw XT_DUP
000171 1cf3          .dw XT_TO_R
000172 09cf          .dw XT_HEADER
000173 1cea          .dw XT_R_FROM
                 .dseg
0000a3           COLON_SMUDGE: .byte 4
                 .cseg
000174 1c37          .dw XT_DOLITERAL
000175 00a5          .dw COLON_SMUDGE+2
000176 1c7c          .dw XT_STORE		; save wid
000177 1c37          .dw XT_DOLITERAL
000178 00a3          .dw COLON_SMUDGE+0
000179 1c7c          .dw XT_STORE		; save NFA
                 
00017a 1c1a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
00017b 0001          .dw $0001
00017c 005c          .db "\",0
00017d 0167          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00017e 1c00          .dw DO_COLON
                 PFA_BACKSLASH:
00017f 05c5          .dw XT_SOURCE
000180 1cbf          .dw XT_SWAP
000181 1cd4          .dw XT_DROP
000182 0112          .dw XT_G_IN
000183 1c7c          .dw XT_STORE
000184 1c1a          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
000185 0001          .dw $0001
000186 0028          .db "(" ,0
000187 017b          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
000188 1c00          .dw DO_COLON
                 PFA_LPARENTHESIS:
000189 1c37          .dw XT_DOLITERAL
00018a 0029          .dw $29
00018b 0591          .dw XT_PARSE
00018c 010a          .dw XT_2DROP
00018d 1c1a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
00018e ff07          .dw $ff07
00018f 6f63
000190 706d
000191 6c69
000192 0065          .db "compile",0
000193 0185          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000194 1c00          .dw DO_COLON
                 PFA_COMPILE:
000195 1cea          .dw XT_R_FROM
000196 1cac          .dw XT_DUP
000197 1e38          .dw XT_1PLUS
000198 1cf3          .dw XT_TO_R
000199 1f6f          .dw XT_FETCHI
00019a 019f          .dw XT_COMMA
00019b 1c1a          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
00019c ff01          .dw $ff01
00019d 002c          .db ',',0 ; ,
00019e 018e          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
00019f 1c00          .dw DO_COLON
                 PFA_COMMA:
0001a0 0148          .dw XT_DP
0001a1 1f79          .dw XT_STOREI
0001a2 0148          .dw XT_DP
0001a3 1e38          .dw XT_1PLUS
0001a4 077b          .dw XT_DOTO
0001a5 0149          .dw PFA_DP
0001a6 1c1a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0001a7 0003          .dw $0003
0001a8 275b
0001a9 005d          .db "[']",0
0001aa 019c          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001ab 1c00          .dw DO_COLON
                 PFA_BRACKETTICK:
0001ac 0194          .dw XT_COMPILE
0001ad 1c37          .dw XT_DOLITERAL
0001ae 0423          .dw XT_TICK
0001af 019f          .dw XT_COMMA
0001b0 1c1a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
0001b1 ff03          .dw $ff03
0001b2 6962
0001b3 006e          .db "bin",0
0001b4 01a7          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0001b5 1c00          .dw DO_COLON
                 PFA_BIN:
0001b6 1c37          .dw XT_DOLITERAL
0001b7 0002          .dw 2
0001b8 00ea          .dw XT_BASE
0001b9 1c7c          .dw XT_STORE
0001ba 1c1a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
0001bb ff07          .dw $ff07
0001bc 6564
0001bd 6963
0001be 616d
0001bf 006c          .db "decimal",0
0001c0 01b1          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0001c1 1c00          .dw DO_COLON
                 PFA_DECIMAL:
0001c2 1c37          .dw XT_DOLITERAL
0001c3 000a          .dw 10
0001c4 00ea          .dw XT_BASE
0001c5 1c7c          .dw XT_STORE
0001c6 1c1a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
0001c7 ff03          .dw $ff03
0001c8 6568
0001c9 0078          .db "hex",0
0001ca 01bb          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0001cb 1c00          .dw DO_COLON
                 PFA_HEX:
0001cc 1c37          .dw XT_DOLITERAL
0001cd 0010          .dw 16
0001ce 00ea          .dw XT_BASE
0001cf 1c7c          .dw XT_STORE
0001d0 1c1a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
0001d1 ff02          .dw $ff02
0001d2 6c62          .db "bl"
0001d3 01c7          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0001d4 1c42          .dw PFA_DOVARIABLE
                 PFA_BL:
0001d5 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0001d6 ff07          .dw $ff07
0001d7 7574
0001d8 6e72
0001d9 656b
0001da 0079          .db "turnkey",0
0001db 01d1          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0001dc 07c3          .dw PFA_DODEFER
                 PFA_TURNKEY:
0001dd 0008          .dw EE_TURNKEY
0001de 0787          .dw XT_EDEFERFETCH
0001df 078c          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
0001e0 ff05          .dw $ff05
0001e1 2f2a
0001e2 6f6d
0001e3 0064          .db "*/mod",0
0001e4 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
0001e5 1c00          .dw DO_COLON
                 PFA_STARSLASHMOD:
0001e6 1cf3          .dw XT_TO_R
0001e7 1daf          .dw XT_MSTAR
0001e8 1cea          .dw XT_R_FROM
0001e9 1dcb          .dw XT_UMSLASHMOD
0001ea 1c1a          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0001eb ff04          .dw $ff04
0001ec 6d2f
0001ed 646f          .db "/mod"
0001ee 01e0          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0001ef 01f0          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0001f0 019c          movw temp2, tosl
                     
0001f1 9109          ld temp0, Y+
0001f2 9119          ld temp1, Y+
                 
0001f3 2f41          mov	temp6,temp1	;move dividend High to sign register
0001f4 2743          eor	temp6,temp3	;xor divisor High with sign register
0001f5 ff17          sbrs	temp1,7	;if MSB in dividend set
0001f6 c004          rjmp	PFA_SLASHMOD_1
0001f7 9510          com	temp1		;    change sign of dividend
0001f8 9500          com	temp0		
0001f9 5f0f          subi	temp0,low(-1)
0001fa 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
0001fb ff37          sbrs	temp3,7	;if MSB in divisor set
0001fc c004          rjmp	PFA_SLASHMOD_2
0001fd 9530          com	temp3		;    change sign of divisor
0001fe 9520          com	temp2		
0001ff 5f2f          subi	temp2,low(-1)
000200 4f3f          sbci	temp3,high(-1)
000201 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000202 18ff          sub	temp5,temp5;clear remainder High byte and carry
000203 e151          ldi	temp7,17	;init loop counter
                 
000204 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000205 1f11          rol	temp1
000206 955a          dec	temp7		;decrement counter
000207 f439          brne	PFA_SLASHMOD_5		;if done
000208 ff47          sbrs	temp6,7		;    if MSB in sign register set
000209 c004          rjmp	PFA_SLASHMOD_4
00020a 9510          com	temp1	;        change sign of result
00020b 9500          com	temp0
00020c 5f0f          subi	temp0,low(-1)
00020d 4f1f          sbci	temp1,high(-1)
00020e c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00020f 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000210 1cff          rol	temp5
000211 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000212 0af3          sbc	temp5,temp3	;
000213 f420          brcc	PFA_SLASHMOD_6		;if result negative
000214 0ee2          add	temp4,temp2	;    restore remainder
000215 1ef3          adc	temp5,temp3
000216 9488          clc			;    clear carry to be shifted into result
000217 cfec          rjmp	PFA_SLASHMOD_3		;else
000218 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000219 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00021a 92fa          st -Y,temp5
00021b 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00021c 01c8          movw tosl, temp0
00021d 940c 1c04     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
00021f ff02          .dw $ff02
000220 2f2a          .db "*/"
000221 01eb          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000222 1c00          .dw DO_COLON
                 PFA_STARSLASH:
000223 01e5          .dw XT_STARSLASHMOD
000224 1cbf          .dw XT_SWAP
000225 1cd4          .dw XT_DROP
000226 1c1a          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000227 ff05          .dw $ff05
000228 2f75
000229 6f6d
00022a 0064          .db "u/mod",0
00022b 021f          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00022c 1c00          .dw DO_COLON
                 PFA_USLASHMOD:
00022d 1cf3          .dw XT_TO_R
00022e 1d34          .dw XT_ZERO
00022f 1cea          .dw XT_R_FROM
000230 1dcb          .dw XT_UMSLASHMOD
000231 1c1a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000232 ff06          .dw $ff06
000233 656e
000234 6167
000235 6574          .db "negate"
000236 0227          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000237 1c00          .dw DO_COLON
                 PFA_NEGATE:
000238 1e06          .dw XT_INVERT
000239 1e38          .dw XT_1PLUS
00023a 1c1a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
00023b ff01          .dw $ff01
00023c 002f          .db "/",0
00023d 0232          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00023e 1c00          .dw DO_COLON
                 PFA_SLASH:
00023f 01ef          .dw XT_SLASHMOD
000240 1cbf          .dw XT_SWAP
000241 1cd4          .dw XT_DROP
000242 1c1a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
000243 ff03          .dw $ff03
000244 6f6d
000245 0064          .db "mod",0
000246 023b          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000247 1c00          .dw DO_COLON
                 PFA_MOD:
000248 01ef          .dw XT_SLASHMOD
000249 1cd4          .dw XT_DROP
00024a 1c1a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
00024b ff03          .dw $ff03
00024c 6261
00024d 0073          .db "abs",0
00024e 0243          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00024f 0250          .dw PFA_ABS
                 PFA_ABS:
000250 2399          tst tosh
000251 f41a          brpl PFA_ABS1
000252 9580          com tosl
000253 9590          com tosh
000254 9601          adiw tosl, 1
                 PFA_ABS1:
000255 940c 1c04     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
000257 ff03          .dw $ff03
000258 696d
000259 006e          .db "min",0
00025a 024b          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00025b 1c00          .dw DO_COLON
                 PFA_MIN:
00025c 0101          .dw XT_2DUP
00025d 1d26          .dw XT_GREATER
00025e 1c30          .dw XT_DOCONDBRANCH
00025f 0261          .dw PFA_MIN1
000260 1cbf          .dw XT_SWAP
                 PFA_MIN1:
000261 1cd4          .dw XT_DROP
000262 1c1a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
000263 ff03          .dw $ff03
000264 616d
000265 0078          .db "max",0
000266 0257          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000267 1c00          .dw DO_COLON
                 PFA_MAX:
000268 0101          .dw XT_2DUP
000269 1d1f          .dw XT_LESS
00026a 1c30          .dw XT_DOCONDBRANCH
00026b 026d          .dw PFA_MAX1
00026c 1cbf          .dw XT_SWAP
                 PFA_MAX1:
00026d 1cd4          .dw XT_DROP
00026e 1c1a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
00026f ff06          .dw $ff06
000270 6977
000271 6874
000272 6e69          .db "within"
000273 0263          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000274 1c00          .dw DO_COLON
                 PFA_WITHIN:
000275 1cca          .dw XT_OVER
000276 1d9c          .dw XT_MINUS
000277 1cf3          .dw XT_TO_R
000278 1d9c          .dw XT_MINUS
000279 1cea          .dw XT_R_FROM
00027a 1d46          .dw XT_ULESS
00027b 1c1a          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
00027c ff07          .dw $ff07 
00027d 6f74
00027e 7075
00027f 6570
000280 0072          .db "toupper",0
000281 026f          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000282 1c00          .dw DO_COLON 
                 PFA_TOUPPER:
000283 1cac          .dw XT_DUP 
000284 1c37          .dw XT_DOLITERAL 
000285 0061          .dw 'a' 
000286 1c37          .dw XT_DOLITERAL 
000287 007b          .dw 'z'+1
000288 0274          .dw XT_WITHIN 
000289 1c30          .dw XT_DOCONDBRANCH
00028a 028e          .dw PFA_TOUPPER0 
00028b 1c37          .dw XT_DOLITERAL
00028c 00df          .dw $df ; inverse of 0x20
00028d 1e1c          .dw XT_AND 
                 PFA_TOUPPER0:
00028e 1c1a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
00028f ff07          .dw $ff07
000290 6f74
000291 6f6c
000292 6577
000293 0072          .db "tolower",0
000294 027c          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000295 1c00          .dw DO_COLON
                 PFA_TOLOWER:
000296 1cac          .dw XT_DUP
000297 1c37          .dw XT_DOLITERAL
000298 0041          .dw 'A'
000299 1c37          .dw XT_DOLITERAL
00029a 005b          .dw 'Z'+1
00029b 0274          .dw XT_WITHIN
00029c 1c30          .dw XT_DOCONDBRANCH
00029d 02a1          .dw PFA_TOLOWER0 
00029e 1c37          .dw XT_DOLITERAL
00029f 0020          .dw $20 
0002a0 1e25          .dw XT_OR 
                 PFA_TOLOWER0:
0002a1 1c1a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002a2 ff03          .dw $ff03
0002a3 6c68
0002a4 0064          .db "hld",0
0002a5 028f          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002a6 1c42          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002a7 00a7          .dw ram_hld
                 
                 .dseg
0000a7           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0002a8 ff04          .dw $ff04
0002a9 6f68
0002aa 646c          .db "hold"
0002ab 02a2          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0002ac 1c00          .dw DO_COLON
                 PFA_HOLD:
0002ad 02a6          .dw XT_HLD
0002ae 1cac          .dw XT_DUP
0002af 1c74          .dw XT_FETCH
0002b0 1e3e          .dw XT_1MINUS
0002b1 1cac          .dw XT_DUP
0002b2 1cf3          .dw XT_TO_R
0002b3 1cbf          .dw XT_SWAP
0002b4 1c7c          .dw XT_STORE
0002b5 1cea          .dw XT_R_FROM
0002b6 1c88          .dw XT_CSTORE
0002b7 1c1a          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
0002b8 ff02          .dw $ff02
0002b9 233c          .db "<#"
0002ba 02a8          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0002bb 1c00          .dw DO_COLON
                 PFA_L_SHARP:
0002bc 011e          .dw XT_PAD
0002bd 02a6          .dw XT_HLD
0002be 1c7c          .dw XT_STORE
0002bf 1c1a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
0002c0 ff01          .dw $ff01
0002c1 0023          .db "#",0
0002c2 02b8          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0002c3 1c00          .dw DO_COLON
                 PFA_SHARP:
0002c4 00ea          .dw XT_BASE
0002c5 1c74          .dw XT_FETCH
0002c6 0342          .dw XT_UDSLASHMOD
0002c7 1cdc          .dw XT_ROT
0002c8 1c37          .dw XT_DOLITERAL
0002c9 0009          .dw 9
0002ca 1cca          .dw XT_OVER
0002cb 1d1f          .dw XT_LESS
0002cc 1c30          .dw XT_DOCONDBRANCH
0002cd 02d1          .dw PFA_SHARP1
0002ce 1c37          .dw XT_DOLITERAL
0002cf 0007          .dw 7
0002d0 1da6          .dw XT_PLUS
                 PFA_SHARP1:
0002d1 1c37          .dw XT_DOLITERAL
0002d2 0030          .dw $30
0002d3 1da6          .dw XT_PLUS
0002d4 02ac          .dw XT_HOLD
0002d5 1c1a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
0002d6 ff02          .dw $ff02
0002d7 7323          .db "#s"
0002d8 02c0          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0002d9 1c00          .dw DO_COLON
                 PFA_SHARP_S:
0002da 02c3          .dw XT_SHARP
0002db 0101          .dw XT_2DUP
0002dc 1e25          .dw XT_OR
0002dd 1d18          .dw XT_EQUALZERO
0002de 1c30          .dw XT_DOCONDBRANCH
0002df 02da          .dw PFA_SHARP_S
0002e0 1c1a          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
0002e1 ff02          .dw $ff02
0002e2 3e23          .db "#>"
0002e3 02d6          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0002e4 1c00          .dw DO_COLON
                 PFA_SHARP_G:
0002e5 010a          .dw XT_2DROP
0002e6 02a6          .dw XT_HLD
0002e7 1c74          .dw XT_FETCH
0002e8 1cac          .dw XT_DUP
0002e9 011e          .dw XT_PAD
0002ea 1cbf          .dw XT_SWAP
0002eb 1d9c          .dw XT_MINUS
0002ec 1c1a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
0002ed ff04          .dw $ff04
0002ee 6973
0002ef 6e67          .db "sign"
0002f0 02e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0002f1 1c00          .dw DO_COLON
                 PFA_SIGN:
0002f2 1d2d          .dw XT_LESSZERO
0002f3 1c30          .dw XT_DOCONDBRANCH
0002f4 02f8          .dw PFA_SIGN1
0002f5 1c37          .dw XT_DOLITERAL
0002f6 002d          .dw $2d
0002f7 02ac          .dw XT_HOLD
                 PFA_SIGN1:
0002f8 1c1a          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
0002f9 ff03          .dw $ff03
0002fa 2e64
0002fb 0072          .db "d.r",0
0002fc 02ed          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
0002fd 1c00          .dw DO_COLON
                 PFA_DDOTR:
0002fe 1cf3          .dw XT_TO_R
0002ff 1cbf          .dw XT_SWAP
000300 1cca          .dw XT_OVER
000301 0883          .dw XT_DABS
000302 02bb          .dw XT_L_SHARP
000303 02d9          .dw XT_SHARP_S
000304 1cdc          .dw XT_ROT
000305 02f1          .dw XT_SIGN
000306 02e4          .dw XT_SHARP_G
000307 1cea          .dw XT_R_FROM
000308 1cca          .dw XT_OVER
000309 1d9c          .dw XT_MINUS
00030a 0405          .dw XT_SPACES
00030b 0414          .dw XT_TYPE
00030c 1c1a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
00030d ff02          .dw $ff02
00030e 722e          .db ".r"
00030f 02f9          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000310 1c00          .dw DO_COLON
                 PFA_DOTR:
000311 1cf3          .dw XT_TO_R
000312 1f29          .dw XT_S2D
000313 1cea          .dw XT_R_FROM
000314 02fd          .dw XT_DDOTR
000315 1c1a          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
000316 ff02          .dw $ff02
000317 2e64          .db "d."
000318 030d          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000319 1c00          .dw DO_COLON
                 PFA_DDOT:
00031a 1d34          .dw XT_ZERO
00031b 02fd          .dw XT_DDOTR
00031c 03fc          .dw XT_SPACE
00031d 1c1a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
00031e ff01          .dw $ff01
00031f 002e          .db ".",0
000320 0316          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000321 1c00          .dw DO_COLON
                 PFA_DOT:
000322 1f29          .dw XT_S2D
000323 0319          .dw XT_DDOT
000324 1c1a          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
000325 ff03          .dw $ff03
000326 6475
000327 002e          .db "ud.",0
000328 031e          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000329 1c00          .dw DO_COLON
                 PFA_UDDOT:
00032a 1d34          .dw XT_ZERO
00032b 0332          .dw XT_UDDOTR
00032c 03fc          .dw XT_SPACE
00032d 1c1a          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
00032e ff04          .dw $ff04
00032f 6475
000330 722e          .db "ud.r"
000331 0325          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000332 1c00          .dw DO_COLON
                 PFA_UDDOTR:
000333 1cf3          .dw XT_TO_R
000334 02bb          .dw XT_L_SHARP
000335 02d9          .dw XT_SHARP_S
000336 02e4          .dw XT_SHARP_G
000337 1cea          .dw XT_R_FROM
000338 1cca          .dw XT_OVER
000339 1d9c          .dw XT_MINUS
00033a 0405          .dw XT_SPACES
00033b 0414          .dw XT_TYPE
00033c 1c1a          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
00033d ff06          .dw $ff06
00033e 6475
00033f 6d2f
000340 646f          .db "ud/mod"
000341 032e          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000342 1c00          .dw DO_COLON
                 PFA_UDSLASHMOD:
000343 1cf3          .dw XT_TO_R
000344 1d34          .dw XT_ZERO
000345 1cfc          .dw XT_R_FETCH
000346 1dcb          .dw XT_UMSLASHMOD
000347 1cea          .dw XT_R_FROM
000348 1cbf          .dw XT_SWAP
000349 1cf3          .dw XT_TO_R
00034a 1dcb          .dw XT_UMSLASHMOD
00034b 1cea          .dw XT_R_FROM
00034c 1c1a          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
00034d ff06          .dw $ff06 
00034e 6964
00034f 6967
000350 3f74          .db "digit?"
000351 033d          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000352 1c00          .dw DO_COLON 
                 PFA_DIGITQ:
000353 0282          .dw XT_TOUPPER
000354 1c37          .dw XT_DOLITERAL 
000355 0030          .dw $30 
000356 1d9c          .dw XT_MINUS 
000357 1cac          .dw XT_DUP 
000358 1c37          .dw XT_DOLITERAL
000359 0009          .dw $09 
00035a 1d51          .dw XT_UGREATER 
00035b 1c30          .dw XT_DOCONDBRANCH
00035c 0369          .dw PFA_DIGITQ0 
00035d 1c37          .dw XT_DOLITERAL
00035e 0007          .dw $07 
00035f 1d9c          .dw XT_MINUS 
000360 1cac          .dw XT_DUP 
000361 1c37          .dw XT_DOLITERAL
000362 0009          .dw $09 
000363 0378          .dw XT_ULESSEQUAL
000364 1c30          .dw XT_DOCONDBRANCH
000365 0369          .dw PFA_DIGITQ1 
000366 1cd4          .dw XT_DROP 
000367 1d34          .dw XT_ZERO
000368 1c1a          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
000369 1cac          .dw XT_DUP 
00036a 00ea          .dw XT_BASE 
00036b 1c74          .dw XT_FETCH 
00036c 0380          .dw XT_UGREATEREQUAL
00036d 1c30          .dw XT_DOCONDBRANCH
00036e 0372          .dw PFA_DIGITQ2 
00036f 1cd4          .dw XT_DROP 
000370 1d34          .dw XT_ZERO
000371 1c1a          .dw XT_EXIT 
                 PFA_DIGITQ2:
000372 1d3d          .dw XT_TRUE
000373 1c1a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
000374 ff03          .dw $ff03 
000375 3c75
000376 003d          .db "u<=",0
000377 034d          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
000378 1c00          .dw DO_COLON 
                 PFA_ULESSEQUAL:
000379 1d51          .dw XT_UGREATER 
00037a 1e06          .dw XT_INVERT 
00037b 1c1a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
00037c ff03          .dw $ff03 
00037d 3e75
00037e 003d          .db "u>=",0
00037f 0374          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
000380 1c00          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
000381 1d46          .dw XT_ULESS 
000382 1e06          .dw XT_INVERT 
000383 1c1a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000384 1c00        .dw DO_COLON
                 PFA_DOSLITERAL:
000385 1cea        .dw XT_R_FROM   ; ( -- addr )
000386 1cac        .dw XT_DUP      ; ( -- addr addr )
000387 1cac        .dw XT_DUP
000388 1f6f        .dw XT_FETCHI   ; ( -- addr addr n )
000389 1cbf        .dw XT_SWAP
00038a 1e38        .dw XT_1PLUS
00038b 1cbf        .dw XT_SWAP
00038c 1cdc        .dw XT_ROT      ; ( -- addr' n addr )
00038d 1cca        .dw XT_OVER     ; ( -- addr' n addr n)
00038e 1e38        .dw XT_1PLUS
00038f 1e0d        .dw XT_2SLASH   ; ( -- addr' n addr k )
000390 1da6        .dw XT_PLUS     ; ( -- addr' n addr'' )
000391 1e38        .dw XT_1PLUS
000392 1cf3        .dw XT_TO_R     ; ( -- )
000393 1c1a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000394 ff02        .dw $ff02
000395 2c73        .db "s",$2c
000396 037c        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000397 1c00          .dw DO_COLON
                 PFA_SCOMMA:
000398 1cac          .dw XT_DUP
000399 039b          .dw XT_DOSCOMMA
00039a 1c1a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00039b 1c00          .dw DO_COLON
                 PFA_DOSCOMMA:
00039c 019f          .dw XT_COMMA
00039d 1cac          .dw XT_DUP   ; ( --addr len len)
00039e 1e0d          .dw XT_2SLASH ; ( -- addr len len/2
00039f 1cbf          .dw XT_SWAP   ; ( -- addr len/2 len
0003a0 1cca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003a1 1e14          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003a2 1d9c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003a3 1cf3          .dw XT_TO_R
0003a4 1d34          .dw XT_ZERO
0003a5 1eaa          .dw XT_DOQDO
0003a6 03ad          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0003a7 1cac          .dw XT_DUP         ; ( -- addr addr )
0003a8 1c74          .dw XT_FETCH       ; ( -- addr c1c2 )
0003a9 019f          .dw XT_COMMA       ; ( -- addr )
0003aa 00f9          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003ab 1ed8          .dw XT_DOLOOP
0003ac 03a7          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003ad 1cea          .dw XT_R_FROM
0003ae 1d5c          .dw XT_GREATERZERO
0003af 1c30          .dw XT_DOCONDBRANCH
0003b0 03b4          .dw PFA_SCOMMA3
0003b1 1cac            .dw XT_DUP     ; well, tricky
0003b2 1c93            .dw XT_CFETCH
0003b3 019f            .dw XT_COMMA
                 PFA_SCOMMA3:
0003b4 1cd4          .dw XT_DROP        ; ( -- )
0003b5 1c1a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003b6 ff05          .dw $ff05
0003b7 7469
0003b8 7079
0003b9 0065          .db "itype",0
0003ba 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003bb 1c00          .dw DO_COLON
                 PFA_ITYPE:
0003bc 1cac          .dw XT_DUP    ; ( --addr len len)
0003bd 1e0d          .dw XT_2SLASH ; ( -- addr len len/2
0003be 1cbf          .dw XT_SWAP   ; ( -- addr len/2 len
0003bf 1cca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003c0 1e14          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003c1 1d9c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003c2 1cf3          .dw XT_TO_R
0003c3 1d34          .dw XT_ZERO
0003c4 1eaa          .dw XT_DOQDO
0003c5 03ce          .dw PFA_ITYPE2
                 PFA_ITYPE1:
0003c6 1cac          .dw XT_DUP         ; ( -- addr addr )
0003c7 1f6f          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003c8 1cac          .dw XT_DUP
0003c9 03db          .dw XT_LOWEMIT
0003ca 03d7          .dw XT_HIEMIT
0003cb 1e38          .dw XT_1PLUS    ; ( -- addr+cell )
0003cc 1ed8          .dw XT_DOLOOP
0003cd 03c6          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0003ce 1cea          .dw XT_R_FROM
0003cf 1d5c          .dw XT_GREATERZERO
0003d0 1c30          .dw XT_DOCONDBRANCH
0003d1 03d5          .dw PFA_ITYPE3
0003d2 1cac            .dw XT_DUP     ; make sure the drop below has always something to do
0003d3 1f6f            .dw XT_FETCHI
0003d4 03db            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0003d5 1cd4          .dw XT_DROP
0003d6 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0003d7 1c00          .dw DO_COLON
                 PFA_HIEMIT:
0003d8 1f0e          .dw XT_BYTESWAP
0003d9 03db          .dw XT_LOWEMIT
0003da 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0003db 1c00          .dw DO_COLON
                 PFA_LOWEMIT:
0003dc 1c37          .dw XT_DOLITERAL
0003dd 00ff          .dw $00ff
0003de 1e1c          .dw XT_AND
0003df 0128          .dw XT_EMIT
0003e0 1c1a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0003e1 ff06          .dw $ff06
0003e2 6369
0003e3 756f
0003e4 746e          .db "icount"
0003e5 03b6          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0003e6 1c00          .dw DO_COLON
                 PFA_ICOUNT:
0003e7 1cac          .dw XT_DUP
0003e8 1e38          .dw XT_1PLUS
0003e9 1cbf          .dw XT_SWAP
0003ea 1f6f          .dw XT_FETCHI
0003eb 1c1a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
0003ec ff02          .dw $ff02
0003ed 7263          .db "cr"
0003ee 03e1          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0003ef 1c00          .dw DO_COLON
                 PFA_CR:
0003f0 1c37          .dw XT_DOLITERAL
0003f1 000d          .dw 13
0003f2 0128          .dw XT_EMIT
0003f3 1c37          .dw XT_DOLITERAL
0003f4 000a          .dw 10
0003f5 0128          .dw XT_EMIT
0003f6 1c1a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
0003f7 ff05          .dw $ff05
0003f8 7073
0003f9 6361
0003fa 0065          .db "space",0
0003fb 03ec          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
0003fc 1c00          .dw DO_COLON
                 PFA_SPACE:
0003fd 01d4          .dw XT_BL
0003fe 0128          .dw XT_EMIT
0003ff 1c1a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
000400 ff06          .dw $ff06
000401 7073
000402 6361
000403 7365          .db "spaces"
000404 03f7          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000405 1c00          .dw DO_COLON
                 PFA_SPACES:
000406 1cac          .dw XT_DUP
000407 1d5c          .dw XT_GREATERZERO
000408 1e1c          .dw XT_AND
000409 1d34          .dw XT_ZERO
00040a 1eaa          .dw XT_DOQDO
00040b 040f          .dw PFA_SPACES2
                 PFA_SPACES1:
00040c 03fc          .dw XT_SPACE
00040d 1ed8          .dw XT_DOLOOP
00040e 040c          .dw PFA_SPACES1
                 PFA_SPACES2:
00040f 1c1a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
000410 ff04          .dw $ff04
000411 7974
000412 6570          .db "type"
000413 0400          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000414 1c00          .dw DO_COLON
                 PFA_TYPE:
000415 1cca          .dw XT_OVER
000416 1da6          .dw XT_PLUS
000417 1cbf          .dW XT_SWAP
000418 1eaa          .dw XT_DOQDO
000419 041f          .dw PFA_TYPE2
                 PFA_TYPE1:
00041a 1ebd          .dw XT_I
00041b 1c93          .dw XT_CFETCH
00041c 0128          .dw XT_EMIT
00041d 1ed8          .dw XT_DOLOOP
00041e 041a          .dw PFA_TYPE1
                 PFA_TYPE2:
00041f 1c1a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
000420 ff01          .dw $ff01
000421 0027          .db "'",0
000422 0410          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000423 1c00          .dw DO_COLON
                 PFA_TICK:
000424 05e0          .dw XT_PARSENAME
000425 05fd          .dw XT_FINDNAME
000426 1d18          .dw XT_EQUALZERO
000427 1c30          .dw XT_DOCONDBRANCH
000428 042c          .dw PFA_TICK1
000429 1c37          .dw XT_DOLITERAL
00042a fff3          .dw -13
00042b 0450          .dw XT_THROW
                 PFA_TICK1:
00042c 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
00042d ff07          .dw $ff07
00042e 6168
00042f 646e
000430 656c
000431 0072          .db "handler",0
000432 0420          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000433 1c52          .dw PFA_DOUSER
                 PFA_HANDLER:
000434 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
000435 ff05          .dw $ff05
000436 6163
000437 6374
000438 0068          .db "catch",0
000439 042d          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00043a 1c00          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
00043b 1e8a          .dw XT_SP_FETCH
00043c 1cf3          .dw XT_TO_R
                     ; handler @ >r
00043d 0433          .dw XT_HANDLER
00043e 1c74          .dw XT_FETCH
00043f 1cf3          .dw XT_TO_R
                     ; rp@ handler !
000440 1e73          .dw XT_RP_FETCH
000441 0433          .dw XT_HANDLER
000442 1c7c          .dw XT_STORE
000443 1c24          .dw XT_EXECUTE
                     ; r> handler !
000444 1cea          .dw XT_R_FROM
000445 0433          .dw XT_HANDLER
000446 1c7c          .dw XT_STORE
000447 1cea          .dw XT_R_FROM
000448 1cd4          .dw XT_DROP
000449 1d34          .dw XT_ZERO
00044a 1c1a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
00044b ff05          .dw $ff05
00044c 6874
00044d 6f72
00044e 0077          .db "throw",0
00044f 0435          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000450 1c00          .dw DO_COLON
                 PFA_THROW:
000451 1cac          .dw XT_DUP
000452 1d18          .dw XT_EQUALZERO
000453 1c30          .dw XT_DOCONDBRANCH
000454 0457          .dw PFA_THROW1
000455 1cd4      	.dw XT_DROP
000456 1c1a      	.dw XT_EXIT
                 PFA_THROW1:
000457 0433          .dw XT_HANDLER
000458 1c74          .dw XT_FETCH
000459 1e7d          .dw XT_RP_STORE
00045a 1cea          .dw XT_R_FROM
00045b 0433          .dw XT_HANDLER
00045c 1c7c          .dw XT_STORE
00045d 1cea          .dw XT_R_FROM
00045e 1cbf          .dw XT_SWAP
00045f 1cf3          .dw XT_TO_R
000460 1e93          .dw XT_SP_STORE
000461 1cd4          .dw XT_DROP
000462 1cea          .dw XT_R_FROM    
000463 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
000464 ff05          .dw $ff05
000465 7363
000466 696b
000467 0070          .db "cskip",0
000468 044b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000469 1c00          .dw DO_COLON
                 PFA_CSKIP:
00046a 1cf3          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00046b 1cac          .dw XT_DUP            ; ( -- addr' n' n' )
00046c 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00046d 0479          .dw PFA_CSKIP2
00046e 1cca          .dw XT_OVER           ; ( -- addr' n' addr' )
00046f 1c93          .dw XT_CFETCH         ; ( -- addr' n' c' )
000470 1cfc          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000471 1d11          .dw XT_EQUAL          ; ( -- addr' n' f )
000472 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000473 0479          .dw PFA_CSKIP2
000474 1c37          .dw XT_DOLITERAL
000475 0001          .dw 1
000476 05cf          .dw XT_SLASHSTRING
000477 1c29          .dw XT_DOBRANCH
000478 046b          .dw PFA_CSKIP1
                 PFA_CSKIP2:
000479 1cea          .dw XT_R_FROM
00047a 1cd4          .dw XT_DROP           ; ( -- addr2 n2)
00047b 1c1a          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
00047c ff06          .dw $ff06
00047d 6361
00047e 6563
00047f 7470          .db "accept"
000480 0464          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000481 1c00          .dw DO_COLON
                 PFA_ACCEPT:
000482 1cac          .dw XT_DUP        ; ( -- addr n1 n1)
000483 1cf3          .dw XT_TO_R
000484 1cf3          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
000485 0139          .dw XT_KEY        ; ( -- addr k )
000486 1cac          .dw XT_DUP        ; ( -- addr k k )
000487 1c37          .dw XT_DOLITERAL
000488 000a          .dw 10
000489 1d07          .dw XT_NOTEQUAL
00048a 1c30          .dw XT_DOCONDBRANCH
00048b 04bf          .dw PFA_ACCEPT2
00048c 1cac          .dw XT_DUP
00048d 1c37          .dw XT_DOLITERAL
00048e 000d          .dw 13
00048f 1d07          .dw XT_NOTEQUAL
000490 1c30          .dw XT_DOCONDBRANCH
000491 04bf          .dw PFA_ACCEPT2
                     ; check backspace
000492 1cac          .dw XT_DUP
000493 1c37          .dw XT_DOLITERAL
000494 0008          .dw 8
000495 1d11          .dw XT_EQUAL
000496 1c30          .dw XT_DOCONDBRANCH
000497 04ab          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
000498 1cea          .dw XT_R_FROM             ; ( -- addr k n1 )
000499 1cfc          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
00049a 1cca          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
00049b 1cf3          .dw XT_TO_R
00049c 1d11          .dw XT_EQUAL              ; ( -- addr k f )
00049d 1c30          .dw XT_DOCONDBRANCH
00049e 04a2          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
00049f 1cd4          .dw XT_DROP               ; ( -- addr )
0004a0 1c29          .dw XT_DOBRANCH
0004a1 0485          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0004a2 1cac          .dw XT_DUP                ; ( -- addr k k )
0004a3 0128          .dw XT_EMIT               ; ( -- addr k )
0004a4 03fc          .dw XT_SPACE              ; ( -- addr k )
0004a5 0128          .dw XT_EMIT               ; ( -- addr )
0004a6 1e3e          .dw XT_1MINUS             ; ( -- addr--)
0004a7 1cea          .dw XT_R_FROM
0004a8 1e38          .dw XT_1PLUS
0004a9 1c29          .dw XT_DOBRANCH
0004aa 04b9          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
0004ab 1cac          .dw XT_DUP            ; ( -- addr k k )
0004ac 01d4          .dw XT_BL
0004ad 1d1f          .dw XT_LESS
0004ae 1c30          .dw XT_DOCONDBRANCH
0004af 04b2          .dw PFA_ACCEPT6
0004b0 1cd4          .dw XT_DROP
0004b1 01d4          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
0004b2 1cac          .dw XT_DUP            ; ( -- addr k k)
0004b3 0128          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
0004b4 1cca          .dw XT_OVER           ; ( -- addr k addr
0004b5 1c88          .dw XT_CSTORE         ; ( -- addr)
0004b6 1e38          .dw XT_1PLUS          ; ( -- addr++)
0004b7 1cea          .dw XT_R_FROM         ; ( -- addr n1)
0004b8 1e3e          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
0004b9 1cac          .dw XT_DUP
0004ba 1cf3          .dw XT_TO_R
0004bb 1d18          .dw XT_EQUALZERO
0004bc 1c30          .dw XT_DOCONDBRANCH
0004bd 0485          .dw PFA_ACCEPT1
0004be 1cac          .dw XT_DUP
                 PFA_ACCEPT2:
0004bf 010a          .dw XT_2DROP
0004c0 1cea          .dw XT_R_FROM
0004c1 1cea          .dw XT_R_FROM
0004c2 1cbf          .dw XT_SWAP
0004c3 1d9c          .dw XT_MINUS
0004c4 03ef          .dw XT_CR
0004c5 1c1a          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004c6 ff06          .dw $ff06
0004c7 6572
0004c8 6966
0004c9 6c6c          .db "refill"
0004ca 047c          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004cb 07c3          .dw PFA_DODEFER
                 PFA_REFILL:
0004cc 001a          .dw USER_REFILL
0004cd 079b          .dw XT_UDEFERFETCH
0004ce 07a2          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
0004cf ff04          .dw $ff04
0004d0 6863
0004d1 7261          .db "char"
0004d2 04c6          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004d3 1c00          .dw DO_COLON
                 PFA_CHAR:
0004d4 05e0          .dw XT_PARSENAME
0004d5 1cd4          .dw XT_DROP
0004d6 1c93          .dw XT_CFETCH
0004d7 1c1a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
0004d8 ff06          .dw $ff06
0004d9 756e
0004da 626d
0004db 7265          .db "number"
0004dc 04cf          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004dd 1c00          .dw DO_COLON
                 PFA_NUMBER:
0004de 00ea          .dw XT_BASE
0004df 1c74          .dw XT_FETCH
0004e0 1cf3          .dw XT_TO_R
0004e1 054e          .dw XT_NUMBERSIGN
0004e2 1cf3          .dw XT_TO_R
0004e3 051a          .dw XT_PRAEFIX
0004e4 054e          .dw XT_NUMBERSIGN
0004e5 1cea          .dw XT_R_FROM
0004e6 1e25          .dw XT_OR
0004e7 1cf3          .dw XT_TO_R
0004e8 1cf3          .dw XT_TO_R
0004e9 1cf3          .dw XT_TO_R
0004ea 1d34          .dw XT_ZERO       ; starting value
0004eb 1d34          .dw XT_ZERO
0004ec 1cea          .dw XT_R_FROM
0004ed 1cea          .dw XT_R_FROM
0004ee 056d          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0004ef 1cb4          .dw XT_QDUP
0004f0 1c30              .dw XT_DOCONDBRANCH
0004f1 050e      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
0004f2 1c37          .dw XT_DOLITERAL
0004f3 0001          .dw 1
0004f4 1d11          .dw XT_EQUAL
0004f5 1c30          .dw XT_DOCONDBRANCH
0004f6 0505          .dw PFA_NUMBER2
                 	; excatly one character is left
0004f7 1c93      	.dw XT_CFETCH
0004f8 1c37      	.dw XT_DOLITERAL
0004f9 002e      	.dw $2e ; .
0004fa 1d11      	.dw XT_EQUAL
0004fb 1c30      	.dw XT_DOCONDBRANCH
0004fc 0505      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
0004fd 1cea      	.dw XT_R_FROM
0004fe 1c30              .dw XT_DOCONDBRANCH
0004ff 0501      	.dw PFA_NUMBER3
000500 0890              .dw XT_DNEGATE
                 PFA_NUMBER3:
000501 1c37      	.dw XT_DOLITERAL
000502 0002      	.dw 2
000503 1c29      	.dw XT_DOBRANCH
000504 0515      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
000505 010a      	.dw XT_2DROP
000506 1cd4      	.dw XT_DROP
000507 1cea      	.dw XT_R_FROM
000508 1cd4      	.dw XT_DROP
000509 1cea              .dw XT_R_FROM
00050a 00ea              .dw XT_BASE
00050b 1c7c              .dw XT_STORE
00050c 1d34      	.dw XT_ZERO
00050d 1c1a      	.dw XT_EXIT
                 PFA_NUMBER1:
00050e 010a          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00050f 1cea          .dw XT_R_FROM
000510 1c30          .dw XT_DOCONDBRANCH
000511 0513          .dw PFA_NUMBER4
000512 0237          .dw XT_NEGATE
                 PFA_NUMBER4:
000513 1c37          .dw XT_DOLITERAL
000514 0001          .dw 1
                 PFA_NUMBER5:
000515 1cea          .dw XT_R_FROM
000516 00ea          .dw XT_BASE
000517 1c7c          .dw XT_STORE
000518 1d3d          .dw XT_TRUE
000519 1c1a          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
00051a 1c00          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
00051b 1cca          .dw XT_OVER 
00051c 1c93          .dw XT_CFETCH 
00051d 1c37          .dw XT_DOLITERAL
00051e 0029          .dw $29 
00051f 1d26          .dw XT_GREATER 
000520 1c30          .dw XT_DOCONDBRANCH
000521 0523          .dw PFA_PRAEFIX0 
000522 1c1a          .dw XT_EXIT 
                 PFA_PRAEFIX0:
000523 1cca          .dw XT_OVER 
000524 1c93          .dw XT_CFETCH 
000525 052a          .dw XT_SETBASE
000526 1c37          .dw XT_DOLITERAL
000527 0001          .dw $1 
000528 05cf          .dw XT_SLASHSTRING 
000529 1c1a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
00052a 1c00          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
00052b 1cac          .dw XT_DUP 
00052c 1c37          .dw XT_DOLITERAL
00052d 0024          .dw '$' 
00052e 1d11          .dw XT_EQUAL 
00052f 1c30          .dw XT_DOCONDBRANCH
000530 0534          .dw PFA_SETBASE0 
000531 1cd4          .dw XT_DROP 
000532 01cb          .dw XT_HEX 
000533 1c1a          .dw XT_EXIT 
                 PFA_SETBASE0:
000534 1cac          .dw XT_DUP 
000535 1c37          .dw XT_DOLITERAL
000536 0025          .dw '%' 
000537 1d11          .dw XT_EQUAL 
000538 1c30          .dw XT_DOCONDBRANCH
000539 053d          .dw PFA_SETBASE1 
00053a 1cd4          .dw XT_DROP 
00053b 01b5          .dw XT_BIN
00053c 1c1a          .dw XT_EXIT 
                 PFA_SETBASE1:
00053d 1cac          .dw XT_DUP 
00053e 1c37          .dw XT_DOLITERAL
00053f 0026          .dw '&'
000540 1d11          .dw XT_EQUAL 
000541 1c30          .dw XT_DOCONDBRANCH
000542 0546          .dw PFA_SETBASE2 
000543 1cd4          .dw XT_DROP
000544 01c1          .dw XT_DECIMAL 
000545 1c1a          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
000546 1c37          .dw XT_DOLITERAL
000547 0023          .dw '#'
000548 1d11          .dw XT_EQUAL 
000549 1c30          .dw XT_DOCONDBRANCH
00054a 054d          .dw PFA_SETBASE3 
00054b 01c1          .dw XT_DECIMAL 
00054c 1c1a          .dw XT_EXIT 
                 PFA_SETBASE3:
00054d 1c1a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
00054e 1c00          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
00054f 1cca          .dw XT_OVER
000550 1c93          .dw XT_CFETCH
000551 1c37          .dw XT_DOLITERAL
000552 002b          .dw '+'
000553 1d11          .dw XT_EQUAL
000554 1c30          .dw XT_DOCONDBRANCH
000555 0559          .dw PFA_NUMBERSIGN_MINUS
000556 1c37            .dw XT_DOLITERAL
000557 0001            .dw 1
000558 05cf            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
000559 1cca          .dw XT_OVER    ; ( -- addr len addr )
00055a 1c93          .dw XT_CFETCH
00055b 1c37          .dw XT_DOLITERAL
00055c 002d          .dw '-'
00055d 1d11          .dw XT_EQUAL  ; ( -- addr len flag )
00055e 1cac          .dw XT_DUP
00055f 1cf3          .dw XT_TO_R
000560 1c30          .dw XT_DOCONDBRANCH
000561 0565          .dw PFA_NUMBERSIGN_PLUS
000562 1c37          .dw XT_DOLITERAL      ; skip sign character
000563 0001          .dw 1
000564 05cf          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
000565 1cea          .dw XT_R_FROM
000566 1c1a          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
000567 ff07          .dw $ff07
000568 6e3e
000569 6d75
00056a 6562
00056b 0072          .db ">number",0
00056c 04d8          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00056d 1c00          .dw DO_COLON
                 PFA_TO_NUMBER:
00056e 1cac          .dw XT_DUP
00056f 1c30          .dw XT_DOCONDBRANCH
000570 058b          .dw PFA_TO_NUMBER1
000571 1cca              .dw XT_OVER
000572 1c93              .dw XT_CFETCH
000573 0352              .dw XT_DIGITQ
000574 1d18              .dw XT_EQUALZERO
000575 1c30              .dw XT_DOCONDBRANCH
000576 0578              .dw PFA_TO_NUMBER2
000577 1c1a                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
000578 1cf3              .dw XT_TO_R
000579 08b5              .dw XT_2SWAP
00057a 1cea              .dw XT_R_FROM
00057b 1cbf              .dw XT_SWAP
00057c 00ea              .dw XT_BASE
00057d 1c74              .dw XT_FETCH
00057e 1de9              .dw XT_UMSTAR
00057f 1cd4              .dw XT_DROP
000580 1cdc              .dw XT_ROT
000581 00ea              .dw XT_BASE
000582 1c74              .dw XT_FETCH
000583 1de9              .dw XT_UMSTAR
000584 0cc3              .dw XT_DPLUS
000585 08b5              .dw XT_2SWAP
000586 1c37              .dw XT_DOLITERAL
000587 0001              .dw 1
000588 05cf              .dw XT_SLASHSTRING
000589 1c29          .dw XT_DOBRANCH
00058a 056e          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
00058b 1c1a          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
00058c ff05          .dw $ff05
00058d 6170
00058e 7372
00058f 0065          .db "parse",0
000590 0567          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000591 1c00          .dw DO_COLON
                 PFA_PARSE:
000592 1cf3          .dw XT_TO_R     ; ( -- )
000593 05c5          .dw XT_SOURCE   ; ( -- addr len)
000594 0112          .dw XT_G_IN     ; ( -- addr len >in)
000595 1c74          .dw XT_FETCH
000596 05cf          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000597 1cea          .dw XT_R_FROM      ; ( -- addr' len' c)
000598 05a6          .dw XT_CSCAN       ; ( -- addr' len'')
000599 1cac          .dw XT_DUP         ; ( -- addr' len'' len'')
00059a 1e38          .dw XT_1PLUS
00059b 0112          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
00059c 1e62          .dw XT_PLUSSTORE   ; ( -- addr' len')
00059d 1c37          .dw XT_DOLITERAL
00059e 0001          .dw 1
00059f 05cf          .dw XT_SLASHSTRING
0005a0 1c1a          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0005a1 ff05          .dw $ff05
0005a2 7363
0005a3 6163
0005a4 006e          .db "cscan",0
0005a5 058c          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0005a6 1c00          .dw DO_COLON
                 PFA_CSCAN:
0005a7 1cbf          .dw XT_SWAP         ; ( -- addr1 c n1 )
0005a8 1cac          .dw XT_DUP          ; ( -- addr1 c n1 n1)
0005a9 1cf3          .dw XT_TO_R         ; ( -- addr1 c n1)
0005aa 1d34          .dw XT_ZERO         ; ( -- addr1 c n1 0)
0005ab 1eaa          .dw XT_DOQDO        ; ( -- addr1 c)
0005ac 05bd          .dw PFA_CSCAN3
                 PFA_CSCAN1:
0005ad 1cca          .dw XT_OVER         ; ( -- addr1 c addr1 )
0005ae 1ebd          .dw XT_I            ; ( -- addr1 c addr1 i)
0005af 1da6          .dw XT_PLUS         ; ( -- addr1 c addr')
0005b0 1c93          .dw XT_CFETCH       ; ( -- addr1 c c')
0005b1 1cca          .dw XT_OVER         ; ( -- addr1 c c' c)
0005b2 1d11          .dw XT_EQUAL        ; ( -- addr1 c f)
0005b3 1c30          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
0005b4 05bb          .dw PFA_CSCAN2
0005b5 1cd4          .dw XT_DROP         ; ( -- addr1 )
0005b6 1ebd          .dw XT_I            ; ( -- addr1 n2)
0005b7 1ee7          .dw XT_UNLOOP       ; ( -- addr1 n2)
0005b8 1cea          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
0005b9 1cd4          .dw XT_DROP         ; ( -- addr1 n2)
0005ba 1c1a          .dw XT_EXIT
                 PFA_CSCAN2:
0005bb 1ed8          .dw XT_DOLOOP
0005bc 05ad          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
0005bd 1cd4          .dw XT_DROP         ; ( -- addr1)
0005be 1cea          .dw XT_R_FROM       ; ( -- addr1 n1)
0005bf 1c1a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0005c0 ff06          .dw $FF06
0005c1 6f73
0005c2 7275
0005c3 6563          .db "source"
0005c4 05a1          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0005c5 07c3          .dw PFA_DODEFER
                 PFA_SOURCE:
0005c6 0016          .dw USER_SOURCE
0005c7 079b          .dw XT_UDEFERFETCH
0005c8 07a2          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0005c9 ff07          .dw $ff07
0005ca 732f
0005cb 7274
0005cc 6e69
0005cd 0067          .db "/string",0
0005ce 05c0          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005cf 1c00          .dw DO_COLON
                 PFA_SLASHSTRING:
0005d0 1cca          .dw XT_OVER    ; ( -- addr1 u1 n u1)
0005d1 025b          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
0005d2 1cdc          .dw XT_ROT     ; ( -- u1 n addr1 )
0005d3 1cca          .dw XT_OVER    ; ( -- u1 n addr1 n)
0005d4 1da6          .dw XT_PLUS    ; ( -- u1 n addr2 )
0005d5 1cdc          .dw XT_ROT     ; ( -- n addr2 u1)
0005d6 1cdc          .dw XT_ROT     ; ( -- addr2 u1 n)
0005d7 1d9c          .dw XT_MINUS   ; ( -- addr2 u2)
0005d8 1c1a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
0005d9 ff0a          .dw $FF0A 
0005da 6170
0005db 7372
0005dc 2d65
0005dd 616e
0005de 656d          .db "parse-name"
0005df 05c9          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005e0 1c00          .dw DO_COLON 
                 PFA_PARSENAME:
0005e1 01d4          .dw XT_BL
0005e2 05e4          .dw XT_SKIPSCANCHAR
0005e3 1c1a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005e4 1c00          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
0005e5 1cf3          .dw XT_TO_R
0005e6 05c5          .dw XT_SOURCE 
0005e7 0112          .dw XT_G_IN 
0005e8 1c74          .dw XT_FETCH 
0005e9 05cf          .dw XT_SLASHSTRING 
                 
0005ea 1cfc          .dw XT_R_FETCH
0005eb 0469          .dw XT_CSKIP
0005ec 1cea          .dw XT_R_FROM
0005ed 05a6          .dw XT_CSCAN
                 
                     ; adjust >IN
0005ee 0101          .dw XT_2DUP
0005ef 1da6          .dw XT_PLUS
0005f0 05c5          .dw XT_SOURCE 
0005f1 1cd4          .dw XT_DROP
0005f2 1d9c          .dw XT_MINUS
0005f3 0112          .dw XT_G_IN
0005f4 1c7c          .dw XT_STORE
0005f5 1c1a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
0005f6 ff09          .dw $ff09
0005f7 6966
0005f8 646e
0005f9 6e2d
0005fa 6d61
0005fb 0065          .db "find-name",0
0005fc 05d9          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0005fd 1c00          .dw DO_COLON
                 PFA_FINDNAME:
0005fe 1c37          .dw XT_DOLITERAL
0005ff 0014          .dw EE_ORDERLISTLEN
000600 1f5b          .dw XT_FETCHE
000601 1d34          .dw XT_ZERO
000602 1eaa          .dw XT_DOQDO
000603 0618          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
000604 0101          .dw XT_2DUP
000605 1c37          .dw XT_DOLITERAL
000606 0016          .dw EE_ORDERLIST
000607 1ebd          .dw XT_I
000608 00f1          .dw XT_CELLS
000609 1da6          .dw XT_PLUS  
00060a 1f5b          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
00060b 07d7          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
00060c 1cb4          .dw XT_QDUP
00060d 1c30          .dw XT_DOCONDBRANCH
00060e 0616          .dw PFA_FINDNAME4
00060f 1cf3      	.dw XT_TO_R
000610 1cf3      	.dw XT_TO_R
000611 010a      	.dw XT_2DROP
000612 1cea      	.dw XT_R_FROM
000613 1cea      	.dw XT_R_FROM
000614 1ee7      	.dw XT_UNLOOP
000615 1c1a      	.dw XT_EXIT
                 PFA_FINDNAME4:
000616 1ed8          .dw XT_DOLOOP
000617 0604          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000618 010a          .dw XT_2DROP
000619 1d34          .dw XT_ZERO
00061a 1c1a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
00061b ff04          .dw $ff04
00061c 7571
00061d 7469          .db "quit"
00061e 05f6          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00061f 1c00          .dw DO_COLON
                 PFA_QUIT:
000620 0697          .dw XT_SP0
000621 1e93          .dw XT_SP_STORE
000622 06ac          .dw XT_RP0
000623 1e7d          .dw XT_RP_STORE
000624 0a5c          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000625 00e4          .dw XT_STATE
000626 1c74          .dw XT_FETCH
000627 1d18          .dw XT_EQUALZERO
000628 1c30          .dw XT_DOCONDBRANCH
000629 062b          .dw PFA_QUIT4
00062a 0641          .dw XT_PROMPTRDY
                 PFA_QUIT4:
00062b 04cb          .dw XT_REFILL
00062c 1c30          .dw XT_DOCONDBRANCH
00062d 0625          .dw PFA_QUIT2
00062e 1c37          .dw XT_DOLITERAL
00062f 06c5          .dw XT_INTERPRET
000630 043a          .dw XT_CATCH
000631 1cb4          .dw XT_QDUP
000632 1c30          .dw XT_DOCONDBRANCH
000633 063d          .dw PFA_QUIT3
000634 1cac      	.dw XT_DUP
000635 1c37      	.dw XT_DOLITERAL
000636 fffe      	.dw -2
000637 1d1f      	.dw XT_LESS
000638 1c30      	.dw XT_DOCONDBRANCH
000639 063b      	.dw PFA_QUIT5
00063a 064f      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00063b 1c29      	.dw XT_DOBRANCH
00063c 0620      	.dw PFA_QUIT
                 PFA_QUIT3:
00063d 0648          .dw XT_PROMPTOK
00063e 1c29          .dw XT_DOBRANCH
00063f 0625          .dw PFA_QUIT2
000640 1c1a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000641 1c00          .dw DO_COLON
                 PFA_PROMPTRDY:
000642 03ef          .dw XT_CR
000643 0384          .dw XT_DOSLITERAL
000644 0002          .dw 2
000645 203e          .db "> "
000646 03bb          .dw XT_ITYPE
000647 1c1a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000648 1c00          .dw DO_COLON
                 PFA_PROMPTOK:
000649 0384          .dw XT_DOSLITERAL
00064a 0003          .dw 3
00064b 6f20
00064c 006b          .db " ok",0
00064d 03bb          .dw XT_ITYPE
00064e 1c1a          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00064f 1c00          .dw DO_COLON
                 PFA_PROMPTERROR:
000650 0384      	.dw XT_DOSLITERAL
000651 0004      	.dw 4
000652 3f20
000653 203f      	.db  " ?? "
000654 03bb          .dw XT_ITYPE
000655 00ea      	.dw XT_BASE
000656 1c74      	.dw XT_FETCH
000657 1cf3      	.dw XT_TO_R
000658 01c1      	.dw XT_DECIMAL
000659 0321      	.dw XT_DOT
00065a 0112      	.dw XT_G_IN
00065b 1c74      	.dw XT_FETCH
00065c 0321      	.dw XT_DOT
00065d 1cea      	.dw XT_R_FROM
00065e 00ea      	.dw XT_BASE
00065f 1c7c      	.dw XT_STORE
000660 1c1a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000661 ff05          .dw $ff05
000662 6170
000663 7375
000664 0065          .db "pause",0
000665 061b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000666 07c3          .dw PFA_DODEFER
                 PFA_PAUSE:
000667 00a9          .dw ram_pause
000668 0791          .dw XT_RDEFERFETCH
000669 0796          .dw XT_RDEFERSTORE
                 
                 .dseg
0000a9           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00066a ff04          .dw $ff04
00066b 6f63
00066c 646c          .db "cold"
00066d 0661          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00066e 066f          .dw PFA_COLD
                 PFA_COLD:
00066f b6a4          in_ r10, MCUSR
000670 24bb          clr r11
000671 2422          clr zerol
000672 2433          clr zeroh
000673 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
0000ab           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000674 eaeb          ldi zl, low(ram_user1)
000675 e0f0          ldi zh, high(ram_user1)
000676 012f          movw upl, zl
                     ; init return stack pointer
000677 e50f          ldi temp0,low(rstackstart)
000678 bf0d          out_ SPL,temp0
000679 8304          std Z+4, temp0
00067a e014          ldi temp1,high(rstackstart)
00067b bf1e          out_ SPH,temp1
00067c 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00067d e0cf          ldi yl,low(stackstart)
00067e 83c6          std Z+6, yl
00067f e0d4          ldi yh,high(stackstart)
000680 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000681 e8aa          ldi XL, low(PFA_WARM)
000682 e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000683 940c 1c04     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000685 ff04          .dw $ff04
000686 6177
000687 6d72          .db "warm"
000688 066a          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000689 1c00          .dw DO_COLON
                 PFA_WARM:
00068a 0905          .dw XT_INITUSER
00068b 1c37          .dw XT_DOLITERAL
00068c 0760          .dw XT_NOOP
00068d 1c37          .dw XT_DOLITERAL
00068e 0666          .dw XT_PAUSE
00068f 07ae          .dw XT_DEFERSTORE
000690 01dc          .dw XT_TURNKEY
000691 061f          .dw XT_QUIT
000692 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000693 ff03          .dw $ff03
000694 7073
000695 0030          .db "sp0",0
000696 0685          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000697 1c69          .dw PFA_DOVALUE1
                 PFA_SP0:
000698 0006          .dw USER_SP0
000699 06a0          .dw XT_UVALUEFETCH
00069a 06a4          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
00069b ff02          .dw $ff02
00069c 7073          .db "sp"
00069d 0693          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
00069e 1c52          .dw PFA_DOUSER
                 PFA_SP:
00069f 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
0006a0 1c00          .dw DO_COLON
                 PFA_UVALUEFETCH:
0006a1 1f6f          .dw XT_FETCHI
0006a2 1c9b          .dw XT_FETCHU
0006a3 1c1a          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
0006a4 1c00          .dw DO_COLON
                 PFA_UVALUESTORE:
0006a5 1f6f          .dw XT_FETCHI
0006a6 1ca3          .dw XT_STOREU
0006a7 1c1a          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0006a8 ff03          .dw $ff03
0006a9 7072
0006aa 0030          .db "rp0",0
0006ab 069b          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0006ac 1c00          .dw DO_COLON
                 PFA_RP0:
0006ad 06b0          .dw XT_DORP0
0006ae 1c74          .dw XT_FETCH
0006af 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0006b0 1c52          .dw PFA_DOUSER
                 PFA_DORP0:
0006b1 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
0006b2 ff05          .dw $ff05
0006b3 6564
0006b4 7470
0006b5 0068          .db "depth",0
0006b6 06a8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0006b7 1c00          .dw DO_COLON
                 PFA_DEPTH:
0006b8 0697          .dw XT_SP0
0006b9 1e8a          .dw XT_SP_FETCH
0006ba 1d9c          .dw XT_MINUS
0006bb 1e0d          .dw XT_2SLASH
0006bc 1e3e          .dw XT_1MINUS
0006bd 1c1a          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
0006be ff09          .dw $ff09
0006bf 6e69
0006c0 6574
0006c1 7072
0006c2 6572
0006c3 0074          .db "interpret",0
0006c4 06b2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
0006c5 1c00          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
0006c6 05e0          .dw XT_PARSENAME ; ( -- addr len )
0006c7 1cb4          .dw XT_QDUP   ; ( -- addr len len )
0006c8 1d5c          .dw XT_GREATERZERO
0006c9 1c30          .dw XT_DOCONDBRANCH
0006ca 06e9          .dw PFA_INTERPRET5
0006cb 1c37          .dw XT_DOLITERAL
0006cc 0026          .dw EE_RECOGNIZERLISTLEN
0006cd 1f5b          .dw XT_FETCHE       ; ( addr len rec # -- )
0006ce 1d34          .dw XT_ZERO
                 
0006cf 1eaa          .dw XT_DOQDO
0006d0 06e5          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
0006d1 0101          .dw XT_2DUP ; ( -- addr len addr len  )
0006d2 1ebd          .dw XT_I    ; ( -- addr len addr len i )
0006d3 1cdc          .dw XT_ROT  ; ( -- addr len len i addr )
0006d4 1cdc          .dw XT_ROT  ; ( -- addr len i addr len )
0006d5 1cf3          .dw XT_TO_R
0006d6 1cf3          .dw XT_TO_R
                 
0006d7 00f1          .dw XT_CELLS
0006d8 1c37          .dw XT_DOLITERAL
0006d9 0028          .dw EE_RECOGNIZERLIST
0006da 1da6          .dw XT_PLUS
0006db 1f5b          .dw XT_FETCHE
                 
0006dc 1c24          .dw XT_EXECUTE
0006dd 1cea          .dw XT_R_FROM
0006de 1cea          .dw XT_R_FROM
0006df 1cdc          .dw XT_ROT
0006e0 1c30          .dw XT_DOCONDBRANCH
0006e1 06e3          .dw PFA_INTERPRET3
0006e2 09ac            .dw XT_LEAVE
                 PFA_INTERPRET3:
0006e3 1ed8          .dw XT_DOLOOP
0006e4 06d1          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
0006e5 010a          .dw XT_2DROP
0006e6 0736          .dw XT_QSTACK
0006e7 1c29          .dw XT_DOBRANCH
0006e8 06c6          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
0006e9 1cd4          .dw xT_DROP
0006ea 1c1a          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
0006eb ff0a          .dw $ff0a
0006ec 6572
0006ed 2d63
0006ee 6e69
0006ef 6e74
0006f0 6d75          .db "rec-intnum"
0006f1 06be          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
0006f2 1c00          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
0006f3 04dd          .dw XT_NUMBER 
0006f4 1c30          .dw XT_DOCONDBRANCH 
0006f5 0707          .dw PFA_REC_NONUMBER
                 
0006f6 00e4          .dw XT_STATE
0006f7 1c74          .dw XT_FETCH
0006f8 1c30          .dw XT_DOCONDBRANCH
0006f9 0704          .dw PFA_REC_NUMBER_DONE
0006fa 1c37      	.dw XT_DOLITERAL
0006fb 0002      	.dw 2
0006fc 1d11      	.dw XT_EQUAL
0006fd 1c30      	.dw XT_DOCONDBRANCH
0006fe 0701      	.dw PFA_REC_NUMBER_SINGLE
0006ff 1cbf      	.dw XT_SWAP
000700 0913              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
000701 0913              .dw XT_LITERAL
000702 1c29              .dw XT_DOBRANCH
000703 0705              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
000704 1cd4          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000705 1d3d          .dw XT_TRUE
000706 1c1a          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000707 1d34          .dw XT_ZERO
000708 1c1a          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000709 ff08          .dw $ff08
00070a 6572
00070b 2d63
00070c 6966
00070d 646e          .db "rec-find"
00070e 06eb          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00070f 1c00          .dw DO_COLON
                 PFA_REC_FIND:
000710 05fd          .dw XT_FINDNAME
000711 1cac          .dw XT_DUP
000712 1c30          .dw XT_DOCONDBRANCH 
000713 0722          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
000714 1d5c      	.dw XT_GREATERZERO
000715 1c30      	.dw XT_DOCONDBRANCH
000716 0719      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000717 1c29      	    .dw XT_DOBRANCH
000718 0720      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000719 00e4      	    .dw XT_STATE
00071a 1c74      	    .dw XT_FETCH
00071b 1c30      	    .dw XT_DOCONDBRANCH
00071c 0720      	    .dw PFA_REC_FIND_EXECUTE
00071d 019f      	    .dw XT_COMMA
00071e 1c29      	    .dw XT_DOBRANCH
00071f 0721      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
000720 1c24          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
000721 1d3d          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000722 1c1a          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
000723 ff0c          .dw $ff0c
000724 6572
000725 2d63
000726 6f6e
000727 6674
000728 756f
000729 646e          .db "rec-notfound"
00072a 0709          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
00072b 1c00          .dw DO_COLON
                 PFA_REC_NOTFOUND:
00072c 0414          .dw XT_TYPE
00072d 1c37          .dw XT_DOLITERAL
00072e fff3          .dw -13
00072f 0450          .dw XT_THROW
000730 1c1a          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
000731 ff06          .dw $ff06
000732 733f
000733 6174
000734 6b63          .db "?stack"
000735 0723          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000736 1c00          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
000737 06b7          .dw XT_DEPTH
000738 1d2d          .dw XT_LESSZERO
000739 1c30          .dw XT_DOCONDBRANCH
00073a 073e          .dw PFA_QSTACK1
00073b 1c37            .dw XT_DOLITERAL
00073c fffc            .dw -4
00073d 0450            .dw XT_THROW
                 PFA_QSTACK1:
00073e 1c1a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
00073f ff03          .dw $ff03
000740 6576
000741 0072          .db "ver",0
000742 0731          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
000743 1c00          .dw DO_COLON
                 PFA_VER:
000744 0b30          .dw XT_ENV_FORTHNAME
000745 03bb          .dw XT_ITYPE
000746 03fc          .dw XT_SPACE
000747 00ea          .dw XT_BASE
000748 1c74          .dw XT_FETCH
000749 1cf3          .dw XT_TO_R
00074a 01c1          .dw XT_DECIMAL
                 
00074b 0b3e          .dw XT_ENV_FORTHVERSION
00074c 1f29          .dw XT_S2D
00074d 02bb          .dw XT_L_SHARP
00074e 02c3          .dw XT_SHARP
00074f 1c37          .dw XT_DOLITERAL
000750 002e          .dw '.'
000751 02ac          .dw XT_HOLD
000752 02d9          .dw XT_SHARP_S
000753 02e4          .dw XT_SHARP_G
000754 1cea          .dw XT_R_FROM
000755 00ea          .dw XT_BASE
000756 1c7c          .dw XT_STORE
                 
000757 0414          .dw XT_TYPE
000758 03fc          .dw XT_SPACE
000759 0b46          .dw XT_ENV_CPU
00075a 03bb          .dw XT_ITYPE
00075b 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
00075c ff04          .dw $ff04
00075d 6f6e
00075e 706f          .db "noop"
00075f 073f          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000760 0761          .dw PFA_NOOP
                 PFA_NOOP:
000761 940c 1c04     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000763 ff06          .dw $ff06
000764 6e75
000765 7375
000766 6465          .db "unused"
000767 075c          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000768 1c00          .dw DO_COLON
                 PFA_UNUSED:
000769 0697          .dw XT_SP0
00076a 0158          .dw XT_HERE
00076b 1d9c          .dw XT_MINUS
00076c 1c1a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
00076d 0002          .dw $0002
00076e 6f74          .db "to"
00076f 0763          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000770 1c00          .dw DO_COLON
                 PFA_TO:
000771 0423          .dw XT_TICK
000772 1e38          .dw XT_1PLUS  		; to body
000773 00e4          .dw XT_STATE
000774 1c74          .dw XT_FETCH
000775 1c30          .dw XT_DOCONDBRANCH
000776 0781          .dw PFA_TO1
000777 0194          .dw XT_COMPILE
000778 077b          .dw XT_DOTO
000779 019f          .dw XT_COMMA
00077a 1c1a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
00077b 1c00          .dw DO_COLON
                 PFA_DOTO:
00077c 1cea          .dw XT_R_FROM
00077d 1cac          .dw XT_DUP
00077e 1e38          .dw XT_1PLUS
00077f 1cf3          .dw XT_TO_R
000780 1f6f          .dw XT_FETCHI
                 PFA_TO1:
000781 1cac          .dw XT_DUP
000782 1e38          .dw XT_1PLUS
000783 1e38          .dw XT_1PLUS
000784 1f6f          .dw XT_FETCHI
000785 1c24          .dw XT_EXECUTE
000786 1c1a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000787 1c00          .dw DO_COLON
                 PFA_EDEFERFETCH:
000788 1e38          .dw XT_1PLUS ; >body
000789 1f6f          .dw XT_FETCHI
00078a 1f5b          .dw XT_FETCHE
00078b 1c1a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00078c 1c00          .dw DO_COLON
                 PFA_EDEFERSTORE:
00078d 1e38          .dw XT_1PLUS
00078e 1f6f          .dw XT_FETCHI
00078f 1f37          .dw XT_STOREE
000790 1c1a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000791 1c00          .dw DO_COLON
                 PFA_RDEFERFETCH:
000792 1e38          .dw XT_1PLUS ; >body
000793 1f6f          .dw XT_FETCHI
000794 1c74          .dw XT_FETCH
000795 1c1a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000796 1c00          .dw DO_COLON
                 PFA_RDEFERSTORE:
000797 1e38          .dw XT_1PLUS
000798 1f6f          .dw XT_FETCHI
000799 1c7c          .dw XT_STORE
00079a 1c1a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00079b 1c00          .dw DO_COLON
                 PFA_UDEFERFETCH:
00079c 1e38          .dw XT_1PLUS ; >body
00079d 1f6f          .dw XT_FETCHI
00079e 1f17          .dw XT_UP_FETCH
00079f 1da6          .dw XT_PLUS
0007a0 1c74          .dw XT_FETCH
0007a1 1c1a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
0007a2 1c00          .dw DO_COLON
                 PFA_UDEFERSTORE:
0007a3 1e38          .dw XT_1PLUS
0007a4 1f6f          .dw XT_FETCHI
0007a5 1f17          .dw XT_UP_FETCH
0007a6 1da6          .dw XT_PLUS
0007a7 1c7c          .dw XT_STORE
0007a8 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
0007a9 ff06          .dw $ff06
0007aa 6564
0007ab 6566
0007ac 2172          .db "defer!"
0007ad 076d          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
0007ae 1c00          .dw DO_COLON
                 PFA_DEFERSTORE:
0007af 1cac          .dw XT_DUP
0007b0 1c37          .dw XT_DOLITERAL
0007b1 0003          .dw 3
0007b2 1da6          .dw XT_PLUS   ; >body 2 +
0007b3 1f6f          .dw XT_FETCHI
0007b4 1c24          .dw XT_EXECUTE
0007b5 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
0007b6 ff06          .dw $ff06
0007b7 6564
0007b8 6566
0007b9 4072          .db "defer@"
0007ba 07a9          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
0007bb 1c00          .dw DO_COLON
                 PFA_DEFERFETCH:
0007bc 1cac          .dw XT_DUP
0007bd 1e38          .dw XT_1PLUS ; >body
0007be 1e38          .dw XT_1PLUS 
0007bf 1f6f          .dw XT_FETCHI
0007c0 1c24          .dw XT_EXECUTE
0007c1 1c1a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
0007c2 07c3          .dw PFA_DODEFER
                 PFA_DODEFER:
0007c3 940e 0a17     call_ DO_DODOES
0007c5 1cac          .dw XT_DUP
0007c6 1e3e          .dw XT_1MINUS
0007c7 1cbf          .dw XT_SWAP
0007c8 1e38          .dw XT_1PLUS
0007c9 1f6f          .dw XT_FETCHI
0007ca 1c24          .dw XT_EXECUTE 
0007cb 1c24          .dw XT_EXECUTE
0007cc 1c1a          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0007cd ff0f          .dw $ff0f
0007ce 6573
0007cf 7261
0007d0 6863
0007d1 772d
0007d2 726f
0007d3 6c64
0007d4 7369
0007d5 0074          .db "search-wordlist",0
0007d6 07b6          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0007d7 1c00          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0007d8 1d34          .dw XT_ZERO
0007d9 1cbf          .dw XT_SWAP
0007da 1c37          .dw XT_DOLITERAL
0007db 07e6          .dw XT_ISWORD
0007dc 1cbf          .dw XT_SWAP
0007dd 081d          .dw XT_TRAVERSEWORDLIST
0007de 1cac          .dw XT_DUP
0007df 1d18          .dw XT_EQUALZERO
0007e0 1c30          .dw XT_DOCONDBRANCH
0007e1 07e5          .dw PFA_SEARCH_WORDLIST1
0007e2 010a             .dw XT_2DROP
0007e3 1cd4             .dw XT_DROP
0007e4 1d34             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
0007e5 1c1a          .dw XT_EXIT
                 
                 XT_ISWORD:
0007e6 1c00          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
0007e7 1cf3          .dw XT_TO_R
0007e8 1cf3          .dw XT_TO_R
0007e9 0101          .dw XT_2DUP
0007ea 1cea          .dw XT_R_FROM
0007eb 1cdc          .dw XT_ROT
0007ec 1cdc          .dw XT_ROT
0007ed 1cfc          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
0007ee 080c          .dw XT_NAME2STRING
0007ef 0838          .dw XT_ICOMPARE      ; (-- addr len 0 f )
0007f0 1c30          .dw XT_DOCONDBRANCH
0007f1 0800          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
0007f2 010a            .dw XT_2DROP
0007f3 1cd4            .dw XT_DROP
                       ; ... get the XT ...
0007f4 1cfc            .dw XT_R_FETCH
0007f5 0bd1            .dw XT_NFA2LFA
0007f6 1e38            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
0007f7 1d3d            .dw XT_TRUE
0007f8 1cea            .dw XT_R_FROM
0007f9 1f6f            .dw XT_FETCHI
0007fa 1d5c            .dw XT_GREATERZERO
0007fb 1c30            .dw XT_DOCONDBRANCH
0007fc 07fe            .dw PFA_ISWORD1
0007fd 0237               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
0007fe 1d34            .dw XT_ZERO       ; finish traverse-wordlist
0007ff 1c1a            .dw XT_EXIT
                 PFA_ISWORD3:
000800 1cea          .dw XT_R_FROM
000801 1cd4          .dw XT_DROP
000802 1d3d          .dw XT_TRUE         ; maybe next word
000803 1c1a          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
000804 ff0b          .dw $ff0b
000805 616e
000806 656d
000807 733e
000808 7274
000809 6e69
00080a 0067          .db "name>string",0
00080b 07cd          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00080c 1c00          .dw DO_COLON
                 PFA_NAME2STRING:
00080d 03e6          .dw XT_ICOUNT   ; ( -- addr n )
00080e 1c37          .dw XT_DOLITERAL
00080f 00ff          .dw $00FF
000810 1e1c          .dw XT_AND      ; mask immediate bit
000811 1c1a          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000812 ff11          .dw $ff11
000813 7274
000814 7661
000815 7265
000816 6573
000817 772d
000818 726f
000819 6c64
00081a 7369
00081b 0074          .db "traverse-wordlist",0
00081c 0804          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00081d 1c00          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
00081e 1f5b          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00081f 1cac          .dw XT_DUP           ; ( -- xt nt nt )
000820 1c30          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000821 0830          .dw PFA_TRAVERSEWORDLIST2       ;
000822 0101          .dw XT_2DUP
000823 1cf3          .dw XT_TO_R
000824 1cf3          .dw XT_TO_R
000825 1cbf          .dw XT_SWAP
000826 1c24          .dw XT_EXECUTE
000827 1cea          .dw XT_R_FROM
000828 1cea          .dw XT_R_FROM
000829 1cdc          .dw XT_ROT
00082a 1c30          .dw XT_DOCONDBRANCH
00082b 0830          .dw PFA_TRAVERSEWORDLIST2
00082c 0bd1          .dw XT_NFA2LFA
00082d 1f6f          .dw XT_FETCHI        ; ( -- addr )
00082e 1c29          .dw XT_DOBRANCH      ; ( -- addr )
00082f 081f          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000830 010a          .dw XT_2DROP
000831 1c1a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
000832 ff08          .dw $ff08
000833 6369
000834 6d6f
000835 6170
000836 6572          .db "icompare"
000837 0812          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000838 1c00          .dw DO_COLON
                 PFA_ICOMPARE:
000839 1cf3          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00083a 1cca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00083b 1cea          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00083c 1d07          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00083d 1c30          .dw XT_DOCONDBRANCH
00083e 0843          .dw PFA_ICOMPARE_SAMELEN
00083f 010a            .dw XT_2DROP
000840 1cd4            .dw XT_DROP
000841 1d34            .dw XT_ZERO
000842 1c1a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000843 1cbf          .dw XT_SWAP ; ( -- r-addr f-addr len )
000844 1d34          .dw XT_ZERO
000845 1eaa          .dw XT_DOQDO
000846 0864          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000847 1cca          .dw XT_OVER
000848 1c74          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000849 1cca          .dw XT_OVER
00084a 1f6f          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00084b 1cac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00084c 1c37          .dw XT_DOLITERAL
00084d 0100          .dw $100
00084e 1d46          .dw XT_ULESS
00084f 1c30          .dw XT_DOCONDBRANCH
000850 0855          .dw PFA_ICOMPARE_LASTCELL
000851 1cbf          .dw XT_SWAP
000852 1c37          .dw XT_DOLITERAL
000853 00ff          .dw $00FF
000854 1e1c          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000855 1d07          .dw XT_NOTEQUAL
000856 1c30          .dw XT_DOCONDBRANCH
000857 085c          .dw PFA_ICOMPARE_NEXTLOOP
000858 010a          .dw XT_2DROP
000859 1d34          .dw XT_ZERO
00085a 1ee7          .dw XT_UNLOOP
00085b 1c1a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00085c 1e38          .dw XT_1PLUS
00085d 1cbf          .dw XT_SWAP
00085e 00f9          .dw XT_CELLPLUS
00085f 1cbf          .dw XT_SWAP
000860 1c37          .dw XT_DOLITERAL
000861 0002          .dw 2
000862 1ebe          .dw XT_DOPLUSLOOP
000863 0847          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000864 010a          .dw XT_2DROP
000865 1d3d          .dw XT_TRUE
000866 1c1a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000867 ff01          .dw $ff01
000868 002a          .db "*",0
000869 0832          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00086a 1c00          .dw DO_COLON
                 PFA_STAR:
00086b 1daf          .dw XT_MSTAR
00086c 087c          .dw XT_D2S
00086d 1c1a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00086e ff01          .dw $FF01
00086f 006a          .db "j",0
000870 0867          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000871 1c00          .dw DO_COLON
                 PFA_J:
000872 1e73          .dw XT_RP_FETCH
000873 1c37          .dw XT_DOLITERAL
000874 0009          .dw 9
000875 1da6          .dw XT_PLUS
000876 1c74          .dw XT_FETCH
000877 1c1a          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000878 ff03          .dw $ff03
000879 3e64
00087a 0073          .db "d>s",0
00087b 086e          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
00087c 1c00          .dw DO_COLON
                 PFA_D2S:
00087d 1cd4          .dw XT_DROP
00087e 1c1a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00087f ff04          .dw $ff04
000880 6164
000881 7362          .db "dabs"
000882 0878          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000883 1c00          .dw DO_COLON
                 PFA_DABS:
000884 1cac          .dw XT_DUP
000885 1d2d          .dw XT_LESSZERO
000886 1c30          .dw XT_DOCONDBRANCH
000887 0889          .dw PFA_DABS1
000888 0890          .dw XT_DNEGATE
                 PFA_DABS1:
000889 1c1a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00088a ff07          .dw $ff07
00088b 6e64
00088c 6765
00088d 7461
00088e 0065          .db "dnegate",0
00088f 087f          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000890 1c00          .dw DO_COLON
                 PFA_DNEGATE:
000891 0ceb          .dw XT_DINVERT
000892 1c37          .dw XT_DOLITERAL
000893 0001          .dw 1
000894 1d34          .dw XT_ZERO
000895 0cc3          .dw XT_DPLUS
000896 1c1a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000897 ff05          .dw $ff05
000898 6d63
000899 766f
00089a 0065          .db "cmove",0
00089b 088a          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00089c 089d          .dw PFA_CMOVE
                 PFA_CMOVE:
00089d 93bf          push xh
00089e 93af          push xl
00089f 91e9          ld zl, Y+
0008a0 91f9          ld zh, Y+ ; addr-to
0008a1 91a9          ld xl, Y+
0008a2 91b9          ld xh, Y+ ; addr-from
0008a3 2f09          mov temp0, tosh
0008a4 2b08          or temp0, tosl
0008a5 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
0008a6 911d          ld temp1, X+
0008a7 9311          st Z+, temp1
0008a8 9701          sbiw tosl, 1
0008a9 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
0008aa 91af          pop xl
0008ab 91bf          pop xh
0008ac 9189
0008ad 9199          loadtos
0008ae 940c 1c04     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
0008b0 ff05          .dw $ff05
0008b1 7332
0008b2 6177
0008b3 0070          .db "2swap",0
0008b4 0897          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
0008b5 1c00          .dw DO_COLON
                 PFA_2SWAP:
0008b6 1cdc          .dw XT_ROT
0008b7 1cf3          .dw XT_TO_R
0008b8 1cdc          .dw XT_ROT
0008b9 1cea          .dw XT_R_FROM
0008ba 1c1a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
0008bb ff03          .dw $ff03
0008bc 6974
0008bd 0062          .db "tib",0
0008be 08b0          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0008bf 1c42          .dw PFA_DOVARIABLE
                 PFA_TIB:
0008c0 00d1          .dw ram_tib
                     
                 .dseg
0000d1           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
0008c1 ff0a          .dw $ff0a
0008c2 6572
0008c3 6966
0008c4 6c6c
0008c5 742d
0008c6 6269          .db "refill-tib"
0008c7 08bb          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
0008c8 1c00          .dw DO_COLON
                 PFA_REFILLTIB:
0008c9 08bf          .dw XT_TIB
0008ca 1c37          .dw XT_DOLITERAL
0008cb 0064          .dw TIBSIZE
0008cc 0481          .dw XT_ACCEPT
0008cd 0118          .dw XT_NUMBERTIB
0008ce 1c7c          .dw XT_STORE
0008cf 1d34          .dw XT_ZERO
0008d0 0112          .dw XT_G_IN
0008d1 1c7c          .dw XT_STORE
0008d2 1c37          .dw XT_DOLITERAL
0008d3 ffff          .dw -1
0008d4 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0008d5 ff0a          .dw $FF0A
0008d6 6f73
0008d7 7275
0008d8 6563
0008d9 742d
0008da 6269          .db "source-tib"
0008db 08c1          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0008dc 1c00          .dw DO_COLON
                 PFA_SOURCETIB:
0008dd 08bf          .dw XT_TIB
0008de 0118          .dw XT_NUMBERTIB
0008df 1c74          .dw XT_FETCH
0008e0 1c1a          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0008e1 ff07        .dw $ff07
0008e2 6565
0008e3 752d
0008e4 6573
0008e5 0072        .db "ee-user",0
0008e6 08d5        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
0008e7 1c42        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
0008e8 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0008e9 ff06        .dw $ff06
0008ea 6565
0008eb 723e
0008ec 6d61        .db "ee>ram"
0008ed 08e1        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0008ee 1c00        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0008ef 1d34          .dw XT_ZERO
0008f0 1eaa          .dw XT_DOQDO
0008f1 08fc          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
0008f2 1cca          .dw XT_OVER
0008f3 1f5b          .dw XT_FETCHE
0008f4 1cca          .dw XT_OVER
0008f5 1c7c          .dw XT_STORE
0008f6 00f9          .dw XT_CELLPLUS
0008f7 1cbf          .dw XT_SWAP
0008f8 00f9          .dw XT_CELLPLUS
0008f9 1cbf          .dw XT_SWAP
0008fa 1ed8          .dw XT_DOLOOP
0008fb 08f2          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
0008fc 010a          .dw XT_2DROP
0008fd 1c1a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
0008fe ff09        .dw $ff09
0008ff 6e69
000900 7469
000901 752d
000902 6573
000903 0072        .db "init-user",0
000904 08e9        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000905 1c00        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000906 08e7          .dw XT_EEUSER
000907 1f17          .dw XT_UP_FETCH
000908 1c37          .dw XT_DOLITERAL
000909 001c          .dw SYSUSERSIZE
00090a 1e0d          .dw XT_2SLASH
00090b 08ee          .dw XT_EE2RAM
00090c 1c1a          .dw XT_EXIT
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
00090d 0007          .dw $0007
00090e 696c
00090f 6574
000910 6172
000911 006c          .db "literal",0
000912 08fe          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000913 1c00          .dw DO_COLON
                 PFA_LITERAL:
000914 0194          .dw XT_COMPILE
000915 1c37          .dw XT_DOLITERAL
000916 019f          .dw XT_COMMA
000917 1c1a          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000918 0008        .dw $0008
000919 6c73
00091a 7469
00091b 7265
00091c 6c61        .db "sliteral"
00091d 090d        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00091e 1c00          .dw DO_COLON
                 PFA_SLITERAL:
00091f 0194          .dw XT_COMPILE
000920 0384          .dw XT_DOSLITERAL    ; ( -- addr n)
000921 0397          .dw XT_SCOMMA
000922 1c1a          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000923 1c00          .dw DO_COLON
                 PFA_GMARK:
000924 0148          .dw XT_DP
000925 0194          .dw XT_COMPILE
000926 ffff          .dw -1           ; ffff does not erase flash
000927 1c1a          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000928 1c00          .dw DO_COLON
                 PFA_GRESOLVE:
000929 0736          .dw XT_QSTACK
00092a 0148          .dw XT_DP
00092b 1cbf          .dw XT_SWAP
00092c 1f79          .dw XT_STOREI
00092d 1c1a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00092e 1c00          .dw DO_COLON
                 PFA_LMARK:
00092f 0148          .dw XT_DP
000930 1c1a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000931 1c00          .dw DO_COLON
                 PFA_LRESOLVE:
000932 0736          .dw XT_QSTACK
000933 019f          .dw XT_COMMA
000934 1c1a          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000935 0005          .dw $0005
000936 6861
000937 6165
000938 0064          .db "ahead",0
000939 0918          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
00093a 1c00          .dw DO_COLON
                 PFA_AHEAD:
00093b 0194          .dw XT_COMPILE
00093c 1c29          .dw XT_DOBRANCH
00093d 0923          .dw XT_GMARK
00093e 1c1a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
00093f 0002          .dw $0002
000940 6669          .db "if"
000941 0935          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000942 1c00          .dw DO_COLON
                 PFA_IF:
000943 0194          .dw XT_COMPILE
000944 1c30          .dw XT_DOCONDBRANCH
000945 0923          .dw XT_GMARK
000946 1c1a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000947 0004          .dw $0004
000948 6c65
000949 6573          .db "else"
00094a 093f          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
00094b 1c00          .dw DO_COLON
                 PFA_ELSE:
00094c 0194          .dw XT_COMPILE
00094d 1c29          .dw XT_DOBRANCH
00094e 0923          .dw XT_GMARK
00094f 1cbf          .dw XT_SWAP
000950 0928          .dw XT_GRESOLVE
000951 1c1a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000952 0004          .dw $0004
000953 6874
000954 6e65          .db "then"
000955 0947          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000956 1c00          .dw DO_COLON
                 PFA_THEN:
000957 0928          .dw XT_GRESOLVE
000958 1c1a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000959 0005          .dw $0005
00095a 6562
00095b 6967
00095c 006e          .db "begin",0
00095d 0952          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00095e 1c00          .dw DO_COLON
                 PFA_BEGIN:
00095f 092e          .dw XT_LMARK
000960 1c1a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
000961 0005          .dw $0005
000962 6877
000963 6c69
000964 0065          .db "while",0
000965 0959          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000966 1c00          .dw DO_COLON
                 PFA_WHILE:
000967 0194          .dw XT_COMPILE
000968 1c30          .dw XT_DOCONDBRANCH
000969 0923          .dw XT_GMARK
00096a 1cbf          .dw XT_SWAP
00096b 1c1a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
00096c 0006          .dw $0006
00096d 6572
00096e 6570
00096f 7461          .db "repeat"
000970 0961          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000971 1c00          .dw DO_COLON
                 PFA_REPEAT:
000972 0984          .dw XT_AGAIN
000973 0928          .dw XT_GRESOLVE
000974 1c1a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000975 0005          .dw $0005
000976 6e75
000977 6974
000978 006c          .db "until",0
000979 096c          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00097a 1c00          .dw DO_COLON
                 PFA_UNTIL:
00097b 0194          .dw XT_COMPILE
00097c 1c30          .dw XT_DOCONDBRANCH
00097d 0931          .dw XT_LRESOLVE
00097e 1c1a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
00097f 0005          .dw $0005
000980 6761
000981 6961
000982 006e          .db "again",0
000983 0975          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000984 1c00          .dw DO_COLON
                 PFA_AGAIN:
000985 0194          .dw XT_COMPILE
000986 1c29          .dw XT_DOBRANCH
000987 0931          .dw XT_LRESOLVE
000988 1c1a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
000989 0002          .dw $0002
00098a 6f64          .db "do"
00098b 097f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
00098c 1c00          .dw DO_COLON
                 PFA_DO:
00098d 0194          .dw XT_COMPILE
00098e 1e98          .dw XT_DODO
00098f 0923          .dw XT_GMARK
000990 092e          .dw XT_LMARK
000991 1c1a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
000992 0004          .dw $0004
000993 6f6c
000994 706f          .db "loop"
000995 0989          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000996 1c00          .dw DO_COLON
                 PFA_LOOP:
000997 0194          .dw XT_COMPILE
000998 1ed8          .dw XT_DOLOOP
000999 0931          .dw XT_LRESOLVE
00099a 0928          .dw XT_GRESOLVE
00099b 1c1a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
00099c 0005          .dw $0005
00099d 6c2b
00099e 6f6f
00099f 0070          .db "+loop",0
0009a0 0992          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0009a1 1c00          .dw DO_COLON
                 PFA_PLUSLOOP:
0009a2 0194          .dw XT_COMPILE
0009a3 1ebe          .dw XT_DOPLUSLOOP
0009a4 0931          .dw XT_LRESOLVE
0009a5 0928          .dw XT_GRESOLVE
0009a6 1c1a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
0009a7 ff05         .dw $FF05
0009a8 656c
0009a9 7661
0009aa 0065         .db "leave",0
0009ab 099c         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0009ac 09ad          .dw PFA_LEAVE
                 PFA_LEAVE:
0009ad 910f          pop temp0  ; drop limit and counter from returnstack
0009ae 911f          pop temp1
0009af 910f          pop temp0
0009b0 911f          pop temp1
0009b1 91af          pop xl
0009b2 91bf          pop xh
0009b3 940c 1c04     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
0009b5 0003          .dw $0003
0009b6 643f
0009b7 006f          .db "?do",0
0009b8 09a7          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0009b9 1c00          .dw DO_COLON
                 PFA_QDO:
0009ba 0194          .dw XT_COMPILE
0009bb 1eaa          .dw XT_DOQDO
0009bc 0923          .dw XT_GMARK
0009bd 092e          .dw XT_LMARK
0009be 1c1a          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0009bf ff06          .dw $ff06
0009c0 7263
0009c1 6165
0009c2 6574          .db "create"
0009c3 09b5          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0009c4 1c00          .dw DO_COLON
                 PFA_CREATE:
0009c5 016d          .dw XT_DOCREATE
0009c6 09f3          .dw XT_REVEAL
0009c7 0194          .dw XT_COMPILE
0009c8 1c4c          .dw PFA_DOCONSTANT
0009c9 1c1a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0009ca ff06          .dw $ff06
0009cb 6568
0009cc 6461
0009cd 7265          .db "header"
0009ce 09bf          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0009cf 1c00          .dw DO_COLON
                 PFA_HEADER:
0009d0 0148          .dw XT_DP           ; the new Name Field
0009d1 1cf3          .dw XT_TO_R
0009d2 1cf3          .dw XT_TO_R		; ( R: NFA WID )
0009d3 1cac          .dw XT_DUP    
0009d4 1d5c          .dw XT_GREATERZERO 
0009d5 1c30          .dw XT_DOCONDBRANCH
0009d6 09e1          .dw PFA_HEADER1
0009d7 1cac          .dw XT_DUP
0009d8 1c37          .dw XT_DOLITERAL
0009d9 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0009da 1e25          .dw XT_OR
0009db 039b          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0009dc 1cea          .dw XT_R_FROM
0009dd 1f5b          .dw XT_FETCHE
0009de 019f          .dw XT_COMMA
0009df 1cea          .dw XT_R_FROM
0009e0 1c1a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0009e1 1c37          .dw XT_DOLITERAL
0009e2 fff0          .dw -16
0009e3 0450          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0009e4 ff07          .dw $ff07
0009e5 6c77
0009e6 6373
0009e7 706f
0009e8 0065          .db "wlscope",0
0009e9 09ca          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0009ea 07c3          .dw PFA_DODEFER
                 PFA_WLSCOPE:
0009eb 0034          .dw EE_WLSCOPE
0009ec 0787          .dw XT_EDEFERFETCH
0009ed 078c          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0009ee ff06          .dw $ff06
0009ef 6572
0009f0 6576
0009f1 6c61          .db "reveal"
0009f2 09e4          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0009f3 1c00          .dw DO_COLON
                 PFA_REVEAL:
0009f4 1c37          .dw XT_DOLITERAL
0009f5 00a3          .dw COLON_SMUDGE+0
0009f6 1c74          .dw XT_FETCH
0009f7 1cb4          .dw XT_QDUP
0009f8 1c30          .dw XT_DOCONDBRANCH
0009f9 0a02          .dw PFA_REVEAL1
                 ;
0009fa 1c37          .dw XT_DOLITERAL
0009fb 00a5          .dw COLON_SMUDGE+2
0009fc 1c74          .dw XT_FETCH		; ( NFA WID )
0009fd 1f37          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
0009fe 1d34          .dw XT_ZERO
0009ff 1c37          .dw XT_DOLITERAL
000a00 00a3          .dw COLON_SMUDGE+0
000a01 1c7c          .dw XT_STORE
                 PFA_REVEAL1:
000a02 1c1a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000a03 ff06          .dw $ff06
000a04 616c
000a05 6574
000a06 7473          .db "latest"
000a07 09ee          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000a08 1c42          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000a09 0135          .dw ram_LATEST
                 
                 .dseg
000135           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000a0a 0005          .dw $0005
000a0b 6f64
000a0c 7365
000a0d 003e          .db "does>",0
000a0e 0a03          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000a0f 1c00          .dw DO_COLON
                 PFA_DOES:
000a10 0194          .dw XT_COMPILE
000a11 0a22          .dw XT_DODOES
000a12 0194          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000a13 940e          .dw $940e       ; the address of this compiled
000a14 0194          .dw XT_COMPILE  ; code will replace the XT of the 
000a15 0a17          .dw DO_DODOES   ; word that CREATE created
000a16 1c1a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000a17 939a
000a18 938a          savetos
000a19 01cb          movw tosl, wl
000a1a 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000a1b 917f          pop wh
000a1c 916f          pop wl
                 
000a1d 93bf          push XH
000a1e 93af          push XL
000a1f 01db          movw XL, wl
000a20 940c 1c04     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000a22 1c00          .dw DO_COLON
                 PFA_DODOES:
000a23 1cea          .dw XT_R_FROM
000a24 1c37          .dw XT_DOLITERAL
000a25 00a5          .dw COLON_SMUDGE+2
000a26 1c74          .dw XT_FETCH
000a27 1f5b          .dw XT_FETCHE
000a28 0bd1          .dw XT_NFA2LFA
000a29 1e38          .dw XT_1PLUS   ; lfa>xt
                 
000a2a 1f79          .dw XT_STOREI
000a2b 1c1a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000a2c ff01          .dw $ff01
000a2d 003a          .db ":",0
000a2e 0a0a          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000a2f 1c00          .dw DO_COLON
                 PFA_COLON:
000a30 016d          .dw XT_DOCREATE
000a31 0148          .dw XT_DP
000a32 0a08          .dw XT_LATEST
000a33 1c7c          .dw XT_STORE
000a34 0194          .dw XT_COMPILE
000a35 1c00          .dw DO_COLON
000a36 0a53          .dw XT_RBRACKET
000a37 1c1a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000a38 ff07          .dw $ff07
000a39 6e3a
000a3a 6e6f
000a3b 6d61
000a3c 0065          .db ":noname",0
000a3d 0a2c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000a3e 1c00          .dw DO_COLON
                 PFA_COLONNONAME:
000a3f 0148          .dw XT_DP
000a40 1cac          .dw XT_DUP
000a41 0a08          .dw XT_LATEST
000a42 1c7c          .dw XT_STORE
                 
000a43 0194          .dw XT_COMPILE
000a44 1c00          .dw DO_COLON
                 
000a45 0a53          .dw XT_RBRACKET
000a46 1c1a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000a47 0001          .dw $0001
000a48 003b          .db $3b,0
000a49 0a38          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000a4a 1c00          .dw DO_COLON
                 PFA_SEMICOLON:
000a4b 0194          .dw XT_COMPILE
000a4c 1c1a          .dw XT_EXIT
000a4d 0a5c          .dw XT_LBRACKET
000a4e 09f3          .dw XT_REVEAL
000a4f 1c1a          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000a50 ff01          .dw $ff01
000a51 005d          .db "]",0
000a52 0a47          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000a53 1c00          .dw DO_COLON
                 PFA_RBRACKET:
000a54 1c37          .dw XT_DOLITERAL
000a55 0001          .dw 1
000a56 00e4          .dw XT_STATE
000a57 1c7c          .dw XT_STORE
000a58 1c1a          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000a59 0001          .dw $0001
000a5a 005b          .db "[",0
000a5b 0a50          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000a5c 1c00          .dw DO_COLON
                 PFA_LBRACKET:
000a5d 1d34          .dw XT_ZERO
000a5e 00e4          .dw XT_STATE
000a5f 1c7c          .dw XT_STORE
000a60 1c1a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000a61 ff08          .dw $ff08
000a62 6176
000a63 6972
000a64 6261
000a65 656c          .db "variable"
000a66 0a59          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000a67 1c00          .dw DO_COLON
                 PFA_VARIABLE:
000a68 0158          .dw XT_HERE
000a69 0a74          .dw XT_CONSTANT
000a6a 1c37          .dw XT_DOLITERAL
000a6b 0002          .dw 2
000a6c 0161          .dw XT_ALLOT
000a6d 1c1a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000a6e ff08          .dw $ff08
000a6f 6f63
000a70 736e
000a71 6174
000a72 746e          .db "constant"
000a73 0a61          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000a74 1c00          .dw DO_COLON
                 PFA_CONSTANT:
000a75 016d          .dw XT_DOCREATE
000a76 09f3          .dw XT_REVEAL
000a77 0194          .dw XT_COMPILE
000a78 1c42          .dw PFA_DOVARIABLE
000a79 019f          .dw XT_COMMA
000a7a 1c1a          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000a7b ff04          .dw $ff04
000a7c 7375
000a7d 7265          .db "user"
000a7e 0a6e          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000a7f 1c00          .dw DO_COLON
                 PFA_USER:
000a80 016d          .dw XT_DOCREATE
000a81 09f3          .dw XT_REVEAL
                 
000a82 0194          .dw XT_COMPILE
000a83 1c52          .dw PFA_DOUSER
000a84 019f          .dw XT_COMMA
000a85 1c1a          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000a86 ff05          .dw $ff05
000a87 6176
000a88 756c
000a89 0065          .db "value",0
000a8a 0a7b          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000a8b 1c00          .dw DO_COLON
                 PFA_VALUE:
000a8c 1c63          .dw XT_DOVALUE
000a8d 0150          .dw XT_EDP
000a8e 019f          .dw XT_COMMA
000a8f 0194          .dw XT_COMPILE
000a90 0a9b          .dw XT_EVALUEFETCH
000a91 0194          .dw XT_COMPILE
000a92 0a9f          .dw XT_EVALUESTORE
000a93 0150          .dw XT_EDP
000a94 1cac          .dw XT_DUP
000a95 1e38          .dw XT_1PLUS
000a96 1e38          .dw XT_1PLUS
000a97 077b          .dw XT_DOTO
000a98 0151          .dw PFA_EDP
000a99 1f37          .dw XT_STOREE
000a9a 1c1a          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000a9b 1c00          .dw DO_COLON
                 PFA_EVALUEFETCH:
000a9c 1f6f          .dw XT_FETCHI
000a9d 1f5b          .dw XT_FETCHE
000a9e 1c1a          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000a9f 1c00          .dw DO_COLON
                 PFA_EVALUESTORE:
000aa0 1f6f          .dw XT_FETCHI
000aa1 1f37          .dw XT_STOREE
000aa2 1c1a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000aa3 0007          .dw $0007
000aa4 6572
000aa5 7563
000aa6 7372
000aa7 0065          .db "recurse",0
000aa8 0a86          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000aa9 1c00          .dw DO_COLON
                 PFA_RECURSE:
000aaa 0a08          .dw XT_LATEST
000aab 1c74          .dw XT_FETCH
000aac 019f          .dw XT_COMMA
000aad 1c1a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000aae ff09          .dw $ff09
000aaf 6d69
000ab0 656d
000ab1 6964
000ab2 7461
000ab3 0065          .db "immediate",0
000ab4 0aa3          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000ab5 1c00          .dw DO_COLON
                 PFA_IMMEDIATE:
000ab6 0b92          .dw XT_GET_CURRENT
000ab7 1f5b          .dw XT_FETCHE
000ab8 1cac          .dw XT_DUP
000ab9 1f6f          .dw XT_FETCHI
000aba 1c37          .dw XT_DOLITERAL
000abb 7fff          .dw $7fff
000abc 1e1c          .dw XT_AND
000abd 1cbf          .dw XT_SWAP
000abe 1f79          .dw XT_STOREI
000abf 1c1a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000ac0 0006          .dw $0006
000ac1 635b
000ac2 6168
000ac3 5d72          .db "[char]"
000ac4 0aae          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000ac5 1c00          .dw DO_COLON
                 PFA_BRACKETCHAR:
000ac6 0194          .dw XT_COMPILE
000ac7 1c37          .dw XT_DOLITERAL
000ac8 04d3          .dw XT_CHAR
000ac9 019f          .dw XT_COMMA
000aca 1c1a          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000acb 0006          .dw $0006
000acc 6261
000acd 726f
000ace 2274          .db "abort", $22
000acf 0ac0          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000ad0 1c00          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000ad1 0194          .dw XT_COMPILE
000ad2 1c30          .dw XT_DOCONDBRANCH
000ad3 0148          .dw XT_DP
000ad4 0194          .dw XT_COMPILE
000ad5 ffff          .dw -1
                     
000ad6 0d22          .dw XT_DOTSTRING
                     
000ad7 0194          .dw XT_COMPILE
000ad8 1c37          .dw XT_DOLITERAL
                     
000ad9 0194          .dw XT_COMPILE
000ada fffe          .dw -2
000adb 0194          .dw XT_COMPILE
000adc 0450          .dw XT_THROW
                     ; then
000add 0148          .dw XT_DP
000ade 1cbf          .dw XT_SWAP
000adf 1f79          .dw XT_STOREI
000ae0 1c1a          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000ae1 ff05          .dw $ff05
000ae2 6261
000ae3 726f
000ae4 0074          .db "abort",0
000ae5 0acb          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000ae6 1c00          .dw DO_COLON
                 PFA_ABORT:
000ae7 1c37          .dw XT_DOLITERAL
000ae8 ffff          .dw -1
000ae9 0450          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000aea ff04          .dw $ff04
000aeb 6f63
000aec 6564          .db "code"
000aed 0ae1          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000aee 1c00          .dw DO_COLON
                 PFA_CODE:
000aef 016d          .dw XT_DOCREATE
000af0 09f3          .dw XT_REVEAL
000af1 0148          .dw XT_DP
000af2 1e38          .dw XT_1PLUS
000af3 019f          .dw XT_COMMA
000af4 1c1a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000af5 ff08          .dw $ff08
000af6 6e65
000af7 2d64
000af8 6f63
000af9 6564          .db "end-code"
000afa 0aea          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000afb 1c00          .dw DO_COLON
                 PFA_ENDCODE:
000afc 0194          .dw XT_COMPILE
000afd 940c          .dw $940c
000afe 0194          .dw XT_COMPILE
000aff 1c04          .dw DO_NEXT
000b00 1c1a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000b01 ff0b          .dw $ff0b
000b02 6e65
000b03 6976
000b04 6f72
000b05 6d6e
000b06 6e65
000b07 0074          .db "environment",0
000b08 0af5          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000b09 1c42          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000b0a 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000b0b ff09          .dw $ff09
000b0c 6f77
000b0d 6472
000b0e 696c
000b0f 7473
000b10 0073          .db "wordlists",0
000b11 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000b12 1c00          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000b13 1c37          .dw XT_DOLITERAL
000b14 0008          .dw NUMWORDLISTS
000b15 1c1a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000b16 ff04          .dw $ff04
000b17 702f
000b18 6461          .db "/pad"
000b19 0b0b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000b1a 1c00          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000b1b 1e8a          .dw XT_SP_FETCH
000b1c 011e          .dw XT_PAD
000b1d 1d9c          .dw XT_MINUS
000b1e 1c1a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000b1f ff05          .dw $ff05
000b20 682f
000b21 6c6f
000b22 0064          .db "/hold",0
000b23 0b16          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000b24 1c00          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000b25 011e          .dw XT_PAD
000b26 0158          .dw XT_HERE
000b27 1d9c          .dw XT_MINUS
000b28 1c1a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000b29 ff0a          .dw $ff0a
000b2a 6f66
000b2b 7472
000b2c 2d68
000b2d 616e
000b2e 656d          .db "forth-name"
000b2f 0b1f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000b30 1c00          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000b31 0384          .dw XT_DOSLITERAL
000b32 0007          .dw 7
000b33 6d61
000b34 6f66
000b35 7472
000b36 0068          .db "amforth",0
000b37 1c1a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000b38 ff07          .dw $ff07
000b39 6576
000b3a 7372
000b3b 6f69
000b3c 006e          .db "version",0
000b3d 0b29          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000b3e 1c00          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000b3f 1c37          .dw XT_DOLITERAL
000b40 0034          .dw 52
000b41 1c1a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000b42 ff03          .dw $ff03
000b43 7063
000b44 0075          .db "cpu",0
000b45 0b38          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000b46 1c00          .dw DO_COLON
                 PFA_EN_CPU:
000b47 1c37          .dw XT_DOLITERAL
000b48 002d          .dw mcu_name
000b49 03e6          .dw XT_ICOUNT
000b4a 1c1a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000b4b ff08          .dw $ff08
000b4c 636d
000b4d 2d75
000b4e 6e69
000b4f 6f66          .db "mcu-info"
000b50 0b42          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000b51 1c00          .dw DO_COLON
                 PFA_EN_MCUINFO:
000b52 1c37          .dw XT_DOLITERAL
000b53 0029          .dw mcu_info
000b54 1c1a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000b55 ff05          .dw $ff05
000b56 752f
000b57 6573
000b58 0072          .db "/user",0
000b59 0b4b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000b5a 1c00          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000b5b 1c37          .dw XT_DOLITERAL
000b5c 0026          .dw SYSUSERSIZE + APPUSERSIZE
000b5d 1c1a          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000b5e ff04          .dw $ff04
000b5f 6540
000b60 5d5b          .db "@e[]"
000b61 0b01          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000b62 1c00          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000b63 1cac          .dw XT_DUP
000b64 1f5b          .dw XT_FETCHE
000b65 1cf3          .dw XT_TO_R    ; save the counter to r-stack
000b66 1cfc          .dw XT_R_FETCH
000b67 1d34          .dw XT_ZERO
000b68 1cbf          .dw XT_SWAP    ; go from bigger to smaller addresses
000b69 1eaa          .dw XT_DOQDO
000b6a 0b74          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000b6b 1ebd          .dw XT_I
000b6c 00f1          .dw XT_CELLS ; ( -- ee-addr i*2 )
000b6d 1cca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000b6e 1da6          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000b6f 1f5b          .dw XT_FETCHE ;( -- ee-addr item_i )
000b70 1cbf          .dw XT_SWAP   ;( -- item_i ee-addr )
000b71 1d3d          .dw XT_TRUE  ; shortcut for -1
000b72 1ebe          .dw XT_DOPLUSLOOP
000b73 0b6b          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000b74 010a          .dw XT_2DROP
000b75 1cea          .dw XT_R_FROM ; get the counter from r-stack
000b76 1c1a          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000b77 ff04          .dw $ff04
000b78 6521
000b79 5d5b          .db "!e[]"
000b7a 0b5e          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000b7b 1c00          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000b7c 0101          .dw XT_2DUP
000b7d 1f37          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000b7e 1cbf          .dw XT_SWAP    
000b7f 1d34          .dw XT_ZERO
000b80 1eaa          .dw XT_DOQDO
000b81 0b88          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000b82 00f9          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000b83 1cbf          .dw XT_SWAP
000b84 1cca          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000b85 1f37          .dw XT_STOREE
000b86 1ed8          .dw XT_DOLOOP
000b87 0b82          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000b88 1cd4          .dw XT_DROP
000b89 1c1a          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000b8a ff0b          .dw $ff0b
000b8b 6567
000b8c 2d74
000b8d 7563
000b8e 7272
000b8f 6e65
000b90 0074          .db "get-current",0
000b91 0b77          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000b92 1c00          .dw DO_COLON
                 PFA_GET_CURRENT:
000b93 1c37          .dw XT_DOLITERAL
000b94 0010          .dw EE_CURRENT
000b95 1f5b          .dw XT_FETCHE
000b96 1c1a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000b97 ff09          .dw $ff09
000b98 6567
000b99 2d74
000b9a 726f
000b9b 6564
000b9c 0072          .db "get-order",0
000b9d 0b8a          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000b9e 1c00          .dw DO_COLON
                 PFA_GET_ORDER:
000b9f 1c37          .dw XT_DOLITERAL
000ba0 0014          .dw EE_ORDERLISTLEN
000ba1 0b62          .dw XT_FETCH_EE_ARRAY
000ba2 1c1a          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000ba3 ff07          .dw $ff07
000ba4 6f63
000ba5 706d
000ba6 7261
000ba7 0065          .db "compare",0
000ba8 0b97          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000ba9 0baa          .dw PFA_COMPARE
                 PFA_COMPARE:
000baa 93bf          push xh
000bab 93af          push xl
000bac 018c          movw temp0, tosl
000bad 9189
000bae 9199          loadtos
000baf 01dc          movw xl, tosl
000bb0 9189
000bb1 9199          loadtos
000bb2 019c          movw temp2, tosl
000bb3 9189
000bb4 9199          loadtos
000bb5 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000bb6 90ed          ld temp4, X+
000bb7 90f1          ld temp5, Z+
000bb8 14ef          cp temp4, temp5
000bb9 f451          brne PFA_COMPARE_NOTEQUAL
000bba 950a          dec temp0
000bbb f019          breq PFA_COMPARE_ENDREACHED2
000bbc 952a          dec temp2
000bbd f7c1          brne PFA_COMPARE_LOOP
000bbe c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000bbf 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000bc0 2b02          or temp0, temp2
000bc1 f411          brne PFA_COMPARE_CHECKLASTCHAR
000bc2 2788          clr tosl
000bc3 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000bc4 ef8f          ser tosl
000bc5 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000bc6 2f98          mov tosh, tosl
000bc7 91af          pop xl
000bc8 91bf          pop xh
000bc9 940c 1c04     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000bcb ff07         .dw $ff07
000bcc 666e
000bcd 3e61
000bce 666c
000bcf 0061         .db "nfa>lfa",0
000bd0 0ba3         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000bd1 1c00          .dw DO_COLON
                 PFA_NFA2LFA:
000bd2 03e6          .dw XT_ICOUNT 
000bd3 1c37          .dw XT_DOLITERAL
000bd4 00ff          .dw $00ff
000bd5 1e1c          .dw XT_AND
000bd6 1e38          .dw XT_1PLUS
000bd7 1e0d          .dw XT_2SLASH
000bd8 1da6          .dw XT_PLUS
000bd9 1c1a          .dw XT_EXIT
                 .include "dict_wl.inc"
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000bda ff0b          .dw $ff0b
000bdb 6573
000bdc 2d74
000bdd 7563
000bde 7272
000bdf 6e65
000be0 0074          .db "set-current",0
000be1 0bcb          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000be2 1c00          .dw DO_COLON
                 PFA_SET_CURRENT:
000be3 1c37          .dw XT_DOLITERAL
000be4 0010          .dw EE_CURRENT
000be5 1f37          .dw XT_STOREE
000be6 1c1a          .dw XT_EXIT
                 .include "words/previous.asm"
                 
                 ; Search Order
                 ; remove the first entry in the search order list
                 VE_PREVIOUS:
000be7 ff08          .dw $ff08
000be8 7270
000be9 7665
000bea 6f69
000beb 7375          .db "previous"
000bec 0bda          .dw VE_HEAD
                     .set VE_HEAD = VE_PREVIOUS
                 XT_PREVIOUS:
000bed 1c00          .dw DO_COLON	
                 PFA_PREVIOUS:
000bee 0b9e          .dw XT_GET_ORDER
000bef 1cbf          .dw XT_SWAP
000bf0 1cd4          .dw XT_DROP
000bf1 1e3e          .dw XT_1MINUS
000bf2 1cac          .dw XT_DUP
000bf3 1d18          .dw XT_EQUALZERO
000bf4 1c30          .dw XT_DOCONDBRANCH
000bf5 0bf9          .dw PFA_PREVIOUS1
000bf6 1c37          .dw XT_DOLITERAL
000bf7 ffce          .dw -50
000bf8 0450          .dw XT_THROW
                 PFA_PREVIOUS1:
000bf9 0c56          .dw XT_SET_ORDER
000bfa 1c1a          .dw XT_EXIT
                 .include "words/definitions.asm"
                 
                 ; Search Order
                 ; Make the compilation word list the same as the current first word list in the search order.
                 VE_DEFINITIONS:
000bfb ff0b          .dw $ff0b
000bfc 6564
000bfd 6966
000bfe 696e
000bff 6974
000c00 6e6f
000c01 0073          .db "definitions",0
000c02 0be7          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFINITIONS
                 XT_DEFINITIONS:
000c03 1c00          .dw DO_COLON
                 PFA_DEFINITIONS:
000c04 0b9e          .dw XT_GET_ORDER
000c05 1cca          .dw XT_OVER
000c06 0be2          .dw XT_SET_CURRENT
                     ; now empty the order list on stack
000c07 1d34          .dw XT_ZERO
000c08 1eaa          .dw XT_DOQDO
000c09 0c0d          .dw PFA_DEFINITIONS2
                 PFA_DEFINITIONS1:
000c0a 1cd4          .dw XT_DROP
000c0b 1ed8          .dw XT_DOLOOP
000c0c 0c0a          .dw PFA_DEFINITIONS1
                 PFA_DEFINITIONS2:
000c0d 1c1a          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000c0e ff08          .dw $ff08
000c0f 6f77
000c10 6472
000c11 696c
000c12 7473          .db "wordlist"
000c13 0bfb          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000c14 1c00          .dw DO_COLON
                 PFA_WORDLIST:
000c15 0150          .dw XT_EDP
000c16 1d34          .dw XT_ZERO
000c17 1cca          .dw XT_OVER
000c18 1f37          .dw XT_STOREE
000c19 1cac          .dw XT_DUP
000c1a 1e38          .dw XT_1PLUS
000c1b 1e38          .dw XT_1PLUS
000c1c 077b          .dw XT_DOTO
000c1d 0151          .dw PFA_EDP
000c1e 1c1a          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000c1f ff04          .dw $ff04
000c20 6e6f
000c21 796c          .db "only"
000c22 0c0e          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000c23 1c00          .dw DO_COLON
                 PFA_ONLY:
000c24 1c37          .dw XT_DOLITERAL
000c25 0012          .dw EE_FORTHWORDLIST
000c26 1c37          .dw XT_DOLITERAL
000c27 0001          .dw 1
000c28 0c56          .dw XT_SET_ORDER
000c29 1c1a          .dw XT_EXIT
                 .include "words/forth.asm"
                 
                 ; Search Order
                 ; replace the search order list with the system default list
                 VE_FORTH:
000c2a ff05          .dw $ff05
000c2b 6f66
000c2c 7472
000c2d 0068          .db "forth",0
000c2e 0c1f          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH
                 XT_FORTH:
000c2f 1c00          .dw DO_COLON
                 PFA_FORTH:
000c30 0b9e          .dw XT_GET_ORDER
000c31 1cbf          .dw XT_SWAP
000c32 1cd4          .dw XT_DROP
000c33 0c40          .dw XT_FORTH_WORDLIST
000c34 1cbf          .dw XT_SWAP
000c35 0c56          .dw XT_SET_ORDER
000c36 1c1a          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000c37 ff0e          .dw $ff0e
000c38 6f66
000c39 7472
000c3a 2d68
000c3b 6f77
000c3c 6472
000c3d 696c
000c3e 7473          .db "forth-wordlist"
000c3f 0c2a          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000c40 1c69          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000c41 000e          .dw EE_WL_FORTH
000c42 0a9b          .dw XT_EVALUEFETCH
000c43 0a9f          .dw XT_EVALUESTORE
                 .include "words/also.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_ALSO:
000c44 ff04          .dw $ff04
000c45 6c61
000c46 6f73          .db "also"
000c47 0c37          .dw VE_HEAD
                     .set VE_HEAD = VE_ALSO
                 XT_ALSO:
000c48 1c00          .dw DO_COLON
                 PFA_ALSO:
000c49 0b9e          .dw XT_GET_ORDER
000c4a 1cca          .dw XT_OVER
000c4b 1cbf          .dw XT_SWAP
000c4c 1e38          .dw XT_1PLUS
000c4d 0c56          .dw XT_SET_ORDER
000c4e 1c1a          .dw XT_EXIT
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 VE_SET_ORDER:
000c4f ff09          .dw $ff09
000c50 6573
000c51 2d74
000c52 726f
000c53 6564
000c54 0072          .db "set-order",0
000c55 0c44          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000c56 1c00          .dw DO_COLON
                 PFA_SET_ORDER:
000c57 1c37          .dw XT_DOLITERAL
000c58 0014          .dw EE_ORDERLISTLEN
000c59 0b7b          .dw XT_STORE_EE_ARRAY
000c5a 1c1a          .dw XT_EXIT
                 
                 .include "words/order.asm"
                 
                 ; Search Order
                 ; print the wids of the current word list and the search order
                 VE_ORDER:
000c5b ff05          .dw $ff05
000c5c 726f
000c5d 6564
000c5e 0072          .db "order",0
000c5f 0c4f          .dw VE_HEAD
                     .set VE_HEAD = VE_ORDER
                 XT_ORDER:
000c60 1c00          .dw DO_COLON
                 PFA_ORDER:
000c61 0b92          .dw XT_GET_CURRENT
000c62 0d01          .dw XT_UDOT
000c63 03ef          .dw XT_CR
000c64 0b9e          .dw XT_GET_ORDER
000c65 1cac          .dw XT_DUP
000c66 0d01          .dw XT_UDOT
000c67 1d34          .dw XT_ZERO
000c68 1eaa          .dw XT_DOQDO
000c69 0c6e          .dw PFA_ORDER2
                 PFA_ORDER1:
000c6a 0d01          .dw XT_UDOT
000c6b 03fc          .dw XT_SPACE         ; ( -- addr n)
000c6c 1ed8          .dw XT_DOLOOP
000c6d 0c6a          .dw PFA_ORDER1
                 PFA_ORDER2:
000c6e 1c1a          .dw XT_EXIT
                 
                 ;.include "dict_mcu.inc"
                 ;.include "dict_vm.inc"
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000c6f ff04          .dw $ff04
000c70 692b
000c71 746e          .db "+int"
000c72 0c5b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000c73 0c74          .dw PFA_INTON
                 PFA_INTON:
000c74 9478          sei
000c75 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000c77 ff04          .dw $ff04
000c78 692d
000c79 746e          .db "-int"
000c7a 0c6f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000c7b 0c7c          .dw PFA_INTOFF
                 PFA_INTOFF:
000c7c 94f8          cli
000c7d 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000c7f ff04          .dw $ff04
000c80 6e69
000c81 2174          .db "int!"
000c82 0c77          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000c83 1c00          .dw DO_COLON
                 PFA_INTSTORE:
000c84 1c37          .dw XT_DOLITERAL
000c85 0075          .dw intvec
000c86 1da6          .dw XT_PLUS
000c87 1c7c          .dw XT_STORE
000c88 1c1a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000c89 ff04          .dw $ff04
000c8a 6e69
000c8b 4074          .db "int@"
000c8c 0c7f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000c8d 1c00          .dw DO_COLON
                 PFA_INTFETCH:
000c8e 1c37          .dw XT_DOLITERAL
000c8f 0075          .dw intvec
000c90 1da6          .dw XT_PLUS
000c91 1c74          .dw XT_FETCH
000c92 1c1a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000c93 ff08          .dw $ff08
000c94 6e69
000c95 2d74
000c96 7274
000c97 7061          .db "int-trap"
000c98 0c89          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000c99 0c9a          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000c9a 9380 0074     sts intcur, tosl
000c9c 9189
000c9d 9199          loadtos
000c9e 9468          set ; set the interrupt flag for the inner interpreter
000c9f 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000ca1 1c00          .dw DO_COLON
                 PFA_ISREXEC:
000ca2 1c37          .dw XT_DOLITERAL
000ca3 0074          .dw intcur
000ca4 1c93          .dw XT_CFETCH
000ca5 1c37          .dw XT_DOLITERAL
000ca6 0075          .dw intvec
000ca7 1da6          .dw XT_PLUS
000ca8 1c74          .dw XT_FETCH
000ca9 1c24          .dw XT_EXECUTE
000caa 0cac          .dw XT_ISREND
000cab 1c1a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000cac 0cad          .dw PFA_ISREND
                 PFA_ISREND:
000cad d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000cae 940c 1c04     jmp_ DO_NEXT
                 PFA_ISREND1:
000cb0 9518          reti
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000cb1 ff03          .dw $ff03
000cb2 3264
000cb3 002a          .db "d2*",0
000cb4 0c93          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000cb5 0cb6          .dw PFA_D2STAR
                 PFA_D2STAR:
000cb6 9109          ld temp0, Y+
000cb7 9119          ld temp1, Y+
000cb8 0f00          lsl temp0
000cb9 1f11          rol temp1
000cba 1f88          rol tosl
000cbb 1f99          rol tosh
000cbc 931a          st -Y, temp1
000cbd 930a          st -Y, temp0
000cbe 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000cc0 ff02          .dw $ff02
000cc1 2b64          .db "d+"
000cc2 0cb1          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000cc3 0cc4          .dw PFA_DPLUS
                 PFA_DPLUS:
000cc4 9129          ld temp2, Y+
000cc5 9139          ld temp3, Y+
                 
000cc6 90e9          ld temp4, Y+
000cc7 90f9          ld temp5, Y+
000cc8 9149          ld temp6, Y+
000cc9 9159          ld temp7, Y+
                 
000cca 0f24          add temp2, temp6
000ccb 1f35          adc temp3, temp7
000ccc 1d8e          adc tosl, temp4
000ccd 1d9f          adc tosh, temp5
                     
000cce 933a          st -Y, temp3
000ccf 932a          st -Y, temp2
000cd0 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000cd2 ff02          .dw $ff02
000cd3 2d64          .db "d-"
000cd4 0cc0          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000cd5 0cd6          .dw PFA_DMINUS
                 PFA_DMINUS:
000cd6 9129          ld temp2, Y+
000cd7 9139          ld temp3, Y+
                 
000cd8 90e9          ld temp4, Y+
000cd9 90f9          ld temp5, Y+
000cda 9149          ld temp6, Y+
000cdb 9159          ld temp7, Y+
                 
000cdc 1b42          sub temp6, temp2
000cdd 0b53          sbc temp7, temp3
000cde 0ae8          sbc temp4, tosl
000cdf 0af9          sbc temp5, tosh
                 
000ce0 935a          st -Y, temp7
000ce1 934a          st -Y, temp6
000ce2 01c7          movw tosl, temp4
000ce3 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000ce5 ff07          .dw $ff07
000ce6 6964
000ce7 766e
000ce8 7265
000ce9 0074          .db "dinvert",0
000cea 0cd2          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000ceb 0cec          .dw PFA_DINVERT
                 PFA_DINVERT:
000cec 9109          ld temp0, Y+
000ced 9119          ld temp1, Y+
000cee 9580          com tosl
000cef 9590          com tosh
000cf0 9500          com temp0
000cf1 9510          com temp1
000cf2 931a          st -Y, temp1
000cf3 930a          st -Y, temp0
000cf4 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
000cf6 ff02          .dw $ff02
000cf7 3d64          .db "d="
000cf8 0ce5          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000cf9 1c00          .dw DO_COLON
                 PFA_DEQUAL:
000cfa 0cd5          .dw XT_DMINUS
000cfb 1e25          .dw XT_OR
000cfc 1d18          .dw XT_EQUALZERO
000cfd 1c1a          .dw XT_EXIT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
000cfe ff02          .dw $ff02
000cff 2e75          .db "u."
000d00 0cf6          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000d01 1c00          .dw DO_COLON
                 PFA_UDOT:
000d02 1d34          .dw XT_ZERO
000d03 0329          .dw XT_UDDOT
000d04 1c1a          .dw XT_EXIT
                 .include "words/udotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 VE_UDOTR:
000d05 ff03          .dw $ff03
000d06 2e75
000d07 0072          .db "u.r",0
000d08 0cfe          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
000d09 1c00          .dw DO_COLON
                 PFA_UDOTR:
000d0a 1d34          .dw XT_ZERO
000d0b 1cbf          .dw XT_SWAP
000d0c 0332          .dw XT_UDDOTR
000d0d 1c1a          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
000d0e ff02          .dw $ff02
000d0f 732e          .db ".s"
000d10 0d05          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000d11 1c00          .dw DO_COLON
                 PFA_DOTS:
000d12 0697          .dw XT_SP0
000d13 1e8a          .dw XT_SP_FETCH
000d14 00f9          .dw XT_CELLPLUS
000d15 1eaa          .dw XT_DOQDO
000d16 0d1e          .dw PFA_DOTS2
                 PFA_DOTS1:
000d17 1ebd          .dw XT_I
000d18 1c74          .dw XT_FETCH 
000d19 0d01          .dw XT_UDOT
000d1a 1c37          .dw XT_DOLITERAL
000d1b 0002          .dw 2
000d1c 1ebe          .dw XT_DOPLUSLOOP
000d1d 0d17          .dw PFA_DOTS1
                 PFA_DOTS2:
000d1e 1c1a          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
000d1f 0002          .dw $0002
000d20 222e          .db ".",$22
000d21 0d0e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000d22 1c00          .dw DO_COLON
                 PFA_DOTSTRING:
000d23 0d2a          .dw XT_SQUOTE
000d24 0194          .dw XT_COMPILE
000d25 03bb          .dw XT_ITYPE
000d26 1c1a          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
000d27 0002        .dw $0002
000d28 2273        .db "s",$22
000d29 0d1f        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000d2a 1c00          .dw DO_COLON
                 PFA_SQUOTE:
000d2b 1c37          .dw XT_DOLITERAL
000d2c 0022          .dw $22
000d2d 0591          .dw XT_PARSE       ; ( -- addr n)
000d2e 00e4          .dw XT_STATE
000d2f 1c74          .dw XT_FETCH
000d30 1c30          .dw XT_DOCONDBRANCH
000d31 0d35          .dw PFA_SQUOTE1
000d32 0194            .dw XT_COMPILE
000d33 0384            .dw XT_DOSLITERAL    ; ( -- addr n)
000d34 0397            .dw XT_SCOMMA
                 PFA_SQUOTE1:
000d35 1c1a          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000d36 ff06          .dw $ff06
000d37 6445
000d38 6665
000d39 7265          .db "Edefer"
000d3a 0d27          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000d3b 1c00          .dw DO_COLON
                 PFA_EDEFER:
000d3c 016d          .dw XT_DOCREATE
000d3d 09f3          .dw XT_REVEAL
000d3e 0194          .dw XT_COMPILE
000d3f 07c3          .dw PFA_DODEFER
                 
000d40 0150          .dw XT_EDP
000d41 1cac          .dw XT_DUP
000d42 019f          .dw XT_COMMA
000d43 0194          .dw XT_COMPILE
000d44 0787          .dw XT_EDEFERFETCH
000d45 0194          .dw XT_COMPILE
000d46 078c          .dw XT_EDEFERSTORE
000d47 00f9          .dw XT_CELLPLUS
000d48 077b          .dw XT_DOTO
000d49 0151          .dw PFA_EDP
000d4a 1c1a          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000d4b ff06          .dw $ff06
000d4c 6452
000d4d 6665
000d4e 7265          .db "Rdefer"
000d4f 0d36          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000d50 1c00          .dw DO_COLON
                 PFA_RDEFER:
000d51 016d          .dw XT_DOCREATE
000d52 09f3          .dw XT_REVEAL
                 
000d53 0194          .dw XT_COMPILE
000d54 07c3          .dw PFA_DODEFER
                 
000d55 0158          .dw XT_HERE
000d56 019f          .dw XT_COMMA
000d57 1c37          .dw XT_DOLITERAL
000d58 0002          .dw 2
000d59 0161          .dw XT_ALLOT
                 
000d5a 0194          .dw XT_COMPILE
000d5b 0791          .dw XT_RDEFERFETCH
000d5c 0194          .dw XT_COMPILE
000d5d 0796          .dw XT_RDEFERSTORE
000d5e 1c1a          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000d5f 0002          .dw $0002
000d60 7369          .db "is"
000d61 0d4b          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000d62 1c00          .dw DO_COLON
                 PFA_IS:
000d63 00e4          .dw XT_STATE
000d64 1c74          .dw XT_FETCH
000d65 1c30          .dw XT_DOCONDBRANCH
000d66 0d6b          .dw PFA_IS1
000d67 01ab          .dw XT_BRACKETTICK
000d68 0194          .dw XT_COMPILE
000d69 07ae          .dw XT_DEFERSTORE
000d6a 1c1a          .dw XT_EXIT
                 PFA_IS1:
000d6b 0423          .dw XT_TICK
000d6c 07ae          .dw XT_DEFERSTORE
000d6d 1c1a          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000d6e ff0b          .dw $ff0b
000d6f 7061
000d70 6c70
000d71 7574
000d72 6e72
000d73 656b
000d74 0079          .db "applturnkey",0
000d75 0d5f          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000d76 1c00          .dw DO_COLON
                 PFA_APPLTURNKEY:
000d77 00a5          .dw XT_USART
000d78 0c73          .dw XT_INTON
000d79 0743          .dw XT_VER
000d7a 03fc          .dw XT_SPACE
000d7b 00ce          .dw XT_F_CPU
000d7c 1c37          .dw XT_DOLITERAL
000d7d 03e8          .dw 1000
000d7e 1dcb          .dw XT_UMSLASHMOD
000d7f 1cbf          .dw XT_SWAP
000d80 1cd4          .dw XT_DROP
000d81 01c1          .dw XT_DECIMAL
000d82 0321          .dw XT_DOT
000d83 0384          .dw XT_DOSLITERAL
000d84 0004          .dw 4
000d85 486b
000d86 207a          .db "kHz "
000d87 03bb          .dw XT_ITYPE
000d88 1c1a          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000d89 ff04          .dw $ff04
000d8a 6966
000d8b 6c6c          .db "fill"
000d8c 0d6e          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000d8d 1c00          .dw DO_COLON
                 PFA_FILL:
000d8e 1cdc          .dw XT_ROT
000d8f 1cdc          .dw XT_ROT
000d90 1d34          .dw XT_ZERO
000d91 1eaa          .dw XT_DOQDO
000d92 0d98          .dw PFA_FILL2
                 PFA_FILL1:
000d93 0101          .dw XT_2DUP
000d94 1c88          .dw XT_CSTORE  ; ( -- c c-addr)
000d95 1e38          .dw XT_1PLUS
000d96 1ed8          .dw XT_DOLOOP
000d97 0d93          .dw PFA_FILL1
                 PFA_FILL2:
000d98 1cd4          .dw XT_DROP
000d99 1cd4          .dw XT_DROP
000d9a 1c1a          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
000d9b ff0d          .dw $ff0d
000d9c 6873
000d9d 776f
000d9e 772d
000d9f 726f
000da0 6c64
000da1 7369
000da2 0074          .db "show-wordlist",0
000da3 0d89          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
000da4 1c00          .dw DO_COLON
                 PFA_SHOWWORDLIST:
000da5 1c37          .dw XT_DOLITERAL
000da6 0daa          .dw XT_SHOWWORD
000da7 1cbf          .dw XT_SWAP
000da8 081d          .dw XT_TRAVERSEWORDLIST
000da9 1c1a          .dw XT_EXIT
                 
                 XT_SHOWWORD:
000daa 1c00          .dw DO_COLON
                 PFA_SHOWWORD:
000dab 080c          .dw XT_NAME2STRING
000dac 03bb          .dw XT_ITYPE
000dad 03fc          .dw XT_SPACE         ; ( -- addr n)
000dae 1d3d          .dw XT_TRUE
000daf 1c1a          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000db0 ff05          .dw $ff05
000db1 6f77
000db2 6472
000db3 0073          .db "words",0
000db4 0d9b          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000db5 1c00          .dw DO_COLON
                 PFA_WORDS:
000db6 1c37          .dw XT_DOLITERAL
000db7 0016          .dw EE_ORDERLIST
000db8 1f5b          .dw XT_FETCHE
000db9 0da4          .dw XT_SHOWWORDLIST
000dba 1c1a          .dw XT_EXIT
                 
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
000dbb ff03          .dw $ff03
000dbc 6d31
000dbd 0073          .db "1ms",0
000dbe 0db0          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000dbf 0dc0          .dw PFA_1MS
                 PFA_1MS:
000dc0 ede0
000dc1 e0f7
000dc2 9731
000dc3 f7f1          delay 1000
000dc4 940c 1c04     jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
000dc6 0008          .dw $0008
000dc7 6c32
000dc8 7469
000dc9 7265
000dca 6c61          .db "2literal"
000dcb 0dbb          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
000dcc 1c00          .dw DO_COLON
                 PFA_2LITERAL:
000dcd 1cbf          .dw XT_SWAP
000dce 0194          .dw XT_COMPILE
000dcf 1c37          .dw XT_DOLITERAL
000dd0 019f          .dw XT_COMMA
000dd1 0194          .dw XT_COMPILE
000dd2 1c37          .dw XT_DOLITERAL
000dd3 019f          .dw XT_COMMA
                     
000dd4 1c1a          .dw XT_EXIT
                 .include "device.inc"
                 
                 ; generated automatically, no not edit
                 
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 .if WANT_EEPROM == 1
                 .endif
                 .if WANT_CPU == 1
                 .endif
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 .if WANT_SPI == 1
                 .endif
                 .if WANT_USART == 1
                 .endif
                 .if WANT_TWI == 1
                 .endif
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 .if WANT_JTAG == 1
                 .endif
                 .if WANT_BOOT_LOAD == 1
                 .endif
                 .if WANT_PORTA == 1
                 .endif
                 .if WANT_PORTB == 1
                 .endif
                 .if WANT_PORTC == 1
                 .endif
                 .if WANT_PORTD == 1
                 .endif
                 .if WANT_WATCHDOG == 1
                 .endif
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c00 93bf          push XH
001c01 93af          push XL          ; PUSH IP
001c02 01db          movw XL, wl
001c03 9611          adiw xl, 1
                 DO_NEXT:
001c04 f06e          brts DO_INTERRUPT
001c05 01fd          movw zl, XL        ; READ IP
001c06 0fee
001c07 1fff
001c08 9165
001c09 9175          readflashcell wl, wh
001c0a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0b 01fb          movw zl, wl
001c0c 0fee
001c0d 1fff
001c0e 9105
001c0f 9115          readflashcell temp0,temp1
001c10 01f8          movw zl, temp0
001c11 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c12 94e8          clt
001c13 ea61          ldi wl, LOW(XT_ISREXEC)
001c14 e07c          ldi wh, HIGH(XT_ISREXEC)
001c15 cff5          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c16 ff04          .dw $ff04
001c17 7865
001c18 7469          .db "exit"
001c19 0dc6          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c1a 1c1b          .dw PFA_EXIT
                 PFA_EXIT:
001c1b 91af          pop XL
001c1c 91bf          pop XH
001c1d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c1e ff07          .dw $ff07
001c1f 7865
001c20 6365
001c21 7475
001c22 0065          .db "execute",0
001c23 1c16          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c24 1c25          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c25 01bc          movw wl, tosl
001c26 9189
001c27 9199          loadtos
001c28 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c29 1c2a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c2a 01fd          movw zl, XL
001c2b 0fee
001c2c 1fff
001c2d 91a5
001c2e 91b5          readflashcell XL,XH
001c2f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c30 1c31          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c31 2b98          or tosh, tosl
001c32 9189
001c33 9199          loadtos
001c34 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c35 9611          adiw XL, 1
001c36 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c37 1c38          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c38 939a
001c39 938a          savetos
001c3a 01fd          movw zl, xl
001c3b 0fee
001c3c 1fff
001c3d 9185
001c3e 9195          readflashcell tosl,tosh
001c3f 9611          adiw xl, 1
001c40 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c41 1c42          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c42 939a
001c43 938a          savetos
001c44 01fb          movw zl, wl
001c45 9631          adiw zl,1
001c46 0fee
001c47 1fff
001c48 9185
001c49 9195          readflashcell tosl,tosh
001c4a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c4b 1c4c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c4c 939a
001c4d 938a          savetos
001c4e 01cb          movw tosl, wl
001c4f 9601          adiw tosl, 1
001c50 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c51 1c52          .dw PFA_DOUSER
                 PFA_DOUSER:
001c52 939a
001c53 938a          savetos
001c54 01fb          movw zl, wl
001c55 9631          adiw zl, 1
001c56 0fee
001c57 1fff
001c58 9185
001c59 9195          readflashcell tosl,tosh
001c5a 0d84          add tosl, upl
001c5b 1d95          adc tosh, uph
001c5c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c5d ff07          .dw $ff07
001c5e 7628
001c5f 6c61
001c60 6575
001c61 0029          .db "(value)", 0
001c62 1c1e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c63 1c00          .dw DO_COLON
                 PFA_DOVALUE:
001c64 016d          .dw XT_DOCREATE
001c65 09f3          .dw XT_REVEAL
001c66 0194          .dw XT_COMPILE
001c67 1c69          .dw PFA_DOVALUE1
001c68 1c1a          .dw XT_EXIT
                 PFA_DOVALUE1:
001c69 940e 0a17     call_ DO_DODOES
001c6b 1cac          .dw XT_DUP
001c6c 1cbf          .dw XT_SWAP
001c6d 1e38          .dw XT_1PLUS
001c6e 1f6f          .dw XT_FETCHI
001c6f 1c24          .dw XT_EXECUTE
001c70 1c1a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c71 ff01          .dw $ff01
001c72 0040          .db "@",0
001c73 1c5d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c74 1c75          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c75 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c76 9181          ld tosl, z+
001c77 9191          ld tosh, z+
001c78 cf8b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c79 ff01          .dw $ff01
001c7a 0021          .db "!",0
001c7b 1c71          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c7c 1c7d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c7d 01fc          movw zl, tosl
001c7e 9189
001c7f 9199          loadtos
                     ; the high byte is written before the low byte
001c80 8391          std Z+1, tosh
001c81 8380          std Z+0, tosl
001c82 9189
001c83 9199          loadtos
001c84 cf7f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c85 ff02          .dw $ff02
001c86 2163          .db "c!"
001c87 1c79          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c88 1c89          .dw PFA_CSTORE
                 PFA_CSTORE:
001c89 01fc          movw zl, tosl
001c8a 9189
001c8b 9199          loadtos
001c8c 8380          st Z, tosl
001c8d 9189
001c8e 9199          loadtos
001c8f cf74          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c90 ff02          .dw $ff02
001c91 4063          .db "c@"
001c92 1c85          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c93 1c94          .dw PFA_CFETCH
                 PFA_CFETCH:
001c94 01fc          movw zl, tosl
001c95 2799          clr tosh
001c96 8180          ld tosl, Z
001c97 cf6c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
001c98 ff02          .dw $ff02
001c99 7540          .db "@u"
001c9a 1c90          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001c9b 1c00          .dw DO_COLON
                 PFA_FETCHU:
001c9c 1f17          .dw XT_UP_FETCH
001c9d 1da6          .dw XT_PLUS
001c9e 1c74          .dw XT_FETCH
001c9f 1c1a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
001ca0 ff02          .dw $ff02
001ca1 7521          .db "!u"
001ca2 1c98          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca3 1c00          .dw DO_COLON
                 PFA_STOREU:
001ca4 1f17          .dw XT_UP_FETCH
001ca5 1da6          .dw XT_PLUS
001ca6 1c7c          .dw XT_STORE
001ca7 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001ca8 ff03          .dw $ff03
001ca9 7564
001caa 0070          .db "dup",0
001cab 1ca0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cac 1cad          .dw PFA_DUP
                 PFA_DUP:
001cad 939a
001cae 938a          savetos
001caf cf54          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001cb0 ff04          .dw $ff04
001cb1 643f
001cb2 7075          .db "?dup"
001cb3 1ca8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb4 1cb5          .dw PFA_QDUP
                 PFA_QDUP:
001cb5 2f08          mov temp0, tosl
001cb6 2b09          or temp0, tosh
001cb7 f011          breq PFA_QDUP1
001cb8 939a
001cb9 938a          savetos
                 PFA_QDUP1:
001cba cf49          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cbb ff04          .dw $ff04
001cbc 7773
001cbd 7061          .db "swap"
001cbe 1cb0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cbf 1cc0          .dw PFA_SWAP
                 PFA_SWAP:
001cc0 018c          movw temp0, tosl
001cc1 9189
001cc2 9199          loadtos
001cc3 931a          st -Y, temp1
001cc4 930a          st -Y, temp0
001cc5 cf3e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001cc6 ff04          .dw $ff04
001cc7 766f
001cc8 7265          .db "over"
001cc9 1cbb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001cca 1ccb          .dw PFA_OVER
                 PFA_OVER:
001ccb 939a
001ccc 938a          savetos
001ccd 818a          ldd tosl, Y+2
001cce 819b          ldd tosh, Y+3
                 
001ccf cf34          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001cd0 ff04          .dw $ff04
001cd1 7264
001cd2 706f          .db "drop"
001cd3 1cc6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd4 1cd5          .dw PFA_DROP
                 PFA_DROP:
001cd5 9189
001cd6 9199          loadtos
001cd7 cf2c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cd8 ff03          .dw $ff03
001cd9 6f72
001cda 0074          .db "rot",0
001cdb 1cd0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001cdc 1cdd          .dw PFA_ROT
                 PFA_ROT:
001cdd 018c          movw temp0, tosl
001cde 9129          ld temp2, Y+
001cdf 9139          ld temp3, Y+ 
001ce0 9189
001ce1 9199          loadtos
                         
001ce2 933a          st -Y, temp3
001ce3 932a          st -Y, temp2
001ce4 931a          st -Y, temp1
001ce5 930a          st -Y, temp0
                 
001ce6 cf1d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001ce7 ff02          .dw $ff02
001ce8 3e72          .db "r>"
001ce9 1cd8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cea 1ceb          .dw PFA_R_FROM
                 PFA_R_FROM:
001ceb 939a
001cec 938a          savetos
001ced 918f          pop tosl
001cee 919f          pop tosh
001cef cf14          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cf0 ff02          .dw $ff02
001cf1 723e          .db ">r"
001cf2 1ce7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cf3 1cf4          .dw PFA_TO_R
                 PFA_TO_R:
001cf4 939f          push tosh
001cf5 938f          push tosl
001cf6 9189
001cf7 9199          loadtos
001cf8 cf0b          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001cf9 ff02          .dw $ff02
001cfa 4072          .db "r@"
001cfb 1cf0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001cfc 1cfd          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001cfd 939a
001cfe 938a          savetos
001cff 918f          pop tosl
001d00 919f          pop tosh
001d01 939f          push tosh
001d02 938f          push tosl
001d03 cf00          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
001d04 ff02          .dw $ff02
001d05 3e3c          .db "<>"
001d06 1cf9          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d07 1d08          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
001d08 9129          ld temp2, Y+
001d09 9139          ld temp3, Y+
001d0a 1782          cp tosl, temp2
001d0b 0793          cpc tosh, temp3
001d0c f151          breq PFA_ZERO1
001d0d c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001d0e ff01          .dw $ff01
001d0f 003d          .db "=",0
001d10 1d04          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001d11 1c00          .dw DO_COLON
                 PFA_EQUAL:
001d12 1d9c          .dw XT_MINUS
001d13 1d18          .dw XT_EQUALZERO
001d14 1c1a          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
001d15 ff02          .dw $ff02
001d16 3d30          .db "0="
001d17 1d0e          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
001d18 1d19          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
001d19 2b98          or tosh, tosl
001d1a f4e1          brne PFA_ZERO1
001d1b c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d1c ff01          .dw $ff01
001d1d 003c          .db "<",0
001d1e 1d15          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d1f 1c00          .dw DO_COLON
                 PFA_LESS:
001d20 1d9c          .dw XT_MINUS
001d21 1d2d          .dw XT_LESSZERO
001d22 1c1a          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d23 ff01          .dw $ff01
001d24 003e          .db ">",0
001d25 1d1c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d26 1c00          .dw DO_COLON
                 PFA_GREATER:
001d27 1d9c          .dw XT_MINUS
001d28 1d5c          .dw XT_GREATERZERO
001d29 1c1a          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
001d2a ff02          .dw $ff02
001d2b 3c30          .db "0<"
001d2c 1d23          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
001d2d 1d2e          .dw PFA_LESSZERO
                 PFA_LESSZERO:
001d2e fd97          sbrc tosh,7
001d2f c010          rjmp PFA_TRUE1
001d30 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d31 ff01          .dw $ff01
001d32 0030          .db "0",0
001d33 1d2a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d34 1d35          .dw PFA_ZERO
                 PFA_ZERO:
001d35 939a
001d36 938a          savetos
                 PFA_ZERO1:
001d37 01c1          movw tosl, zerol
001d38 cecb          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d39 ff04          .dw $ff04
001d3a 7274
001d3b 6575          .db "true"
001d3c 1d31          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d3d 1d3e          .dw PFA_TRUE
                 PFA_TRUE:
001d3e 939a
001d3f 938a          savetos
                 PFA_TRUE1:
001d40 ef8f          ser tosl
001d41 ef9f          ser tosh
001d42 cec1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d43 ff02          .dw $ff02
001d44 3c75          .db "u<"
001d45 1d39          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d46 1d47          .dw PFA_ULESS
                 PFA_ULESS:
001d47 9129          ld temp2, Y+
001d48 9139          ld temp3, Y+
001d49 1782          cp tosl, temp2
001d4a 0793          cpc tosh, temp3
001d4b f358          brlo PFA_ZERO1
001d4c f351          brbs 1, PFA_ZERO1
001d4d cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
001d4e ff02          .dw $ff02
001d4f 3e75          .db "u>"
001d50 1d43          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d51 1d52          .dw PFA_UGREATER
                 PFA_UGREATER:
001d52 9129          ld temp2, Y+
001d53 9139          ld temp3, Y+
001d54 1728          cp temp2, tosl
001d55 0739          cpc temp3, tosh
001d56 f300          brlo PFA_ZERO1
001d57 f2f9          brbs 1, PFA_ZERO1
001d58 cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d59 ff02          .dw $ff02
001d5a 3e30          .db "0>"
001d5b 1d4e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d5c 1d5d          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d5d 1582          cp tosl, zerol
001d5e 0593          cpc tosh, zeroh
001d5f f2bc          brlt PFA_ZERO1
001d60 f2b1          brbs 1, PFA_ZERO1
001d61 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
001d62 ff02          .dw $ff02
001d63 3e64          .db "d>"
001d64 1d59          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
001d65 1c00          .dw DO_COLON
                 PFA_DGREATER:
001d66 0cd5          .dw XT_DMINUS
001d67 1d6d          .dw XT_DGREATERZERO
001d68 1c1a          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d69 ff03          .dw $ff03
001d6a 3064
001d6b 003e          .db "d0>",0
001d6c 1d62          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d6d 1d6e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d6e 1582          cp tosl, zerol
001d6f 0593          cpc tosh, zeroh
001d70 9189
001d71 9199          loadtos
001d72 0582          cpc tosl, zerol
001d73 0593          cpc tosh, zeroh
001d74 f214          brlt PFA_ZERO1
001d75 f209          brbs 1, PFA_ZERO1
001d76 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
001d77 ff02          .dw $ff02
001d78 3c64          .db "d<"
001d79 1d69          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
001d7a 1c00          .dw DO_COLON
                 PFA_DLESS:
001d7b 0cd5          .dw XT_DMINUS
001d7c 1d82          .dw XT_DLESSZERO
001d7d 1c1a          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
001d7e ff03          .dw $ff03
001d7f 3064
001d80 003c          .db "d0<",0
001d81 1d77          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
001d82 1d83          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
001d83 9622          adiw Y,2
001d84 fd97          sbrc tosh,7
001d85 940c 1d40     jmp PFA_TRUE1
001d87 940c 1d37     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d89 ff04          .dw $ff04
001d8a 6f6c
001d8b 3267          .db "log2"
001d8c 1d7e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d8d 1d8e          .dw PFA_LOG2
                 PFA_LOG2:
001d8e 01fc          movw zl, tosl
001d8f 2799          clr tosh
001d90 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d91 958a          dec tosl
001d92 f022          brmi PFA_LOG2_2 ; wrong data
001d93 0fee          lsl  zl
001d94 1fff          rol  zh
001d95 f7d8          brcc PFA_LOG2_1
001d96 ce6d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d97 959a          dec tosh
001d98 ce6b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d99 ff01          .dw $ff01
001d9a 002d          .db "-",0
001d9b 1d89          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d9c 1d9d          .dw PFA_MINUS
                 PFA_MINUS:
001d9d 9109          ld temp0, Y+
001d9e 9119          ld temp1, Y+
001d9f 1b08          sub temp0, tosl
001da0 0b19          sbc temp1, tosh
001da1 01c8          movw tosl, temp0
001da2 ce61          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001da3 ff01          .dw $ff01
001da4 002b          .db "+",0
001da5 1d99          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001da6 1da7          .dw PFA_PLUS
                 PFA_PLUS:
001da7 9109          ld temp0, Y+
001da8 9119          ld temp1, Y+
001da9 0f80          add tosl, temp0
001daa 1f91          adc tosh, temp1
001dab ce58          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001dac ff02          .dw $ff02
001dad 2a6d          .db "m*"
001dae 1da3          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001daf 1db0          .dw PFA_MSTAR
                 PFA_MSTAR:
001db0 018c          movw temp0, tosl
001db1 9189
001db2 9199          loadtos
001db3 019c          movw temp2, tosl
                     ; high cell ah*bh
001db4 0231          muls temp3, temp1
001db5 0170          movw temp4, r0
                     ; low cell  al*bl
001db6 9f20          mul  temp2, temp0
001db7 01c0          movw tosl, r0
                     ; signed ah*bl
001db8 0330          mulsu temp3, temp0
001db9 08f3          sbc   temp5, zeroh
001dba 0d90          add   tosh,  r0
001dbb 1ce1          adc   temp4, r1
001dbc 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001dbd 0312          mulsu temp1, temp2
001dbe 08f3          sbc   temp5, zeroh
001dbf 0d90          add   tosh,  r0
001dc0 1ce1          adc   temp4, r1
001dc1 1cf3          adc   temp5, zeroh
                 
001dc2 939a
001dc3 938a          savetos
001dc4 01c7          movw tosl, temp4
001dc5 ce3e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001dc6 ff06          .dw $ff06
001dc7 6d75
001dc8 6d2f
001dc9 646f          .db "um/mod"
001dca 1dac          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dcb 1dcc          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dcc 017c          movw temp4, tosl
                 
001dcd 9129          ld temp2, Y+
001dce 9139          ld temp3, Y+
                   
001dcf 9109          ld temp0, Y+
001dd0 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dd1 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dd2 2755          clr temp7
001dd3 0f00          lsl temp0
001dd4 1f11          rol temp1
001dd5 1f22          rol temp2
001dd6 1f33          rol temp3
001dd7 1f55          rol temp7
                 
                   ; try subtracting divisor
001dd8 152e          cp temp2, temp4
001dd9 053f          cpc temp3, temp5
001dda 0552          cpc temp7,zerol
                 
001ddb f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001ddc 9503          inc temp0
001ddd 192e          sub temp2, temp4
001dde 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001ddf 954a          dec  temp6
001de0 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001de1 933a          st -Y,temp3
001de2 932a          st -Y,temp2
                 
                     ; put quotient on stack
001de3 01c8          movw tosl, temp0
001de4 ce1f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001de5 ff03          .dw $ff03
001de6 6d75
001de7 002a          .db "um*",0
001de8 1dc6          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001de9 1dea          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001dea 018c          movw temp0, tosl
001deb 9189
001dec 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001ded 9f80          mul tosl,temp0
001dee 01f0          movw zl, r0
001def 2722          clr temp2
001df0 2733          clr temp3
                     ; middle bytes
001df1 9f90          mul tosh, temp0
001df2 0df0          add zh, r0
001df3 1d21          adc temp2, r1
001df4 1d33          adc temp3, zeroh
                         
001df5 9f81          mul tosl, temp1
001df6 0df0          add zh, r0
001df7 1d21          adc temp2, r1
001df8 1d33          adc temp3, zeroh
                     
001df9 9f91          mul tosh, temp1
001dfa 0d20          add temp2, r0
001dfb 1d31          adc temp3, r1
001dfc 01cf          movw tosl, zl
001dfd 939a
001dfe 938a          savetos
001dff 01c9          movw tosl, temp2
001e00 ce03          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001e01 ff06          .dw $ff06
001e02 6e69
001e03 6576
001e04 7472          .db "invert"
001e05 1de5          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001e06 1e07          .dw PFA_INVERT
                 PFA_INVERT:
001e07 9580          com tosl
001e08 9590          com tosh
001e09 cdfa          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001e0a ff02          .dw $ff02
001e0b 2f32          .db "2/"
001e0c 1e01          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001e0d 1e0e          .dw PFA_2SLASH
                 PFA_2SLASH:
001e0e 9595          asr tosh
001e0f 9587          ror tosl
001e10 cdf3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e11 ff02          .dw $ff02
001e12 2a32          .db "2*"
001e13 1e0a          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e14 1e15          .dw PFA_2STAR
                 PFA_2STAR:
001e15 0f88          lsl tosl
001e16 1f99          rol tosh
001e17 cdec          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e18 ff03          .dw $ff03
001e19 6e61
001e1a 0064          .db "and",0
001e1b 1e11          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e1c 1e1d          .dw PFA_AND
                 PFA_AND:
001e1d 9109          ld temp0, Y+
001e1e 9119          ld temp1, Y+
001e1f 2380          and tosl, temp0
001e20 2391          and tosh, temp1
001e21 cde2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e22 ff02          .dw $ff02
001e23 726f          .db "or"
001e24 1e18          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e25 1e26          .dw PFA_OR
                 PFA_OR:
001e26 9109          ld temp0, Y+
001e27 9119          ld temp1, Y+
001e28 2b80          or tosl, temp0
001e29 2b91          or tosh, temp1
001e2a cdd9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e2b ff03          .dw $ff03
001e2c 6f78
001e2d 0072          .db "xor",0
001e2e 1e22          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e2f 1e30          .dw PFA_XOR
                 PFA_XOR:
001e30 9109          ld temp0, Y+
001e31 9119          ld temp1, Y+
001e32 2780          eor tosl, temp0
001e33 2791          eor tosh, temp1
001e34 cdcf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e35 ff02          .dw $ff02
001e36 2b31          .db "1+"
001e37 1e2b          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e38 1e39          .dw PFA_1PLUS
                 PFA_1PLUS:
001e39 9601          adiw tosl,1
001e3a cdc9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e3b ff02          .dw $ff02 
001e3c 2d31          .db "1-"
001e3d 1e35          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e3e 1e3f          .dw PFA_1MINUS
                 PFA_1MINUS:
001e3f 9701          sbiw tosl, 1
001e40 cdc3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e41 ff06          .dw $ff06
001e42 736c
001e43 6968
001e44 7466          .db "lshift"
001e45 1e3b          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e46 1e47          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e47 01fc          movw zl, tosl
001e48 9189
001e49 9199          loadtos
                 PFA_LSHIFT1:
001e4a 9731          sbiw zl, 1
001e4b f01a          brmi PFA_LSHIFT2
001e4c 0f88          lsl tosl
001e4d 1f99          rol tosh
001e4e cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e50 ff06          .dw $ff06
001e51 7372
001e52 6968
001e53 7466          .db "rshift"
001e54 1e41          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e55 1e56          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e56 01fc          movw zl, tosl
001e57 9189
001e58 9199          loadtos
                 PFA_RSHIFT1:
001e59 9731          sbiw zl, 1
001e5a f01a          brmi PFA_RSHIFT2
001e5b 9596          lsr tosh
001e5c 9587          ror tosl
001e5d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e5e cda5          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e5f ff02          .dw $ff02
001e60 212b          .db "+!"
001e61 1e50          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e62 1e63          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e63 01fc          movw zl, tosl
001e64 9189
001e65 9199          loadtos
001e66 8120          ldd temp2, Z+0
001e67 8131          ldd temp3, Z+1
001e68 0f82          add tosl, temp2
001e69 1f93          adc tosh, temp3
001e6a 8380          std Z+0, tosl
001e6b 8391          std Z+1, tosh
001e6c 9189
001e6d 9199          loadtos
001e6e cd95          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e6f ff03          .dw $ff03
001e70 7072
001e71 0040          .db "rp@",0
001e72 1e5f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e73 1e74          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e74 939a
001e75 938a          savetos
001e76 b78d          in tosl, SPL
001e77 b79e          in tosh, SPH
001e78 cd8b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e79 ff03          .dw $ff03
001e7a 7072
001e7b 0021          .db "rp!",0
001e7c 1e6f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e7d 1e7e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e7e b72f          in temp2, SREG
001e7f 94f8          cli
001e80 bf8d          out SPL, tosl
001e81 bf9e          out SPH, tosh
001e82 bf2f          out SREG, temp2
001e83 9189
001e84 9199          loadtos
001e85 cd7e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e86 ff03          .dw $ff03
001e87 7073
001e88 0040          .db "sp@",0
001e89 1e79          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e8a 1e8b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e8b 939a
001e8c 938a          savetos
001e8d 01ce          movw tosl, yl
001e8e cd75          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e8f ff03          .dw $ff03
001e90 7073
001e91 0021          .db "sp!",0
001e92 1e86          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e93 1e94          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e94 01ec          movw yl, tosl
001e95 9189
001e96 9199          loadtos
001e97 cd6c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e98 1e99          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
001e99 01fd          movw zl, xl
001e9a 0fee
001e9b 1fff
001e9c 9105
001e9d 9115          readflashcell temp0,temp1
001e9e 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
001e9f 9129          ld temp2, Y+
001ea0 9139          ld temp3, Y+
                 PFA_DODO1:
001ea1 931f          push temp1
001ea2 930f          push temp0
001ea3 933f          push temp3
001ea4 932f          push temp2
001ea5 939f          push tosh
001ea6 938f          push tosl
001ea7 9189
001ea8 9199          loadtos
001ea9 cd5a          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
001eaa 1eab          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
001eab 01fd          movw zl, xl
001eac 0fee
001ead 1fff
001eae 9105
001eaf 9115          readflashcell temp0,temp1
001eb0 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
001eb1 9129          ld temp2, Y+
001eb2 9139          ld temp3, Y+
                     ; now check for equality
001eb3 1782          cp tosl, temp2
001eb4 0793          cpc tosh, temp3
001eb5 f759          brne PFA_DODO1
                     ; both values are the same -> skip loop
001eb6 01d8          movw xl, temp0
001eb7 9189
001eb8 9199          loadtos
001eb9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001eba ff01          .dw $FF01
001ebb 0069          .db "i",0
001ebc 1e8f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001ebd 1cfd          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001ebe 1ebf          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001ebf 91ef          pop zl
001ec0 91ff          pop zh
001ec1 0fe8          add zl, tosl
001ec2 1ff9          adc zh, tosh
001ec3 2f19          mov temp1, tosh
001ec4 9189
001ec5 9199          loadtos
                 PFA_DOPLUSLOOP4: 
001ec6 912f          pop temp2
001ec7 913f          pop temp3
001ec8 17e2          cp zl, temp2
001ec9 07f3          cpc zh, temp3
001eca ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
001ecb c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
001ecc f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
001ecd c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
001ece f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
001ecf 933f          push temp3
001ed0 932f          push temp2
001ed1 93ff          push zh
001ed2 93ef          push zl
001ed3 cd56          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
001ed4 910f          pop  temp0
001ed5 911f          pop  temp1  ; remove leave destination
001ed6 9611          adiw xl, 1 ; skip branch-back address
001ed7 cd2c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001ed8 1ed9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001ed9 91ef          pop zl
001eda 91ff          pop zh
001edb 9631          adiw zl,1
001edc 912f          pop temp2
001edd 913f          pop temp3
001ede 17e2          cp zl, temp2
001edf 07f3          cpc zh, temp3
001ee0 f399          breq PFA_DOPLUSLOOP1
001ee1 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ee2 ff06          .dw $ff06
001ee3 6e75
001ee4 6f6c
001ee5 706f          .db "unloop"
001ee6 1eba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ee7 1ee8          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ee8 911f          pop temp1
001ee9 910f          pop temp0
001eea 911f          pop temp1
001eeb 910f          pop temp0
001eec 911f          pop temp1
001eed 910f          pop temp0
001eee cd15          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001eef ff06          .dw $ff06
001ef0 6d63
001ef1 766f
001ef2 3e65          .db "cmove>"
001ef3 1ee2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001ef4 1ef5          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ef5 93bf          push xh
001ef6 93af          push xl
001ef7 91e9          ld zl, Y+
001ef8 91f9          ld zh, Y+ ; addr-to
001ef9 91a9          ld xl, Y+
001efa 91b9          ld xh, Y+ ; addr-from
001efb 2f09          mov temp0, tosh
001efc 2b08          or temp0, tosl
001efd f041          brbs 1, PFA_CMOVE_G1
001efe 0fe8          add zl, tosl
001eff 1ff9          adc zh, tosh
001f00 0fa8          add xl, tosl
001f01 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001f02 911e          ld temp1, -X
001f03 9312          st -Z, temp1
001f04 9701          sbiw tosl, 1
001f05 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001f06 91af          pop xl
001f07 91bf          pop xh
001f08 9189
001f09 9199          loadtos
001f0a ccf9          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001f0b ff02          .dw $ff02
001f0c 3c3e          .db "><"
001f0d 1eef          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001f0e 1f0f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001f0f 2f09          mov temp0, tosh
001f10 2f98          mov tosh, tosl
001f11 2f80          mov tosl, temp0
001f12 ccf1          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001f13 ff03          .dw $ff03
001f14 7075
001f15 0040          .db "up@",0
001f16 1f0b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001f17 1f18          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001f18 939a
001f19 938a          savetos
001f1a 01c2          movw tosl, upl
001f1b cce8          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001f1c ff03          .dw $ff03
001f1d 7075
001f1e 0021          .db "up!",0
001f1f 1f13          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001f20 1f21          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001f21 012c          movw upl, tosl
001f22 9189
001f23 9199          loadtos
001f24 ccdf          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
001f25 ff03          .dw $ff03
001f26 3e73
001f27 0064          .db "s>d",0
001f28 1f1c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
001f29 1c00          .dw DO_COLON
                 PFA_S2D:
001f2a 1cac          .dw XT_DUP
001f2b 1d2d          .dw XT_LESSZERO
                 .include "words/not.asm"
001f2c 1c1a      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
001f2d ff03          .dw $ff03
001f2e 6f6e
001f2f 0074          .db "not",0
001f30 1f25          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
001f31 1c00          .dw DO_COLON
                 PFA_NOT:
001f32 1d18          .dw XT_EQUALZERO
001f33 1c1a          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f34 ff02          .dw $ff02
001f35 6521          .db "!e"
001f36 1f2d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f37 1f38          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f38 01fc          movw zl, tosl
001f39 9189
001f3a 9199          loadtos
001f3b b72f          in_ temp2, SREG
001f3c 94f8          cli
001f3d d028          rcall PFA_FETCHE2
001f3e b30d          in_  temp0, EEDR
001f3f 1708          cp temp0,tosl
001f40 f009          breq PFA_STOREE3
001f41 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f42 9631          adiw zl,1
001f43 d022          rcall PFA_FETCHE2
001f44 b30d          in_  temp0, EEDR
001f45 1709          cp temp0,tosh
001f46 f011          breq PFA_STOREE4
001f47 2f89          mov tosl, tosh
001f48 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f49 bf2f          out_ SREG, temp2
001f4a 9189
001f4b 9199          loadtos
001f4c ccb7          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f4d 99e1          sbic EECR, EEPE
001f4e cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f4f b707          in_ temp0, SPMCSR
001f50 fd00          sbrc temp0,SPMEN
001f51 cffd          rjmp PFA_STOREE2
                 
001f52 bbff          out_ EEARH,zh
001f53 bbee          out_ EEARL,zl
001f54 bb8d          out_ EEDR, tosl
001f55 9ae2          sbi EECR,EEMPE
001f56 9ae1          sbi EECR,EEPE
                 
001f57 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f58 ff02          .dw $ff02
001f59 6540          .db "@e"
001f5a 1f34          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f5b 1f5c          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f5c b72f          in_ temp2, SREG
001f5d 94f8          cli
001f5e 01fc          movw zl, tosl
001f5f d006          rcall PFA_FETCHE2
001f60 b38d          in_ tosl, EEDR
                 
001f61 9631          adiw zl,1
                 
001f62 d003          rcall PFA_FETCHE2
001f63 b39d          in_  tosh, EEDR
001f64 bf2f          out_ SREG, temp2
001f65 cc9e          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f66 99e1          sbic EECR, EEPE
001f67 cffe          rjmp PFA_FETCHE2
                 
001f68 bbff          out_ EEARH,zh
001f69 bbee          out_ EEARL,zl
                 
001f6a 9ae0          sbi EECR,EERE
001f6b 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001f6c ff02          .dw $ff02
001f6d 6940          .db "@i"
001f6e 1f58          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001f6f 1f70          .dw PFA_FETCHI
                 PFA_FETCHI:
001f70 01fc          movw zl, tosl
001f71 0fee
001f72 1fff
001f73 9185
001f74 9195          readflashcell tosl,tosh
001f75 cc8e          jmp_ DO_NEXT
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f76 ff02          .dw $ff02
001f77 6921          .db "!i"
001f78 1f6c          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f79 07c3          .dw PFA_DODEFER
                 PFA_STOREI:
001f7a 000a          .dw EE_STOREI
001f7b 0787          .dw XT_EDEFERFETCH
001f7c 078c          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f7d ff09          .dw $ff09
001f7e 2128
001f7f 2d69
001f80 726e
001f81 7777
001f82 0029          .db "(!i-nrww)",0
001f83 1f76          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f84 1f85          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f85 b71f        in temp1,SREG
001f86 931f        push temp1
001f87 94f8        cli
                 
001f88 019c        movw temp2, tosl ; save the (word) address
001f89 9189
001f8a 9199        loadtos          ; get the new value for the flash cell
001f8b 93af        push xl
001f8c 93bf        push xh
001f8d 93cf        push yl
001f8e 93df        push yh
001f8f d009        rcall DO_STOREI_atmega
001f90 91df        pop yh
001f91 91cf        pop yl
001f92 91bf        pop xh
001f93 91af        pop xl
                   ; finally clear the stack
001f94 9189
001f95 9199        loadtos
001f96 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f97 bf1f        out SREG,temp1
                 
001f98 cc6b        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f99 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f9a 94e0        com temp4
001f9b 94f0        com temp5
001f9c 218e        and tosl, temp4
001f9d 219f        and tosh, temp5
001f9e 2b98        or tosh, tosl
001f9f f019        breq DO_STOREI_writepage 
                 
001fa0 01f9          movw zl, temp2
001fa1 e002          ldi temp0,(1<<PGERS)
001fa2 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001fa3 01f9        movw zl, temp2
001fa4 e004        ldi temp0,(1<<PGWRT)
001fa5 d01d        rcall dospm
                 
                   ; reenable RWW section
001fa6 01f9        movw zl, temp2
001fa7 e100        ldi temp0,(1<<RWWSRE)
001fa8 d01a        rcall dospm
001fa9 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001faa 01f9        movw zl, temp2
                   ; get the beginning of page
001fab 7ce0        andi zl,low(pagemask)
001fac 7fff        andi zh,high(pagemask)
001fad 01ef        movw y, z
                   ; loop counter (in words)
001fae e4a0        ldi xl,low(pagesize)
001faf e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001fb0 01fe        movw z, y
001fb1 0fee
001fb2 1fff
001fb3 9145
001fb4 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001fb5 01fe        movw z, y
001fb6 17e2        cp zl, temp2
001fb7 07f3        cpc zh, temp3
001fb8 f011        breq pageload_newdata
001fb9 010a          movw r0, temp6
001fba c002          rjmp pageload_cont
                 pageload_newdata:
001fbb 017a          movw temp4, temp6
001fbc 010c          movw r0, tosl
                 pageload_cont:
001fbd 2700        clr temp0
001fbe d004        rcall dospm
001fbf 9621        adiw y, 1
001fc0 9711        sbiw x, 1
001fc1 f771        brne pageload_loop
                 
                 pageload_done:
001fc2 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fc3 99e1        sbic EECR, EEPE
001fc4 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001fc5 b717        in_  temp1, SPMCSR
001fc6 fd10        sbrc temp1, SPMEN
001fc7 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fc8 0fee
001fc9 1fff        writeflashcell
                   ; execute spm
001fca 6001        ori temp0, (1<<SPMEN)
001fcb bf07        out_ SPMCSR,temp0
001fcc 95e8        spm
001fcd 9508        ret
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
001fce ff03          .dw $ff03
001fcf 3e6e
001fd0 0072          .db "n>r",0
001fd1 1f7d          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
001fd2 1fd3          .dw PFA_N_TO_R
                 PFA_N_TO_R:
001fd3 01fc          movw zl, tosl
001fd4 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
001fd5 9189
001fd6 9199          loadtos
001fd7 939f          push tosh
001fd8 938f          push tosl
001fd9 950a          dec temp0
001fda f7d1          brne PFA_N_TO_R1
001fdb 93ef          push zl
001fdc 93ff          push zh
001fdd 9189
001fde 9199          loadtos
001fdf cc24          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
001fe0 ff03          .dw $ff03
001fe1 726e
001fe2 003e          .db "nr>",0
001fe3 1fce          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
001fe4 1fe5          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
001fe5 939a
001fe6 938a          savetos
001fe7 91ff          pop zh
001fe8 91ef          pop zl
001fe9 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
001fea 918f          pop tosl
001feb 919f          pop tosh
001fec 939a
001fed 938a          savetos
001fee 950a          dec temp0
001fef f7d1          brne PFA_N_R_FROM1
001ff0 01cf          movw tosl, zl
001ff1 cc12          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 d5 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 37 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 76 0d         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 84 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 55 0b         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 e0 1f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 0f 07         .dw XT_REC_FIND
00002a f2 06         .dw XT_REC_INTNUMBER
00002c 2b 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 92 0b         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c 5f 04         .dw rstackstart  ; USER_RP
00003e 0f 04         .dw stackstart   ; USER_SP0
000040 0f 04         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 81 00         .dw XT_TX  ; USER_EMIT
000048 8f 00         .dw XT_TXQ ; USER_EMITQ
00004a 57 00         .dw XT_RX  ; USER_KEY
00004c 71 00         .dw XT_RXQ ; USER_KEYQ
00004e dc 08         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 c8 08         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 33 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 12
000058 7a 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  80 r17:  57 r18:  58 r19:  42 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 173 r25: 123 r26:  45 r27:  22 r28:   6 r29:   4 r30:  71 r31:  35 
x  :   4 y  : 189 z  :  42 
Registers used: 29 out of 35 (82.9%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :  11 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  11 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   2 jmp   :  22 
ld    : 131 ldd   :   4 ldi   :  22 lds   :   2 lpm   :  20 lsl   :  16 
lsr   :   1 mov   :  12 movw  :  66 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  52 
push  :  38 rcall :  33 ret   :   6 reti  :   2 rjmp  :  89 rol   :  25 
ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  62 std   :   8 sts   :   3 
sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003fe4   1850   9238  11088   16384  67.7%
[.dseg] 0x000060 0x000137      0    215    215    1024  21.0%
[.eseg] 0x000000 0x00005a      0     90     90     512  17.6%

Assembly complete, 0 errors, 2 warnings
