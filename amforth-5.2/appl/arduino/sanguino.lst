
AVRASM ver. 2.1.51  sanguino.asm Mon Dec 23 20:35:16 2013

sanguino.asm(2): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
sanguino.asm(3): Including file '../../core/devices/atmega644p\device.asm'
../../core/devices/atmega644p\device.asm(5): Including file '../../Atmel/Appnotes2\m644Pdef.inc'
sanguino.asm(14): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
sanguino.asm(23): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(5): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(6): Including file '../../core\words/marker.asm'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(10): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl_core.inc(16): Including file '../../core\words/fill.asm'
dict_appl_core.inc(17): Including file '../../core\words/d-2star.asm'
dict_appl_core.inc(18): Including file '../../core\words/d-plus.asm'
dict_appl_core.inc(19): Including file '../../core\words/d-minus.asm'
dict_appl_core.inc(20): Including file '../../core\words/d-invert.asm'
dict_appl_core.inc(21): Including file '../../core\words/udot.asm'
dict_appl_core.inc(22): Including file '../../core\words/dot-s.asm'
dict_appl_core.inc(24): Including file '../../core\words/dotstring.asm'
dict_appl_core.inc(25): Including file '../../core\words/squote.asm'
dict_appl_core.inc(27): Including file '../../core\words/edefer.asm'
dict_appl_core.inc(28): Including file '../../core\words/rdefer.asm'
dict_appl_core.inc(29): Including file '../../core\words/is.asm'
dict_appl_core.inc(31): Including file 'words/applturnkey.asm'
dict_appl_core.inc(32): Including file '../../core\words/1ms.asm'
dict_appl_core.inc(33): Including file '../../core\words/ms.asm'
dict_appl_core.inc(34): Including file '../../core\words/show-wordlist.asm'
dict_appl_core.inc(35): Including file '../../core\words/words.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_USART1 = 0
                 .set WANT_CPU = 0
                 .set WANT_SPI = 0
                 .equ intvecsize = 2 ; please verify; flash size: 65536 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0ce      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0cc      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0ca      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d0c8      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d0c6      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d0c4      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d0c2      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d0c0      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d0be      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d0bc      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d0ba      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d0b8      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d0b6      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d0b4      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d0b2      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d0b0      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d0ae      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d0ac      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d0aa      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0a8      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0a6      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0a4      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0a2      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0a0      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d09e      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d09c      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d09a      	 rcall isr ; Store Program Memory Read
                 .org 56
000038 d098      	 rcall isr ; USART1 RX complete
                 .org 58
00003a d096      	 rcall isr ; USART1 Data Register Empty
                 .org 60
00003c d094      	 rcall isr ; USART1 TX complete
                 .equ INTVECTORS = 31
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
00003d 1000      	.dw 4096
                 mcu_eepromsize:
00003e 0800      	.dw 2048
                 mcu_maxdp:
00003f e000      	.dw 57344 
                 mcu_numints:
000040 001f      	.dw 31
                 mcu_name:
000041 000a      	.dw 10
000042 5441
000043 656d
000044 6167
000045 3436
000046 5034      	.db "ATmega644P"
                 .set codestart=pc
                 
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64    ; 80 characters is one line
                 .equ APPUSERSIZE = 10  ; size of application specific user area
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 ; baud rate of terminal
                 
                 .equ BAUD = 9600
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000028 940c 0047   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000047 93af        push xl
000048 b7af        in xl, SREG
000049 93af        push xl
00004a 93bf        push xh
00004b 93ef        push zl
00004c 93ff        push zh
                 
00004d 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
00004f 91a0 0100   lds xl,usart_rx_in
000051 e0e2        ldi zl, low(usart_rx_data)
000052 e0f1        ldi zh, high(usart_rx_data)
000053 0fea        add zl, xl
000054 1df3        adc zh, zeroh
000055 83b0        st Z, xh
                 
000056 95a3        inc xl
000057 70af        andi xl,usart_rx_mask
                 
000058 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00005a 91ff        pop zh
00005b 91ef        pop zl
00005c 91bf        pop xh
00005d 91af        pop xl
00005e bfaf        out SREG, xl
00005f 91af        pop xl
000060 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000061 7000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000062 7134        .dw XT_ZERO
000063 7037        .dw XT_DOLITERAL
000064 0100        .dw usart_rx_in
000065 707c        .dw XT_STORE
                 
000066 701a        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000067 ff06          .dw $ff06
000068 7872
000069 692d
00006a 7273          .db "rx-isr"
00006b 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
00006c 7000          .dw DO_COLON
                 PFA_RX_ISR:
00006d 0086        .dw XT_RXQ_ISR
00006e 7030        .dw XT_DOCONDBRANCH
00006f 006d        .dw PFA_RX_ISR
000070 7037        .dw XT_DOLITERAL
000071 0101        .dw usart_rx_out
000072 7093        .dw XT_CFETCH
000073 70ac        .dw XT_DUP
000074 7238        .dw XT_1PLUS
000075 7037        .dw XT_DOLITERAL
000076 000f        .dw usart_rx_mask
000077 721c        .dw XT_AND
000078 7037        .dw XT_DOLITERAL
000079 0101        .dw usart_rx_out
00007a 7088        .dw XT_CSTORE
00007b 7037        .dw XT_DOLITERAL
00007c 0102        .dw usart_rx_data
00007d 71a6        .dw XT_PLUS
00007e 7093        .dw XT_CFETCH
00007f 701a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000080 ff07          .dw $ff07
000081 7872
000082 2d3f
000083 7369
000084 0072          .db "rx?-isr",0
000085 0067          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000086 7000          .dw DO_COLON
                 PFA_RXQ_ISR:
000087 06bd        .dw XT_PAUSE
000088 7037        .dw XT_DOLITERAL
000089 0101        .dw usart_rx_out
00008a 7093        .dw XT_CFETCH
00008b 7037        .dw XT_DOLITERAL
00008c 0100        .dw usart_rx_in
00008d 7093        .dw XT_CFETCH
00008e 7107        .dw XT_NOTEQUAL
00008f 701a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000090 ff07          .dw $ff07
000091 7874
000092 702d
000093 6c6f
000094 006c          .db "tx-poll",0
000095 0080          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000096 7000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000097 00a4        .dw XT_TXQ_POLL
000098 7030        .dw XT_DOCONDBRANCH
000099 0097        .dw PFA_TX_POLL
                   ; send to usart
00009a 7037        .dw XT_DOLITERAL
00009b 00c6        .dw USART_DATA
00009c 7088        .dw XT_CSTORE
00009d 701a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00009e ff08          .dw $ff08
00009f 7874
0000a0 2d3f
0000a1 6f70
0000a2 6c6c          .db "tx?-poll"
0000a3 0090          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000a4 7000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000a5 06bd        .dw XT_PAUSE
0000a6 7037        .dw XT_DOLITERAL
0000a7 00c0        .dw USART_A
0000a8 7093        .dw XT_CFETCH
0000a9 7037        .dw XT_DOLITERAL
0000aa 0020        .dw bm_USART_TXRD
0000ab 721c        .dw XT_AND
0000ac 701a        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000ad ff04        .dw $ff04
0000ae 6275
0000af 7272        .db "ubrr"
0000b0 009e        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000b1 7069        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000b2 0054        .dw EE_UBRRVAL
0000b3 755a        .dw XT_EVALUEFETCH
0000b4 755e        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000b5 ff06        .dw $ff06
0000b6 752b
0000b7 6173
0000b8 7472        .db "+usart"
0000b9 00ad        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000ba 7000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000bb 7037        .dw XT_DOLITERAL
0000bc 0098        .dw USART_B_VALUE
0000bd 7037        .dw XT_DOLITERAL
0000be 00c1        .dw USART_B
0000bf 7088        .dw XT_CSTORE
                 
0000c0 7037        .dw XT_DOLITERAL
0000c1 0006        .dw USART_C_VALUE
0000c2 7037        .dw XT_DOLITERAL
0000c3 00c2        .dw USART_C | bm_USARTC_en
0000c4 7088        .dw XT_CSTORE
                 
0000c5 00b1        .dw XT_UBRR
0000c6 70ac        .dw XT_DUP
0000c7 730e        .dw XT_BYTESWAP
0000c8 7037        .dw XT_DOLITERAL
0000c9 00c5        .dw BAUDRATE_HIGH
0000ca 7088        .dw XT_CSTORE
0000cb 7037        .dw XT_DOLITERAL
0000cc 00c4        .dw BAUDRATE_LOW
0000cd 7088        .dw XT_CSTORE
                 
0000ce 0061        .dw XT_USART_INIT_RX
0000cf 07b7        .dw XT_USART_INIT_TX
0000d0 701a        .dw XT_EXIT
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 .set NUMWORDLISTS = 8
                 
                 ; some registers
                 .set WANT_PORTA = 0
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 06c6   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000d1 920a          st -Y, r0
0000d2 b60f          in r0, SREG
0000d3 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000d4 900f          pop r0
0000d5 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000d6 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000d7 9200 0114     sts intcur, r0
0000d9 9009          ld r0, Y+
0000da be0f          out SREG, r0
0000db 9009          ld r0, Y+
0000dc 9468          set ; set the interrupt flag for the inner interpreter
0000dd 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0000de ff04          .dw $ff04
0000df 692b
0000e0 746e          .db "+int"
0000e1 00b5          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0000e2 00e3          .dw PFA_INTON
                 PFA_INTON:
0000e3 9478          sei
0000e4 940c 7004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0000e6 ff04          .dw $ff04
0000e7 692d
0000e8 746e          .db "-int"
0000e9 00de          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
0000ea 00eb          .dw PFA_INTOFF
                 PFA_INTOFF:
0000eb 94f8          cli
0000ec 940c 7004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
0000ee ff04          .dw $ff04
0000ef 6e69
0000f0 2174          .db "int!"
0000f1 00e6          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
0000f2 7000          .dw DO_COLON
                 PFA_INTSTORE:
0000f3 7037          .dw XT_DOLITERAL
0000f4 0115          .dw intvec
0000f5 71a6          .dw XT_PLUS
0000f6 707c          .dw XT_STORE
0000f7 701a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
0000f8 ff04          .dw $ff04
0000f9 6e69
0000fa 4074          .db "int@"
0000fb 00ee          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
0000fc 7000          .dw DO_COLON
                 PFA_INTFETCH:
0000fd 7037          .dw XT_DOLITERAL
0000fe 0115          .dw intvec
0000ff 71a6          .dw XT_PLUS
000100 7074          .dw XT_FETCH
000101 701a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000102 ff08          .dw $ff08
000103 6e69
000104 2d74
000105 7274
000106 7061          .db "int-trap"
000107 00f8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000108 0109          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000109 9380 0114     sts intcur, tosl
00010b 9189
00010c 9199          loadtos
00010d 9468          set ; set the interrupt flag for the inner interpreter
00010e 940c 7004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000110 7000          .dw DO_COLON
                 PFA_ISREXEC:
000111 7037          .dw XT_DOLITERAL
000112 0114          .dw intcur
000113 7093          .dw XT_CFETCH
000114 7037          .dw XT_DOLITERAL
000115 0115          .dw intvec
000116 71a6          .dw XT_PLUS
000117 7074          .dw XT_FETCH
000118 7024          .dw XT_EXECUTE
000119 011b          .dw XT_ISREND
00011a 701a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00011b 011c          .dw PFA_ISREND
                 PFA_ISREND:
00011c d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00011d 940c 7004     jmp_ DO_NEXT
                 PFA_ISREND1:
00011f 9518          reti
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
000120 ff05          .dw $ff05
000121 5f66
000122 7063
000123 0075          .db "f_cpu",0
000124 0102          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000125 7069          .dw PFA_DOVALUE1
                 PFA_F_CPU:
000126 0056          .dw EE_FCPU
000127 0129          .dw XT_FETCH2E
000128 0132          .dw XT_STORE2E
                 
                 XT_FETCH2E:
000129 7000          .dw DO_COLON
                 PFA_FETCH2E:
00012a 73c7          .dw XT_FETCHI
00012b 70ac          .dw XT_DUP
00012c 0150          .dw XT_CELLPLUS
00012d 735b          .dw XT_FETCHE
00012e 70bf          .dw XT_SWAP
00012f 735b          .dw XT_FETCHE
000130 70bf          .dw XT_SWAP
000131 701a          .dw XT_EXIT
                 
                 XT_STORE2E:
000132 7000          .dw DO_COLON
                 PFA_STORE2E:
000133 7037          .dw XT_DOLITERAL
000134 ffeb          .dw -21
000135 04a7          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
000136 ff05          .dw $ff05
000137 7473
000138 7461
000139 0065          .db "state",0
00013a 0120          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00013b 7042          .dw PFA_DOVARIABLE
                 PFA_STATE:
00013c 0153          .dw ram_state
                 
                 .dseg
000153           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
00013d ff04          .dw $ff04
00013e 6162
00013f 6573          .db "base"
000140 0136          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000141 7052          .dw PFA_DOUSER
                 PFA_BASE:
000142 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
000143 ff05          .dw $ff05
000144 6563
000145 6c6c
000146 0073          .db "cells",0
000147 013d          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
000148 7000          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
000149 7214          .dw XT_2STAR
                 .else
                 .endif
00014a 701a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00014b ff05          .dw $ff05
00014c 6563
00014d 6c6c
00014e 002b          .db "cell+",0
00014f 0143          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000150 0151          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000151 9602          adiw tosl, CELLSIZE
000152 940c 7004     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
000154 ff04          .dw $ff04
000155 6432
000156 7075          .db "2dup"
000157 014b          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000158 7000          .dw DO_COLON
                 PFA_2DUP:
000159 70ca          .dw XT_OVER
00015a 70ca          .dw XT_OVER
00015b 701a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
00015c ff05          .dw $ff05
00015d 6432
00015e 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
00015f 0070          .db "2drop"
000160 0154          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000161 7000          .dw DO_COLON
                 PFA_2DROP:
000162 70d4          .dw XT_DROP
000163 70d4          .dw XT_DROP
000164 701a          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
000165 ff03          .dw $ff03
000166 693e
000167 006e          .db ">in",0
000168 015c          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000169 7052          .dw PFA_DOUSER
                 PFA_G_IN:
00016a 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
00016b ff04          .dw $ff04
00016c 7423
00016d 6269          .db "#tib"
00016e 0165          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00016f 7042          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000170 0155          .dw ram_sharptib
                 
                 .dseg
000155           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000171 ff03          .dw $ff03
000172 6170
000173 0064          .db "pad",0
000174 016b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
000175 7000          .dw DO_COLON
                 PFA_PAD:
000176 01af          .dw XT_HERE
000177 7037          .dw XT_DOLITERAL
000178 0064          .dw 100
000179 71a6          .dw XT_PLUS
00017a 701a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
00017b ff04          .dw $ff04
00017c 6d65
00017d 7469          .db "emit"
00017e 0171          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00017f 081a          .dw PFA_DODEFER
                 PFA_EMIT:
000180 000e          .dw USER_EMIT
000181 07f2          .dw XT_UDEFERFETCH
000182 07f9          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
000183 ff05          .dw $ff05
000184 6d65
000185 7469
000186 003f          .db "emit?",0
000187 017b          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000188 081a          .dw PFA_DODEFER
                 PFA_EMITQ:
000189 0010          .dw USER_EMITQ
00018a 07f2          .dw XT_UDEFERFETCH
00018b 07f9          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
00018c ff03          .dw $ff03
00018d 656b
00018e 0079          .db "key",0
00018f 0183          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000190 081a          .dw PFA_DODEFER
                 PFA_KEY:
000191 0012          .dw USER_KEY
000192 07f2          .dw XT_UDEFERFETCH
000193 07f9          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
000194 ff04          .dw $ff04
000195 656b
000196 3f79          .db "key?"
000197 018c          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000198 081a          .dw PFA_DODEFER
                 PFA_KEYQ:
000199 0014          .dw USER_KEYQ
00019a 07f2          .dw XT_UDEFERFETCH
00019b 07f9          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00019c ff02          .dw $ff02
00019d 7064          .db "dp"
00019e 0194          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00019f 7069          .dw PFA_DOVALUE1
                 PFA_DP:
0001a0 0002          .dw EE_DP
0001a1 755a          .dw XT_EVALUEFETCH
0001a2 755e          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
0001a3 ff03          .dw $ff03
0001a4 6465
0001a5 0070          .db "edp",0
0001a6 019c          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
0001a7 7069          .dw PFA_DOVALUE1
                 PFA_EDP:
0001a8 0006          .dw EE_EDP
0001a9 755a          .dw XT_EVALUEFETCH
0001aa 755e          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0001ab ff04          .dw $ff04
0001ac 6568
0001ad 6572          .db "here"
0001ae 01a3          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0001af 7069          .dw PFA_DOVALUE1
                 PFA_HERE:
0001b0 0004          .dw EE_HERE
0001b1 755a          .dw XT_EVALUEFETCH
0001b2 755e          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0001b3 ff05          .dw $ff05
0001b4 6c61
0001b5 6f6c
0001b6 0074          .db "allot",0
0001b7 01ab          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0001b8 7000          .dw DO_COLON
                 PFA_ALLOT:
0001b9 01af          .dw XT_HERE
0001ba 71a6          .dw XT_PLUS
0001bb 07d2          .dw XT_DOTO
0001bc 01b0          .dw PFA_HERE
0001bd 701a          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
0001be ff08          .dw $ff08
0001bf 6328
0001c0 6572
0001c1 7461
0001c2 2965          .db "(create)"
0001c3 01b3          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001c4 7000          .dw DO_COLON
                 PFA_DOCREATE:
0001c5 0637          .dw XT_PARSENAME
0001c6 74aa          .dw XT_WLSCOPE
0001c7 70ac          .dw XT_DUP
0001c8 70f3          .dw XT_TO_R
0001c9 748f          .dw XT_HEADER
0001ca 70ea          .dw XT_R_FROM
                 .dseg
000157           COLON_SMUDGE: .byte 4
                 .cseg
0001cb 7037          .dw XT_DOLITERAL
0001cc 0159          .dw COLON_SMUDGE+2
0001cd 707c          .dw XT_STORE		; save wid
0001ce 7037          .dw XT_DOLITERAL
0001cf 0157          .dw COLON_SMUDGE+0
0001d0 707c          .dw XT_STORE		; save NFA
                 
0001d1 701a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
0001d2 0001          .dw $0001
0001d3 005c          .db "\",0
0001d4 01be          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001d5 7000          .dw DO_COLON
                 PFA_BACKSLASH:
0001d6 061c          .dw XT_SOURCE
0001d7 70bf          .dw XT_SWAP
0001d8 70d4          .dw XT_DROP
0001d9 0169          .dw XT_G_IN
0001da 707c          .dw XT_STORE
0001db 701a          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
0001dc 0001          .dw $0001
0001dd 0028          .db "(" ,0
0001de 01d2          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
0001df 7000          .dw DO_COLON
                 PFA_LPARENTHESIS:
0001e0 7037          .dw XT_DOLITERAL
0001e1 0029          .dw $29
0001e2 05e8          .dw XT_PARSE
0001e3 0161          .dw XT_2DROP
0001e4 701a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
0001e5 ff07          .dw $ff07
0001e6 6f63
0001e7 706d
0001e8 6c69
0001e9 0065          .db "compile",0
0001ea 01dc          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001eb 7000          .dw DO_COLON
                 PFA_COMPILE:
0001ec 70ea          .dw XT_R_FROM
0001ed 70ac          .dw XT_DUP
0001ee 7238          .dw XT_1PLUS
0001ef 70f3          .dw XT_TO_R
0001f0 73c7          .dw XT_FETCHI
0001f1 01f6          .dw XT_COMMA
0001f2 701a          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001f3 ff01          .dw $ff01
0001f4 002c          .db ',',0 ; ,
0001f5 01e5          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001f6 7000          .dw DO_COLON
                 PFA_COMMA:
0001f7 019f          .dw XT_DP
0001f8 736f          .dw XT_STOREI
0001f9 019f          .dw XT_DP
0001fa 7238          .dw XT_1PLUS
0001fb 07d2          .dw XT_DOTO
0001fc 01a0          .dw PFA_DP
0001fd 701a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0001fe 0003          .dw $0003
0001ff 275b
000200 005d          .db "[']",0
000201 01f3          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000202 7000          .dw DO_COLON
                 PFA_BRACKETTICK:
000203 01eb          .dw XT_COMPILE
000204 7037          .dw XT_DOLITERAL
000205 047a          .dw XT_TICK
000206 01f6          .dw XT_COMMA
000207 701a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
000208 ff03          .dw $ff03
000209 6962
00020a 006e          .db "bin",0
00020b 01fe          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00020c 7000          .dw DO_COLON
                 PFA_BIN:
00020d 7037          .dw XT_DOLITERAL
00020e 0002          .dw 2
00020f 0141          .dw XT_BASE
000210 707c          .dw XT_STORE
000211 701a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
000212 ff07          .dw $ff07
000213 6564
000214 6963
000215 616d
000216 006c          .db "decimal",0
000217 0208          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000218 7000          .dw DO_COLON
                 PFA_DECIMAL:
000219 7037          .dw XT_DOLITERAL
00021a 000a          .dw 10
00021b 0141          .dw XT_BASE
00021c 707c          .dw XT_STORE
00021d 701a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
00021e ff03          .dw $ff03
00021f 6568
000220 0078          .db "hex",0
000221 0212          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000222 7000          .dw DO_COLON
                 PFA_HEX:
000223 7037          .dw XT_DOLITERAL
000224 0010          .dw 16
000225 0141          .dw XT_BASE
000226 707c          .dw XT_STORE
000227 701a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
000228 ff02          .dw $ff02
000229 6c62          .db "bl"
00022a 021e          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00022b 7042          .dw PFA_DOVARIABLE
                 PFA_BL:
00022c 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00022d ff07          .dw $ff07
00022e 7574
00022f 6e72
000230 656b
000231 0079          .db "turnkey",0
000232 0228          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000233 081a          .dw PFA_DODEFER
                 PFA_TURNKEY:
000234 0008          .dw EE_TURNKEY
000235 07de          .dw XT_EDEFERFETCH
000236 07e3          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
000237 ff05          .dw $ff05
000238 2f2a
000239 6f6d
00023a 0064          .db "*/mod",0
00023b 022d          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
00023c 7000          .dw DO_COLON
                 PFA_STARSLASHMOD:
00023d 70f3          .dw XT_TO_R
00023e 71af          .dw XT_MSTAR
00023f 70ea          .dw XT_R_FROM
000240 71cb          .dw XT_UMSLASHMOD
000241 701a          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000242 ff04          .dw $ff04
000243 6d2f
000244 646f          .db "/mod"
000245 0237          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000246 0247          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000247 019c          movw temp2, tosl
                     
000248 9109          ld temp0, Y+
000249 9119          ld temp1, Y+
                 
00024a 2f41          mov	temp6,temp1	;move dividend High to sign register
00024b 2743          eor	temp6,temp3	;xor divisor High with sign register
00024c ff17          sbrs	temp1,7	;if MSB in dividend set
00024d c004          rjmp	PFA_SLASHMOD_1
00024e 9510          com	temp1		;    change sign of dividend
00024f 9500          com	temp0		
000250 5f0f          subi	temp0,low(-1)
000251 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000252 ff37          sbrs	temp3,7	;if MSB in divisor set
000253 c004          rjmp	PFA_SLASHMOD_2
000254 9530          com	temp3		;    change sign of divisor
000255 9520          com	temp2		
000256 5f2f          subi	temp2,low(-1)
000257 4f3f          sbci	temp3,high(-1)
000258 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000259 18ff          sub	temp5,temp5;clear remainder High byte and carry
00025a e151          ldi	temp7,17	;init loop counter
                 
00025b 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00025c 1f11          rol	temp1
00025d 955a          dec	temp7		;decrement counter
00025e f439          brne	PFA_SLASHMOD_5		;if done
00025f ff47          sbrs	temp6,7		;    if MSB in sign register set
000260 c004          rjmp	PFA_SLASHMOD_4
000261 9510          com	temp1	;        change sign of result
000262 9500          com	temp0
000263 5f0f          subi	temp0,low(-1)
000264 4f1f          sbci	temp1,high(-1)
000265 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000266 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000267 1cff          rol	temp5
000268 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000269 0af3          sbc	temp5,temp3	;
00026a f420          brcc	PFA_SLASHMOD_6		;if result negative
00026b 0ee2          add	temp4,temp2	;    restore remainder
00026c 1ef3          adc	temp5,temp3
00026d 9488          clc			;    clear carry to be shifted into result
00026e cfec          rjmp	PFA_SLASHMOD_3		;else
00026f 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000270 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000271 92fa          st -Y,temp5
000272 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000273 01c8          movw tosl, temp0
000274 940c 7004     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
000276 ff02          .dw $ff02
000277 2f2a          .db "*/"
000278 0242          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000279 7000          .dw DO_COLON
                 PFA_STARSLASH:
00027a 023c          .dw XT_STARSLASHMOD
00027b 70bf          .dw XT_SWAP
00027c 70d4          .dw XT_DROP
00027d 701a          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00027e ff05          .dw $ff05
00027f 2f75
000280 6f6d
000281 0064          .db "u/mod",0
000282 0276          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000283 7000          .dw DO_COLON
                 PFA_USLASHMOD:
000284 70f3          .dw XT_TO_R
000285 7134          .dw XT_ZERO
000286 70ea          .dw XT_R_FROM
000287 71cb          .dw XT_UMSLASHMOD
000288 701a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000289 ff06          .dw $ff06
00028a 656e
00028b 6167
00028c 6574          .db "negate"
00028d 027e          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00028e 7000          .dw DO_COLON
                 PFA_NEGATE:
00028f 7206          .dw XT_INVERT
000290 7238          .dw XT_1PLUS
000291 701a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
000292 ff01          .dw $ff01
000293 002f          .db "/",0
000294 0289          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000295 7000          .dw DO_COLON
                 PFA_SLASH:
000296 0246          .dw XT_SLASHMOD
000297 70bf          .dw XT_SWAP
000298 70d4          .dw XT_DROP
000299 701a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
00029a ff03          .dw $ff03
00029b 6f6d
00029c 0064          .db "mod",0
00029d 0292          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00029e 7000          .dw DO_COLON
                 PFA_MOD:
00029f 0246          .dw XT_SLASHMOD
0002a0 70d4          .dw XT_DROP
0002a1 701a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
0002a2 ff03          .dw $ff03
0002a3 6261
0002a4 0073          .db "abs",0
0002a5 029a          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
0002a6 02a7          .dw PFA_ABS
                 PFA_ABS:
0002a7 2399          tst tosh
0002a8 f41a          brpl PFA_ABS1
0002a9 9580          com tosl
0002aa 9590          com tosh
0002ab 9601          adiw tosl, 1
                 PFA_ABS1:
0002ac 940c 7004     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
0002ae ff03          .dw $ff03
0002af 696d
0002b0 006e          .db "min",0
0002b1 02a2          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
0002b2 7000          .dw DO_COLON
                 PFA_MIN:
0002b3 0158          .dw XT_2DUP
0002b4 7126          .dw XT_GREATER
0002b5 7030          .dw XT_DOCONDBRANCH
0002b6 02b8          .dw PFA_MIN1
0002b7 70bf          .dw XT_SWAP
                 PFA_MIN1:
0002b8 70d4          .dw XT_DROP
0002b9 701a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
0002ba ff03          .dw $ff03
0002bb 616d
0002bc 0078          .db "max",0
0002bd 02ae          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
0002be 7000          .dw DO_COLON
                 PFA_MAX:
0002bf 0158          .dw XT_2DUP
0002c0 711f          .dw XT_LESS
0002c1 7030          .dw XT_DOCONDBRANCH
0002c2 02c4          .dw PFA_MAX1
0002c3 70bf          .dw XT_SWAP
                 PFA_MAX1:
0002c4 70d4          .dw XT_DROP
0002c5 701a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
0002c6 ff06          .dw $ff06
0002c7 6977
0002c8 6874
0002c9 6e69          .db "within"
0002ca 02ba          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
0002cb 7000          .dw DO_COLON
                 PFA_WITHIN:
0002cc 70ca          .dw XT_OVER
0002cd 719c          .dw XT_MINUS
0002ce 70f3          .dw XT_TO_R
0002cf 719c          .dw XT_MINUS
0002d0 70ea          .dw XT_R_FROM
0002d1 7146          .dw XT_ULESS
0002d2 701a          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
0002d3 ff07          .dw $ff07 
0002d4 6f74
0002d5 7075
0002d6 6570
0002d7 0072          .db "toupper",0
0002d8 02c6          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0002d9 7000          .dw DO_COLON 
                 PFA_TOUPPER:
0002da 70ac          .dw XT_DUP 
0002db 7037          .dw XT_DOLITERAL 
0002dc 0061          .dw 'a' 
0002dd 7037          .dw XT_DOLITERAL 
0002de 007b          .dw 'z'+1
0002df 02cb          .dw XT_WITHIN 
0002e0 7030          .dw XT_DOCONDBRANCH
0002e1 02e5          .dw PFA_TOUPPER0 
0002e2 7037          .dw XT_DOLITERAL
0002e3 00df          .dw $df ; inverse of 0x20
0002e4 721c          .dw XT_AND 
                 PFA_TOUPPER0:
0002e5 701a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
0002e6 ff07          .dw $ff07
0002e7 6f74
0002e8 6f6c
0002e9 6577
0002ea 0072          .db "tolower",0
0002eb 02d3          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0002ec 7000          .dw DO_COLON
                 PFA_TOLOWER:
0002ed 70ac          .dw XT_DUP
0002ee 7037          .dw XT_DOLITERAL
0002ef 0041          .dw 'A'
0002f0 7037          .dw XT_DOLITERAL
0002f1 005b          .dw 'Z'+1
0002f2 02cb          .dw XT_WITHIN
0002f3 7030          .dw XT_DOCONDBRANCH
0002f4 02f8          .dw PFA_TOLOWER0 
0002f5 7037          .dw XT_DOLITERAL
0002f6 0020          .dw $20 
0002f7 7225          .dw XT_OR 
                 PFA_TOLOWER0:
0002f8 701a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002f9 ff03          .dw $ff03
0002fa 6c68
0002fb 0064          .db "hld",0
0002fc 02e6          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002fd 7042          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002fe 015b          .dw ram_hld
                 
                 .dseg
00015b           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0002ff ff04          .dw $ff04
000300 6f68
000301 646c          .db "hold"
000302 02f9          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000303 7000          .dw DO_COLON
                 PFA_HOLD:
000304 02fd          .dw XT_HLD
000305 70ac          .dw XT_DUP
000306 7074          .dw XT_FETCH
000307 723e          .dw XT_1MINUS
000308 70ac          .dw XT_DUP
000309 70f3          .dw XT_TO_R
00030a 70bf          .dw XT_SWAP
00030b 707c          .dw XT_STORE
00030c 70ea          .dw XT_R_FROM
00030d 7088          .dw XT_CSTORE
00030e 701a          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
00030f ff02          .dw $ff02
000310 233c          .db "<#"
000311 02ff          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000312 7000          .dw DO_COLON
                 PFA_L_SHARP:
000313 0175          .dw XT_PAD
000314 02fd          .dw XT_HLD
000315 707c          .dw XT_STORE
000316 701a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
000317 ff01          .dw $ff01
000318 0023          .db "#",0
000319 030f          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00031a 7000          .dw DO_COLON
                 PFA_SHARP:
00031b 0141          .dw XT_BASE
00031c 7074          .dw XT_FETCH
00031d 0399          .dw XT_UDSLASHMOD
00031e 70dc          .dw XT_ROT
00031f 7037          .dw XT_DOLITERAL
000320 0009          .dw 9
000321 70ca          .dw XT_OVER
000322 711f          .dw XT_LESS
000323 7030          .dw XT_DOCONDBRANCH
000324 0328          .dw PFA_SHARP1
000325 7037          .dw XT_DOLITERAL
000326 0007          .dw 7
000327 71a6          .dw XT_PLUS
                 PFA_SHARP1:
000328 7037          .dw XT_DOLITERAL
000329 0030          .dw $30
00032a 71a6          .dw XT_PLUS
00032b 0303          .dw XT_HOLD
00032c 701a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
00032d ff02          .dw $ff02
00032e 7323          .db "#s"
00032f 0317          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000330 7000          .dw DO_COLON
                 PFA_SHARP_S:
000331 031a          .dw XT_SHARP
000332 0158          .dw XT_2DUP
000333 7225          .dw XT_OR
000334 7118          .dw XT_EQUALZERO
000335 7030          .dw XT_DOCONDBRANCH
000336 0331          .dw PFA_SHARP_S
000337 701a          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
000338 ff02          .dw $ff02
000339 3e23          .db "#>"
00033a 032d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00033b 7000          .dw DO_COLON
                 PFA_SHARP_G:
00033c 0161          .dw XT_2DROP
00033d 02fd          .dw XT_HLD
00033e 7074          .dw XT_FETCH
00033f 70ac          .dw XT_DUP
000340 0175          .dw XT_PAD
000341 70bf          .dw XT_SWAP
000342 719c          .dw XT_MINUS
000343 701a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
000344 ff04          .dw $ff04
000345 6973
000346 6e67          .db "sign"
000347 0338          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000348 7000          .dw DO_COLON
                 PFA_SIGN:
000349 712d          .dw XT_LESSZERO
00034a 7030          .dw XT_DOCONDBRANCH
00034b 034f          .dw PFA_SIGN1
00034c 7037          .dw XT_DOLITERAL
00034d 002d          .dw $2d
00034e 0303          .dw XT_HOLD
                 PFA_SIGN1:
00034f 701a          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
000350 ff03          .dw $ff03
000351 2e64
000352 0072          .db "d.r",0
000353 0344          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000354 7000          .dw DO_COLON
                 PFA_DDOTR:
000355 70f3          .dw XT_TO_R
000356 70bf          .dw XT_SWAP
000357 70ca          .dw XT_OVER
000358 08da          .dw XT_DABS
000359 0312          .dw XT_L_SHARP
00035a 0330          .dw XT_SHARP_S
00035b 70dc          .dw XT_ROT
00035c 0348          .dw XT_SIGN
00035d 033b          .dw XT_SHARP_G
00035e 70ea          .dw XT_R_FROM
00035f 70ca          .dw XT_OVER
000360 719c          .dw XT_MINUS
000361 045c          .dw XT_SPACES
000362 046b          .dw XT_TYPE
000363 701a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
000364 ff02          .dw $ff02
000365 722e          .db ".r"
000366 0350          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000367 7000          .dw DO_COLON
                 PFA_DOTR:
000368 70f3          .dw XT_TO_R
000369 7329          .dw XT_S2D
00036a 70ea          .dw XT_R_FROM
00036b 0354          .dw XT_DDOTR
00036c 701a          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
00036d ff02          .dw $ff02
00036e 2e64          .db "d."
00036f 0364          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000370 7000          .dw DO_COLON
                 PFA_DDOT:
000371 7134          .dw XT_ZERO
000372 0354          .dw XT_DDOTR
000373 0453          .dw XT_SPACE
000374 701a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
000375 ff01          .dw $ff01
000376 002e          .db ".",0
000377 036d          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000378 7000          .dw DO_COLON
                 PFA_DOT:
000379 7329          .dw XT_S2D
00037a 0370          .dw XT_DDOT
00037b 701a          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
00037c ff03          .dw $ff03
00037d 6475
00037e 002e          .db "ud.",0
00037f 0375          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000380 7000          .dw DO_COLON
                 PFA_UDDOT:
000381 7134          .dw XT_ZERO
000382 0389          .dw XT_UDDOTR
000383 0453          .dw XT_SPACE
000384 701a          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
000385 ff04          .dw $ff04
000386 6475
000387 722e          .db "ud.r"
000388 037c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000389 7000          .dw DO_COLON
                 PFA_UDDOTR:
00038a 70f3          .dw XT_TO_R
00038b 0312          .dw XT_L_SHARP
00038c 0330          .dw XT_SHARP_S
00038d 033b          .dw XT_SHARP_G
00038e 70ea          .dw XT_R_FROM
00038f 70ca          .dw XT_OVER
000390 719c          .dw XT_MINUS
000391 045c          .dw XT_SPACES
000392 046b          .dw XT_TYPE
000393 701a          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
000394 ff06          .dw $ff06
000395 6475
000396 6d2f
000397 646f          .db "ud/mod"
000398 0385          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000399 7000          .dw DO_COLON
                 PFA_UDSLASHMOD:
00039a 70f3          .dw XT_TO_R
00039b 7134          .dw XT_ZERO
00039c 70fc          .dw XT_R_FETCH
00039d 71cb          .dw XT_UMSLASHMOD
00039e 70ea          .dw XT_R_FROM
00039f 70bf          .dw XT_SWAP
0003a0 70f3          .dw XT_TO_R
0003a1 71cb          .dw XT_UMSLASHMOD
0003a2 70ea          .dw XT_R_FROM
0003a3 701a          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
0003a4 ff06          .dw $ff06 
0003a5 6964
0003a6 6967
0003a7 3f74          .db "digit?"
0003a8 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0003a9 7000          .dw DO_COLON 
                 PFA_DIGITQ:
0003aa 02d9          .dw XT_TOUPPER
0003ab 7037          .dw XT_DOLITERAL 
0003ac 0030          .dw $30 
0003ad 719c          .dw XT_MINUS 
0003ae 70ac          .dw XT_DUP 
0003af 7037          .dw XT_DOLITERAL
0003b0 0009          .dw $09 
0003b1 7151          .dw XT_UGREATER 
0003b2 7030          .dw XT_DOCONDBRANCH
0003b3 03c0          .dw PFA_DIGITQ0 
0003b4 7037          .dw XT_DOLITERAL
0003b5 0007          .dw $07 
0003b6 719c          .dw XT_MINUS 
0003b7 70ac          .dw XT_DUP 
0003b8 7037          .dw XT_DOLITERAL
0003b9 0009          .dw $09 
0003ba 03cf          .dw XT_ULESSEQUAL
0003bb 7030          .dw XT_DOCONDBRANCH
0003bc 03c0          .dw PFA_DIGITQ1 
0003bd 70d4          .dw XT_DROP 
0003be 7134          .dw XT_ZERO
0003bf 701a          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
0003c0 70ac          .dw XT_DUP 
0003c1 0141          .dw XT_BASE 
0003c2 7074          .dw XT_FETCH 
0003c3 03d7          .dw XT_UGREATEREQUAL
0003c4 7030          .dw XT_DOCONDBRANCH
0003c5 03c9          .dw PFA_DIGITQ2 
0003c6 70d4          .dw XT_DROP 
0003c7 7134          .dw XT_ZERO
0003c8 701a          .dw XT_EXIT 
                 PFA_DIGITQ2:
0003c9 713d          .dw XT_TRUE
0003ca 701a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
0003cb ff03          .dw $ff03 
0003cc 3c75
0003cd 003d          .db "u<=",0
0003ce 03a4          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
0003cf 7000          .dw DO_COLON 
                 PFA_ULESSEQUAL:
0003d0 7151          .dw XT_UGREATER 
0003d1 7206          .dw XT_INVERT 
0003d2 701a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
0003d3 ff03          .dw $ff03 
0003d4 3e75
0003d5 003d          .db "u>=",0
0003d6 03cb          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
0003d7 7000          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
0003d8 7146          .dw XT_ULESS 
0003d9 7206          .dw XT_INVERT 
0003da 701a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003db 7000        .dw DO_COLON
                 PFA_DOSLITERAL:
0003dc 70ea        .dw XT_R_FROM   ; ( -- addr )
0003dd 70ac        .dw XT_DUP      ; ( -- addr addr )
0003de 70ac        .dw XT_DUP
0003df 73c7        .dw XT_FETCHI   ; ( -- addr addr n )
0003e0 70bf        .dw XT_SWAP
0003e1 7238        .dw XT_1PLUS
0003e2 70bf        .dw XT_SWAP
0003e3 70dc        .dw XT_ROT      ; ( -- addr' n addr )
0003e4 70ca        .dw XT_OVER     ; ( -- addr' n addr n)
0003e5 7238        .dw XT_1PLUS
0003e6 720d        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003e7 71a6        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003e8 7238        .dw XT_1PLUS
0003e9 70f3        .dw XT_TO_R     ; ( -- )
0003ea 701a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003eb ff02        .dw $ff02
0003ec 2c73        .db "s",$2c
0003ed 03d3        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003ee 7000          .dw DO_COLON
                 PFA_SCOMMA:
0003ef 70ac          .dw XT_DUP
0003f0 03f2          .dw XT_DOSCOMMA
0003f1 701a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003f2 7000          .dw DO_COLON
                 PFA_DOSCOMMA:
0003f3 01f6          .dw XT_COMMA
0003f4 70ac          .dw XT_DUP   ; ( --addr len len)
0003f5 720d          .dw XT_2SLASH ; ( -- addr len len/2
0003f6 70bf          .dw XT_SWAP   ; ( -- addr len/2 len
0003f7 70ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003f8 7214          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003f9 719c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003fa 70f3          .dw XT_TO_R
0003fb 7134          .dw XT_ZERO
0003fc 72aa          .dw XT_DOQDO
0003fd 0404          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0003fe 70ac          .dw XT_DUP         ; ( -- addr addr )
0003ff 7074          .dw XT_FETCH       ; ( -- addr c1c2 )
000400 01f6          .dw XT_COMMA       ; ( -- addr )
000401 0150          .dw XT_CELLPLUS    ; ( -- addr+cell )
000402 72d8          .dw XT_DOLOOP
000403 03fe          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000404 70ea          .dw XT_R_FROM
000405 715c          .dw XT_GREATERZERO
000406 7030          .dw XT_DOCONDBRANCH
000407 040b          .dw PFA_SCOMMA3
000408 70ac            .dw XT_DUP     ; well, tricky
000409 7093            .dw XT_CFETCH
00040a 01f6            .dw XT_COMMA
                 PFA_SCOMMA3:
00040b 70d4          .dw XT_DROP        ; ( -- )
00040c 701a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00040d ff05          .dw $ff05
00040e 7469
00040f 7079
000410 0065          .db "itype",0
000411 03eb          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000412 7000          .dw DO_COLON
                 PFA_ITYPE:
000413 70ac          .dw XT_DUP    ; ( --addr len len)
000414 720d          .dw XT_2SLASH ; ( -- addr len len/2
000415 70bf          .dw XT_SWAP   ; ( -- addr len/2 len
000416 70ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
000417 7214          .dw XT_2STAR  ; ( -- addr len/2 len len'
000418 719c          .dw XT_MINUS  ; ( -- addr len/2 rem
000419 70f3          .dw XT_TO_R
00041a 7134          .dw XT_ZERO
00041b 72aa          .dw XT_DOQDO
00041c 0425          .dw PFA_ITYPE2
                 PFA_ITYPE1:
00041d 70ac          .dw XT_DUP         ; ( -- addr addr )
00041e 73c7          .dw XT_FETCHI      ; ( -- addr c1c2 )
00041f 70ac          .dw XT_DUP
000420 0432          .dw XT_LOWEMIT
000421 042e          .dw XT_HIEMIT
000422 7238          .dw XT_1PLUS    ; ( -- addr+cell )
000423 72d8          .dw XT_DOLOOP
000424 041d          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000425 70ea          .dw XT_R_FROM
000426 715c          .dw XT_GREATERZERO
000427 7030          .dw XT_DOCONDBRANCH
000428 042c          .dw PFA_ITYPE3
000429 70ac            .dw XT_DUP     ; make sure the drop below has always something to do
00042a 73c7            .dw XT_FETCHI
00042b 0432            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00042c 70d4          .dw XT_DROP
00042d 701a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00042e 7000          .dw DO_COLON
                 PFA_HIEMIT:
00042f 730e          .dw XT_BYTESWAP
000430 0432          .dw XT_LOWEMIT
000431 701a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000432 7000          .dw DO_COLON
                 PFA_LOWEMIT:
000433 7037          .dw XT_DOLITERAL
000434 00ff          .dw $00ff
000435 721c          .dw XT_AND
000436 017f          .dw XT_EMIT
000437 701a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000438 ff06          .dw $ff06
000439 6369
00043a 756f
00043b 746e          .db "icount"
00043c 040d          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00043d 7000          .dw DO_COLON
                 PFA_ICOUNT:
00043e 70ac          .dw XT_DUP
00043f 7238          .dw XT_1PLUS
000440 70bf          .dw XT_SWAP
000441 73c7          .dw XT_FETCHI
000442 701a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
000443 ff02          .dw $ff02
000444 7263          .db "cr"
000445 0438          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000446 7000          .dw DO_COLON
                 PFA_CR:
000447 7037          .dw XT_DOLITERAL
000448 000d          .dw 13
000449 017f          .dw XT_EMIT
00044a 7037          .dw XT_DOLITERAL
00044b 000a          .dw 10
00044c 017f          .dw XT_EMIT
00044d 701a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
00044e ff05          .dw $ff05
00044f 7073
000450 6361
000451 0065          .db "space",0
000452 0443          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000453 7000          .dw DO_COLON
                 PFA_SPACE:
000454 022b          .dw XT_BL
000455 017f          .dw XT_EMIT
000456 701a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
000457 ff06          .dw $ff06
000458 7073
000459 6361
00045a 7365          .db "spaces"
00045b 044e          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00045c 7000          .dw DO_COLON
                 PFA_SPACES:
00045d 70ac          .dw XT_DUP
00045e 715c          .dw XT_GREATERZERO
00045f 721c          .dw XT_AND
000460 7134          .dw XT_ZERO
000461 72aa          .dw XT_DOQDO
000462 0466          .dw PFA_SPACES2
                 PFA_SPACES1:
000463 0453          .dw XT_SPACE
000464 72d8          .dw XT_DOLOOP
000465 0463          .dw PFA_SPACES1
                 PFA_SPACES2:
000466 701a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
000467 ff04          .dw $ff04
000468 7974
000469 6570          .db "type"
00046a 0457          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00046b 7000          .dw DO_COLON
                 PFA_TYPE:
00046c 70ca          .dw XT_OVER
00046d 71a6          .dw XT_PLUS
00046e 70bf          .dW XT_SWAP
00046f 72aa          .dw XT_DOQDO
000470 0476          .dw PFA_TYPE2
                 PFA_TYPE1:
000471 72bd          .dw XT_I
000472 7093          .dw XT_CFETCH
000473 017f          .dw XT_EMIT
000474 72d8          .dw XT_DOLOOP
000475 0471          .dw PFA_TYPE1
                 PFA_TYPE2:
000476 701a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
000477 ff01          .dw $ff01
000478 0027          .db "'",0
000479 0467          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00047a 7000          .dw DO_COLON
                 PFA_TICK:
00047b 0637          .dw XT_PARSENAME
00047c 0654          .dw XT_FINDNAME
00047d 7118          .dw XT_EQUALZERO
00047e 7030          .dw XT_DOCONDBRANCH
00047f 0483          .dw PFA_TICK1
000480 7037          .dw XT_DOLITERAL
000481 fff3          .dw -13
000482 04a7          .dw XT_THROW
                 PFA_TICK1:
000483 701a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
000484 ff07          .dw $ff07
000485 6168
000486 646e
000487 656c
000488 0072          .db "handler",0
000489 0477          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00048a 7052          .dw PFA_DOUSER
                 PFA_HANDLER:
00048b 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
00048c ff05          .dw $ff05
00048d 6163
00048e 6374
00048f 0068          .db "catch",0
000490 0484          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000491 7000          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
000492 728a          .dw XT_SP_FETCH
000493 70f3          .dw XT_TO_R
                     ; handler @ >r
000494 048a          .dw XT_HANDLER
000495 7074          .dw XT_FETCH
000496 70f3          .dw XT_TO_R
                     ; rp@ handler !
000497 7273          .dw XT_RP_FETCH
000498 048a          .dw XT_HANDLER
000499 707c          .dw XT_STORE
00049a 7024          .dw XT_EXECUTE
                     ; r> handler !
00049b 70ea          .dw XT_R_FROM
00049c 048a          .dw XT_HANDLER
00049d 707c          .dw XT_STORE
00049e 70ea          .dw XT_R_FROM
00049f 70d4          .dw XT_DROP
0004a0 7134          .dw XT_ZERO
0004a1 701a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
0004a2 ff05          .dw $ff05
0004a3 6874
0004a4 6f72
0004a5 0077          .db "throw",0
0004a6 048c          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
0004a7 7000          .dw DO_COLON
                 PFA_THROW:
0004a8 70ac          .dw XT_DUP
0004a9 7118          .dw XT_EQUALZERO
0004aa 7030          .dw XT_DOCONDBRANCH
0004ab 04ae          .dw PFA_THROW1
0004ac 70d4      	.dw XT_DROP
0004ad 701a      	.dw XT_EXIT
                 PFA_THROW1:
0004ae 048a          .dw XT_HANDLER
0004af 7074          .dw XT_FETCH
0004b0 727d          .dw XT_RP_STORE
0004b1 70ea          .dw XT_R_FROM
0004b2 048a          .dw XT_HANDLER
0004b3 707c          .dw XT_STORE
0004b4 70ea          .dw XT_R_FROM
0004b5 70bf          .dw XT_SWAP
0004b6 70f3          .dw XT_TO_R
0004b7 7293          .dw XT_SP_STORE
0004b8 70d4          .dw XT_DROP
0004b9 70ea          .dw XT_R_FROM    
0004ba 701a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
0004bb ff05          .dw $ff05
0004bc 7363
0004bd 696b
0004be 0070          .db "cskip",0
0004bf 04a2          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
0004c0 7000          .dw DO_COLON
                 PFA_CSKIP:
0004c1 70f3          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0004c2 70ac          .dw XT_DUP            ; ( -- addr' n' n' )
0004c3 7030          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0004c4 04d0          .dw PFA_CSKIP2
0004c5 70ca          .dw XT_OVER           ; ( -- addr' n' addr' )
0004c6 7093          .dw XT_CFETCH         ; ( -- addr' n' c' )
0004c7 70fc          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0004c8 7111          .dw XT_EQUAL          ; ( -- addr' n' f )
0004c9 7030          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0004ca 04d0          .dw PFA_CSKIP2
0004cb 7037          .dw XT_DOLITERAL
0004cc 0001          .dw 1
0004cd 0626          .dw XT_SLASHSTRING
0004ce 7029          .dw XT_DOBRANCH
0004cf 04c2          .dw PFA_CSKIP1
                 PFA_CSKIP2:
0004d0 70ea          .dw XT_R_FROM
0004d1 70d4          .dw XT_DROP           ; ( -- addr2 n2)
0004d2 701a          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
0004d3 ff06          .dw $ff06
0004d4 6361
0004d5 6563
0004d6 7470          .db "accept"
0004d7 04bb          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0004d8 7000          .dw DO_COLON
                 PFA_ACCEPT:
0004d9 70ac          .dw XT_DUP        ; ( -- addr n1 n1)
0004da 70f3          .dw XT_TO_R
0004db 70f3          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
0004dc 0190          .dw XT_KEY        ; ( -- addr k )
0004dd 70ac          .dw XT_DUP        ; ( -- addr k k )
0004de 7037          .dw XT_DOLITERAL
0004df 000a          .dw 10
0004e0 7107          .dw XT_NOTEQUAL
0004e1 7030          .dw XT_DOCONDBRANCH
0004e2 0516          .dw PFA_ACCEPT2
0004e3 70ac          .dw XT_DUP
0004e4 7037          .dw XT_DOLITERAL
0004e5 000d          .dw 13
0004e6 7107          .dw XT_NOTEQUAL
0004e7 7030          .dw XT_DOCONDBRANCH
0004e8 0516          .dw PFA_ACCEPT2
                     ; check backspace
0004e9 70ac          .dw XT_DUP
0004ea 7037          .dw XT_DOLITERAL
0004eb 0008          .dw 8
0004ec 7111          .dw XT_EQUAL
0004ed 7030          .dw XT_DOCONDBRANCH
0004ee 0502          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
0004ef 70ea          .dw XT_R_FROM             ; ( -- addr k n1 )
0004f0 70fc          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
0004f1 70ca          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
0004f2 70f3          .dw XT_TO_R
0004f3 7111          .dw XT_EQUAL              ; ( -- addr k f )
0004f4 7030          .dw XT_DOCONDBRANCH
0004f5 04f9          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
0004f6 70d4          .dw XT_DROP               ; ( -- addr )
0004f7 7029          .dw XT_DOBRANCH
0004f8 04dc          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0004f9 70ac          .dw XT_DUP                ; ( -- addr k k )
0004fa 017f          .dw XT_EMIT               ; ( -- addr k )
0004fb 0453          .dw XT_SPACE              ; ( -- addr k )
0004fc 017f          .dw XT_EMIT               ; ( -- addr )
0004fd 723e          .dw XT_1MINUS             ; ( -- addr--)
0004fe 70ea          .dw XT_R_FROM
0004ff 7238          .dw XT_1PLUS
000500 7029          .dw XT_DOBRANCH
000501 0510          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
000502 70ac          .dw XT_DUP            ; ( -- addr k k )
000503 022b          .dw XT_BL
000504 711f          .dw XT_LESS
000505 7030          .dw XT_DOCONDBRANCH
000506 0509          .dw PFA_ACCEPT6
000507 70d4          .dw XT_DROP
000508 022b          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
000509 70ac          .dw XT_DUP            ; ( -- addr k k)
00050a 017f          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
00050b 70ca          .dw XT_OVER           ; ( -- addr k addr
00050c 7088          .dw XT_CSTORE         ; ( -- addr)
00050d 7238          .dw XT_1PLUS          ; ( -- addr++)
00050e 70ea          .dw XT_R_FROM         ; ( -- addr n1)
00050f 723e          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
000510 70ac          .dw XT_DUP
000511 70f3          .dw XT_TO_R
000512 7118          .dw XT_EQUALZERO
000513 7030          .dw XT_DOCONDBRANCH
000514 04dc          .dw PFA_ACCEPT1
000515 70ac          .dw XT_DUP
                 PFA_ACCEPT2:
000516 0161          .dw XT_2DROP
000517 70ea          .dw XT_R_FROM
000518 70ea          .dw XT_R_FROM
000519 70bf          .dw XT_SWAP
00051a 719c          .dw XT_MINUS
00051b 0446          .dw XT_CR
00051c 701a          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
00051d ff06          .dw $ff06
00051e 6572
00051f 6966
000520 6c6c          .db "refill"
000521 04d3          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000522 081a          .dw PFA_DODEFER
                 PFA_REFILL:
000523 001a          .dw USER_REFILL
000524 07f2          .dw XT_UDEFERFETCH
000525 07f9          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
000526 ff04          .dw $ff04
000527 6863
000528 7261          .db "char"
000529 051d          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00052a 7000          .dw DO_COLON
                 PFA_CHAR:
00052b 0637          .dw XT_PARSENAME
00052c 70d4          .dw XT_DROP
00052d 7093          .dw XT_CFETCH
00052e 701a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
00052f ff06          .dw $ff06
000530 756e
000531 626d
000532 7265          .db "number"
000533 0526          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000534 7000          .dw DO_COLON
                 PFA_NUMBER:
000535 0141          .dw XT_BASE
000536 7074          .dw XT_FETCH
000537 70f3          .dw XT_TO_R
000538 05a5          .dw XT_NUMBERSIGN
000539 70f3          .dw XT_TO_R
00053a 0571          .dw XT_PRAEFIX
00053b 05a5          .dw XT_NUMBERSIGN
00053c 70ea          .dw XT_R_FROM
00053d 7225          .dw XT_OR
00053e 70f3          .dw XT_TO_R
00053f 70f3          .dw XT_TO_R
000540 70f3          .dw XT_TO_R
000541 7134          .dw XT_ZERO       ; starting value
000542 7134          .dw XT_ZERO
000543 70ea          .dw XT_R_FROM
000544 70ea          .dw XT_R_FROM
000545 05c4          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000546 70b4          .dw XT_QDUP
000547 7030              .dw XT_DOCONDBRANCH
000548 0565      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
000549 7037          .dw XT_DOLITERAL
00054a 0001          .dw 1
00054b 7111          .dw XT_EQUAL
00054c 7030          .dw XT_DOCONDBRANCH
00054d 055c          .dw PFA_NUMBER2
                 	; excatly one character is left
00054e 7093      	.dw XT_CFETCH
00054f 7037      	.dw XT_DOLITERAL
000550 002e      	.dw $2e ; .
000551 7111      	.dw XT_EQUAL
000552 7030      	.dw XT_DOCONDBRANCH
000553 055c      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
000554 70ea      	.dw XT_R_FROM
000555 7030              .dw XT_DOCONDBRANCH
000556 0558      	.dw PFA_NUMBER3
000557 08e7              .dw XT_DNEGATE
                 PFA_NUMBER3:
000558 7037      	.dw XT_DOLITERAL
000559 0002      	.dw 2
00055a 7029      	.dw XT_DOBRANCH
00055b 056c      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
00055c 0161      	.dw XT_2DROP
00055d 70d4      	.dw XT_DROP
00055e 70ea      	.dw XT_R_FROM
00055f 70d4      	.dw XT_DROP
000560 70ea              .dw XT_R_FROM
000561 0141              .dw XT_BASE
000562 707c              .dw XT_STORE
000563 7134      	.dw XT_ZERO
000564 701a      	.dw XT_EXIT
                 PFA_NUMBER1:
000565 0161          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000566 70ea          .dw XT_R_FROM
000567 7030          .dw XT_DOCONDBRANCH
000568 056a          .dw PFA_NUMBER4
000569 028e          .dw XT_NEGATE
                 PFA_NUMBER4:
00056a 7037          .dw XT_DOLITERAL
00056b 0001          .dw 1
                 PFA_NUMBER5:
00056c 70ea          .dw XT_R_FROM
00056d 0141          .dw XT_BASE
00056e 707c          .dw XT_STORE
00056f 713d          .dw XT_TRUE
000570 701a          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
000571 7000          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
000572 70ca          .dw XT_OVER 
000573 7093          .dw XT_CFETCH 
000574 7037          .dw XT_DOLITERAL
000575 0029          .dw $29 
000576 7126          .dw XT_GREATER 
000577 7030          .dw XT_DOCONDBRANCH
000578 057a          .dw PFA_PRAEFIX0 
000579 701a          .dw XT_EXIT 
                 PFA_PRAEFIX0:
00057a 70ca          .dw XT_OVER 
00057b 7093          .dw XT_CFETCH 
00057c 0581          .dw XT_SETBASE
00057d 7037          .dw XT_DOLITERAL
00057e 0001          .dw $1 
00057f 0626          .dw XT_SLASHSTRING 
000580 701a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000581 7000          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000582 70ac          .dw XT_DUP 
000583 7037          .dw XT_DOLITERAL
000584 0024          .dw '$' 
000585 7111          .dw XT_EQUAL 
000586 7030          .dw XT_DOCONDBRANCH
000587 058b          .dw PFA_SETBASE0 
000588 70d4          .dw XT_DROP 
000589 0222          .dw XT_HEX 
00058a 701a          .dw XT_EXIT 
                 PFA_SETBASE0:
00058b 70ac          .dw XT_DUP 
00058c 7037          .dw XT_DOLITERAL
00058d 0025          .dw '%' 
00058e 7111          .dw XT_EQUAL 
00058f 7030          .dw XT_DOCONDBRANCH
000590 0594          .dw PFA_SETBASE1 
000591 70d4          .dw XT_DROP 
000592 020c          .dw XT_BIN
000593 701a          .dw XT_EXIT 
                 PFA_SETBASE1:
000594 70ac          .dw XT_DUP 
000595 7037          .dw XT_DOLITERAL
000596 0026          .dw '&'
000597 7111          .dw XT_EQUAL 
000598 7030          .dw XT_DOCONDBRANCH
000599 059d          .dw PFA_SETBASE2 
00059a 70d4          .dw XT_DROP
00059b 0218          .dw XT_DECIMAL 
00059c 701a          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
00059d 7037          .dw XT_DOLITERAL
00059e 0023          .dw '#'
00059f 7111          .dw XT_EQUAL 
0005a0 7030          .dw XT_DOCONDBRANCH
0005a1 05a4          .dw PFA_SETBASE3 
0005a2 0218          .dw XT_DECIMAL 
0005a3 701a          .dw XT_EXIT 
                 PFA_SETBASE3:
0005a4 701a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
0005a5 7000          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
0005a6 70ca          .dw XT_OVER
0005a7 7093          .dw XT_CFETCH
0005a8 7037          .dw XT_DOLITERAL
0005a9 002b          .dw '+'
0005aa 7111          .dw XT_EQUAL
0005ab 7030          .dw XT_DOCONDBRANCH
0005ac 05b0          .dw PFA_NUMBERSIGN_MINUS
0005ad 7037            .dw XT_DOLITERAL
0005ae 0001            .dw 1
0005af 0626            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
0005b0 70ca          .dw XT_OVER    ; ( -- addr len addr )
0005b1 7093          .dw XT_CFETCH
0005b2 7037          .dw XT_DOLITERAL
0005b3 002d          .dw '-'
0005b4 7111          .dw XT_EQUAL  ; ( -- addr len flag )
0005b5 70ac          .dw XT_DUP
0005b6 70f3          .dw XT_TO_R
0005b7 7030          .dw XT_DOCONDBRANCH
0005b8 05bc          .dw PFA_NUMBERSIGN_PLUS
0005b9 7037          .dw XT_DOLITERAL      ; skip sign character
0005ba 0001          .dw 1
0005bb 0626          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
0005bc 70ea          .dw XT_R_FROM
0005bd 701a          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
0005be ff07          .dw $ff07
0005bf 6e3e
0005c0 6d75
0005c1 6562
0005c2 0072          .db ">number",0
0005c3 052f          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0005c4 7000          .dw DO_COLON
                 PFA_TO_NUMBER:
0005c5 70ac          .dw XT_DUP
0005c6 7030          .dw XT_DOCONDBRANCH
0005c7 05e2          .dw PFA_TO_NUMBER1
0005c8 70ca              .dw XT_OVER
0005c9 7093              .dw XT_CFETCH
0005ca 03a9              .dw XT_DIGITQ
0005cb 7118              .dw XT_EQUALZERO
0005cc 7030              .dw XT_DOCONDBRANCH
0005cd 05cf              .dw PFA_TO_NUMBER2
0005ce 701a                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
0005cf 70f3              .dw XT_TO_R
0005d0 090c              .dw XT_2SWAP
0005d1 70ea              .dw XT_R_FROM
0005d2 70bf              .dw XT_SWAP
0005d3 0141              .dw XT_BASE
0005d4 7074              .dw XT_FETCH
0005d5 71e9              .dw XT_UMSTAR
0005d6 70d4              .dw XT_DROP
0005d7 70dc              .dw XT_ROT
0005d8 0141              .dw XT_BASE
0005d9 7074              .dw XT_FETCH
0005da 71e9              .dw XT_UMSTAR
0005db 76bb              .dw XT_DPLUS
0005dc 090c              .dw XT_2SWAP
0005dd 7037              .dw XT_DOLITERAL
0005de 0001              .dw 1
0005df 0626              .dw XT_SLASHSTRING
0005e0 7029          .dw XT_DOBRANCH
0005e1 05c5          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
0005e2 701a          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
0005e3 ff05          .dw $ff05
0005e4 6170
0005e5 7372
0005e6 0065          .db "parse",0
0005e7 05be          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0005e8 7000          .dw DO_COLON
                 PFA_PARSE:
0005e9 70f3          .dw XT_TO_R     ; ( -- )
0005ea 061c          .dw XT_SOURCE   ; ( -- addr len)
0005eb 0169          .dw XT_G_IN     ; ( -- addr len >in)
0005ec 7074          .dw XT_FETCH
0005ed 0626          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0005ee 70ea          .dw XT_R_FROM      ; ( -- addr' len' c)
0005ef 05fd          .dw XT_CSCAN       ; ( -- addr' len'')
0005f0 70ac          .dw XT_DUP         ; ( -- addr' len'' len'')
0005f1 7238          .dw XT_1PLUS
0005f2 0169          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
0005f3 7262          .dw XT_PLUSSTORE   ; ( -- addr' len')
0005f4 7037          .dw XT_DOLITERAL
0005f5 0001          .dw 1
0005f6 0626          .dw XT_SLASHSTRING
0005f7 701a          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0005f8 ff05          .dw $ff05
0005f9 7363
0005fa 6163
0005fb 006e          .db "cscan",0
0005fc 05e3          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0005fd 7000          .dw DO_COLON
                 PFA_CSCAN:
0005fe 70bf          .dw XT_SWAP         ; ( -- addr1 c n1 )
0005ff 70ac          .dw XT_DUP          ; ( -- addr1 c n1 n1)
000600 70f3          .dw XT_TO_R         ; ( -- addr1 c n1)
000601 7134          .dw XT_ZERO         ; ( -- addr1 c n1 0)
000602 72aa          .dw XT_DOQDO        ; ( -- addr1 c)
000603 0614          .dw PFA_CSCAN3
                 PFA_CSCAN1:
000604 70ca          .dw XT_OVER         ; ( -- addr1 c addr1 )
000605 72bd          .dw XT_I            ; ( -- addr1 c addr1 i)
000606 71a6          .dw XT_PLUS         ; ( -- addr1 c addr')
000607 7093          .dw XT_CFETCH       ; ( -- addr1 c c')
000608 70ca          .dw XT_OVER         ; ( -- addr1 c c' c)
000609 7111          .dw XT_EQUAL        ; ( -- addr1 c f)
00060a 7030          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
00060b 0612          .dw PFA_CSCAN2
00060c 70d4          .dw XT_DROP         ; ( -- addr1 )
00060d 72bd          .dw XT_I            ; ( -- addr1 n2)
00060e 72e7          .dw XT_UNLOOP       ; ( -- addr1 n2)
00060f 70ea          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
000610 70d4          .dw XT_DROP         ; ( -- addr1 n2)
000611 701a          .dw XT_EXIT
                 PFA_CSCAN2:
000612 72d8          .dw XT_DOLOOP
000613 0604          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
000614 70d4          .dw XT_DROP         ; ( -- addr1)
000615 70ea          .dw XT_R_FROM       ; ( -- addr1 n1)
000616 701a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
000617 ff06          .dw $FF06
000618 6f73
000619 7275
00061a 6563          .db "source"
00061b 05f8          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00061c 081a          .dw PFA_DODEFER
                 PFA_SOURCE:
00061d 0016          .dw USER_SOURCE
00061e 07f2          .dw XT_UDEFERFETCH
00061f 07f9          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
000620 ff07          .dw $ff07
000621 732f
000622 7274
000623 6e69
000624 0067          .db "/string",0
000625 0617          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000626 7000          .dw DO_COLON
                 PFA_SLASHSTRING:
000627 70ca          .dw XT_OVER    ; ( -- addr1 u1 n u1)
000628 02b2          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
000629 70dc          .dw XT_ROT     ; ( -- u1 n addr1 )
00062a 70ca          .dw XT_OVER    ; ( -- u1 n addr1 n)
00062b 71a6          .dw XT_PLUS    ; ( -- u1 n addr2 )
00062c 70dc          .dw XT_ROT     ; ( -- n addr2 u1)
00062d 70dc          .dw XT_ROT     ; ( -- addr2 u1 n)
00062e 719c          .dw XT_MINUS   ; ( -- addr2 u2)
00062f 701a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
000630 ff0a          .dw $FF0A 
000631 6170
000632 7372
000633 2d65
000634 616e
000635 656d          .db "parse-name"
000636 0620          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000637 7000          .dw DO_COLON 
                 PFA_PARSENAME:
000638 022b          .dw XT_BL
000639 063b          .dw XT_SKIPSCANCHAR
00063a 701a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00063b 7000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
00063c 70f3          .dw XT_TO_R
00063d 061c          .dw XT_SOURCE 
00063e 0169          .dw XT_G_IN 
00063f 7074          .dw XT_FETCH 
000640 0626          .dw XT_SLASHSTRING 
                 
000641 70fc          .dw XT_R_FETCH
000642 04c0          .dw XT_CSKIP
000643 70ea          .dw XT_R_FROM
000644 05fd          .dw XT_CSCAN
                 
                     ; adjust >IN
000645 0158          .dw XT_2DUP
000646 71a6          .dw XT_PLUS
000647 061c          .dw XT_SOURCE 
000648 70d4          .dw XT_DROP
000649 719c          .dw XT_MINUS
00064a 0169          .dw XT_G_IN
00064b 707c          .dw XT_STORE
00064c 701a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
00064d ff09          .dw $ff09
00064e 6966
00064f 646e
000650 6e2d
000651 6d61
000652 0065          .db "find-name",0
000653 0630          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000654 7000          .dw DO_COLON
                 PFA_FINDNAME:
000655 7037          .dw XT_DOLITERAL
000656 0014          .dw EE_ORDERLISTLEN
000657 735b          .dw XT_FETCHE
000658 7134          .dw XT_ZERO
000659 72aa          .dw XT_DOQDO
00065a 066f          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
00065b 0158          .dw XT_2DUP
00065c 7037          .dw XT_DOLITERAL
00065d 0016          .dw EE_ORDERLIST
00065e 72bd          .dw XT_I
00065f 0148          .dw XT_CELLS
000660 71a6          .dw XT_PLUS  
000661 735b          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
000662 082e          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
000663 70b4          .dw XT_QDUP
000664 7030          .dw XT_DOCONDBRANCH
000665 066d          .dw PFA_FINDNAME4
000666 70f3      	.dw XT_TO_R
000667 70f3      	.dw XT_TO_R
000668 0161      	.dw XT_2DROP
000669 70ea      	.dw XT_R_FROM
00066a 70ea      	.dw XT_R_FROM
00066b 72e7      	.dw XT_UNLOOP
00066c 701a      	.dw XT_EXIT
                 PFA_FINDNAME4:
00066d 72d8          .dw XT_DOLOOP
00066e 065b          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
00066f 0161          .dw XT_2DROP
000670 7134          .dw XT_ZERO
000671 701a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
000672 ff04          .dw $ff04
000673 7571
000674 7469          .db "quit"
000675 064d          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000676 7000          .dw DO_COLON
                 PFA_QUIT:
000677 06ee          .dw XT_SP0
000678 7293          .dw XT_SP_STORE
000679 0703          .dw XT_RP0
00067a 727d          .dw XT_RP_STORE
00067b 751b          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00067c 013b          .dw XT_STATE
00067d 7074          .dw XT_FETCH
00067e 7118          .dw XT_EQUALZERO
00067f 7030          .dw XT_DOCONDBRANCH
000680 0682          .dw PFA_QUIT4
000681 0698          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000682 0522          .dw XT_REFILL
000683 7030          .dw XT_DOCONDBRANCH
000684 067c          .dw PFA_QUIT2
000685 7037          .dw XT_DOLITERAL
000686 071c          .dw XT_INTERPRET
000687 0491          .dw XT_CATCH
000688 70b4          .dw XT_QDUP
000689 7030          .dw XT_DOCONDBRANCH
00068a 0694          .dw PFA_QUIT3
00068b 70ac      	.dw XT_DUP
00068c 7037      	.dw XT_DOLITERAL
00068d fffe      	.dw -2
00068e 711f      	.dw XT_LESS
00068f 7030      	.dw XT_DOCONDBRANCH
000690 0692      	.dw PFA_QUIT5
000691 06a6      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000692 7029      	.dw XT_DOBRANCH
000693 0677      	.dw PFA_QUIT
                 PFA_QUIT3:
000694 069f          .dw XT_PROMPTOK
000695 7029          .dw XT_DOBRANCH
000696 067c          .dw PFA_QUIT2
000697 701a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000698 7000          .dw DO_COLON
                 PFA_PROMPTRDY:
000699 0446          .dw XT_CR
00069a 03db          .dw XT_DOSLITERAL
00069b 0002          .dw 2
00069c 203e          .db "> "
00069d 0412          .dw XT_ITYPE
00069e 701a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00069f 7000          .dw DO_COLON
                 PFA_PROMPTOK:
0006a0 03db          .dw XT_DOSLITERAL
0006a1 0003          .dw 3
0006a2 6f20
0006a3 006b          .db " ok",0
0006a4 0412          .dw XT_ITYPE
0006a5 701a          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
0006a6 7000          .dw DO_COLON
                 PFA_PROMPTERROR:
0006a7 03db      	.dw XT_DOSLITERAL
0006a8 0004      	.dw 4
0006a9 3f20
0006aa 203f      	.db  " ?? "
0006ab 0412          .dw XT_ITYPE
0006ac 0141      	.dw XT_BASE
0006ad 7074      	.dw XT_FETCH
0006ae 70f3      	.dw XT_TO_R
0006af 0218      	.dw XT_DECIMAL
0006b0 0378      	.dw XT_DOT
0006b1 0169      	.dw XT_G_IN
0006b2 7074      	.dw XT_FETCH
0006b3 0378      	.dw XT_DOT
0006b4 70ea      	.dw XT_R_FROM
0006b5 0141      	.dw XT_BASE
0006b6 707c      	.dw XT_STORE
0006b7 701a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
0006b8 ff05          .dw $ff05
0006b9 6170
0006ba 7375
0006bb 0065          .db "pause",0
0006bc 0672          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
0006bd 081a          .dw PFA_DODEFER
                 PFA_PAUSE:
0006be 015d          .dw ram_pause
0006bf 07e8          .dw XT_RDEFERFETCH
0006c0 07ed          .dw XT_RDEFERSTORE
                 
                 .dseg
00015d           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
0006c1 ff04          .dw $ff04
0006c2 6f63
0006c3 646c          .db "cold"
0006c4 06b8          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
0006c5 06c6          .dw PFA_COLD
                 PFA_COLD:
0006c6 b6a4          in_ r10, MCUSR
0006c7 24bb          clr r11
0006c8 2422          clr zerol
0006c9 2433          clr zeroh
0006ca be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
00015f           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
0006cb e5ef          ldi zl, low(ram_user1)
0006cc e0f1          ldi zh, high(ram_user1)
0006cd 012f          movw upl, zl
                     ; init return stack pointer
0006ce ef0f          ldi temp0,low(rstackstart)
0006cf bf0d          out_ SPL,temp0
0006d0 8304          std Z+4, temp0
0006d1 e110          ldi temp1,high(rstackstart)
0006d2 bf1e          out_ SPH,temp1
0006d3 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
0006d4 eacf          ldi yl,low(stackstart)
0006d5 83c6          std Z+6, yl
0006d6 e1d0          ldi yh,high(stackstart)
0006d7 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
0006d8 eea1          ldi XL, low(PFA_WARM)
0006d9 e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
0006da 940c 7004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
0006dc ff04          .dw $ff04
0006dd 6177
0006de 6d72          .db "warm"
0006df 06c1          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
0006e0 7000          .dw DO_COLON
                 PFA_WARM:
0006e1 095c          .dw XT_INITUSER
0006e2 7037          .dw XT_DOLITERAL
0006e3 07b7          .dw XT_NOOP
0006e4 7037          .dw XT_DOLITERAL
0006e5 06bd          .dw XT_PAUSE
0006e6 0805          .dw XT_DEFERSTORE
0006e7 0233          .dw XT_TURNKEY
0006e8 0676          .dw XT_QUIT
0006e9 701a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0006ea ff03          .dw $ff03
0006eb 7073
0006ec 0030          .db "sp0",0
0006ed 06dc          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0006ee 7069          .dw PFA_DOVALUE1
                 PFA_SP0:
0006ef 0006          .dw USER_SP0
0006f0 06f7          .dw XT_UVALUEFETCH
0006f1 06fb          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0006f2 ff02          .dw $ff02
0006f3 7073          .db "sp"
0006f4 06ea          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0006f5 7052          .dw PFA_DOUSER
                 PFA_SP:
0006f6 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
0006f7 7000          .dw DO_COLON
                 PFA_UVALUEFETCH:
0006f8 73c7          .dw XT_FETCHI
0006f9 709b          .dw XT_FETCHU
0006fa 701a          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
0006fb 7000          .dw DO_COLON
                 PFA_UVALUESTORE:
0006fc 73c7          .dw XT_FETCHI
0006fd 70a3          .dw XT_STOREU
0006fe 701a          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0006ff ff03          .dw $ff03
000700 7072
000701 0030          .db "rp0",0
000702 06f2          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000703 7000          .dw DO_COLON
                 PFA_RP0:
000704 0707          .dw XT_DORP0
000705 7074          .dw XT_FETCH
000706 701a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000707 7052          .dw PFA_DOUSER
                 PFA_DORP0:
000708 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
000709 ff05          .dw $ff05
00070a 6564
00070b 7470
00070c 0068          .db "depth",0
00070d 06ff          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00070e 7000          .dw DO_COLON
                 PFA_DEPTH:
00070f 06ee          .dw XT_SP0
000710 728a          .dw XT_SP_FETCH
000711 719c          .dw XT_MINUS
000712 720d          .dw XT_2SLASH
000713 723e          .dw XT_1MINUS
000714 701a          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
000715 ff09          .dw $ff09
000716 6e69
000717 6574
000718 7072
000719 6572
00071a 0074          .db "interpret",0
00071b 0709          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00071c 7000          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
00071d 0637          .dw XT_PARSENAME ; ( -- addr len )
00071e 70b4          .dw XT_QDUP   ; ( -- addr len len )
00071f 715c          .dw XT_GREATERZERO
000720 7030          .dw XT_DOCONDBRANCH
000721 0740          .dw PFA_INTERPRET5
000722 7037          .dw XT_DOLITERAL
000723 0026          .dw EE_RECOGNIZERLISTLEN
000724 735b          .dw XT_FETCHE       ; ( addr len rec # -- )
000725 7134          .dw XT_ZERO
                 
000726 72aa          .dw XT_DOQDO
000727 073c          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
000728 0158          .dw XT_2DUP ; ( -- addr len addr len  )
000729 72bd          .dw XT_I    ; ( -- addr len addr len i )
00072a 70dc          .dw XT_ROT  ; ( -- addr len len i addr )
00072b 70dc          .dw XT_ROT  ; ( -- addr len i addr len )
00072c 70f3          .dw XT_TO_R
00072d 70f3          .dw XT_TO_R
                 
00072e 0148          .dw XT_CELLS
00072f 7037          .dw XT_DOLITERAL
000730 0028          .dw EE_RECOGNIZERLIST
000731 71a6          .dw XT_PLUS
000732 735b          .dw XT_FETCHE
                 
000733 7024          .dw XT_EXECUTE
000734 70ea          .dw XT_R_FROM
000735 70ea          .dw XT_R_FROM
000736 70dc          .dw XT_ROT
000737 7030          .dw XT_DOCONDBRANCH
000738 073a          .dw PFA_INTERPRET3
000739 746d            .dw XT_LEAVE
                 PFA_INTERPRET3:
00073a 72d8          .dw XT_DOLOOP
00073b 0728          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
00073c 0161          .dw XT_2DROP
00073d 078d          .dw XT_QSTACK
00073e 7029          .dw XT_DOBRANCH
00073f 071d          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
000740 70d4          .dw xT_DROP
000741 701a          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
000742 ff0a          .dw $ff0a
000743 6572
000744 2d63
000745 6e69
000746 6e74
000747 6d75          .db "rec-intnum"
000748 0715          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
000749 7000          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
00074a 0534          .dw XT_NUMBER 
00074b 7030          .dw XT_DOCONDBRANCH 
00074c 075e          .dw PFA_REC_NONUMBER
                 
00074d 013b          .dw XT_STATE
00074e 7074          .dw XT_FETCH
00074f 7030          .dw XT_DOCONDBRANCH
000750 075b          .dw PFA_REC_NUMBER_DONE
000751 7037      	.dw XT_DOLITERAL
000752 0002      	.dw 2
000753 7111      	.dw XT_EQUAL
000754 7030      	.dw XT_DOCONDBRANCH
000755 0758      	.dw PFA_REC_NUMBER_SINGLE
000756 70bf      	.dw XT_SWAP
000757 73d4              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
000758 73d4              .dw XT_LITERAL
000759 7029              .dw XT_DOBRANCH
00075a 075c              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
00075b 70d4          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
00075c 713d          .dw XT_TRUE
00075d 701a          .dw XT_EXIT
                 PFA_REC_NONUMBER:
00075e 7134          .dw XT_ZERO
00075f 701a          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000760 ff08          .dw $ff08
000761 6572
000762 2d63
000763 6966
000764 646e          .db "rec-find"
000765 0742          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
000766 7000          .dw DO_COLON
                 PFA_REC_FIND:
000767 0654          .dw XT_FINDNAME
000768 70ac          .dw XT_DUP
000769 7030          .dw XT_DOCONDBRANCH 
00076a 0779          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
00076b 715c      	.dw XT_GREATERZERO
00076c 7030      	.dw XT_DOCONDBRANCH
00076d 0770      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
00076e 7029      	    .dw XT_DOBRANCH
00076f 0777      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000770 013b      	    .dw XT_STATE
000771 7074      	    .dw XT_FETCH
000772 7030      	    .dw XT_DOCONDBRANCH
000773 0777      	    .dw PFA_REC_FIND_EXECUTE
000774 01f6      	    .dw XT_COMMA
000775 7029      	    .dw XT_DOBRANCH
000776 0778      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
000777 7024          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
000778 713d          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000779 701a          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
00077a ff0c          .dw $ff0c
00077b 6572
00077c 2d63
00077d 6f6e
00077e 6674
00077f 756f
000780 646e          .db "rec-notfound"
000781 0760          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000782 7000          .dw DO_COLON
                 PFA_REC_NOTFOUND:
000783 046b          .dw XT_TYPE
000784 7037          .dw XT_DOLITERAL
000785 fff3          .dw -13
000786 04a7          .dw XT_THROW
000787 701a          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
000788 ff06          .dw $ff06
000789 733f
00078a 6174
00078b 6b63          .db "?stack"
00078c 077a          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00078d 7000          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
00078e 070e          .dw XT_DEPTH
00078f 712d          .dw XT_LESSZERO
000790 7030          .dw XT_DOCONDBRANCH
000791 0795          .dw PFA_QSTACK1
000792 7037            .dw XT_DOLITERAL
000793 fffc            .dw -4
000794 04a7            .dw XT_THROW
                 PFA_QSTACK1:
000795 701a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
000796 ff03          .dw $ff03
000797 6576
000798 0072          .db "ver",0
000799 0788          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
00079a 7000          .dw DO_COLON
                 PFA_VER:
00079b 75ef          .dw XT_ENV_FORTHNAME
00079c 0412          .dw XT_ITYPE
00079d 0453          .dw XT_SPACE
00079e 0141          .dw XT_BASE
00079f 7074          .dw XT_FETCH
0007a0 70f3          .dw XT_TO_R
0007a1 0218          .dw XT_DECIMAL
                 
0007a2 75fd          .dw XT_ENV_FORTHVERSION
0007a3 7329          .dw XT_S2D
0007a4 0312          .dw XT_L_SHARP
0007a5 031a          .dw XT_SHARP
0007a6 7037          .dw XT_DOLITERAL
0007a7 002e          .dw '.'
0007a8 0303          .dw XT_HOLD
0007a9 0330          .dw XT_SHARP_S
0007aa 033b          .dw XT_SHARP_G
0007ab 70ea          .dw XT_R_FROM
0007ac 0141          .dw XT_BASE
0007ad 707c          .dw XT_STORE
                 
0007ae 046b          .dw XT_TYPE
0007af 0453          .dw XT_SPACE
0007b0 7605          .dw XT_ENV_CPU
0007b1 0412          .dw XT_ITYPE
0007b2 701a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
0007b3 ff04          .dw $ff04
0007b4 6f6e
0007b5 706f          .db "noop"
0007b6 0796          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
0007b7 07b8          .dw PFA_NOOP
                 PFA_NOOP:
0007b8 940c 7004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
0007ba ff06          .dw $ff06
0007bb 6e75
0007bc 7375
0007bd 6465          .db "unused"
0007be 07b3          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
0007bf 7000          .dw DO_COLON
                 PFA_UNUSED:
0007c0 06ee          .dw XT_SP0
0007c1 01af          .dw XT_HERE
0007c2 719c          .dw XT_MINUS
0007c3 701a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
0007c4 0002          .dw $0002
0007c5 6f74          .db "to"
0007c6 07ba          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
0007c7 7000          .dw DO_COLON
                 PFA_TO:
0007c8 047a          .dw XT_TICK
0007c9 7238          .dw XT_1PLUS  		; to body
0007ca 013b          .dw XT_STATE
0007cb 7074          .dw XT_FETCH
0007cc 7030          .dw XT_DOCONDBRANCH
0007cd 07d8          .dw PFA_TO1
0007ce 01eb          .dw XT_COMPILE
0007cf 07d2          .dw XT_DOTO
0007d0 01f6          .dw XT_COMMA
0007d1 701a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
0007d2 7000          .dw DO_COLON
                 PFA_DOTO:
0007d3 70ea          .dw XT_R_FROM
0007d4 70ac          .dw XT_DUP
0007d5 7238          .dw XT_1PLUS
0007d6 70f3          .dw XT_TO_R
0007d7 73c7          .dw XT_FETCHI
                 PFA_TO1:
0007d8 70ac          .dw XT_DUP
0007d9 7238          .dw XT_1PLUS
0007da 7238          .dw XT_1PLUS
0007db 73c7          .dw XT_FETCHI
0007dc 7024          .dw XT_EXECUTE
0007dd 701a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
0007de 7000          .dw DO_COLON
                 PFA_EDEFERFETCH:
0007df 7238          .dw XT_1PLUS ; >body
0007e0 73c7          .dw XT_FETCHI
0007e1 735b          .dw XT_FETCHE
0007e2 701a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
0007e3 7000          .dw DO_COLON
                 PFA_EDEFERSTORE:
0007e4 7238          .dw XT_1PLUS
0007e5 73c7          .dw XT_FETCHI
0007e6 7337          .dw XT_STOREE
0007e7 701a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
0007e8 7000          .dw DO_COLON
                 PFA_RDEFERFETCH:
0007e9 7238          .dw XT_1PLUS ; >body
0007ea 73c7          .dw XT_FETCHI
0007eb 7074          .dw XT_FETCH
0007ec 701a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
0007ed 7000          .dw DO_COLON
                 PFA_RDEFERSTORE:
0007ee 7238          .dw XT_1PLUS
0007ef 73c7          .dw XT_FETCHI
0007f0 707c          .dw XT_STORE
0007f1 701a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
0007f2 7000          .dw DO_COLON
                 PFA_UDEFERFETCH:
0007f3 7238          .dw XT_1PLUS ; >body
0007f4 73c7          .dw XT_FETCHI
0007f5 7317          .dw XT_UP_FETCH
0007f6 71a6          .dw XT_PLUS
0007f7 7074          .dw XT_FETCH
0007f8 701a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
0007f9 7000          .dw DO_COLON
                 PFA_UDEFERSTORE:
0007fa 7238          .dw XT_1PLUS
0007fb 73c7          .dw XT_FETCHI
0007fc 7317          .dw XT_UP_FETCH
0007fd 71a6          .dw XT_PLUS
0007fe 707c          .dw XT_STORE
0007ff 701a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
000800 ff06          .dw $ff06
000801 6564
000802 6566
000803 2172          .db "defer!"
000804 07c4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000805 7000          .dw DO_COLON
                 PFA_DEFERSTORE:
000806 70ac          .dw XT_DUP
000807 7037          .dw XT_DOLITERAL
000808 0003          .dw 3
000809 71a6          .dw XT_PLUS   ; >body 2 +
00080a 73c7          .dw XT_FETCHI
00080b 7024          .dw XT_EXECUTE
00080c 701a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
00080d ff06          .dw $ff06
00080e 6564
00080f 6566
000810 4072          .db "defer@"
000811 0800          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000812 7000          .dw DO_COLON
                 PFA_DEFERFETCH:
000813 70ac          .dw XT_DUP
000814 7238          .dw XT_1PLUS ; >body
000815 7238          .dw XT_1PLUS 
000816 73c7          .dw XT_FETCHI
000817 7024          .dw XT_EXECUTE
000818 701a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
000819 081a          .dw PFA_DODEFER
                 PFA_DODEFER:
00081a 940e 74d7     call_ DO_DODOES
00081c 70ac          .dw XT_DUP
00081d 723e          .dw XT_1MINUS
00081e 70bf          .dw XT_SWAP
00081f 7238          .dw XT_1PLUS
000820 73c7          .dw XT_FETCHI
000821 7024          .dw XT_EXECUTE 
000822 7024          .dw XT_EXECUTE
000823 701a          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
000824 ff0f          .dw $ff0f
000825 6573
000826 7261
000827 6863
000828 772d
000829 726f
00082a 6c64
00082b 7369
00082c 0074          .db "search-wordlist",0
00082d 080d          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00082e 7000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
00082f 7134          .dw XT_ZERO
000830 70bf          .dw XT_SWAP
000831 7037          .dw XT_DOLITERAL
000832 083d          .dw XT_ISWORD
000833 70bf          .dw XT_SWAP
000834 0874          .dw XT_TRAVERSEWORDLIST
000835 70ac          .dw XT_DUP
000836 7118          .dw XT_EQUALZERO
000837 7030          .dw XT_DOCONDBRANCH
000838 083c          .dw PFA_SEARCH_WORDLIST1
000839 0161             .dw XT_2DROP
00083a 70d4             .dw XT_DROP
00083b 7134             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
00083c 701a          .dw XT_EXIT
                 
                 XT_ISWORD:
00083d 7000          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
00083e 70f3          .dw XT_TO_R
00083f 70f3          .dw XT_TO_R
000840 0158          .dw XT_2DUP
000841 70ea          .dw XT_R_FROM
000842 70dc          .dw XT_ROT
000843 70dc          .dw XT_ROT
000844 70fc          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
000845 0863          .dw XT_NAME2STRING
000846 088f          .dw XT_ICOMPARE      ; (-- addr len 0 f )
000847 7030          .dw XT_DOCONDBRANCH
000848 0857          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
000849 0161            .dw XT_2DROP
00084a 70d4            .dw XT_DROP
                       ; ... get the XT ...
00084b 70fc            .dw XT_R_FETCH
00084c 768f            .dw XT_NFA2LFA
00084d 7238            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
00084e 713d            .dw XT_TRUE
00084f 70ea            .dw XT_R_FROM
000850 73c7            .dw XT_FETCHI
000851 715c            .dw XT_GREATERZERO
000852 7030            .dw XT_DOCONDBRANCH
000853 0855            .dw PFA_ISWORD1
000854 028e               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
000855 7134            .dw XT_ZERO       ; finish traverse-wordlist
000856 701a            .dw XT_EXIT
                 PFA_ISWORD3:
000857 70ea          .dw XT_R_FROM
000858 70d4          .dw XT_DROP
000859 713d          .dw XT_TRUE         ; maybe next word
00085a 701a          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
00085b ff0b          .dw $ff0b
00085c 616e
00085d 656d
00085e 733e
00085f 7274
000860 6e69
000861 0067          .db "name>string",0
000862 0824          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000863 7000          .dw DO_COLON
                 PFA_NAME2STRING:
000864 043d          .dw XT_ICOUNT   ; ( -- addr n )
000865 7037          .dw XT_DOLITERAL
000866 00ff          .dw $00FF
000867 721c          .dw XT_AND      ; mask immediate bit
000868 701a          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000869 ff11          .dw $ff11
00086a 7274
00086b 7661
00086c 7265
00086d 6573
00086e 772d
00086f 726f
000870 6c64
000871 7369
000872 0074          .db "traverse-wordlist",0
000873 085b          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000874 7000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
000875 735b          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000876 70ac          .dw XT_DUP           ; ( -- xt nt nt )
000877 7030          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000878 0887          .dw PFA_TRAVERSEWORDLIST2       ;
000879 0158          .dw XT_2DUP
00087a 70f3          .dw XT_TO_R
00087b 70f3          .dw XT_TO_R
00087c 70bf          .dw XT_SWAP
00087d 7024          .dw XT_EXECUTE
00087e 70ea          .dw XT_R_FROM
00087f 70ea          .dw XT_R_FROM
000880 70dc          .dw XT_ROT
000881 7030          .dw XT_DOCONDBRANCH
000882 0887          .dw PFA_TRAVERSEWORDLIST2
000883 768f          .dw XT_NFA2LFA
000884 73c7          .dw XT_FETCHI        ; ( -- addr )
000885 7029          .dw XT_DOBRANCH      ; ( -- addr )
000886 0876          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000887 0161          .dw XT_2DROP
000888 701a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
000889 ff08          .dw $ff08
00088a 6369
00088b 6d6f
00088c 6170
00088d 6572          .db "icompare"
00088e 0869          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00088f 7000          .dw DO_COLON
                 PFA_ICOMPARE:
000890 70f3          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000891 70ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000892 70ea          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000893 7107          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000894 7030          .dw XT_DOCONDBRANCH
000895 089a          .dw PFA_ICOMPARE_SAMELEN
000896 0161            .dw XT_2DROP
000897 70d4            .dw XT_DROP
000898 7134            .dw XT_ZERO
000899 701a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00089a 70bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
00089b 7134          .dw XT_ZERO
00089c 72aa          .dw XT_DOQDO
00089d 08bb          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00089e 70ca          .dw XT_OVER
00089f 7074          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
0008a0 70ca          .dw XT_OVER
0008a1 73c7          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0008a2 70ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0008a3 7037          .dw XT_DOLITERAL
0008a4 0100          .dw $100
0008a5 7146          .dw XT_ULESS
0008a6 7030          .dw XT_DOCONDBRANCH
0008a7 08ac          .dw PFA_ICOMPARE_LASTCELL
0008a8 70bf          .dw XT_SWAP
0008a9 7037          .dw XT_DOLITERAL
0008aa 00ff          .dw $00FF
0008ab 721c          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0008ac 7107          .dw XT_NOTEQUAL
0008ad 7030          .dw XT_DOCONDBRANCH
0008ae 08b3          .dw PFA_ICOMPARE_NEXTLOOP
0008af 0161          .dw XT_2DROP
0008b0 7134          .dw XT_ZERO
0008b1 72e7          .dw XT_UNLOOP
0008b2 701a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
0008b3 7238          .dw XT_1PLUS
0008b4 70bf          .dw XT_SWAP
0008b5 0150          .dw XT_CELLPLUS
0008b6 70bf          .dw XT_SWAP
0008b7 7037          .dw XT_DOLITERAL
0008b8 0002          .dw 2
0008b9 72be          .dw XT_DOPLUSLOOP
0008ba 089e          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
0008bb 0161          .dw XT_2DROP
0008bc 713d          .dw XT_TRUE
0008bd 701a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
0008be ff01          .dw $ff01
0008bf 002a          .db "*",0
0008c0 0889          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
0008c1 7000          .dw DO_COLON
                 PFA_STAR:
0008c2 71af          .dw XT_MSTAR
0008c3 08d3          .dw XT_D2S
0008c4 701a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
0008c5 ff01          .dw $FF01
0008c6 006a          .db "j",0
0008c7 08be          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
0008c8 7000          .dw DO_COLON
                 PFA_J:
0008c9 7273          .dw XT_RP_FETCH
0008ca 7037          .dw XT_DOLITERAL
0008cb 0009          .dw 9
0008cc 71a6          .dw XT_PLUS
0008cd 7074          .dw XT_FETCH
0008ce 701a          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
0008cf ff03          .dw $ff03
0008d0 3e64
0008d1 0073          .db "d>s",0
0008d2 08c5          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
0008d3 7000          .dw DO_COLON
                 PFA_D2S:
0008d4 70d4          .dw XT_DROP
0008d5 701a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
0008d6 ff04          .dw $ff04
0008d7 6164
0008d8 7362          .db "dabs"
0008d9 08cf          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
0008da 7000          .dw DO_COLON
                 PFA_DABS:
0008db 70ac          .dw XT_DUP
0008dc 712d          .dw XT_LESSZERO
0008dd 7030          .dw XT_DOCONDBRANCH
0008de 08e0          .dw PFA_DABS1
0008df 08e7          .dw XT_DNEGATE
                 PFA_DABS1:
0008e0 701a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
0008e1 ff07          .dw $ff07
0008e2 6e64
0008e3 6765
0008e4 7461
0008e5 0065          .db "dnegate",0
0008e6 08d6          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
0008e7 7000          .dw DO_COLON
                 PFA_DNEGATE:
0008e8 76e1          .dw XT_DINVERT
0008e9 7037          .dw XT_DOLITERAL
0008ea 0001          .dw 1
0008eb 7134          .dw XT_ZERO
0008ec 76bb          .dw XT_DPLUS
0008ed 701a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
0008ee ff05          .dw $ff05
0008ef 6d63
0008f0 766f
0008f1 0065          .db "cmove",0
0008f2 08e1          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
0008f3 08f4          .dw PFA_CMOVE
                 PFA_CMOVE:
0008f4 93bf          push xh
0008f5 93af          push xl
0008f6 91e9          ld zl, Y+
0008f7 91f9          ld zh, Y+ ; addr-to
0008f8 91a9          ld xl, Y+
0008f9 91b9          ld xh, Y+ ; addr-from
0008fa 2f09          mov temp0, tosh
0008fb 2b08          or temp0, tosl
0008fc f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
0008fd 911d          ld temp1, X+
0008fe 9311          st Z+, temp1
0008ff 9701          sbiw tosl, 1
000900 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000901 91af          pop xl
000902 91bf          pop xh
000903 9189
000904 9199          loadtos
000905 940c 7004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
000907 ff05          .dw $ff05
000908 7332
000909 6177
00090a 0070          .db "2swap",0
00090b 08ee          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00090c 7000          .dw DO_COLON
                 PFA_2SWAP:
00090d 70dc          .dw XT_ROT
00090e 70f3          .dw XT_TO_R
00090f 70dc          .dw XT_ROT
000910 70ea          .dw XT_R_FROM
000911 701a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000912 ff03          .dw $ff03
000913 6974
000914 0062          .db "tib",0
000915 0907          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000916 7042          .dw PFA_DOVARIABLE
                 PFA_TIB:
000917 0185          .dw ram_tib
                     
                 .dseg
000185           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
000918 ff0a          .dw $ff0a
000919 6572
00091a 6966
00091b 6c6c
00091c 742d
00091d 6269          .db "refill-tib"
00091e 0912          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00091f 7000          .dw DO_COLON
                 PFA_REFILLTIB:
000920 0916          .dw XT_TIB
000921 7037          .dw XT_DOLITERAL
000922 0064          .dw TIBSIZE
000923 04d8          .dw XT_ACCEPT
000924 016f          .dw XT_NUMBERTIB
000925 707c          .dw XT_STORE
000926 7134          .dw XT_ZERO
000927 0169          .dw XT_G_IN
000928 707c          .dw XT_STORE
000929 7037          .dw XT_DOLITERAL
00092a ffff          .dw -1
00092b 701a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
00092c ff0a          .dw $FF0A
00092d 6f73
00092e 7275
00092f 6563
000930 742d
000931 6269          .db "source-tib"
000932 0918          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000933 7000          .dw DO_COLON
                 PFA_SOURCETIB:
000934 0916          .dw XT_TIB
000935 016f          .dw XT_NUMBERTIB
000936 7074          .dw XT_FETCH
000937 701a          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
000938 ff07        .dw $ff07
000939 6565
00093a 752d
00093b 6573
00093c 0072        .db "ee-user",0
00093d 092c        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
00093e 7042        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
00093f 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000940 ff06        .dw $ff06
000941 6565
000942 723e
000943 6d61        .db "ee>ram"
000944 0938        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000945 7000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000946 7134          .dw XT_ZERO
000947 72aa          .dw XT_DOQDO
000948 0953          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000949 70ca          .dw XT_OVER
00094a 735b          .dw XT_FETCHE
00094b 70ca          .dw XT_OVER
00094c 707c          .dw XT_STORE
00094d 0150          .dw XT_CELLPLUS
00094e 70bf          .dw XT_SWAP
00094f 0150          .dw XT_CELLPLUS
000950 70bf          .dw XT_SWAP
000951 72d8          .dw XT_DOLOOP
000952 0949          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000953 0161          .dw XT_2DROP
000954 701a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000955 ff09        .dw $ff09
000956 6e69
000957 7469
000958 752d
000959 6573
00095a 0072        .db "init-user",0
00095b 0940        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
00095c 7000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
00095d 093e          .dw XT_EEUSER
00095e 7317          .dw XT_UP_FETCH
00095f 7037          .dw XT_DOLITERAL
000960 001c          .dw SYSUSERSIZE
000961 720d          .dw XT_2SLASH
000962 0945          .dw XT_EE2RAM
000963 701a          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_MARKER:
000964 ff08          .dw $ff08
000965 6d28
000966 7261
000967 656b
000968 2972          .db "(marker)"
000969 0955          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
00096a 7069          .dw PFA_DOVALUE1
                 PFA_MARKER:
00096b 0036          .dw EE_MARKER
00096c 755a          .dw XT_EVALUEFETCH
00096d 755e          .dw XT_EVALUESTORE
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
007000 93bf          push XH
007001 93af          push XL          ; PUSH IP
007002 01db          movw XL, wl
007003 9611          adiw xl, 1
                 DO_NEXT:
007004 f06e          brts DO_INTERRUPT
007005 01fd          movw zl, XL        ; READ IP
007006 0fee
007007 1fff
007008 9165
007009 9175          readflashcell wl, wh
00700a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00700b 01fb          movw zl, wl
00700c 0fee
00700d 1fff
00700e 9105
00700f 9115          readflashcell temp0,temp1
007010 01f8          movw zl, temp0
007011 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
007012 94e8          clt
007013 e160          ldi wl, LOW(XT_ISREXEC)
007014 e071          ldi wh, HIGH(XT_ISREXEC)
007015 cff5          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
007016 ff04          .dw $ff04
007017 7865
007018 7469          .db "exit"
007019 0964          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00701a 701b          .dw PFA_EXIT
                 PFA_EXIT:
00701b 91af          pop XL
00701c 91bf          pop XH
00701d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00701e ff07          .dw $ff07
00701f 7865
007020 6365
007021 7475
007022 0065          .db "execute",0
007023 7016          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
007024 7025          .dw PFA_EXECUTE
                 PFA_EXECUTE:
007025 01bc          movw wl, tosl
007026 9189
007027 9199          loadtos
007028 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
007029 702a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00702a 01fd          movw zl, XL
00702b 0fee
00702c 1fff
00702d 91a5
00702e 91b5          readflashcell XL,XH
00702f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
007030 7031          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
007031 2b98          or tosh, tosl
007032 9189
007033 9199          loadtos
007034 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
007035 9611          adiw XL, 1
007036 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
007037 7038          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
007038 939a
007039 938a          savetos
00703a 01fd          movw zl, xl
00703b 0fee
00703c 1fff
00703d 9185
00703e 9195          readflashcell tosl,tosh
00703f 9611          adiw xl, 1
007040 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
007041 7042          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
007042 939a
007043 938a          savetos
007044 01fb          movw zl, wl
007045 9631          adiw zl,1
007046 0fee
007047 1fff
007048 9185
007049 9195          readflashcell tosl,tosh
00704a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00704b 704c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00704c 939a
00704d 938a          savetos
00704e 01cb          movw tosl, wl
00704f 9601          adiw tosl, 1
007050 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
007051 7052          .dw PFA_DOUSER
                 PFA_DOUSER:
007052 939a
007053 938a          savetos
007054 01fb          movw zl, wl
007055 9631          adiw zl, 1
007056 0fee
007057 1fff
007058 9185
007059 9195          readflashcell tosl,tosh
00705a 0d84          add tosl, upl
00705b 1d95          adc tosh, uph
00705c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00705d ff07          .dw $ff07
00705e 7628
00705f 6c61
007060 6575
007061 0029          .db "(value)", 0
007062 701e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
007063 7000          .dw DO_COLON
                 PFA_DOVALUE:
007064 01c4          .dw XT_DOCREATE
007065 74b3          .dw XT_REVEAL
007066 01eb          .dw XT_COMPILE
007067 7069          .dw PFA_DOVALUE1
007068 701a          .dw XT_EXIT
                 PFA_DOVALUE1:
007069 940e 74d7     call_ DO_DODOES
00706b 70ac          .dw XT_DUP
00706c 70bf          .dw XT_SWAP
00706d 7238          .dw XT_1PLUS
00706e 73c7          .dw XT_FETCHI
00706f 7024          .dw XT_EXECUTE
007070 701a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
007071 ff01          .dw $ff01
007072 0040          .db "@",0
007073 705d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
007074 7075          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
007075 01fc          movw zl, tosl
                     ; low byte is read before the high byte
007076 9181          ld tosl, z+
007077 9191          ld tosh, z+
007078 cf8b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
007079 ff01          .dw $ff01
00707a 0021          .db "!",0
00707b 7071          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00707c 707d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00707d 01fc          movw zl, tosl
00707e 9189
00707f 9199          loadtos
                     ; the high byte is written before the low byte
007080 8391          std Z+1, tosh
007081 8380          std Z+0, tosl
007082 9189
007083 9199          loadtos
007084 cf7f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
007085 ff02          .dw $ff02
007086 2163          .db "c!"
007087 7079          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
007088 7089          .dw PFA_CSTORE
                 PFA_CSTORE:
007089 01fc          movw zl, tosl
00708a 9189
00708b 9199          loadtos
00708c 8380          st Z, tosl
00708d 9189
00708e 9199          loadtos
00708f cf74          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
007090 ff02          .dw $ff02
007091 4063          .db "c@"
007092 7085          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
007093 7094          .dw PFA_CFETCH
                 PFA_CFETCH:
007094 01fc          movw zl, tosl
007095 2799          clr tosh
007096 8180          ld tosl, Z
007097 cf6c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
007098 ff02          .dw $ff02
007099 7540          .db "@u"
00709a 7090          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00709b 7000          .dw DO_COLON
                 PFA_FETCHU:
00709c 7317          .dw XT_UP_FETCH
00709d 71a6          .dw XT_PLUS
00709e 7074          .dw XT_FETCH
00709f 701a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
0070a0 ff02          .dw $ff02
0070a1 7521          .db "!u"
0070a2 7098          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0070a3 7000          .dw DO_COLON
                 PFA_STOREU:
0070a4 7317          .dw XT_UP_FETCH
0070a5 71a6          .dw XT_PLUS
0070a6 707c          .dw XT_STORE
0070a7 701a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0070a8 ff03          .dw $ff03
0070a9 7564
0070aa 0070          .db "dup",0
0070ab 70a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0070ac 70ad          .dw PFA_DUP
                 PFA_DUP:
0070ad 939a
0070ae 938a          savetos
0070af cf54          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0070b0 ff04          .dw $ff04
0070b1 643f
0070b2 7075          .db "?dup"
0070b3 70a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0070b4 70b5          .dw PFA_QDUP
                 PFA_QDUP:
0070b5 2f08          mov temp0, tosl
0070b6 2b09          or temp0, tosh
0070b7 f011          breq PFA_QDUP1
0070b8 939a
0070b9 938a          savetos
                 PFA_QDUP1:
0070ba cf49          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0070bb ff04          .dw $ff04
0070bc 7773
0070bd 7061          .db "swap"
0070be 70b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0070bf 70c0          .dw PFA_SWAP
                 PFA_SWAP:
0070c0 018c          movw temp0, tosl
0070c1 9189
0070c2 9199          loadtos
0070c3 931a          st -Y, temp1
0070c4 930a          st -Y, temp0
0070c5 cf3e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0070c6 ff04          .dw $ff04
0070c7 766f
0070c8 7265          .db "over"
0070c9 70bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0070ca 70cb          .dw PFA_OVER
                 PFA_OVER:
0070cb 939a
0070cc 938a          savetos
0070cd 818a          ldd tosl, Y+2
0070ce 819b          ldd tosh, Y+3
                 
0070cf cf34          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0070d0 ff04          .dw $ff04
0070d1 7264
0070d2 706f          .db "drop"
0070d3 70c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0070d4 70d5          .dw PFA_DROP
                 PFA_DROP:
0070d5 9189
0070d6 9199          loadtos
0070d7 cf2c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0070d8 ff03          .dw $ff03
0070d9 6f72
0070da 0074          .db "rot",0
0070db 70d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0070dc 70dd          .dw PFA_ROT
                 PFA_ROT:
0070dd 018c          movw temp0, tosl
0070de 9129          ld temp2, Y+
0070df 9139          ld temp3, Y+ 
0070e0 9189
0070e1 9199          loadtos
                         
0070e2 933a          st -Y, temp3
0070e3 932a          st -Y, temp2
0070e4 931a          st -Y, temp1
0070e5 930a          st -Y, temp0
                 
0070e6 cf1d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0070e7 ff02          .dw $ff02
0070e8 3e72          .db "r>"
0070e9 70d8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0070ea 70eb          .dw PFA_R_FROM
                 PFA_R_FROM:
0070eb 939a
0070ec 938a          savetos
0070ed 918f          pop tosl
0070ee 919f          pop tosh
0070ef cf14          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0070f0 ff02          .dw $ff02
0070f1 723e          .db ">r"
0070f2 70e7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0070f3 70f4          .dw PFA_TO_R
                 PFA_TO_R:
0070f4 939f          push tosh
0070f5 938f          push tosl
0070f6 9189
0070f7 9199          loadtos
0070f8 cf0b          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
0070f9 ff02          .dw $ff02
0070fa 4072          .db "r@"
0070fb 70f0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
0070fc 70fd          .dw PFA_R_FETCH
                 PFA_R_FETCH:
0070fd 939a
0070fe 938a          savetos
0070ff 918f          pop tosl
007100 919f          pop tosh
007101 939f          push tosh
007102 938f          push tosl
007103 cf00          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
007104 ff02          .dw $ff02
007105 3e3c          .db "<>"
007106 70f9          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
007107 7108          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
007108 9129          ld temp2, Y+
007109 9139          ld temp3, Y+
00710a 1782          cp tosl, temp2
00710b 0793          cpc tosh, temp3
00710c f151          breq PFA_ZERO1
00710d c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00710e ff01          .dw $ff01
00710f 003d          .db "=",0
007110 7104          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
007111 7000          .dw DO_COLON
                 PFA_EQUAL:
007112 719c          .dw XT_MINUS
007113 7118          .dw XT_EQUALZERO
007114 701a          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
007115 ff02          .dw $ff02
007116 3d30          .db "0="
007117 710e          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
007118 7119          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
007119 2b98          or tosh, tosl
00711a f4e1          brne PFA_ZERO1
00711b c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00711c ff01          .dw $ff01
00711d 003c          .db "<",0
00711e 7115          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00711f 7000          .dw DO_COLON
                 PFA_LESS:
007120 719c          .dw XT_MINUS
007121 712d          .dw XT_LESSZERO
007122 701a          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
007123 ff01          .dw $ff01
007124 003e          .db ">",0
007125 711c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
007126 7000          .dw DO_COLON
                 PFA_GREATER:
007127 719c          .dw XT_MINUS
007128 715c          .dw XT_GREATERZERO
007129 701a          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00712a ff02          .dw $ff02
00712b 3c30          .db "0<"
00712c 7123          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00712d 712e          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00712e fd97          sbrc tosh,7
00712f c010          rjmp PFA_TRUE1
007130 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
007131 ff01          .dw $ff01
007132 0030          .db "0",0
007133 712a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
007134 7135          .dw PFA_ZERO
                 PFA_ZERO:
007135 939a
007136 938a          savetos
                 PFA_ZERO1:
007137 01c1          movw tosl, zerol
007138 cecb          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
007139 ff04          .dw $ff04
00713a 7274
00713b 6575          .db "true"
00713c 7131          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00713d 713e          .dw PFA_TRUE
                 PFA_TRUE:
00713e 939a
00713f 938a          savetos
                 PFA_TRUE1:
007140 ef8f          ser tosl
007141 ef9f          ser tosh
007142 cec1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
007143 ff02          .dw $ff02
007144 3c75          .db "u<"
007145 7139          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
007146 7147          .dw PFA_ULESS
                 PFA_ULESS:
007147 9129          ld temp2, Y+
007148 9139          ld temp3, Y+
007149 1782          cp tosl, temp2
00714a 0793          cpc tosh, temp3
00714b f358          brlo PFA_ZERO1
00714c f351          brbs 1, PFA_ZERO1
00714d cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00714e ff02          .dw $ff02
00714f 3e75          .db "u>"
007150 7143          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
007151 7152          .dw PFA_UGREATER
                 PFA_UGREATER:
007152 9129          ld temp2, Y+
007153 9139          ld temp3, Y+
007154 1728          cp temp2, tosl
007155 0739          cpc temp3, tosh
007156 f300          brlo PFA_ZERO1
007157 f2f9          brbs 1, PFA_ZERO1
007158 cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
007159 ff02          .dw $ff02
00715a 3e30          .db "0>"
00715b 714e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00715c 715d          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00715d 1582          cp tosl, zerol
00715e 0593          cpc tosh, zeroh
00715f f2bc          brlt PFA_ZERO1
007160 f2b1          brbs 1, PFA_ZERO1
007161 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
007162 ff02          .dw $ff02
007163 3e64          .db "d>"
007164 7159          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
007165 7000          .dw DO_COLON
                 PFA_DGREATER:
007166 76cc          .dw XT_DMINUS
007167 716d          .dw XT_DGREATERZERO
007168 701a          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
007169 ff03          .dw $ff03
00716a 3064
00716b 003e          .db "d0>",0
00716c 7162          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00716d 716e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00716e 1582          cp tosl, zerol
00716f 0593          cpc tosh, zeroh
007170 9189
007171 9199          loadtos
007172 0582          cpc tosl, zerol
007173 0593          cpc tosh, zeroh
007174 f214          brlt PFA_ZERO1
007175 f209          brbs 1, PFA_ZERO1
007176 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
007177 ff02          .dw $ff02
007178 3c64          .db "d<"
007179 7169          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00717a 7000          .dw DO_COLON
                 PFA_DLESS:
00717b 76cc          .dw XT_DMINUS
00717c 7182          .dw XT_DLESSZERO
00717d 701a          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00717e ff03          .dw $ff03
00717f 3064
007180 003c          .db "d0<",0
007181 7177          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
007182 7183          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
007183 9622          adiw Y,2
007184 fd97          sbrc tosh,7
007185 940c 7140     jmp PFA_TRUE1
007187 940c 7137     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
007189 ff04          .dw $ff04
00718a 6f6c
00718b 3267          .db "log2"
00718c 717e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00718d 718e          .dw PFA_LOG2
                 PFA_LOG2:
00718e 01fc          movw zl, tosl
00718f 2799          clr tosh
007190 e180          ldi tosl, 16
                 PFA_LOG2_1:
007191 958a          dec tosl
007192 f022          brmi PFA_LOG2_2 ; wrong data
007193 0fee          lsl  zl
007194 1fff          rol  zh
007195 f7d8          brcc PFA_LOG2_1
007196 ce6d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
007197 959a          dec tosh
007198 ce6b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
007199 ff01          .dw $ff01
00719a 002d          .db "-",0
00719b 7189          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00719c 719d          .dw PFA_MINUS
                 PFA_MINUS:
00719d 9109          ld temp0, Y+
00719e 9119          ld temp1, Y+
00719f 1b08          sub temp0, tosl
0071a0 0b19          sbc temp1, tosh
0071a1 01c8          movw tosl, temp0
0071a2 ce61          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
0071a3 ff01          .dw $ff01
0071a4 002b          .db "+",0
0071a5 7199          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
0071a6 71a7          .dw PFA_PLUS
                 PFA_PLUS:
0071a7 9109          ld temp0, Y+
0071a8 9119          ld temp1, Y+
0071a9 0f80          add tosl, temp0
0071aa 1f91          adc tosh, temp1
0071ab ce58          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0071ac ff02          .dw $ff02
0071ad 2a6d          .db "m*"
0071ae 71a3          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0071af 71b0          .dw PFA_MSTAR
                 PFA_MSTAR:
0071b0 018c          movw temp0, tosl
0071b1 9189
0071b2 9199          loadtos
0071b3 019c          movw temp2, tosl
                     ; high cell ah*bh
0071b4 0231          muls temp3, temp1
0071b5 0170          movw temp4, r0
                     ; low cell  al*bl
0071b6 9f20          mul  temp2, temp0
0071b7 01c0          movw tosl, r0
                     ; signed ah*bl
0071b8 0330          mulsu temp3, temp0
0071b9 08f3          sbc   temp5, zeroh
0071ba 0d90          add   tosh,  r0
0071bb 1ce1          adc   temp4, r1
0071bc 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0071bd 0312          mulsu temp1, temp2
0071be 08f3          sbc   temp5, zeroh
0071bf 0d90          add   tosh,  r0
0071c0 1ce1          adc   temp4, r1
0071c1 1cf3          adc   temp5, zeroh
                 
0071c2 939a
0071c3 938a          savetos
0071c4 01c7          movw tosl, temp4
0071c5 ce3e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0071c6 ff06          .dw $ff06
0071c7 6d75
0071c8 6d2f
0071c9 646f          .db "um/mod"
0071ca 71ac          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0071cb 71cc          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0071cc 017c          movw temp4, tosl
                 
0071cd 9129          ld temp2, Y+
0071ce 9139          ld temp3, Y+
                   
0071cf 9109          ld temp0, Y+
0071d0 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0071d1 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0071d2 2755          clr temp7
0071d3 0f00          lsl temp0
0071d4 1f11          rol temp1
0071d5 1f22          rol temp2
0071d6 1f33          rol temp3
0071d7 1f55          rol temp7
                 
                   ; try subtracting divisor
0071d8 152e          cp temp2, temp4
0071d9 053f          cpc temp3, temp5
0071da 0552          cpc temp7,zerol
                 
0071db f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0071dc 9503          inc temp0
0071dd 192e          sub temp2, temp4
0071de 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0071df 954a          dec  temp6
0071e0 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0071e1 933a          st -Y,temp3
0071e2 932a          st -Y,temp2
                 
                     ; put quotient on stack
0071e3 01c8          movw tosl, temp0
0071e4 ce1f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0071e5 ff03          .dw $ff03
0071e6 6d75
0071e7 002a          .db "um*",0
0071e8 71c6          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0071e9 71ea          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0071ea 018c          movw temp0, tosl
0071eb 9189
0071ec 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0071ed 9f80          mul tosl,temp0
0071ee 01f0          movw zl, r0
0071ef 2722          clr temp2
0071f0 2733          clr temp3
                     ; middle bytes
0071f1 9f90          mul tosh, temp0
0071f2 0df0          add zh, r0
0071f3 1d21          adc temp2, r1
0071f4 1d33          adc temp3, zeroh
                         
0071f5 9f81          mul tosl, temp1
0071f6 0df0          add zh, r0
0071f7 1d21          adc temp2, r1
0071f8 1d33          adc temp3, zeroh
                     
0071f9 9f91          mul tosh, temp1
0071fa 0d20          add temp2, r0
0071fb 1d31          adc temp3, r1
0071fc 01cf          movw tosl, zl
0071fd 939a
0071fe 938a          savetos
0071ff 01c9          movw tosl, temp2
007200 ce03          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
007201 ff06          .dw $ff06
007202 6e69
007203 6576
007204 7472          .db "invert"
007205 71e5          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
007206 7207          .dw PFA_INVERT
                 PFA_INVERT:
007207 9580          com tosl
007208 9590          com tosh
007209 cdfa          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00720a ff02          .dw $ff02
00720b 2f32          .db "2/"
00720c 7201          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00720d 720e          .dw PFA_2SLASH
                 PFA_2SLASH:
00720e 9595          asr tosh
00720f 9587          ror tosl
007210 cdf3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
007211 ff02          .dw $ff02
007212 2a32          .db "2*"
007213 720a          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
007214 7215          .dw PFA_2STAR
                 PFA_2STAR:
007215 0f88          lsl tosl
007216 1f99          rol tosh
007217 cdec          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
007218 ff03          .dw $ff03
007219 6e61
00721a 0064          .db "and",0
00721b 7211          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00721c 721d          .dw PFA_AND
                 PFA_AND:
00721d 9109          ld temp0, Y+
00721e 9119          ld temp1, Y+
00721f 2380          and tosl, temp0
007220 2391          and tosh, temp1
007221 cde2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
007222 ff02          .dw $ff02
007223 726f          .db "or"
007224 7218          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
007225 7226          .dw PFA_OR
                 PFA_OR:
007226 9109          ld temp0, Y+
007227 9119          ld temp1, Y+
007228 2b80          or tosl, temp0
007229 2b91          or tosh, temp1
00722a cdd9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00722b ff03          .dw $ff03
00722c 6f78
00722d 0072          .db "xor",0
00722e 7222          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00722f 7230          .dw PFA_XOR
                 PFA_XOR:
007230 9109          ld temp0, Y+
007231 9119          ld temp1, Y+
007232 2780          eor tosl, temp0
007233 2791          eor tosh, temp1
007234 cdcf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
007235 ff02          .dw $ff02
007236 2b31          .db "1+"
007237 722b          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
007238 7239          .dw PFA_1PLUS
                 PFA_1PLUS:
007239 9601          adiw tosl,1
00723a cdc9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00723b ff02          .dw $ff02 
00723c 2d31          .db "1-"
00723d 7235          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00723e 723f          .dw PFA_1MINUS
                 PFA_1MINUS:
00723f 9701          sbiw tosl, 1
007240 cdc3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
007241 ff06          .dw $ff06
007242 736c
007243 6968
007244 7466          .db "lshift"
007245 723b          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
007246 7247          .dw PFA_LSHIFT
                 PFA_LSHIFT:
007247 01fc          movw zl, tosl
007248 9189
007249 9199          loadtos
                 PFA_LSHIFT1:
00724a 9731          sbiw zl, 1
00724b f01a          brmi PFA_LSHIFT2
00724c 0f88          lsl tosl
00724d 1f99          rol tosh
00724e cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00724f cdb4          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
007250 ff06          .dw $ff06
007251 7372
007252 6968
007253 7466          .db "rshift"
007254 7241          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
007255 7256          .dw PFA_RSHIFT
                 PFA_RSHIFT:
007256 01fc          movw zl, tosl
007257 9189
007258 9199          loadtos
                 PFA_RSHIFT1:
007259 9731          sbiw zl, 1
00725a f01a          brmi PFA_RSHIFT2
00725b 9596          lsr tosh
00725c 9587          ror tosl
00725d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00725e cda5          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00725f ff02          .dw $ff02
007260 212b          .db "+!"
007261 7250          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
007262 7263          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
007263 01fc          movw zl, tosl
007264 9189
007265 9199          loadtos
007266 8120          ldd temp2, Z+0
007267 8131          ldd temp3, Z+1
007268 0f82          add tosl, temp2
007269 1f93          adc tosh, temp3
00726a 8380          std Z+0, tosl
00726b 8391          std Z+1, tosh
00726c 9189
00726d 9199          loadtos
00726e cd95          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00726f ff03          .dw $ff03
007270 7072
007271 0040          .db "rp@",0
007272 725f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
007273 7274          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
007274 939a
007275 938a          savetos
007276 b78d          in tosl, SPL
007277 b79e          in tosh, SPH
007278 cd8b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
007279 ff03          .dw $ff03
00727a 7072
00727b 0021          .db "rp!",0
00727c 726f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00727d 727e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00727e b72f          in temp2, SREG
00727f 94f8          cli
007280 bf8d          out SPL, tosl
007281 bf9e          out SPH, tosh
007282 bf2f          out SREG, temp2
007283 9189
007284 9199          loadtos
007285 cd7e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
007286 ff03          .dw $ff03
007287 7073
007288 0040          .db "sp@",0
007289 7279          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00728a 728b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00728b 939a
00728c 938a          savetos
00728d 01ce          movw tosl, yl
00728e cd75          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00728f ff03          .dw $ff03
007290 7073
007291 0021          .db "sp!",0
007292 7286          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
007293 7294          .dw PFA_SP_STORE
                 PFA_SP_STORE:
007294 01ec          movw yl, tosl
007295 9189
007296 9199          loadtos
007297 cd6c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
007298 7299          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
007299 01fd          movw zl, xl
00729a 0fee
00729b 1fff
00729c 9105
00729d 9115          readflashcell temp0,temp1
00729e 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00729f 9129          ld temp2, Y+
0072a0 9139          ld temp3, Y+
                 PFA_DODO1:
0072a1 931f          push temp1
0072a2 930f          push temp0
0072a3 933f          push temp3
0072a4 932f          push temp2
0072a5 939f          push tosh
0072a6 938f          push tosl
0072a7 9189
0072a8 9199          loadtos
0072a9 cd5a          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
0072aa 72ab          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
0072ab 01fd          movw zl, xl
0072ac 0fee
0072ad 1fff
0072ae 9105
0072af 9115          readflashcell temp0,temp1
0072b0 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
0072b1 9129          ld temp2, Y+
0072b2 9139          ld temp3, Y+
                     ; now check for equality
0072b3 1782          cp tosl, temp2
0072b4 0793          cpc tosh, temp3
0072b5 f759          brne PFA_DODO1
                     ; both values are the same -> skip loop
0072b6 01d8          movw xl, temp0
0072b7 9189
0072b8 9199          loadtos
0072b9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
0072ba ff01          .dw $FF01
0072bb 0069          .db "i",0
0072bc 728f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
0072bd 70fd          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
0072be 72bf          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
0072bf 91ef          pop zl
0072c0 91ff          pop zh
0072c1 0fe8          add zl, tosl
0072c2 1ff9          adc zh, tosh
0072c3 2f19          mov temp1, tosh
0072c4 9189
0072c5 9199          loadtos
                 PFA_DOPLUSLOOP4: 
0072c6 912f          pop temp2
0072c7 913f          pop temp3
0072c8 17e2          cp zl, temp2
0072c9 07f3          cpc zh, temp3
0072ca ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
0072cb c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
0072cc f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
0072cd c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
0072ce f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
0072cf 933f          push temp3
0072d0 932f          push temp2
0072d1 93ff          push zh
0072d2 93ef          push zl
0072d3 cd56          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
0072d4 910f          pop  temp0
0072d5 911f          pop  temp1  ; remove leave destination
0072d6 9611          adiw xl, 1 ; skip branch-back address
0072d7 cd2c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
0072d8 72d9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
0072d9 91ef          pop zl
0072da 91ff          pop zh
0072db 9631          adiw zl,1
0072dc 912f          pop temp2
0072dd 913f          pop temp3
0072de 17e2          cp zl, temp2
0072df 07f3          cpc zh, temp3
0072e0 f399          breq PFA_DOPLUSLOOP1
0072e1 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
0072e2 ff06          .dw $ff06
0072e3 6e75
0072e4 6f6c
0072e5 706f          .db "unloop"
0072e6 72ba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
0072e7 72e8          .dw PFA_UNLOOP
                 PFA_UNLOOP:
0072e8 911f          pop temp1
0072e9 910f          pop temp0
0072ea 911f          pop temp1
0072eb 910f          pop temp0
0072ec 911f          pop temp1
0072ed 910f          pop temp0
0072ee cd15          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
0072ef ff06          .dw $ff06
0072f0 6d63
0072f1 766f
0072f2 3e65          .db "cmove>"
0072f3 72e2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
0072f4 72f5          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
0072f5 93bf          push xh
0072f6 93af          push xl
0072f7 91e9          ld zl, Y+
0072f8 91f9          ld zh, Y+ ; addr-to
0072f9 91a9          ld xl, Y+
0072fa 91b9          ld xh, Y+ ; addr-from
0072fb 2f09          mov temp0, tosh
0072fc 2b08          or temp0, tosl
0072fd f041          brbs 1, PFA_CMOVE_G1
0072fe 0fe8          add zl, tosl
0072ff 1ff9          adc zh, tosh
007300 0fa8          add xl, tosl
007301 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
007302 911e          ld temp1, -X
007303 9312          st -Z, temp1
007304 9701          sbiw tosl, 1
007305 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
007306 91af          pop xl
007307 91bf          pop xh
007308 9189
007309 9199          loadtos
00730a ccf9          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00730b ff02          .dw $ff02
00730c 3c3e          .db "><"
00730d 72ef          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00730e 730f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00730f 2f09          mov temp0, tosh
007310 2f98          mov tosh, tosl
007311 2f80          mov tosl, temp0
007312 ccf1          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
007313 ff03          .dw $ff03
007314 7075
007315 0040          .db "up@",0
007316 730b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
007317 7318          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
007318 939a
007319 938a          savetos
00731a 01c2          movw tosl, upl
00731b cce8          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00731c ff03          .dw $ff03
00731d 7075
00731e 0021          .db "up!",0
00731f 7313          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
007320 7321          .dw PFA_UP_STORE
                 PFA_UP_STORE:
007321 012c          movw upl, tosl
007322 9189
007323 9199          loadtos
007324 ccdf          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
007325 ff03          .dw $ff03
007326 3e73
007327 0064          .db "s>d",0
007328 731c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
007329 7000          .dw DO_COLON
                 PFA_S2D:
00732a 70ac          .dw XT_DUP
00732b 712d          .dw XT_LESSZERO
                 .include "words/not.asm"
00732c 701a      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
00732d ff03          .dw $ff03
00732e 6f6e
00732f 0074          .db "not",0
007330 7325          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
007331 7000          .dw DO_COLON
                 PFA_NOT:
007332 7118          .dw XT_EQUALZERO
007333 701a          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
007334 ff02          .dw $ff02
007335 6521          .db "!e"
007336 732d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
007337 7338          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
007338 01fc          movw zl, tosl
007339 9189
00733a 9199          loadtos
00733b b72f          in_ temp2, SREG
00733c 94f8          cli
00733d d028          rcall PFA_FETCHE2
00733e b500          in_  temp0, EEDR
00733f 1708          cp temp0,tosl
007340 f009          breq PFA_STOREE3
007341 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
007342 9631          adiw zl,1
007343 d022          rcall PFA_FETCHE2
007344 b500          in_  temp0, EEDR
007345 1709          cp temp0,tosh
007346 f011          breq PFA_STOREE4
007347 2f89          mov tosl, tosh
007348 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
007349 bf2f          out_ SREG, temp2
00734a 9189
00734b 9199          loadtos
00734c ccb7          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00734d 99f9          sbic EECR, EEPE
00734e cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00734f b707          in_ temp0, SPMCSR
007350 fd00          sbrc temp0,SPMEN
007351 cffd          rjmp PFA_STOREE2
                 
007352 bdf2          out_ EEARH,zh
007353 bde1          out_ EEARL,zl
007354 bd80          out_ EEDR, tosl
007355 9afa          sbi EECR,EEMPE
007356 9af9          sbi EECR,EEPE
                 
007357 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
007358 ff02          .dw $ff02
007359 6540          .db "@e"
00735a 7334          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00735b 735c          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00735c b72f          in_ temp2, SREG
00735d 94f8          cli
00735e 01fc          movw zl, tosl
00735f d006          rcall PFA_FETCHE2
007360 b580          in_ tosl, EEDR
                 
007361 9631          adiw zl,1
                 
007362 d003          rcall PFA_FETCHE2
007363 b590          in_  tosh, EEDR
007364 bf2f          out_ SREG, temp2
007365 cc9e          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
007366 99f9          sbic EECR, EEPE
007367 cffe          rjmp PFA_FETCHE2
                 
007368 bdf2          out_ EEARH,zh
007369 bde1          out_ EEARL,zl
                 
00736a 9af8          sbi EECR,EERE
00736b 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00736c ff02          .dw $ff02
00736d 6921          .db "!i"
00736e 7358          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00736f 081a          .dw PFA_DODEFER
                 PFA_STOREI:
007370 000a          .dw EE_STOREI
007371 07de          .dw XT_EDEFERFETCH
007372 07e3          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
007373 ff09          .dw $ff09
007374 2128
007375 2d69
007376 726e
007377 7777
007378 0029          .db "(!i-nrww)",0
007379 736c          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00737a 737b          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00737b b71f        in temp1,SREG
00737c 931f        push temp1
00737d 94f8        cli
                 
00737e 019c        movw temp2, tosl ; save the (word) address
00737f 9189
007380 9199        loadtos          ; get the new value for the flash cell
007381 93af        push xl
007382 93bf        push xh
007383 93cf        push yl
007384 93df        push yh
007385 d009        rcall DO_STOREI_atmega
007386 91df        pop yh
007387 91cf        pop yl
007388 91bf        pop xh
007389 91af        pop xl
                   ; finally clear the stack
00738a 9189
00738b 9199        loadtos
00738c 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00738d bf1f        out SREG,temp1
                 
00738e cc75        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00738f d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
007390 94e0        com temp4
007391 94f0        com temp5
007392 218e        and tosl, temp4
007393 219f        and tosh, temp5
007394 2b98        or tosh, tosl
007395 f019        breq DO_STOREI_writepage 
                 
007396 01f9          movw zl, temp2
007397 e002          ldi temp0,(1<<PGERS)
007398 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
007399 01f9        movw zl, temp2
00739a e004        ldi temp0,(1<<PGWRT)
00739b d01d        rcall dospm
                 
                   ; reenable RWW section
00739c 01f9        movw zl, temp2
00739d e100        ldi temp0,(1<<RWWSRE)
00739e d01a        rcall dospm
00739f 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
0073a0 01f9        movw zl, temp2
                   ; get the beginning of page
0073a1 78e0        andi zl,low(pagemask)
0073a2 7fff        andi zh,high(pagemask)
0073a3 01ef        movw y, z
                   ; loop counter (in words)
0073a4 e8a0        ldi xl,low(pagesize)
0073a5 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
0073a6 01fe        movw z, y
0073a7 0fee
0073a8 1fff
0073a9 9145
0073aa 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
0073ab 01fe        movw z, y
0073ac 17e2        cp zl, temp2
0073ad 07f3        cpc zh, temp3
0073ae f011        breq pageload_newdata
0073af 010a          movw r0, temp6
0073b0 c002          rjmp pageload_cont
                 pageload_newdata:
0073b1 017a          movw temp4, temp6
0073b2 010c          movw r0, tosl
                 pageload_cont:
0073b3 2700        clr temp0
0073b4 d004        rcall dospm
0073b5 9621        adiw y, 1
0073b6 9711        sbiw x, 1
0073b7 f771        brne pageload_loop
                 
                 pageload_done:
0073b8 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
0073b9 99f9        sbic EECR, EEPE
0073ba cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
0073bb b717        in_  temp1, SPMCSR
0073bc fd10        sbrc temp1, SPMEN
0073bd cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
0073be 0fee
0073bf 1fff        writeflashcell
                   ; execute spm
0073c0 6001        ori temp0, (1<<SPMEN)
0073c1 bf07        out_ SPMCSR,temp0
0073c2 95e8        spm
0073c3 9508        ret
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
0073c4 ff02          .dw $ff02
0073c5 6940          .db "@i"
0073c6 7373          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
0073c7 73c8          .dw PFA_FETCHI
                 PFA_FETCHI:
0073c8 01fc          movw zl, tosl
0073c9 0fee
0073ca 1fff
0073cb 9185
0073cc 9195          readflashcell tosl,tosh
0073cd cc36          jmp_ DO_NEXT
                 ;.include "dict_interrupt.inc"
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
0073ce 0007          .dw $0007
0073cf 696c
0073d0 6574
0073d1 6172
0073d2 006c          .db "literal",0
0073d3 73c4          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0073d4 7000          .dw DO_COLON
                 PFA_LITERAL:
0073d5 01eb          .dw XT_COMPILE
0073d6 7037          .dw XT_DOLITERAL
0073d7 01f6          .dw XT_COMMA
0073d8 701a          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
0073d9 0008        .dw $0008
0073da 6c73
0073db 7469
0073dc 7265
0073dd 6c61        .db "sliteral"
0073de 73ce        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0073df 7000          .dw DO_COLON
                 PFA_SLITERAL:
0073e0 01eb          .dw XT_COMPILE
0073e1 03db          .dw XT_DOSLITERAL    ; ( -- addr n)
0073e2 03ee          .dw XT_SCOMMA
0073e3 701a          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0073e4 7000          .dw DO_COLON
                 PFA_GMARK:
0073e5 019f          .dw XT_DP
0073e6 01eb          .dw XT_COMPILE
0073e7 ffff          .dw -1           ; ffff does not erase flash
0073e8 701a          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0073e9 7000          .dw DO_COLON
                 PFA_GRESOLVE:
0073ea 078d          .dw XT_QSTACK
0073eb 019f          .dw XT_DP
0073ec 70bf          .dw XT_SWAP
0073ed 736f          .dw XT_STOREI
0073ee 701a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0073ef 7000          .dw DO_COLON
                 PFA_LMARK:
0073f0 019f          .dw XT_DP
0073f1 701a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0073f2 7000          .dw DO_COLON
                 PFA_LRESOLVE:
0073f3 078d          .dw XT_QSTACK
0073f4 01f6          .dw XT_COMMA
0073f5 701a          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
0073f6 0005          .dw $0005
0073f7 6861
0073f8 6165
0073f9 0064          .db "ahead",0
0073fa 73d9          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0073fb 7000          .dw DO_COLON
                 PFA_AHEAD:
0073fc 01eb          .dw XT_COMPILE
0073fd 7029          .dw XT_DOBRANCH
0073fe 73e4          .dw XT_GMARK
0073ff 701a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
007400 0002          .dw $0002
007401 6669          .db "if"
007402 73f6          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
007403 7000          .dw DO_COLON
                 PFA_IF:
007404 01eb          .dw XT_COMPILE
007405 7030          .dw XT_DOCONDBRANCH
007406 73e4          .dw XT_GMARK
007407 701a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
007408 0004          .dw $0004
007409 6c65
00740a 6573          .db "else"
00740b 7400          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
00740c 7000          .dw DO_COLON
                 PFA_ELSE:
00740d 01eb          .dw XT_COMPILE
00740e 7029          .dw XT_DOBRANCH
00740f 73e4          .dw XT_GMARK
007410 70bf          .dw XT_SWAP
007411 73e9          .dw XT_GRESOLVE
007412 701a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
007413 0004          .dw $0004
007414 6874
007415 6e65          .db "then"
007416 7408          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
007417 7000          .dw DO_COLON
                 PFA_THEN:
007418 73e9          .dw XT_GRESOLVE
007419 701a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
00741a 0005          .dw $0005
00741b 6562
00741c 6967
00741d 006e          .db "begin",0
00741e 7413          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00741f 7000          .dw DO_COLON
                 PFA_BEGIN:
007420 73ef          .dw XT_LMARK
007421 701a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
007422 0005          .dw $0005
007423 6877
007424 6c69
007425 0065          .db "while",0
007426 741a          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
007427 7000          .dw DO_COLON
                 PFA_WHILE:
007428 01eb          .dw XT_COMPILE
007429 7030          .dw XT_DOCONDBRANCH
00742a 73e4          .dw XT_GMARK
00742b 70bf          .dw XT_SWAP
00742c 701a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
00742d 0006          .dw $0006
00742e 6572
00742f 6570
007430 7461          .db "repeat"
007431 7422          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
007432 7000          .dw DO_COLON
                 PFA_REPEAT:
007433 7445          .dw XT_AGAIN
007434 73e9          .dw XT_GRESOLVE
007435 701a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
007436 0005          .dw $0005
007437 6e75
007438 6974
007439 006c          .db "until",0
00743a 742d          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00743b 7000          .dw DO_COLON
                 PFA_UNTIL:
00743c 01eb          .dw XT_COMPILE
00743d 7030          .dw XT_DOCONDBRANCH
00743e 73f2          .dw XT_LRESOLVE
00743f 701a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
007440 0005          .dw $0005
007441 6761
007442 6961
007443 006e          .db "again",0
007444 7436          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
007445 7000          .dw DO_COLON
                 PFA_AGAIN:
007446 01eb          .dw XT_COMPILE
007447 7029          .dw XT_DOBRANCH
007448 73f2          .dw XT_LRESOLVE
007449 701a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
00744a 0002          .dw $0002
00744b 6f64          .db "do"
00744c 7440          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
00744d 7000          .dw DO_COLON
                 PFA_DO:
00744e 01eb          .dw XT_COMPILE
00744f 7298          .dw XT_DODO
007450 73e4          .dw XT_GMARK
007451 73ef          .dw XT_LMARK
007452 701a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
007453 0004          .dw $0004
007454 6f6c
007455 706f          .db "loop"
007456 744a          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
007457 7000          .dw DO_COLON
                 PFA_LOOP:
007458 01eb          .dw XT_COMPILE
007459 72d8          .dw XT_DOLOOP
00745a 73f2          .dw XT_LRESOLVE
00745b 73e9          .dw XT_GRESOLVE
00745c 701a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
00745d 0005          .dw $0005
00745e 6c2b
00745f 6f6f
007460 0070          .db "+loop",0
007461 7453          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
007462 7000          .dw DO_COLON
                 PFA_PLUSLOOP:
007463 01eb          .dw XT_COMPILE
007464 72be          .dw XT_DOPLUSLOOP
007465 73f2          .dw XT_LRESOLVE
007466 73e9          .dw XT_GRESOLVE
007467 701a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
007468 ff05         .dw $FF05
007469 656c
00746a 7661
00746b 0065         .db "leave",0
00746c 745d         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00746d 746e          .dw PFA_LEAVE
                 PFA_LEAVE:
00746e 910f          pop temp0  ; drop limit and counter from returnstack
00746f 911f          pop temp1
007470 910f          pop temp0
007471 911f          pop temp1
007472 91af          pop xl
007473 91bf          pop xh
007474 cb8f          jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
007475 0003          .dw $0003
007476 643f
007477 006f          .db "?do",0
007478 7468          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
007479 7000          .dw DO_COLON
                 PFA_QDO:
00747a 01eb          .dw XT_COMPILE
00747b 72aa          .dw XT_DOQDO
00747c 73e4          .dw XT_GMARK
00747d 73ef          .dw XT_LMARK
00747e 701a          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
00747f ff06          .dw $ff06
007480 7263
007481 6165
007482 6574          .db "create"
007483 7475          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
007484 7000          .dw DO_COLON
                 PFA_CREATE:
007485 01c4          .dw XT_DOCREATE
007486 74b3          .dw XT_REVEAL
007487 01eb          .dw XT_COMPILE
007488 704c          .dw PFA_DOCONSTANT
007489 701a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
00748a ff06          .dw $ff06
00748b 6568
00748c 6461
00748d 7265          .db "header"
00748e 747f          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
00748f 7000          .dw DO_COLON
                 PFA_HEADER:
007490 019f          .dw XT_DP           ; the new Name Field
007491 70f3          .dw XT_TO_R
007492 70f3          .dw XT_TO_R		; ( R: NFA WID )
007493 70ac          .dw XT_DUP    
007494 715c          .dw XT_GREATERZERO 
007495 7030          .dw XT_DOCONDBRANCH
007496 74a1          .dw PFA_HEADER1
007497 70ac          .dw XT_DUP
007498 7037          .dw XT_DOLITERAL
007499 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00749a 7225          .dw XT_OR
00749b 03f2          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00749c 70ea          .dw XT_R_FROM
00749d 735b          .dw XT_FETCHE
00749e 01f6          .dw XT_COMMA
00749f 70ea          .dw XT_R_FROM
0074a0 701a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0074a1 7037          .dw XT_DOLITERAL
0074a2 fff0          .dw -16
0074a3 04a7          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0074a4 ff07          .dw $ff07
0074a5 6c77
0074a6 6373
0074a7 706f
0074a8 0065          .db "wlscope",0
0074a9 748a          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0074aa 081a          .dw PFA_DODEFER
                 PFA_WLSCOPE:
0074ab 0034          .dw EE_WLSCOPE
0074ac 07de          .dw XT_EDEFERFETCH
0074ad 07e3          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0074ae ff06          .dw $ff06
0074af 6572
0074b0 6576
0074b1 6c61          .db "reveal"
0074b2 74a4          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0074b3 7000          .dw DO_COLON
                 PFA_REVEAL:
0074b4 7037          .dw XT_DOLITERAL
0074b5 0157          .dw COLON_SMUDGE+0
0074b6 7074          .dw XT_FETCH
0074b7 70b4          .dw XT_QDUP
0074b8 7030          .dw XT_DOCONDBRANCH
0074b9 74c2          .dw PFA_REVEAL1
                 ;
0074ba 7037          .dw XT_DOLITERAL
0074bb 0159          .dw COLON_SMUDGE+2
0074bc 7074          .dw XT_FETCH		; ( NFA WID )
0074bd 7337          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
0074be 7134          .dw XT_ZERO
0074bf 7037          .dw XT_DOLITERAL
0074c0 0157          .dw COLON_SMUDGE+0
0074c1 707c          .dw XT_STORE
                 PFA_REVEAL1:
0074c2 701a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
0074c3 ff06          .dw $ff06
0074c4 616c
0074c5 6574
0074c6 7473          .db "latest"
0074c7 74ae          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0074c8 7042          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0074c9 01e9          .dw ram_LATEST
                 
                 .dseg
0001e9           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0074ca 0005          .dw $0005
0074cb 6f64
0074cc 7365
0074cd 003e          .db "does>",0
0074ce 74c3          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0074cf 7000          .dw DO_COLON
                 PFA_DOES:
0074d0 01eb          .dw XT_COMPILE
0074d1 74e1          .dw XT_DODOES
0074d2 01eb          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0074d3 940e          .dw $940e       ; the address of this compiled
0074d4 01eb          .dw XT_COMPILE  ; code will replace the XT of the 
0074d5 74d7          .dw DO_DODOES   ; word that CREATE created
0074d6 701a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0074d7 939a
0074d8 938a          savetos
0074d9 01cb          movw tosl, wl
0074da 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0074db 917f          pop wh
0074dc 916f          pop wl
                 
0074dd 93bf          push XH
0074de 93af          push XL
0074df 01db          movw XL, wl
0074e0 cb23          jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0074e1 7000          .dw DO_COLON
                 PFA_DODOES:
0074e2 70ea          .dw XT_R_FROM
0074e3 7037          .dw XT_DOLITERAL
0074e4 0159          .dw COLON_SMUDGE+2
0074e5 7074          .dw XT_FETCH
0074e6 735b          .dw XT_FETCHE
0074e7 768f          .dw XT_NFA2LFA
0074e8 7238          .dw XT_1PLUS   ; lfa>xt
                 
0074e9 736f          .dw XT_STOREI
0074ea 701a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
0074eb ff01          .dw $ff01
0074ec 003a          .db ":",0
0074ed 74ca          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0074ee 7000          .dw DO_COLON
                 PFA_COLON:
0074ef 01c4          .dw XT_DOCREATE
0074f0 019f          .dw XT_DP
0074f1 74c8          .dw XT_LATEST
0074f2 707c          .dw XT_STORE
0074f3 01eb          .dw XT_COMPILE
0074f4 7000          .dw DO_COLON
0074f5 7512          .dw XT_RBRACKET
0074f6 701a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0074f7 ff07          .dw $ff07
0074f8 6e3a
0074f9 6e6f
0074fa 6d61
0074fb 0065          .db ":noname",0
0074fc 74eb          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0074fd 7000          .dw DO_COLON
                 PFA_COLONNONAME:
0074fe 019f          .dw XT_DP
0074ff 70ac          .dw XT_DUP
007500 74c8          .dw XT_LATEST
007501 707c          .dw XT_STORE
                 
007502 01eb          .dw XT_COMPILE
007503 7000          .dw DO_COLON
                 
007504 7512          .dw XT_RBRACKET
007505 701a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
007506 0001          .dw $0001
007507 003b          .db $3b,0
007508 74f7          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
007509 7000          .dw DO_COLON
                 PFA_SEMICOLON:
00750a 01eb          .dw XT_COMPILE
00750b 701a          .dw XT_EXIT
00750c 751b          .dw XT_LBRACKET
00750d 74b3          .dw XT_REVEAL
00750e 701a          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
00750f ff01          .dw $ff01
007510 005d          .db "]",0
007511 7506          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
007512 7000          .dw DO_COLON
                 PFA_RBRACKET:
007513 7037          .dw XT_DOLITERAL
007514 0001          .dw 1
007515 013b          .dw XT_STATE
007516 707c          .dw XT_STORE
007517 701a          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
007518 0001          .dw $0001
007519 005b          .db "[",0
00751a 750f          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00751b 7000          .dw DO_COLON
                 PFA_LBRACKET:
00751c 7134          .dw XT_ZERO
00751d 013b          .dw XT_STATE
00751e 707c          .dw XT_STORE
00751f 701a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
007520 ff08          .dw $ff08
007521 6176
007522 6972
007523 6261
007524 656c          .db "variable"
007525 7518          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
007526 7000          .dw DO_COLON
                 PFA_VARIABLE:
007527 01af          .dw XT_HERE
007528 7533          .dw XT_CONSTANT
007529 7037          .dw XT_DOLITERAL
00752a 0002          .dw 2
00752b 01b8          .dw XT_ALLOT
00752c 701a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
00752d ff08          .dw $ff08
00752e 6f63
00752f 736e
007530 6174
007531 746e          .db "constant"
007532 7520          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
007533 7000          .dw DO_COLON
                 PFA_CONSTANT:
007534 01c4          .dw XT_DOCREATE
007535 74b3          .dw XT_REVEAL
007536 01eb          .dw XT_COMPILE
007537 7042          .dw PFA_DOVARIABLE
007538 01f6          .dw XT_COMMA
007539 701a          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00753a ff04          .dw $ff04
00753b 7375
00753c 7265          .db "user"
00753d 752d          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00753e 7000          .dw DO_COLON
                 PFA_USER:
00753f 01c4          .dw XT_DOCREATE
007540 74b3          .dw XT_REVEAL
                 
007541 01eb          .dw XT_COMPILE
007542 7052          .dw PFA_DOUSER
007543 01f6          .dw XT_COMMA
007544 701a          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
007545 ff05          .dw $ff05
007546 6176
007547 756c
007548 0065          .db "value",0
007549 753a          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
00754a 7000          .dw DO_COLON
                 PFA_VALUE:
00754b 7063          .dw XT_DOVALUE
00754c 01a7          .dw XT_EDP
00754d 01f6          .dw XT_COMMA
00754e 01eb          .dw XT_COMPILE
00754f 755a          .dw XT_EVALUEFETCH
007550 01eb          .dw XT_COMPILE
007551 755e          .dw XT_EVALUESTORE
007552 01a7          .dw XT_EDP
007553 70ac          .dw XT_DUP
007554 7238          .dw XT_1PLUS
007555 7238          .dw XT_1PLUS
007556 07d2          .dw XT_DOTO
007557 01a8          .dw PFA_EDP
007558 7337          .dw XT_STOREE
007559 701a          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
00755a 7000          .dw DO_COLON
                 PFA_EVALUEFETCH:
00755b 73c7          .dw XT_FETCHI
00755c 735b          .dw XT_FETCHE
00755d 701a          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
00755e 7000          .dw DO_COLON
                 PFA_EVALUESTORE:
00755f 73c7          .dw XT_FETCHI
007560 7337          .dw XT_STOREE
007561 701a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
007562 0007          .dw $0007
007563 6572
007564 7563
007565 7372
007566 0065          .db "recurse",0
007567 7545          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
007568 7000          .dw DO_COLON
                 PFA_RECURSE:
007569 74c8          .dw XT_LATEST
00756a 7074          .dw XT_FETCH
00756b 01f6          .dw XT_COMMA
00756c 701a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00756d ff09          .dw $ff09
00756e 6d69
00756f 656d
007570 6964
007571 7461
007572 0065          .db "immediate",0
007573 7562          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
007574 7000          .dw DO_COLON
                 PFA_IMMEDIATE:
007575 7651          .dw XT_GET_CURRENT
007576 735b          .dw XT_FETCHE
007577 70ac          .dw XT_DUP
007578 73c7          .dw XT_FETCHI
007579 7037          .dw XT_DOLITERAL
00757a 7fff          .dw $7fff
00757b 721c          .dw XT_AND
00757c 70bf          .dw XT_SWAP
00757d 736f          .dw XT_STOREI
00757e 701a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
00757f 0006          .dw $0006
007580 635b
007581 6168
007582 5d72          .db "[char]"
007583 756d          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
007584 7000          .dw DO_COLON
                 PFA_BRACKETCHAR:
007585 01eb          .dw XT_COMPILE
007586 7037          .dw XT_DOLITERAL
007587 052a          .dw XT_CHAR
007588 01f6          .dw XT_COMMA
007589 701a          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
00758a 0006          .dw $0006
00758b 6261
00758c 726f
00758d 2274          .db "abort", $22
00758e 757f          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
00758f 7000          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
007590 01eb          .dw XT_COMPILE
007591 7030          .dw XT_DOCONDBRANCH
007592 019f          .dw XT_DP
007593 01eb          .dw XT_COMPILE
007594 ffff          .dw -1
                     
007595 7706          .dw XT_DOTSTRING
                     
007596 01eb          .dw XT_COMPILE
007597 7037          .dw XT_DOLITERAL
                     
007598 01eb          .dw XT_COMPILE
007599 fffe          .dw -2
00759a 01eb          .dw XT_COMPILE
00759b 04a7          .dw XT_THROW
                     ; then
00759c 019f          .dw XT_DP
00759d 70bf          .dw XT_SWAP
00759e 736f          .dw XT_STOREI
00759f 701a          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
0075a0 ff05          .dw $ff05
0075a1 6261
0075a2 726f
0075a3 0074          .db "abort",0
0075a4 758a          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0075a5 7000          .dw DO_COLON
                 PFA_ABORT:
0075a6 7037          .dw XT_DOLITERAL
0075a7 ffff          .dw -1
0075a8 04a7          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
0075a9 ff04          .dw $ff04
0075aa 6f63
0075ab 6564          .db "code"
0075ac 75a0          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
0075ad 7000          .dw DO_COLON
                 PFA_CODE:
0075ae 01c4          .dw XT_DOCREATE
0075af 74b3          .dw XT_REVEAL
0075b0 019f          .dw XT_DP
0075b1 7238          .dw XT_1PLUS
0075b2 01f6          .dw XT_COMMA
0075b3 701a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
0075b4 ff08          .dw $ff08
0075b5 6e65
0075b6 2d64
0075b7 6f63
0075b8 6564          .db "end-code"
0075b9 75a9          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
0075ba 7000          .dw DO_COLON
                 PFA_ENDCODE:
0075bb 01eb          .dw XT_COMPILE
0075bc 940c          .dw $940c
0075bd 01eb          .dw XT_COMPILE
0075be 7004          .dw DO_NEXT
0075bf 701a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
0075c0 ff0b          .dw $ff0b
0075c1 6e65
0075c2 6976
0075c3 6f72
0075c4 6d6e
0075c5 6e65
0075c6 0074          .db "environment",0
0075c7 75b4          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0075c8 7042          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0075c9 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0075ca ff09          .dw $ff09
0075cb 6f77
0075cc 6472
0075cd 696c
0075ce 7473
0075cf 0073          .db "wordlists",0
0075d0 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0075d1 7000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0075d2 7037          .dw XT_DOLITERAL
0075d3 0008          .dw NUMWORDLISTS
0075d4 701a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0075d5 ff04          .dw $ff04
0075d6 702f
0075d7 6461          .db "/pad"
0075d8 75ca          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0075d9 7000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0075da 728a          .dw XT_SP_FETCH
0075db 0175          .dw XT_PAD
0075dc 719c          .dw XT_MINUS
0075dd 701a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
0075de ff05          .dw $ff05
0075df 682f
0075e0 6c6f
0075e1 0064          .db "/hold",0
0075e2 75d5          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0075e3 7000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
0075e4 0175          .dw XT_PAD
0075e5 01af          .dw XT_HERE
0075e6 719c          .dw XT_MINUS
0075e7 701a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
0075e8 ff0a          .dw $ff0a
0075e9 6f66
0075ea 7472
0075eb 2d68
0075ec 616e
0075ed 656d          .db "forth-name"
0075ee 75de          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0075ef 7000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0075f0 03db          .dw XT_DOSLITERAL
0075f1 0007          .dw 7
0075f2 6d61
0075f3 6f66
0075f4 7472
0075f5 0068          .db "amforth",0
0075f6 701a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
0075f7 ff07          .dw $ff07
0075f8 6576
0075f9 7372
0075fa 6f69
0075fb 006e          .db "version",0
0075fc 75e8          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0075fd 7000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
0075fe 7037          .dw XT_DOLITERAL
0075ff 0034          .dw 52
007600 701a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
007601 ff03          .dw $ff03
007602 7063
007603 0075          .db "cpu",0
007604 75f7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
007605 7000          .dw DO_COLON
                 PFA_EN_CPU:
007606 7037          .dw XT_DOLITERAL
007607 0041          .dw mcu_name
007608 043d          .dw XT_ICOUNT
007609 701a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00760a ff08          .dw $ff08
00760b 636d
00760c 2d75
00760d 6e69
00760e 6f66          .db "mcu-info"
00760f 7601          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
007610 7000          .dw DO_COLON
                 PFA_EN_MCUINFO:
007611 7037          .dw XT_DOLITERAL
007612 003d          .dw mcu_info
007613 701a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
007614 ff05          .dw $ff05
007615 752f
007616 6573
007617 0072          .db "/user",0
007618 760a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
007619 7000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
00761a 7037          .dw XT_DOLITERAL
00761b 0026          .dw SYSUSERSIZE + APPUSERSIZE
00761c 701a          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
00761d ff04          .dw $ff04
00761e 6540
00761f 5d5b          .db "@e[]"
007620 75c0          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
007621 7000          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
007622 70ac          .dw XT_DUP
007623 735b          .dw XT_FETCHE
007624 70f3          .dw XT_TO_R    ; save the counter to r-stack
007625 70fc          .dw XT_R_FETCH
007626 7134          .dw XT_ZERO
007627 70bf          .dw XT_SWAP    ; go from bigger to smaller addresses
007628 72aa          .dw XT_DOQDO
007629 7633          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
00762a 72bd          .dw XT_I
00762b 0148          .dw XT_CELLS ; ( -- ee-addr i*2 )
00762c 70ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
00762d 71a6          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
00762e 735b          .dw XT_FETCHE ;( -- ee-addr item_i )
00762f 70bf          .dw XT_SWAP   ;( -- item_i ee-addr )
007630 713d          .dw XT_TRUE  ; shortcut for -1
007631 72be          .dw XT_DOPLUSLOOP
007632 762a          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
007633 0161          .dw XT_2DROP
007634 70ea          .dw XT_R_FROM ; get the counter from r-stack
007635 701a          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
007636 ff04          .dw $ff04
007637 6521
007638 5d5b          .db "!e[]"
007639 761d          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
00763a 7000          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
00763b 0158          .dw XT_2DUP
00763c 7337          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00763d 70bf          .dw XT_SWAP    
00763e 7134          .dw XT_ZERO
00763f 72aa          .dw XT_DOQDO
007640 7647          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
007641 0150          .dw XT_CELLPLUS ; ( -- i_x e-addr )
007642 70bf          .dw XT_SWAP
007643 70ca          .dw XT_OVER      ; ( -- e-addr i_x e-addr
007644 7337          .dw XT_STOREE
007645 72d8          .dw XT_DOLOOP
007646 7641          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
007647 70d4          .dw XT_DROP
007648 701a          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
007649 ff0b          .dw $ff0b
00764a 6567
00764b 2d74
00764c 7563
00764d 7272
00764e 6e65
00764f 0074          .db "get-current",0
007650 7636          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
007651 7000          .dw DO_COLON
                 PFA_GET_CURRENT:
007652 7037          .dw XT_DOLITERAL
007653 0010          .dw EE_CURRENT
007654 735b          .dw XT_FETCHE
007655 701a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
007656 ff09          .dw $ff09
007657 6567
007658 2d74
007659 726f
00765a 6564
00765b 0072          .db "get-order",0
00765c 7649          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
00765d 7000          .dw DO_COLON
                 PFA_GET_ORDER:
00765e 7037          .dw XT_DOLITERAL
00765f 0014          .dw EE_ORDERLISTLEN
007660 7621          .dw XT_FETCH_EE_ARRAY
007661 701a          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
007662 ff07          .dw $ff07
007663 6f63
007664 706d
007665 7261
007666 0065          .db "compare",0
007667 7656          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
007668 7669          .dw PFA_COMPARE
                 PFA_COMPARE:
007669 93bf          push xh
00766a 93af          push xl
00766b 018c          movw temp0, tosl
00766c 9189
00766d 9199          loadtos
00766e 01dc          movw xl, tosl
00766f 9189
007670 9199          loadtos
007671 019c          movw temp2, tosl
007672 9189
007673 9199          loadtos
007674 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
007675 90ed          ld temp4, X+
007676 90f1          ld temp5, Z+
007677 14ef          cp temp4, temp5
007678 f451          brne PFA_COMPARE_NOTEQUAL
007679 950a          dec temp0
00767a f019          breq PFA_COMPARE_ENDREACHED2
00767b 952a          dec temp2
00767c f7c1          brne PFA_COMPARE_LOOP
00767d c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00767e 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
00767f 2b02          or temp0, temp2
007680 f411          brne PFA_COMPARE_CHECKLASTCHAR
007681 2788          clr tosl
007682 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
007683 ef8f          ser tosl
007684 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
007685 2f98          mov tosh, tosl
007686 91af          pop xl
007687 91bf          pop xh
007688 c97b          jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
007689 ff07         .dw $ff07
00768a 666e
00768b 3e61
00768c 666c
00768d 0061         .db "nfa>lfa",0
00768e 7662         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
00768f 7000          .dw DO_COLON
                 PFA_NFA2LFA:
007690 043d          .dw XT_ICOUNT 
007691 7037          .dw XT_DOLITERAL
007692 00ff          .dw $00ff
007693 721c          .dw XT_AND
007694 7238          .dw XT_1PLUS
007695 720d          .dw XT_2SLASH
007696 71a6          .dw XT_PLUS
007697 701a          .dw XT_EXIT
                 ;.include "dict_usart.inc"
                 ;.include "dict_wl.inc"
                 ;.include "dict_mcu.inc"
                 ;.include "dict_minimum.inc"
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
007698 ff04          .dw $ff04
007699 6966
00769a 6c6c          .db "fill"
00769b 7689          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00769c 7000          .dw DO_COLON
                 PFA_FILL:
00769d 70dc          .dw XT_ROT
00769e 70dc          .dw XT_ROT
00769f 7134          .dw XT_ZERO
0076a0 72aa          .dw XT_DOQDO
0076a1 76a7          .dw PFA_FILL2
                 PFA_FILL1:
0076a2 0158          .dw XT_2DUP
0076a3 7088          .dw XT_CSTORE  ; ( -- c c-addr)
0076a4 7238          .dw XT_1PLUS
0076a5 72d8          .dw XT_DOLOOP
0076a6 76a2          .dw PFA_FILL1
                 PFA_FILL2:
0076a7 70d4          .dw XT_DROP
0076a8 70d4          .dw XT_DROP
0076a9 701a          .dw XT_EXIT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
0076aa ff03          .dw $ff03
0076ab 3264
0076ac 002a          .db "d2*",0
0076ad 7698          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
0076ae 76af          .dw PFA_D2STAR
                 PFA_D2STAR:
0076af 9109          ld temp0, Y+
0076b0 9119          ld temp1, Y+
0076b1 0f00          lsl temp0
0076b2 1f11          rol temp1
0076b3 1f88          rol tosl
0076b4 1f99          rol tosh
0076b5 931a          st -Y, temp1
0076b6 930a          st -Y, temp0
0076b7 c94c          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
0076b8 ff02          .dw $ff02
0076b9 2b64          .db "d+"
0076ba 76aa          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
0076bb 76bc          .dw PFA_DPLUS
                 PFA_DPLUS:
0076bc 9129          ld temp2, Y+
0076bd 9139          ld temp3, Y+
                 
0076be 90e9          ld temp4, Y+
0076bf 90f9          ld temp5, Y+
0076c0 9149          ld temp6, Y+
0076c1 9159          ld temp7, Y+
                 
0076c2 0f24          add temp2, temp6
0076c3 1f35          adc temp3, temp7
0076c4 1d8e          adc tosl, temp4
0076c5 1d9f          adc tosh, temp5
                     
0076c6 933a          st -Y, temp3
0076c7 932a          st -Y, temp2
0076c8 c93b          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
0076c9 ff02          .dw $ff02
0076ca 2d64          .db "d-"
0076cb 76b8          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
0076cc 76cd          .dw PFA_DMINUS
                 PFA_DMINUS:
0076cd 9129          ld temp2, Y+
0076ce 9139          ld temp3, Y+
                 
0076cf 90e9          ld temp4, Y+
0076d0 90f9          ld temp5, Y+
0076d1 9149          ld temp6, Y+
0076d2 9159          ld temp7, Y+
                 
0076d3 1b42          sub temp6, temp2
0076d4 0b53          sbc temp7, temp3
0076d5 0ae8          sbc temp4, tosl
0076d6 0af9          sbc temp5, tosh
                 
0076d7 935a          st -Y, temp7
0076d8 934a          st -Y, temp6
0076d9 01c7          movw tosl, temp4
0076da c929          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0076db ff07          .dw $ff07
0076dc 6964
0076dd 766e
0076de 7265
0076df 0074          .db "dinvert",0
0076e0 76c9          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0076e1 76e2          .dw PFA_DINVERT
                 PFA_DINVERT:
0076e2 9109          ld temp0, Y+
0076e3 9119          ld temp1, Y+
0076e4 9580          com tosl
0076e5 9590          com tosh
0076e6 9500          com temp0
0076e7 9510          com temp1
0076e8 931a          st -Y, temp1
0076e9 930a          st -Y, temp0
0076ea c919          jmp_ DO_NEXT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
0076eb ff02          .dw $ff02
0076ec 2e75          .db "u."
0076ed 76db          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0076ee 7000          .dw DO_COLON
                 PFA_UDOT:
0076ef 7134          .dw XT_ZERO
0076f0 0380          .dw XT_UDDOT
0076f1 701a          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
0076f2 ff02          .dw $ff02
0076f3 732e          .db ".s"
0076f4 76eb          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
0076f5 7000          .dw DO_COLON
                 PFA_DOTS:
0076f6 06ee          .dw XT_SP0
0076f7 728a          .dw XT_SP_FETCH
0076f8 0150          .dw XT_CELLPLUS
0076f9 72aa          .dw XT_DOQDO
0076fa 7702          .dw PFA_DOTS2
                 PFA_DOTS1:
0076fb 72bd          .dw XT_I
0076fc 7074          .dw XT_FETCH 
0076fd 76ee          .dw XT_UDOT
0076fe 7037          .dw XT_DOLITERAL
0076ff 0002          .dw 2
007700 72be          .dw XT_DOPLUSLOOP
007701 76fb          .dw PFA_DOTS1
                 PFA_DOTS2:
007702 701a          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
007703 0002          .dw $0002
007704 222e          .db ".",$22
007705 76f2          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
007706 7000          .dw DO_COLON
                 PFA_DOTSTRING:
007707 770e          .dw XT_SQUOTE
007708 01eb          .dw XT_COMPILE
007709 0412          .dw XT_ITYPE
00770a 701a          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
00770b 0002        .dw $0002
00770c 2273        .db "s",$22
00770d 7703        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00770e 7000          .dw DO_COLON
                 PFA_SQUOTE:
00770f 7037          .dw XT_DOLITERAL
007710 0022          .dw $22
007711 05e8          .dw XT_PARSE       ; ( -- addr n)
007712 013b          .dw XT_STATE
007713 7074          .dw XT_FETCH
007714 7030          .dw XT_DOCONDBRANCH
007715 7719          .dw PFA_SQUOTE1
007716 01eb            .dw XT_COMPILE
007717 03db            .dw XT_DOSLITERAL    ; ( -- addr n)
007718 03ee            .dw XT_SCOMMA
                 PFA_SQUOTE1:
007719 701a          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
00771a ff06          .dw $ff06
00771b 6445
00771c 6665
00771d 7265          .db "Edefer"
00771e 770b          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
00771f 7000          .dw DO_COLON
                 PFA_EDEFER:
007720 01c4          .dw XT_DOCREATE
007721 74b3          .dw XT_REVEAL
007722 01eb          .dw XT_COMPILE
007723 081a          .dw PFA_DODEFER
                 
007724 01a7          .dw XT_EDP
007725 70ac          .dw XT_DUP
007726 01f6          .dw XT_COMMA
007727 01eb          .dw XT_COMPILE
007728 07de          .dw XT_EDEFERFETCH
007729 01eb          .dw XT_COMPILE
00772a 07e3          .dw XT_EDEFERSTORE
00772b 0150          .dw XT_CELLPLUS
00772c 07d2          .dw XT_DOTO
00772d 01a8          .dw PFA_EDP
00772e 701a          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
00772f ff06          .dw $ff06
007730 6452
007731 6665
007732 7265          .db "Rdefer"
007733 771a          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
007734 7000          .dw DO_COLON
                 PFA_RDEFER:
007735 01c4          .dw XT_DOCREATE
007736 74b3          .dw XT_REVEAL
                 
007737 01eb          .dw XT_COMPILE
007738 081a          .dw PFA_DODEFER
                 
007739 01af          .dw XT_HERE
00773a 01f6          .dw XT_COMMA
00773b 7037          .dw XT_DOLITERAL
00773c 0002          .dw 2
00773d 01b8          .dw XT_ALLOT
                 
00773e 01eb          .dw XT_COMPILE
00773f 07e8          .dw XT_RDEFERFETCH
007740 01eb          .dw XT_COMPILE
007741 07ed          .dw XT_RDEFERSTORE
007742 701a          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
007743 0002          .dw $0002
007744 7369          .db "is"
007745 772f          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
007746 7000          .dw DO_COLON
                 PFA_IS:
007747 013b          .dw XT_STATE
007748 7074          .dw XT_FETCH
007749 7030          .dw XT_DOCONDBRANCH
00774a 774f          .dw PFA_IS1
00774b 0202          .dw XT_BRACKETTICK
00774c 01eb          .dw XT_COMPILE
00774d 0805          .dw XT_DEFERSTORE
00774e 701a          .dw XT_EXIT
                 PFA_IS1:
00774f 047a          .dw XT_TICK
007750 0805          .dw XT_DEFERSTORE
007751 701a          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
007752 ff0b          .dw $ff0b
007753 7061
007754 6c70
007755 7574
007756 6e72
007757 656b
007758 0079          .db "applturnkey",0
007759 7743          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
00775a 7000          .dw DO_COLON
                 PFA_APPLTURNKEY:
00775b 00ba          .dw XT_USART
00775c 00e2          .dw XT_INTON
00775d 079a          .dw XT_VER
00775e 0453          .dw XT_SPACE
00775f 03db          .dw XT_DOSLITERAL
007760 000a          .dw 10
007761 6f46
007762 7472
007763 6468
007764 6975
007765 6f6e          .db "Forthduino"
007766 0412          .dw XT_ITYPE
                 
007767 701a          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
007768 ff03          .dw $ff03
007769 6d31
00776a 0073          .db "1ms",0
00776b 7752          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
00776c 776d          .dw PFA_1MS
                 PFA_1MS:
00776d eae0
00776e e0ff
00776f 9731
007770 f7f1          delay 1000
007771 c892          jmp_ DO_NEXT
                 .include "words/ms.asm"
                 
                 ; Time
                 ; busy waits the specified amount of milliseconds
                 VE_MS:
007772 ff02          .dw $ff02
007773 736d          .db "ms"
007774 7768          .dw VE_HEAD
                     .set VE_HEAD = VE_MS
                 XT_MS:
007775 7000          .dw DO_COLON
                 PFA_MS:
007776 7134          .dw XT_ZERO
007777 72aa          .dw XT_DOQDO
007778 777c          .dw PFA_MS2
                 PFA_MS1:
007779 776c          .dw XT_1MS
00777a 72d8          .dw XT_DOLOOP
00777b 7779          .dw PFA_MS1
                 PFA_MS2:
00777c 701a          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
00777d ff0d          .dw $ff0d
00777e 6873
00777f 776f
007780 772d
007781 726f
007782 6c64
007783 7369
007784 0074          .db "show-wordlist",0
007785 7772          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
007786 7000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
007787 7037          .dw XT_DOLITERAL
007788 778c          .dw XT_SHOWWORD
007789 70bf          .dw XT_SWAP
00778a 0874          .dw XT_TRAVERSEWORDLIST
00778b 701a          .dw XT_EXIT
                 
                 XT_SHOWWORD:
00778c 7000          .dw DO_COLON
                 PFA_SHOWWORD:
00778d 0863          .dw XT_NAME2STRING
00778e 0412          .dw XT_ITYPE
00778f 0453          .dw XT_SPACE         ; ( -- addr n)
007790 713d          .dw XT_TRUE
007791 701a          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
007792 ff05          .dw $ff05
007793 6f77
007794 6472
007795 0073          .db "words",0
007796 777d          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
007797 7000          .dw DO_COLON
                 PFA_WORDS:
007798 7037          .dw XT_DOLITERAL
007799 0016          .dw EE_ORDERLIST
00779a 735b          .dw XT_FETCHE
00779b 7786          .dw XT_SHOWWORDLIST
00779c 701a          .dw XT_EXIT
                 ;.include "device.inc"
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 6e 09         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 eb 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 5a 77         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 7a 73         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 14 76         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 92 77         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 66 07         .dw XT_REC_FIND
00002a 49 07         .dw XT_REC_INTNUMBER
00002c 82 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 51 76         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 10         .dw rstackstart  ; USER_RP
00003e af 10         .dw stackstart   ; USER_SP0
000040 af 10         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 96 00         .dw XT_TX  ; USER_EMIT
000048 a4 00         .dw XT_TXQ ; USER_EMITQ
00004a 6c 00         .dw XT_RX  ; USER_KEY
00004c 86 00         .dw XT_RXQ ; USER_KEYQ
00004e 33 09         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 1f 09         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 67 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 24
000058 f4 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega644P" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  76 r17:  57 r18:  58 r19:  42 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 164 r25: 117 r26:  45 r27:  22 r28:   6 r29:   4 r30:  66 r31:  33 
x  :   4 y  : 181 z  :  42 
Registers used: 29 out of 35 (82.9%)

"ATmega644P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :   9 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  11 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   2 jmp   :  14 
ld    : 127 ldd   :   4 ldi   :  22 lds   :   2 lpm   :  20 lsl   :  16 
lsr   :   1 mov   :  10 movw  :  64 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  48 
push  :  34 rcall :  43 ret   :   6 reti  :   2 rjmp  :  95 rol   :  25 
ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  58 std   :   8 sts   :   3 
sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega644P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00ef3a   1802  10768  12570   65536  19.2%
[.dseg] 0x000100 0x0001eb      0    235    235    4096   5.7%
[.eseg] 0x000000 0x00005a      0     90     90    2048   4.4%

Assembly complete, 0 errors, 2 warnings
