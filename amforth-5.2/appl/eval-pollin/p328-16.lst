
AVRASM ver. 2.1.51  p328-16.asm Mon Dec 23 20:35:27 2013

p328-16.asm(2): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
p328-16.asm(3): Including file '../../core/devices/atmega328p\device.asm'
../../core/devices/atmega328p\device.asm(5): Including file '../../Atmel/Appnotes2\m328Pdef.inc'
p328-16.asm(12): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
p328-16.asm(18): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(4): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(5): Including file '../../core\dict_wl.inc'
../../core\dict_wl.inc(2): Including file '../../core\words/set-current.asm'
../../core\dict_wl.inc(3): Including file '../../core\words/previous.asm'
../../core\dict_wl.inc(4): Including file '../../core\words/definitions.asm'
../../core\dict_wl.inc(5): Including file '../../core\words/wordlist.asm'
../../core\dict_wl.inc(7): Including file '../../core\words/only.asm'
../../core\dict_wl.inc(8): Including file '../../core\words/forth.asm'
../../core\dict_wl.inc(9): Including file '../../core\words/forth-wordlist.asm'
../../core\dict_wl.inc(10): Including file '../../core\words/also.asm'
../../core\dict_wl.inc(11): Including file '../../core\words/set-order.asm'
../../core\dict_wl.inc(12): Including file '../../core\words/order.asm'
dict_appl.inc(8): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(10): Including file '../../core\words/d-2star.asm'
dict_appl.inc(11): Including file '../../core\words/d-plus.asm'
dict_appl.inc(12): Including file '../../core\words/d-minus.asm'
dict_appl.inc(13): Including file '../../core\words/d-invert.asm'
dict_appl.inc(14): Including file '../../core\words/d-equal.asm'
dict_appl.inc(15): Including file '../../core\words/udot.asm'
dict_appl.inc(16): Including file '../../core\words/udotr.asm'
dict_appl.inc(17): Including file '../../core\words/dot-s.asm'
dict_appl.inc(19): Including file '../../core\words/dotstring.asm'
dict_appl.inc(20): Including file '../../core\words/squote.asm'
dict_appl.inc(22): Including file '../../core\words/edefer.asm'
dict_appl.inc(23): Including file '../../core\words/rdefer.asm'
dict_appl.inc(24): Including file '../../core\words/is.asm'
dict_appl.inc(26): Including file 'words/applturnkey.asm'
dict_appl.inc(28): Including file '../../core\words/fill.asm'
dict_appl.inc(30): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(31): Including file '../../core\words/words.asm'
dict_appl.inc(33): Including file '../../core\words/1ms.asm'
dict_appl.inc(34): Including file '../../core\words/2literal.asm'
dict_appl.inc(35): Including file '../../core/devices/atmega328p\device.inc'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/n_to_r.asm'
dict_appl_core.inc(9): Including file '../../core\words/n_r_from.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0c4      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0c2      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0c0      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 8
000008 d0be      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d0bc      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d0ba      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 14
00000e d0b8      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 16
000010 d0b6      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 18
000012 d0b4      	 rcall isr ; Timer/Counter2 Overflow
                 .org 20
000014 d0b2      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 22
000016 d0b0      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 24
000018 d0ae      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 26
00001a d0ac      	 rcall isr ; Timer/Counter1 Overflow
                 .org 28
00001c d0aa      	 rcall isr ; TimerCounter0 Compare Match A
                 .org 30
00001e d0a8      	 rcall isr ; TimerCounter0 Compare Match B
                 .org 32
000020 d0a6      	 rcall isr ; Timer/Couner0 Overflow
                 .org 34
000022 d0a4      	 rcall isr ; SPI Serial Transfer Complete
                 .org 36
000024 d0a2      	 rcall isr ; USART Rx Complete
                 .org 38
000026 d0a0      	 rcall isr ; USART, Data Register Empty
                 .org 40
000028 d09e      	 rcall isr ; USART Tx Complete
                 .org 42
00002a d09c      	 rcall isr ; ADC Conversion Complete
                 .org 44
00002c d09a      	 rcall isr ; EEPROM Ready
                 .org 46
00002e d098      	 rcall isr ; Analog Comparator
                 .org 48
000030 d096      	 rcall isr ; Two-wire Serial Interface
                 .org 50
000032 d094      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 26
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ SPMEN = SELFPRGEN
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000033 0800      	.dw 2048
                 mcu_eepromsize:
000034 0400      	.dw 1024
                 mcu_maxdp:
000035 7000      	.dw 28672 
                 mcu_numints:
000036 001a      	.dw 26
                 mcu_name:
000037 000a      	.dw 10
000038 5441
000039 656d
00003a 6167
00003b 3233
00003c 5038      	.db "ATmega328P"
                 .set codestart=pc
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64    ; 80 characters is one line...
                 .equ APPUSERSIZE = 10  ; size of user area
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 ; baud rate of terminal
                 .equ BAUD = 9600
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000024 940c 003d   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00003d 93af        push xl
00003e b7af        in xl, SREG
00003f 93af        push xl
000040 93bf        push xh
000041 93ef        push zl
000042 93ff        push zh
                 
000043 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
000045 91a0 0100   lds xl,usart_rx_in
000047 e0e2        ldi zl, low(usart_rx_data)
000048 e0f1        ldi zh, high(usart_rx_data)
000049 0fea        add zl, xl
00004a 1df3        adc zh, zeroh
00004b 83b0        st Z, xh
                 
00004c 95a3        inc xl
00004d 70af        andi xl,usart_rx_mask
                 
00004e 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000050 91ff        pop zh
000051 91ef        pop zl
000052 91bf        pop xh
000053 91af        pop xl
000054 bfaf        out SREG, xl
000055 91af        pop xl
000056 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000057 3800        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000058 3934        .dw XT_ZERO
000059 3837        .dw XT_DOLITERAL
00005a 0100        .dw usart_rx_in
00005b 387c        .dw XT_STORE
                 
00005c 381a        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00005d ff06          .dw $ff06
00005e 7872
00005f 692d
000060 7273          .db "rx-isr"
000061 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000062 3800          .dw DO_COLON
                 PFA_RX_ISR:
000063 007c        .dw XT_RXQ_ISR
000064 3830        .dw XT_DOCONDBRANCH
000065 0063        .dw PFA_RX_ISR
000066 3837        .dw XT_DOLITERAL
000067 0101        .dw usart_rx_out
000068 3893        .dw XT_CFETCH
000069 38ac        .dw XT_DUP
00006a 3a38        .dw XT_1PLUS
00006b 3837        .dw XT_DOLITERAL
00006c 000f        .dw usart_rx_mask
00006d 3a1c        .dw XT_AND
00006e 3837        .dw XT_DOLITERAL
00006f 0101        .dw usart_rx_out
000070 3888        .dw XT_CSTORE
000071 3837        .dw XT_DOLITERAL
000072 0102        .dw usart_rx_data
000073 39a6        .dw XT_PLUS
000074 3893        .dw XT_CFETCH
000075 381a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000076 ff07          .dw $ff07
000077 7872
000078 2d3f
000079 7369
00007a 0072          .db "rx?-isr",0
00007b 005d          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
00007c 3800          .dw DO_COLON
                 PFA_RXQ_ISR:
00007d 0671        .dw XT_PAUSE
00007e 3837        .dw XT_DOLITERAL
00007f 0101        .dw usart_rx_out
000080 3893        .dw XT_CFETCH
000081 3837        .dw XT_DOLITERAL
000082 0100        .dw usart_rx_in
000083 3893        .dw XT_CFETCH
000084 3907        .dw XT_NOTEQUAL
000085 381a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000086 ff07          .dw $ff07
000087 7874
000088 702d
000089 6c6f
00008a 006c          .db "tx-poll",0
00008b 0076          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
00008c 3800          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
00008d 009a        .dw XT_TXQ_POLL
00008e 3830        .dw XT_DOCONDBRANCH
00008f 008d        .dw PFA_TX_POLL
                   ; send to usart
000090 3837        .dw XT_DOLITERAL
000091 00c6        .dw USART_DATA
000092 3888        .dw XT_CSTORE
000093 381a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000094 ff08          .dw $ff08
000095 7874
000096 2d3f
000097 6f70
000098 6c6c          .db "tx?-poll"
000099 0086          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
00009a 3800          .dw DO_COLON
                 PFA_TXQ_POLL:
00009b 0671        .dw XT_PAUSE
00009c 3837        .dw XT_DOLITERAL
00009d 00c0        .dw USART_A
00009e 3893        .dw XT_CFETCH
00009f 3837        .dw XT_DOLITERAL
0000a0 0020        .dw bm_USART_TXRD
0000a1 3a1c        .dw XT_AND
0000a2 381a        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000a3 ff04        .dw $ff04
0000a4 6275
0000a5 7272        .db "ubrr"
0000a6 0094        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000a7 3869        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000a8 0054        .dw EE_UBRRVAL
0000a9 0aa6        .dw XT_EVALUEFETCH
0000aa 0aaa        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000ab ff06        .dw $ff06
0000ac 752b
0000ad 6173
0000ae 7472        .db "+usart"
0000af 00a3        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000b0 3800        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000b1 3837        .dw XT_DOLITERAL
0000b2 0098        .dw USART_B_VALUE
0000b3 3837        .dw XT_DOLITERAL
0000b4 00c1        .dw USART_B
0000b5 3888        .dw XT_CSTORE
                 
0000b6 3837        .dw XT_DOLITERAL
0000b7 0006        .dw USART_C_VALUE
0000b8 3837        .dw XT_DOLITERAL
0000b9 00c2        .dw USART_C | bm_USARTC_en
0000ba 3888        .dw XT_CSTORE
                 
0000bb 00a7        .dw XT_UBRR
0000bc 38ac        .dw XT_DUP
0000bd 3b0e        .dw XT_BYTESWAP
0000be 3837        .dw XT_DOLITERAL
0000bf 00c5        .dw BAUDRATE_HIGH
0000c0 3888        .dw XT_CSTORE
0000c1 3837        .dw XT_DOLITERAL
0000c2 00c4        .dw BAUDRATE_LOW
0000c3 3888        .dw XT_CSTORE
                 
0000c4 0057        .dw XT_USART_INIT_RX
0000c5 076b        .dw XT_USART_INIT_TX
0000c6 381a        .dw XT_EXIT
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 .set NUMWORDLISTS = 8
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 067a   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000c7 920a          st -Y, r0
0000c8 b60f          in r0, SREG
0000c9 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000ca 900f          pop r0
0000cb 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000cc 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000cd 9200 0114     sts intcur, r0
0000cf 9009          ld r0, Y+
0000d0 be0f          out SREG, r0
0000d1 9009          ld r0, Y+
0000d2 9468          set ; set the interrupt flag for the inner interpreter
0000d3 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
0000d4 ff05          .dw $ff05
0000d5 5f66
0000d6 7063
0000d7 0075          .db "f_cpu",0
0000d8 00ab          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0000d9 3869          .dw PFA_DOVALUE1
                 PFA_F_CPU:
0000da 0056          .dw EE_FCPU
0000db 00dd          .dw XT_FETCH2E
0000dc 00e6          .dw XT_STORE2E
                 
                 XT_FETCH2E:
0000dd 3800          .dw DO_COLON
                 PFA_FETCH2E:
0000de 3b6f          .dw XT_FETCHI
0000df 38ac          .dw XT_DUP
0000e0 0104          .dw XT_CELLPLUS
0000e1 3b5b          .dw XT_FETCHE
0000e2 38bf          .dw XT_SWAP
0000e3 3b5b          .dw XT_FETCHE
0000e4 38bf          .dw XT_SWAP
0000e5 381a          .dw XT_EXIT
                 
                 XT_STORE2E:
0000e6 3800          .dw DO_COLON
                 PFA_STORE2E:
0000e7 3837          .dw XT_DOLITERAL
0000e8 ffeb          .dw -21
0000e9 045b          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0000ea ff05          .dw $ff05
0000eb 7473
0000ec 7461
0000ed 0065          .db "state",0
0000ee 00d4          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0000ef 3842          .dw PFA_DOVARIABLE
                 PFA_STATE:
0000f0 0149          .dw ram_state
                 
                 .dseg
000149           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
0000f1 ff04          .dw $ff04
0000f2 6162
0000f3 6573          .db "base"
0000f4 00ea          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0000f5 3852          .dw PFA_DOUSER
                 PFA_BASE:
0000f6 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0000f7 ff05          .dw $ff05
0000f8 6563
0000f9 6c6c
0000fa 0073          .db "cells",0
0000fb 00f1          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0000fc 3800          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
0000fd 3a14          .dw XT_2STAR
                 .else
                 .endif
0000fe 381a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0000ff ff05          .dw $ff05
000100 6563
000101 6c6c
000102 002b          .db "cell+",0
000103 00f7          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000104 0105          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000105 9602          adiw tosl, CELLSIZE
000106 940c 3804     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
000108 ff04          .dw $ff04
000109 6432
00010a 7075          .db "2dup"
00010b 00ff          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00010c 3800          .dw DO_COLON
                 PFA_2DUP:
00010d 38ca          .dw XT_OVER
00010e 38ca          .dw XT_OVER
00010f 381a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
000110 ff05          .dw $ff05
000111 6432
000112 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
000113 0070          .db "2drop"
000114 0108          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000115 3800          .dw DO_COLON
                 PFA_2DROP:
000116 38d4          .dw XT_DROP
000117 38d4          .dw XT_DROP
000118 381a          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
000119 ff03          .dw $ff03
00011a 693e
00011b 006e          .db ">in",0
00011c 0110          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
00011d 3852          .dw PFA_DOUSER
                 PFA_G_IN:
00011e 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
00011f ff04          .dw $ff04
000120 7423
000121 6269          .db "#tib"
000122 0119          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000123 3842          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000124 014b          .dw ram_sharptib
                 
                 .dseg
00014b           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000125 ff03          .dw $ff03
000126 6170
000127 0064          .db "pad",0
000128 011f          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
000129 3800          .dw DO_COLON
                 PFA_PAD:
00012a 0163          .dw XT_HERE
00012b 3837          .dw XT_DOLITERAL
00012c 0064          .dw 100
00012d 39a6          .dw XT_PLUS
00012e 381a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
00012f ff04          .dw $ff04
000130 6d65
000131 7469          .db "emit"
000132 0125          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000133 07ce          .dw PFA_DODEFER
                 PFA_EMIT:
000134 000e          .dw USER_EMIT
000135 07a6          .dw XT_UDEFERFETCH
000136 07ad          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
000137 ff05          .dw $ff05
000138 6d65
000139 7469
00013a 003f          .db "emit?",0
00013b 012f          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00013c 07ce          .dw PFA_DODEFER
                 PFA_EMITQ:
00013d 0010          .dw USER_EMITQ
00013e 07a6          .dw XT_UDEFERFETCH
00013f 07ad          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
000140 ff03          .dw $ff03
000141 656b
000142 0079          .db "key",0
000143 0137          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000144 07ce          .dw PFA_DODEFER
                 PFA_KEY:
000145 0012          .dw USER_KEY
000146 07a6          .dw XT_UDEFERFETCH
000147 07ad          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
000148 ff04          .dw $ff04
000149 656b
00014a 3f79          .db "key?"
00014b 0140          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00014c 07ce          .dw PFA_DODEFER
                 PFA_KEYQ:
00014d 0014          .dw USER_KEYQ
00014e 07a6          .dw XT_UDEFERFETCH
00014f 07ad          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000150 ff02          .dw $ff02
000151 7064          .db "dp"
000152 0148          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000153 3869          .dw PFA_DOVALUE1
                 PFA_DP:
000154 0002          .dw EE_DP
000155 0aa6          .dw XT_EVALUEFETCH
000156 0aaa          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
000157 ff03          .dw $ff03
000158 6465
000159 0070          .db "edp",0
00015a 0150          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
00015b 3869          .dw PFA_DOVALUE1
                 PFA_EDP:
00015c 0006          .dw EE_EDP
00015d 0aa6          .dw XT_EVALUEFETCH
00015e 0aaa          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00015f ff04          .dw $ff04
000160 6568
000161 6572          .db "here"
000162 0157          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000163 3869          .dw PFA_DOVALUE1
                 PFA_HERE:
000164 0004          .dw EE_HERE
000165 0aa6          .dw XT_EVALUEFETCH
000166 0aaa          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000167 ff05          .dw $ff05
000168 6c61
000169 6f6c
00016a 0074          .db "allot",0
00016b 015f          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00016c 3800          .dw DO_COLON
                 PFA_ALLOT:
00016d 0163          .dw XT_HERE
00016e 39a6          .dw XT_PLUS
00016f 0786          .dw XT_DOTO
000170 0164          .dw PFA_HERE
000171 381a          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000172 ff08          .dw $ff08
000173 6328
000174 6572
000175 7461
000176 2965          .db "(create)"
000177 0167          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000178 3800          .dw DO_COLON
                 PFA_DOCREATE:
000179 05eb          .dw XT_PARSENAME
00017a 09f5          .dw XT_WLSCOPE
00017b 38ac          .dw XT_DUP
00017c 38f3          .dw XT_TO_R
00017d 09da          .dw XT_HEADER
00017e 38ea          .dw XT_R_FROM
                 .dseg
00014d           COLON_SMUDGE: .byte 4
                 .cseg
00017f 3837          .dw XT_DOLITERAL
000180 014f          .dw COLON_SMUDGE+2
000181 387c          .dw XT_STORE		; save wid
000182 3837          .dw XT_DOLITERAL
000183 014d          .dw COLON_SMUDGE+0
000184 387c          .dw XT_STORE		; save NFA
                 
000185 381a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
000186 0001          .dw $0001
000187 005c          .db "\",0
000188 0172          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000189 3800          .dw DO_COLON
                 PFA_BACKSLASH:
00018a 05d0          .dw XT_SOURCE
00018b 38bf          .dw XT_SWAP
00018c 38d4          .dw XT_DROP
00018d 011d          .dw XT_G_IN
00018e 387c          .dw XT_STORE
00018f 381a          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
000190 0001          .dw $0001
000191 0028          .db "(" ,0
000192 0186          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
000193 3800          .dw DO_COLON
                 PFA_LPARENTHESIS:
000194 3837          .dw XT_DOLITERAL
000195 0029          .dw $29
000196 059c          .dw XT_PARSE
000197 0115          .dw XT_2DROP
000198 381a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
000199 ff07          .dw $ff07
00019a 6f63
00019b 706d
00019c 6c69
00019d 0065          .db "compile",0
00019e 0190          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
00019f 3800          .dw DO_COLON
                 PFA_COMPILE:
0001a0 38ea          .dw XT_R_FROM
0001a1 38ac          .dw XT_DUP
0001a2 3a38          .dw XT_1PLUS
0001a3 38f3          .dw XT_TO_R
0001a4 3b6f          .dw XT_FETCHI
0001a5 01aa          .dw XT_COMMA
0001a6 381a          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001a7 ff01          .dw $ff01
0001a8 002c          .db ',',0 ; ,
0001a9 0199          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001aa 3800          .dw DO_COLON
                 PFA_COMMA:
0001ab 0153          .dw XT_DP
0001ac 3b79          .dw XT_STOREI
0001ad 0153          .dw XT_DP
0001ae 3a38          .dw XT_1PLUS
0001af 0786          .dw XT_DOTO
0001b0 0154          .dw PFA_DP
0001b1 381a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0001b2 0003          .dw $0003
0001b3 275b
0001b4 005d          .db "[']",0
0001b5 01a7          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001b6 3800          .dw DO_COLON
                 PFA_BRACKETTICK:
0001b7 019f          .dw XT_COMPILE
0001b8 3837          .dw XT_DOLITERAL
0001b9 042e          .dw XT_TICK
0001ba 01aa          .dw XT_COMMA
0001bb 381a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
0001bc ff03          .dw $ff03
0001bd 6962
0001be 006e          .db "bin",0
0001bf 01b2          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0001c0 3800          .dw DO_COLON
                 PFA_BIN:
0001c1 3837          .dw XT_DOLITERAL
0001c2 0002          .dw 2
0001c3 00f5          .dw XT_BASE
0001c4 387c          .dw XT_STORE
0001c5 381a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
0001c6 ff07          .dw $ff07
0001c7 6564
0001c8 6963
0001c9 616d
0001ca 006c          .db "decimal",0
0001cb 01bc          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0001cc 3800          .dw DO_COLON
                 PFA_DECIMAL:
0001cd 3837          .dw XT_DOLITERAL
0001ce 000a          .dw 10
0001cf 00f5          .dw XT_BASE
0001d0 387c          .dw XT_STORE
0001d1 381a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
0001d2 ff03          .dw $ff03
0001d3 6568
0001d4 0078          .db "hex",0
0001d5 01c6          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0001d6 3800          .dw DO_COLON
                 PFA_HEX:
0001d7 3837          .dw XT_DOLITERAL
0001d8 0010          .dw 16
0001d9 00f5          .dw XT_BASE
0001da 387c          .dw XT_STORE
0001db 381a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
0001dc ff02          .dw $ff02
0001dd 6c62          .db "bl"
0001de 01d2          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0001df 3842          .dw PFA_DOVARIABLE
                 PFA_BL:
0001e0 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0001e1 ff07          .dw $ff07
0001e2 7574
0001e3 6e72
0001e4 656b
0001e5 0079          .db "turnkey",0
0001e6 01dc          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0001e7 07ce          .dw PFA_DODEFER
                 PFA_TURNKEY:
0001e8 0008          .dw EE_TURNKEY
0001e9 0792          .dw XT_EDEFERFETCH
0001ea 0797          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
0001eb ff05          .dw $ff05
0001ec 2f2a
0001ed 6f6d
0001ee 0064          .db "*/mod",0
0001ef 01e1          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
0001f0 3800          .dw DO_COLON
                 PFA_STARSLASHMOD:
0001f1 38f3          .dw XT_TO_R
0001f2 39af          .dw XT_MSTAR
0001f3 38ea          .dw XT_R_FROM
0001f4 39cb          .dw XT_UMSLASHMOD
0001f5 381a          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0001f6 ff04          .dw $ff04
0001f7 6d2f
0001f8 646f          .db "/mod"
0001f9 01eb          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0001fa 01fb          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0001fb 019c          movw temp2, tosl
                     
0001fc 9109          ld temp0, Y+
0001fd 9119          ld temp1, Y+
                 
0001fe 2f41          mov	temp6,temp1	;move dividend High to sign register
0001ff 2743          eor	temp6,temp3	;xor divisor High with sign register
000200 ff17          sbrs	temp1,7	;if MSB in dividend set
000201 c004          rjmp	PFA_SLASHMOD_1
000202 9510          com	temp1		;    change sign of dividend
000203 9500          com	temp0		
000204 5f0f          subi	temp0,low(-1)
000205 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000206 ff37          sbrs	temp3,7	;if MSB in divisor set
000207 c004          rjmp	PFA_SLASHMOD_2
000208 9530          com	temp3		;    change sign of divisor
000209 9520          com	temp2		
00020a 5f2f          subi	temp2,low(-1)
00020b 4f3f          sbci	temp3,high(-1)
00020c 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00020d 18ff          sub	temp5,temp5;clear remainder High byte and carry
00020e e151          ldi	temp7,17	;init loop counter
                 
00020f 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000210 1f11          rol	temp1
000211 955a          dec	temp7		;decrement counter
000212 f439          brne	PFA_SLASHMOD_5		;if done
000213 ff47          sbrs	temp6,7		;    if MSB in sign register set
000214 c004          rjmp	PFA_SLASHMOD_4
000215 9510          com	temp1	;        change sign of result
000216 9500          com	temp0
000217 5f0f          subi	temp0,low(-1)
000218 4f1f          sbci	temp1,high(-1)
000219 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00021a 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00021b 1cff          rol	temp5
00021c 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00021d 0af3          sbc	temp5,temp3	;
00021e f420          brcc	PFA_SLASHMOD_6		;if result negative
00021f 0ee2          add	temp4,temp2	;    restore remainder
000220 1ef3          adc	temp5,temp3
000221 9488          clc			;    clear carry to be shifted into result
000222 cfec          rjmp	PFA_SLASHMOD_3		;else
000223 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000224 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000225 92fa          st -Y,temp5
000226 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000227 01c8          movw tosl, temp0
000228 940c 3804     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
00022a ff02          .dw $ff02
00022b 2f2a          .db "*/"
00022c 01f6          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
00022d 3800          .dw DO_COLON
                 PFA_STARSLASH:
00022e 01f0          .dw XT_STARSLASHMOD
00022f 38bf          .dw XT_SWAP
000230 38d4          .dw XT_DROP
000231 381a          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000232 ff05          .dw $ff05
000233 2f75
000234 6f6d
000235 0064          .db "u/mod",0
000236 022a          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000237 3800          .dw DO_COLON
                 PFA_USLASHMOD:
000238 38f3          .dw XT_TO_R
000239 3934          .dw XT_ZERO
00023a 38ea          .dw XT_R_FROM
00023b 39cb          .dw XT_UMSLASHMOD
00023c 381a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00023d ff06          .dw $ff06
00023e 656e
00023f 6167
000240 6574          .db "negate"
000241 0232          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000242 3800          .dw DO_COLON
                 PFA_NEGATE:
000243 3a06          .dw XT_INVERT
000244 3a38          .dw XT_1PLUS
000245 381a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
000246 ff01          .dw $ff01
000247 002f          .db "/",0
000248 023d          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000249 3800          .dw DO_COLON
                 PFA_SLASH:
00024a 01fa          .dw XT_SLASHMOD
00024b 38bf          .dw XT_SWAP
00024c 38d4          .dw XT_DROP
00024d 381a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
00024e ff03          .dw $ff03
00024f 6f6d
000250 0064          .db "mod",0
000251 0246          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000252 3800          .dw DO_COLON
                 PFA_MOD:
000253 01fa          .dw XT_SLASHMOD
000254 38d4          .dw XT_DROP
000255 381a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000256 ff03          .dw $ff03
000257 6261
000258 0073          .db "abs",0
000259 024e          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00025a 025b          .dw PFA_ABS
                 PFA_ABS:
00025b 2399          tst tosh
00025c f41a          brpl PFA_ABS1
00025d 9580          com tosl
00025e 9590          com tosh
00025f 9601          adiw tosl, 1
                 PFA_ABS1:
000260 940c 3804     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
000262 ff03          .dw $ff03
000263 696d
000264 006e          .db "min",0
000265 0256          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000266 3800          .dw DO_COLON
                 PFA_MIN:
000267 010c          .dw XT_2DUP
000268 3926          .dw XT_GREATER
000269 3830          .dw XT_DOCONDBRANCH
00026a 026c          .dw PFA_MIN1
00026b 38bf          .dw XT_SWAP
                 PFA_MIN1:
00026c 38d4          .dw XT_DROP
00026d 381a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
00026e ff03          .dw $ff03
00026f 616d
000270 0078          .db "max",0
000271 0262          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000272 3800          .dw DO_COLON
                 PFA_MAX:
000273 010c          .dw XT_2DUP
000274 391f          .dw XT_LESS
000275 3830          .dw XT_DOCONDBRANCH
000276 0278          .dw PFA_MAX1
000277 38bf          .dw XT_SWAP
                 PFA_MAX1:
000278 38d4          .dw XT_DROP
000279 381a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
00027a ff06          .dw $ff06
00027b 6977
00027c 6874
00027d 6e69          .db "within"
00027e 026e          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00027f 3800          .dw DO_COLON
                 PFA_WITHIN:
000280 38ca          .dw XT_OVER
000281 399c          .dw XT_MINUS
000282 38f3          .dw XT_TO_R
000283 399c          .dw XT_MINUS
000284 38ea          .dw XT_R_FROM
000285 3946          .dw XT_ULESS
000286 381a          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
000287 ff07          .dw $ff07 
000288 6f74
000289 7075
00028a 6570
00028b 0072          .db "toupper",0
00028c 027a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00028d 3800          .dw DO_COLON 
                 PFA_TOUPPER:
00028e 38ac          .dw XT_DUP 
00028f 3837          .dw XT_DOLITERAL 
000290 0061          .dw 'a' 
000291 3837          .dw XT_DOLITERAL 
000292 007b          .dw 'z'+1
000293 027f          .dw XT_WITHIN 
000294 3830          .dw XT_DOCONDBRANCH
000295 0299          .dw PFA_TOUPPER0 
000296 3837          .dw XT_DOLITERAL
000297 00df          .dw $df ; inverse of 0x20
000298 3a1c          .dw XT_AND 
                 PFA_TOUPPER0:
000299 381a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
00029a ff07          .dw $ff07
00029b 6f74
00029c 6f6c
00029d 6577
00029e 0072          .db "tolower",0
00029f 0287          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0002a0 3800          .dw DO_COLON
                 PFA_TOLOWER:
0002a1 38ac          .dw XT_DUP
0002a2 3837          .dw XT_DOLITERAL
0002a3 0041          .dw 'A'
0002a4 3837          .dw XT_DOLITERAL
0002a5 005b          .dw 'Z'+1
0002a6 027f          .dw XT_WITHIN
0002a7 3830          .dw XT_DOCONDBRANCH
0002a8 02ac          .dw PFA_TOLOWER0 
0002a9 3837          .dw XT_DOLITERAL
0002aa 0020          .dw $20 
0002ab 3a25          .dw XT_OR 
                 PFA_TOLOWER0:
0002ac 381a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002ad ff03          .dw $ff03
0002ae 6c68
0002af 0064          .db "hld",0
0002b0 029a          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002b1 3842          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002b2 0151          .dw ram_hld
                 
                 .dseg
000151           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0002b3 ff04          .dw $ff04
0002b4 6f68
0002b5 646c          .db "hold"
0002b6 02ad          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0002b7 3800          .dw DO_COLON
                 PFA_HOLD:
0002b8 02b1          .dw XT_HLD
0002b9 38ac          .dw XT_DUP
0002ba 3874          .dw XT_FETCH
0002bb 3a3e          .dw XT_1MINUS
0002bc 38ac          .dw XT_DUP
0002bd 38f3          .dw XT_TO_R
0002be 38bf          .dw XT_SWAP
0002bf 387c          .dw XT_STORE
0002c0 38ea          .dw XT_R_FROM
0002c1 3888          .dw XT_CSTORE
0002c2 381a          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
0002c3 ff02          .dw $ff02
0002c4 233c          .db "<#"
0002c5 02b3          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0002c6 3800          .dw DO_COLON
                 PFA_L_SHARP:
0002c7 0129          .dw XT_PAD
0002c8 02b1          .dw XT_HLD
0002c9 387c          .dw XT_STORE
0002ca 381a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
0002cb ff01          .dw $ff01
0002cc 0023          .db "#",0
0002cd 02c3          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0002ce 3800          .dw DO_COLON
                 PFA_SHARP:
0002cf 00f5          .dw XT_BASE
0002d0 3874          .dw XT_FETCH
0002d1 034d          .dw XT_UDSLASHMOD
0002d2 38dc          .dw XT_ROT
0002d3 3837          .dw XT_DOLITERAL
0002d4 0009          .dw 9
0002d5 38ca          .dw XT_OVER
0002d6 391f          .dw XT_LESS
0002d7 3830          .dw XT_DOCONDBRANCH
0002d8 02dc          .dw PFA_SHARP1
0002d9 3837          .dw XT_DOLITERAL
0002da 0007          .dw 7
0002db 39a6          .dw XT_PLUS
                 PFA_SHARP1:
0002dc 3837          .dw XT_DOLITERAL
0002dd 0030          .dw $30
0002de 39a6          .dw XT_PLUS
0002df 02b7          .dw XT_HOLD
0002e0 381a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
0002e1 ff02          .dw $ff02
0002e2 7323          .db "#s"
0002e3 02cb          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0002e4 3800          .dw DO_COLON
                 PFA_SHARP_S:
0002e5 02ce          .dw XT_SHARP
0002e6 010c          .dw XT_2DUP
0002e7 3a25          .dw XT_OR
0002e8 3918          .dw XT_EQUALZERO
0002e9 3830          .dw XT_DOCONDBRANCH
0002ea 02e5          .dw PFA_SHARP_S
0002eb 381a          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
0002ec ff02          .dw $ff02
0002ed 3e23          .db "#>"
0002ee 02e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0002ef 3800          .dw DO_COLON
                 PFA_SHARP_G:
0002f0 0115          .dw XT_2DROP
0002f1 02b1          .dw XT_HLD
0002f2 3874          .dw XT_FETCH
0002f3 38ac          .dw XT_DUP
0002f4 0129          .dw XT_PAD
0002f5 38bf          .dw XT_SWAP
0002f6 399c          .dw XT_MINUS
0002f7 381a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
0002f8 ff04          .dw $ff04
0002f9 6973
0002fa 6e67          .db "sign"
0002fb 02ec          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0002fc 3800          .dw DO_COLON
                 PFA_SIGN:
0002fd 392d          .dw XT_LESSZERO
0002fe 3830          .dw XT_DOCONDBRANCH
0002ff 0303          .dw PFA_SIGN1
000300 3837          .dw XT_DOLITERAL
000301 002d          .dw $2d
000302 02b7          .dw XT_HOLD
                 PFA_SIGN1:
000303 381a          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
000304 ff03          .dw $ff03
000305 2e64
000306 0072          .db "d.r",0
000307 02f8          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000308 3800          .dw DO_COLON
                 PFA_DDOTR:
000309 38f3          .dw XT_TO_R
00030a 38bf          .dw XT_SWAP
00030b 38ca          .dw XT_OVER
00030c 088e          .dw XT_DABS
00030d 02c6          .dw XT_L_SHARP
00030e 02e4          .dw XT_SHARP_S
00030f 38dc          .dw XT_ROT
000310 02fc          .dw XT_SIGN
000311 02ef          .dw XT_SHARP_G
000312 38ea          .dw XT_R_FROM
000313 38ca          .dw XT_OVER
000314 399c          .dw XT_MINUS
000315 0410          .dw XT_SPACES
000316 041f          .dw XT_TYPE
000317 381a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
000318 ff02          .dw $ff02
000319 722e          .db ".r"
00031a 0304          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00031b 3800          .dw DO_COLON
                 PFA_DOTR:
00031c 38f3          .dw XT_TO_R
00031d 3b29          .dw XT_S2D
00031e 38ea          .dw XT_R_FROM
00031f 0308          .dw XT_DDOTR
000320 381a          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
000321 ff02          .dw $ff02
000322 2e64          .db "d."
000323 0318          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000324 3800          .dw DO_COLON
                 PFA_DDOT:
000325 3934          .dw XT_ZERO
000326 0308          .dw XT_DDOTR
000327 0407          .dw XT_SPACE
000328 381a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
000329 ff01          .dw $ff01
00032a 002e          .db ".",0
00032b 0321          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00032c 3800          .dw DO_COLON
                 PFA_DOT:
00032d 3b29          .dw XT_S2D
00032e 0324          .dw XT_DDOT
00032f 381a          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
000330 ff03          .dw $ff03
000331 6475
000332 002e          .db "ud.",0
000333 0329          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000334 3800          .dw DO_COLON
                 PFA_UDDOT:
000335 3934          .dw XT_ZERO
000336 033d          .dw XT_UDDOTR
000337 0407          .dw XT_SPACE
000338 381a          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
000339 ff04          .dw $ff04
00033a 6475
00033b 722e          .db "ud.r"
00033c 0330          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00033d 3800          .dw DO_COLON
                 PFA_UDDOTR:
00033e 38f3          .dw XT_TO_R
00033f 02c6          .dw XT_L_SHARP
000340 02e4          .dw XT_SHARP_S
000341 02ef          .dw XT_SHARP_G
000342 38ea          .dw XT_R_FROM
000343 38ca          .dw XT_OVER
000344 399c          .dw XT_MINUS
000345 0410          .dw XT_SPACES
000346 041f          .dw XT_TYPE
000347 381a          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
000348 ff06          .dw $ff06
000349 6475
00034a 6d2f
00034b 646f          .db "ud/mod"
00034c 0339          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00034d 3800          .dw DO_COLON
                 PFA_UDSLASHMOD:
00034e 38f3          .dw XT_TO_R
00034f 3934          .dw XT_ZERO
000350 38fc          .dw XT_R_FETCH
000351 39cb          .dw XT_UMSLASHMOD
000352 38ea          .dw XT_R_FROM
000353 38bf          .dw XT_SWAP
000354 38f3          .dw XT_TO_R
000355 39cb          .dw XT_UMSLASHMOD
000356 38ea          .dw XT_R_FROM
000357 381a          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
000358 ff06          .dw $ff06 
000359 6964
00035a 6967
00035b 3f74          .db "digit?"
00035c 0348          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00035d 3800          .dw DO_COLON 
                 PFA_DIGITQ:
00035e 028d          .dw XT_TOUPPER
00035f 3837          .dw XT_DOLITERAL 
000360 0030          .dw $30 
000361 399c          .dw XT_MINUS 
000362 38ac          .dw XT_DUP 
000363 3837          .dw XT_DOLITERAL
000364 0009          .dw $09 
000365 3951          .dw XT_UGREATER 
000366 3830          .dw XT_DOCONDBRANCH
000367 0374          .dw PFA_DIGITQ0 
000368 3837          .dw XT_DOLITERAL
000369 0007          .dw $07 
00036a 399c          .dw XT_MINUS 
00036b 38ac          .dw XT_DUP 
00036c 3837          .dw XT_DOLITERAL
00036d 0009          .dw $09 
00036e 0383          .dw XT_ULESSEQUAL
00036f 3830          .dw XT_DOCONDBRANCH
000370 0374          .dw PFA_DIGITQ1 
000371 38d4          .dw XT_DROP 
000372 3934          .dw XT_ZERO
000373 381a          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
000374 38ac          .dw XT_DUP 
000375 00f5          .dw XT_BASE 
000376 3874          .dw XT_FETCH 
000377 038b          .dw XT_UGREATEREQUAL
000378 3830          .dw XT_DOCONDBRANCH
000379 037d          .dw PFA_DIGITQ2 
00037a 38d4          .dw XT_DROP 
00037b 3934          .dw XT_ZERO
00037c 381a          .dw XT_EXIT 
                 PFA_DIGITQ2:
00037d 393d          .dw XT_TRUE
00037e 381a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
00037f ff03          .dw $ff03 
000380 3c75
000381 003d          .db "u<=",0
000382 0358          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
000383 3800          .dw DO_COLON 
                 PFA_ULESSEQUAL:
000384 3951          .dw XT_UGREATER 
000385 3a06          .dw XT_INVERT 
000386 381a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
000387 ff03          .dw $ff03 
000388 3e75
000389 003d          .db "u>=",0
00038a 037f          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
00038b 3800          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
00038c 3946          .dw XT_ULESS 
00038d 3a06          .dw XT_INVERT 
00038e 381a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00038f 3800        .dw DO_COLON
                 PFA_DOSLITERAL:
000390 38ea        .dw XT_R_FROM   ; ( -- addr )
000391 38ac        .dw XT_DUP      ; ( -- addr addr )
000392 38ac        .dw XT_DUP
000393 3b6f        .dw XT_FETCHI   ; ( -- addr addr n )
000394 38bf        .dw XT_SWAP
000395 3a38        .dw XT_1PLUS
000396 38bf        .dw XT_SWAP
000397 38dc        .dw XT_ROT      ; ( -- addr' n addr )
000398 38ca        .dw XT_OVER     ; ( -- addr' n addr n)
000399 3a38        .dw XT_1PLUS
00039a 3a0d        .dw XT_2SLASH   ; ( -- addr' n addr k )
00039b 39a6        .dw XT_PLUS     ; ( -- addr' n addr'' )
00039c 3a38        .dw XT_1PLUS
00039d 38f3        .dw XT_TO_R     ; ( -- )
00039e 381a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00039f ff02        .dw $ff02
0003a0 2c73        .db "s",$2c
0003a1 0387        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003a2 3800          .dw DO_COLON
                 PFA_SCOMMA:
0003a3 38ac          .dw XT_DUP
0003a4 03a6          .dw XT_DOSCOMMA
0003a5 381a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003a6 3800          .dw DO_COLON
                 PFA_DOSCOMMA:
0003a7 01aa          .dw XT_COMMA
0003a8 38ac          .dw XT_DUP   ; ( --addr len len)
0003a9 3a0d          .dw XT_2SLASH ; ( -- addr len len/2
0003aa 38bf          .dw XT_SWAP   ; ( -- addr len/2 len
0003ab 38ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003ac 3a14          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003ad 399c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003ae 38f3          .dw XT_TO_R
0003af 3934          .dw XT_ZERO
0003b0 3aaa          .dw XT_DOQDO
0003b1 03b8          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0003b2 38ac          .dw XT_DUP         ; ( -- addr addr )
0003b3 3874          .dw XT_FETCH       ; ( -- addr c1c2 )
0003b4 01aa          .dw XT_COMMA       ; ( -- addr )
0003b5 0104          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003b6 3ad8          .dw XT_DOLOOP
0003b7 03b2          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003b8 38ea          .dw XT_R_FROM
0003b9 395c          .dw XT_GREATERZERO
0003ba 3830          .dw XT_DOCONDBRANCH
0003bb 03bf          .dw PFA_SCOMMA3
0003bc 38ac            .dw XT_DUP     ; well, tricky
0003bd 3893            .dw XT_CFETCH
0003be 01aa            .dw XT_COMMA
                 PFA_SCOMMA3:
0003bf 38d4          .dw XT_DROP        ; ( -- )
0003c0 381a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003c1 ff05          .dw $ff05
0003c2 7469
0003c3 7079
0003c4 0065          .db "itype",0
0003c5 039f          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003c6 3800          .dw DO_COLON
                 PFA_ITYPE:
0003c7 38ac          .dw XT_DUP    ; ( --addr len len)
0003c8 3a0d          .dw XT_2SLASH ; ( -- addr len len/2
0003c9 38bf          .dw XT_SWAP   ; ( -- addr len/2 len
0003ca 38ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003cb 3a14          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003cc 399c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003cd 38f3          .dw XT_TO_R
0003ce 3934          .dw XT_ZERO
0003cf 3aaa          .dw XT_DOQDO
0003d0 03d9          .dw PFA_ITYPE2
                 PFA_ITYPE1:
0003d1 38ac          .dw XT_DUP         ; ( -- addr addr )
0003d2 3b6f          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003d3 38ac          .dw XT_DUP
0003d4 03e6          .dw XT_LOWEMIT
0003d5 03e2          .dw XT_HIEMIT
0003d6 3a38          .dw XT_1PLUS    ; ( -- addr+cell )
0003d7 3ad8          .dw XT_DOLOOP
0003d8 03d1          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0003d9 38ea          .dw XT_R_FROM
0003da 395c          .dw XT_GREATERZERO
0003db 3830          .dw XT_DOCONDBRANCH
0003dc 03e0          .dw PFA_ITYPE3
0003dd 38ac            .dw XT_DUP     ; make sure the drop below has always something to do
0003de 3b6f            .dw XT_FETCHI
0003df 03e6            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0003e0 38d4          .dw XT_DROP
0003e1 381a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0003e2 3800          .dw DO_COLON
                 PFA_HIEMIT:
0003e3 3b0e          .dw XT_BYTESWAP
0003e4 03e6          .dw XT_LOWEMIT
0003e5 381a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0003e6 3800          .dw DO_COLON
                 PFA_LOWEMIT:
0003e7 3837          .dw XT_DOLITERAL
0003e8 00ff          .dw $00ff
0003e9 3a1c          .dw XT_AND
0003ea 0133          .dw XT_EMIT
0003eb 381a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0003ec ff06          .dw $ff06
0003ed 6369
0003ee 756f
0003ef 746e          .db "icount"
0003f0 03c1          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0003f1 3800          .dw DO_COLON
                 PFA_ICOUNT:
0003f2 38ac          .dw XT_DUP
0003f3 3a38          .dw XT_1PLUS
0003f4 38bf          .dw XT_SWAP
0003f5 3b6f          .dw XT_FETCHI
0003f6 381a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
0003f7 ff02          .dw $ff02
0003f8 7263          .db "cr"
0003f9 03ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0003fa 3800          .dw DO_COLON
                 PFA_CR:
0003fb 3837          .dw XT_DOLITERAL
0003fc 000d          .dw 13
0003fd 0133          .dw XT_EMIT
0003fe 3837          .dw XT_DOLITERAL
0003ff 000a          .dw 10
000400 0133          .dw XT_EMIT
000401 381a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
000402 ff05          .dw $ff05
000403 7073
000404 6361
000405 0065          .db "space",0
000406 03f7          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000407 3800          .dw DO_COLON
                 PFA_SPACE:
000408 01df          .dw XT_BL
000409 0133          .dw XT_EMIT
00040a 381a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
00040b ff06          .dw $ff06
00040c 7073
00040d 6361
00040e 7365          .db "spaces"
00040f 0402          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000410 3800          .dw DO_COLON
                 PFA_SPACES:
000411 38ac          .dw XT_DUP
000412 395c          .dw XT_GREATERZERO
000413 3a1c          .dw XT_AND
000414 3934          .dw XT_ZERO
000415 3aaa          .dw XT_DOQDO
000416 041a          .dw PFA_SPACES2
                 PFA_SPACES1:
000417 0407          .dw XT_SPACE
000418 3ad8          .dw XT_DOLOOP
000419 0417          .dw PFA_SPACES1
                 PFA_SPACES2:
00041a 381a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
00041b ff04          .dw $ff04
00041c 7974
00041d 6570          .db "type"
00041e 040b          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00041f 3800          .dw DO_COLON
                 PFA_TYPE:
000420 38ca          .dw XT_OVER
000421 39a6          .dw XT_PLUS
000422 38bf          .dW XT_SWAP
000423 3aaa          .dw XT_DOQDO
000424 042a          .dw PFA_TYPE2
                 PFA_TYPE1:
000425 3abd          .dw XT_I
000426 3893          .dw XT_CFETCH
000427 0133          .dw XT_EMIT
000428 3ad8          .dw XT_DOLOOP
000429 0425          .dw PFA_TYPE1
                 PFA_TYPE2:
00042a 381a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
00042b ff01          .dw $ff01
00042c 0027          .db "'",0
00042d 041b          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00042e 3800          .dw DO_COLON
                 PFA_TICK:
00042f 05eb          .dw XT_PARSENAME
000430 0608          .dw XT_FINDNAME
000431 3918          .dw XT_EQUALZERO
000432 3830          .dw XT_DOCONDBRANCH
000433 0437          .dw PFA_TICK1
000434 3837          .dw XT_DOLITERAL
000435 fff3          .dw -13
000436 045b          .dw XT_THROW
                 PFA_TICK1:
000437 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
000438 ff07          .dw $ff07
000439 6168
00043a 646e
00043b 656c
00043c 0072          .db "handler",0
00043d 042b          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00043e 3852          .dw PFA_DOUSER
                 PFA_HANDLER:
00043f 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
000440 ff05          .dw $ff05
000441 6163
000442 6374
000443 0068          .db "catch",0
000444 0438          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000445 3800          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
000446 3a8a          .dw XT_SP_FETCH
000447 38f3          .dw XT_TO_R
                     ; handler @ >r
000448 043e          .dw XT_HANDLER
000449 3874          .dw XT_FETCH
00044a 38f3          .dw XT_TO_R
                     ; rp@ handler !
00044b 3a73          .dw XT_RP_FETCH
00044c 043e          .dw XT_HANDLER
00044d 387c          .dw XT_STORE
00044e 3824          .dw XT_EXECUTE
                     ; r> handler !
00044f 38ea          .dw XT_R_FROM
000450 043e          .dw XT_HANDLER
000451 387c          .dw XT_STORE
000452 38ea          .dw XT_R_FROM
000453 38d4          .dw XT_DROP
000454 3934          .dw XT_ZERO
000455 381a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
000456 ff05          .dw $ff05
000457 6874
000458 6f72
000459 0077          .db "throw",0
00045a 0440          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00045b 3800          .dw DO_COLON
                 PFA_THROW:
00045c 38ac          .dw XT_DUP
00045d 3918          .dw XT_EQUALZERO
00045e 3830          .dw XT_DOCONDBRANCH
00045f 0462          .dw PFA_THROW1
000460 38d4      	.dw XT_DROP
000461 381a      	.dw XT_EXIT
                 PFA_THROW1:
000462 043e          .dw XT_HANDLER
000463 3874          .dw XT_FETCH
000464 3a7d          .dw XT_RP_STORE
000465 38ea          .dw XT_R_FROM
000466 043e          .dw XT_HANDLER
000467 387c          .dw XT_STORE
000468 38ea          .dw XT_R_FROM
000469 38bf          .dw XT_SWAP
00046a 38f3          .dw XT_TO_R
00046b 3a93          .dw XT_SP_STORE
00046c 38d4          .dw XT_DROP
00046d 38ea          .dw XT_R_FROM    
00046e 381a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
00046f ff05          .dw $ff05
000470 7363
000471 696b
000472 0070          .db "cskip",0
000473 0456          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000474 3800          .dw DO_COLON
                 PFA_CSKIP:
000475 38f3          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000476 38ac          .dw XT_DUP            ; ( -- addr' n' n' )
000477 3830          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000478 0484          .dw PFA_CSKIP2
000479 38ca          .dw XT_OVER           ; ( -- addr' n' addr' )
00047a 3893          .dw XT_CFETCH         ; ( -- addr' n' c' )
00047b 38fc          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00047c 3911          .dw XT_EQUAL          ; ( -- addr' n' f )
00047d 3830          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00047e 0484          .dw PFA_CSKIP2
00047f 3837          .dw XT_DOLITERAL
000480 0001          .dw 1
000481 05da          .dw XT_SLASHSTRING
000482 3829          .dw XT_DOBRANCH
000483 0476          .dw PFA_CSKIP1
                 PFA_CSKIP2:
000484 38ea          .dw XT_R_FROM
000485 38d4          .dw XT_DROP           ; ( -- addr2 n2)
000486 381a          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
000487 ff06          .dw $ff06
000488 6361
000489 6563
00048a 7470          .db "accept"
00048b 046f          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00048c 3800          .dw DO_COLON
                 PFA_ACCEPT:
00048d 38ac          .dw XT_DUP        ; ( -- addr n1 n1)
00048e 38f3          .dw XT_TO_R
00048f 38f3          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
000490 0144          .dw XT_KEY        ; ( -- addr k )
000491 38ac          .dw XT_DUP        ; ( -- addr k k )
000492 3837          .dw XT_DOLITERAL
000493 000a          .dw 10
000494 3907          .dw XT_NOTEQUAL
000495 3830          .dw XT_DOCONDBRANCH
000496 04ca          .dw PFA_ACCEPT2
000497 38ac          .dw XT_DUP
000498 3837          .dw XT_DOLITERAL
000499 000d          .dw 13
00049a 3907          .dw XT_NOTEQUAL
00049b 3830          .dw XT_DOCONDBRANCH
00049c 04ca          .dw PFA_ACCEPT2
                     ; check backspace
00049d 38ac          .dw XT_DUP
00049e 3837          .dw XT_DOLITERAL
00049f 0008          .dw 8
0004a0 3911          .dw XT_EQUAL
0004a1 3830          .dw XT_DOCONDBRANCH
0004a2 04b6          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
0004a3 38ea          .dw XT_R_FROM             ; ( -- addr k n1 )
0004a4 38fc          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
0004a5 38ca          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
0004a6 38f3          .dw XT_TO_R
0004a7 3911          .dw XT_EQUAL              ; ( -- addr k f )
0004a8 3830          .dw XT_DOCONDBRANCH
0004a9 04ad          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
0004aa 38d4          .dw XT_DROP               ; ( -- addr )
0004ab 3829          .dw XT_DOBRANCH
0004ac 0490          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0004ad 38ac          .dw XT_DUP                ; ( -- addr k k )
0004ae 0133          .dw XT_EMIT               ; ( -- addr k )
0004af 0407          .dw XT_SPACE              ; ( -- addr k )
0004b0 0133          .dw XT_EMIT               ; ( -- addr )
0004b1 3a3e          .dw XT_1MINUS             ; ( -- addr--)
0004b2 38ea          .dw XT_R_FROM
0004b3 3a38          .dw XT_1PLUS
0004b4 3829          .dw XT_DOBRANCH
0004b5 04c4          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
0004b6 38ac          .dw XT_DUP            ; ( -- addr k k )
0004b7 01df          .dw XT_BL
0004b8 391f          .dw XT_LESS
0004b9 3830          .dw XT_DOCONDBRANCH
0004ba 04bd          .dw PFA_ACCEPT6
0004bb 38d4          .dw XT_DROP
0004bc 01df          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
0004bd 38ac          .dw XT_DUP            ; ( -- addr k k)
0004be 0133          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
0004bf 38ca          .dw XT_OVER           ; ( -- addr k addr
0004c0 3888          .dw XT_CSTORE         ; ( -- addr)
0004c1 3a38          .dw XT_1PLUS          ; ( -- addr++)
0004c2 38ea          .dw XT_R_FROM         ; ( -- addr n1)
0004c3 3a3e          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
0004c4 38ac          .dw XT_DUP
0004c5 38f3          .dw XT_TO_R
0004c6 3918          .dw XT_EQUALZERO
0004c7 3830          .dw XT_DOCONDBRANCH
0004c8 0490          .dw PFA_ACCEPT1
0004c9 38ac          .dw XT_DUP
                 PFA_ACCEPT2:
0004ca 0115          .dw XT_2DROP
0004cb 38ea          .dw XT_R_FROM
0004cc 38ea          .dw XT_R_FROM
0004cd 38bf          .dw XT_SWAP
0004ce 399c          .dw XT_MINUS
0004cf 03fa          .dw XT_CR
0004d0 381a          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004d1 ff06          .dw $ff06
0004d2 6572
0004d3 6966
0004d4 6c6c          .db "refill"
0004d5 0487          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004d6 07ce          .dw PFA_DODEFER
                 PFA_REFILL:
0004d7 001a          .dw USER_REFILL
0004d8 07a6          .dw XT_UDEFERFETCH
0004d9 07ad          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
0004da ff04          .dw $ff04
0004db 6863
0004dc 7261          .db "char"
0004dd 04d1          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004de 3800          .dw DO_COLON
                 PFA_CHAR:
0004df 05eb          .dw XT_PARSENAME
0004e0 38d4          .dw XT_DROP
0004e1 3893          .dw XT_CFETCH
0004e2 381a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
0004e3 ff06          .dw $ff06
0004e4 756e
0004e5 626d
0004e6 7265          .db "number"
0004e7 04da          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004e8 3800          .dw DO_COLON
                 PFA_NUMBER:
0004e9 00f5          .dw XT_BASE
0004ea 3874          .dw XT_FETCH
0004eb 38f3          .dw XT_TO_R
0004ec 0559          .dw XT_NUMBERSIGN
0004ed 38f3          .dw XT_TO_R
0004ee 0525          .dw XT_PRAEFIX
0004ef 0559          .dw XT_NUMBERSIGN
0004f0 38ea          .dw XT_R_FROM
0004f1 3a25          .dw XT_OR
0004f2 38f3          .dw XT_TO_R
0004f3 38f3          .dw XT_TO_R
0004f4 38f3          .dw XT_TO_R
0004f5 3934          .dw XT_ZERO       ; starting value
0004f6 3934          .dw XT_ZERO
0004f7 38ea          .dw XT_R_FROM
0004f8 38ea          .dw XT_R_FROM
0004f9 0578          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0004fa 38b4          .dw XT_QDUP
0004fb 3830              .dw XT_DOCONDBRANCH
0004fc 0519      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
0004fd 3837          .dw XT_DOLITERAL
0004fe 0001          .dw 1
0004ff 3911          .dw XT_EQUAL
000500 3830          .dw XT_DOCONDBRANCH
000501 0510          .dw PFA_NUMBER2
                 	; excatly one character is left
000502 3893      	.dw XT_CFETCH
000503 3837      	.dw XT_DOLITERAL
000504 002e      	.dw $2e ; .
000505 3911      	.dw XT_EQUAL
000506 3830      	.dw XT_DOCONDBRANCH
000507 0510      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
000508 38ea      	.dw XT_R_FROM
000509 3830              .dw XT_DOCONDBRANCH
00050a 050c      	.dw PFA_NUMBER3
00050b 089b              .dw XT_DNEGATE
                 PFA_NUMBER3:
00050c 3837      	.dw XT_DOLITERAL
00050d 0002      	.dw 2
00050e 3829      	.dw XT_DOBRANCH
00050f 0520      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
000510 0115      	.dw XT_2DROP
000511 38d4      	.dw XT_DROP
000512 38ea      	.dw XT_R_FROM
000513 38d4      	.dw XT_DROP
000514 38ea              .dw XT_R_FROM
000515 00f5              .dw XT_BASE
000516 387c              .dw XT_STORE
000517 3934      	.dw XT_ZERO
000518 381a      	.dw XT_EXIT
                 PFA_NUMBER1:
000519 0115          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00051a 38ea          .dw XT_R_FROM
00051b 3830          .dw XT_DOCONDBRANCH
00051c 051e          .dw PFA_NUMBER4
00051d 0242          .dw XT_NEGATE
                 PFA_NUMBER4:
00051e 3837          .dw XT_DOLITERAL
00051f 0001          .dw 1
                 PFA_NUMBER5:
000520 38ea          .dw XT_R_FROM
000521 00f5          .dw XT_BASE
000522 387c          .dw XT_STORE
000523 393d          .dw XT_TRUE
000524 381a          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
000525 3800          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
000526 38ca          .dw XT_OVER 
000527 3893          .dw XT_CFETCH 
000528 3837          .dw XT_DOLITERAL
000529 0029          .dw $29 
00052a 3926          .dw XT_GREATER 
00052b 3830          .dw XT_DOCONDBRANCH
00052c 052e          .dw PFA_PRAEFIX0 
00052d 381a          .dw XT_EXIT 
                 PFA_PRAEFIX0:
00052e 38ca          .dw XT_OVER 
00052f 3893          .dw XT_CFETCH 
000530 0535          .dw XT_SETBASE
000531 3837          .dw XT_DOLITERAL
000532 0001          .dw $1 
000533 05da          .dw XT_SLASHSTRING 
000534 381a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000535 3800          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000536 38ac          .dw XT_DUP 
000537 3837          .dw XT_DOLITERAL
000538 0024          .dw '$' 
000539 3911          .dw XT_EQUAL 
00053a 3830          .dw XT_DOCONDBRANCH
00053b 053f          .dw PFA_SETBASE0 
00053c 38d4          .dw XT_DROP 
00053d 01d6          .dw XT_HEX 
00053e 381a          .dw XT_EXIT 
                 PFA_SETBASE0:
00053f 38ac          .dw XT_DUP 
000540 3837          .dw XT_DOLITERAL
000541 0025          .dw '%' 
000542 3911          .dw XT_EQUAL 
000543 3830          .dw XT_DOCONDBRANCH
000544 0548          .dw PFA_SETBASE1 
000545 38d4          .dw XT_DROP 
000546 01c0          .dw XT_BIN
000547 381a          .dw XT_EXIT 
                 PFA_SETBASE1:
000548 38ac          .dw XT_DUP 
000549 3837          .dw XT_DOLITERAL
00054a 0026          .dw '&'
00054b 3911          .dw XT_EQUAL 
00054c 3830          .dw XT_DOCONDBRANCH
00054d 0551          .dw PFA_SETBASE2 
00054e 38d4          .dw XT_DROP
00054f 01cc          .dw XT_DECIMAL 
000550 381a          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
000551 3837          .dw XT_DOLITERAL
000552 0023          .dw '#'
000553 3911          .dw XT_EQUAL 
000554 3830          .dw XT_DOCONDBRANCH
000555 0558          .dw PFA_SETBASE3 
000556 01cc          .dw XT_DECIMAL 
000557 381a          .dw XT_EXIT 
                 PFA_SETBASE3:
000558 381a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
000559 3800          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
00055a 38ca          .dw XT_OVER
00055b 3893          .dw XT_CFETCH
00055c 3837          .dw XT_DOLITERAL
00055d 002b          .dw '+'
00055e 3911          .dw XT_EQUAL
00055f 3830          .dw XT_DOCONDBRANCH
000560 0564          .dw PFA_NUMBERSIGN_MINUS
000561 3837            .dw XT_DOLITERAL
000562 0001            .dw 1
000563 05da            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
000564 38ca          .dw XT_OVER    ; ( -- addr len addr )
000565 3893          .dw XT_CFETCH
000566 3837          .dw XT_DOLITERAL
000567 002d          .dw '-'
000568 3911          .dw XT_EQUAL  ; ( -- addr len flag )
000569 38ac          .dw XT_DUP
00056a 38f3          .dw XT_TO_R
00056b 3830          .dw XT_DOCONDBRANCH
00056c 0570          .dw PFA_NUMBERSIGN_PLUS
00056d 3837          .dw XT_DOLITERAL      ; skip sign character
00056e 0001          .dw 1
00056f 05da          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
000570 38ea          .dw XT_R_FROM
000571 381a          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
000572 ff07          .dw $ff07
000573 6e3e
000574 6d75
000575 6562
000576 0072          .db ">number",0
000577 04e3          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000578 3800          .dw DO_COLON
                 PFA_TO_NUMBER:
000579 38ac          .dw XT_DUP
00057a 3830          .dw XT_DOCONDBRANCH
00057b 0596          .dw PFA_TO_NUMBER1
00057c 38ca              .dw XT_OVER
00057d 3893              .dw XT_CFETCH
00057e 035d              .dw XT_DIGITQ
00057f 3918              .dw XT_EQUALZERO
000580 3830              .dw XT_DOCONDBRANCH
000581 0583              .dw PFA_TO_NUMBER2
000582 381a                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
000583 38f3              .dw XT_TO_R
000584 08c0              .dw XT_2SWAP
000585 38ea              .dw XT_R_FROM
000586 38bf              .dw XT_SWAP
000587 00f5              .dw XT_BASE
000588 3874              .dw XT_FETCH
000589 39e9              .dw XT_UMSTAR
00058a 38d4              .dw XT_DROP
00058b 38dc              .dw XT_ROT
00058c 00f5              .dw XT_BASE
00058d 3874              .dw XT_FETCH
00058e 39e9              .dw XT_UMSTAR
00058f 0cce              .dw XT_DPLUS
000590 08c0              .dw XT_2SWAP
000591 3837              .dw XT_DOLITERAL
000592 0001              .dw 1
000593 05da              .dw XT_SLASHSTRING
000594 3829          .dw XT_DOBRANCH
000595 0579          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
000596 381a          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
000597 ff05          .dw $ff05
000598 6170
000599 7372
00059a 0065          .db "parse",0
00059b 0572          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00059c 3800          .dw DO_COLON
                 PFA_PARSE:
00059d 38f3          .dw XT_TO_R     ; ( -- )
00059e 05d0          .dw XT_SOURCE   ; ( -- addr len)
00059f 011d          .dw XT_G_IN     ; ( -- addr len >in)
0005a0 3874          .dw XT_FETCH
0005a1 05da          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0005a2 38ea          .dw XT_R_FROM      ; ( -- addr' len' c)
0005a3 05b1          .dw XT_CSCAN       ; ( -- addr' len'')
0005a4 38ac          .dw XT_DUP         ; ( -- addr' len'' len'')
0005a5 3a38          .dw XT_1PLUS
0005a6 011d          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
0005a7 3a62          .dw XT_PLUSSTORE   ; ( -- addr' len')
0005a8 3837          .dw XT_DOLITERAL
0005a9 0001          .dw 1
0005aa 05da          .dw XT_SLASHSTRING
0005ab 381a          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0005ac ff05          .dw $ff05
0005ad 7363
0005ae 6163
0005af 006e          .db "cscan",0
0005b0 0597          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0005b1 3800          .dw DO_COLON
                 PFA_CSCAN:
0005b2 38bf          .dw XT_SWAP         ; ( -- addr1 c n1 )
0005b3 38ac          .dw XT_DUP          ; ( -- addr1 c n1 n1)
0005b4 38f3          .dw XT_TO_R         ; ( -- addr1 c n1)
0005b5 3934          .dw XT_ZERO         ; ( -- addr1 c n1 0)
0005b6 3aaa          .dw XT_DOQDO        ; ( -- addr1 c)
0005b7 05c8          .dw PFA_CSCAN3
                 PFA_CSCAN1:
0005b8 38ca          .dw XT_OVER         ; ( -- addr1 c addr1 )
0005b9 3abd          .dw XT_I            ; ( -- addr1 c addr1 i)
0005ba 39a6          .dw XT_PLUS         ; ( -- addr1 c addr')
0005bb 3893          .dw XT_CFETCH       ; ( -- addr1 c c')
0005bc 38ca          .dw XT_OVER         ; ( -- addr1 c c' c)
0005bd 3911          .dw XT_EQUAL        ; ( -- addr1 c f)
0005be 3830          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
0005bf 05c6          .dw PFA_CSCAN2
0005c0 38d4          .dw XT_DROP         ; ( -- addr1 )
0005c1 3abd          .dw XT_I            ; ( -- addr1 n2)
0005c2 3ae7          .dw XT_UNLOOP       ; ( -- addr1 n2)
0005c3 38ea          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
0005c4 38d4          .dw XT_DROP         ; ( -- addr1 n2)
0005c5 381a          .dw XT_EXIT
                 PFA_CSCAN2:
0005c6 3ad8          .dw XT_DOLOOP
0005c7 05b8          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
0005c8 38d4          .dw XT_DROP         ; ( -- addr1)
0005c9 38ea          .dw XT_R_FROM       ; ( -- addr1 n1)
0005ca 381a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0005cb ff06          .dw $FF06
0005cc 6f73
0005cd 7275
0005ce 6563          .db "source"
0005cf 05ac          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0005d0 07ce          .dw PFA_DODEFER
                 PFA_SOURCE:
0005d1 0016          .dw USER_SOURCE
0005d2 07a6          .dw XT_UDEFERFETCH
0005d3 07ad          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0005d4 ff07          .dw $ff07
0005d5 732f
0005d6 7274
0005d7 6e69
0005d8 0067          .db "/string",0
0005d9 05cb          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005da 3800          .dw DO_COLON
                 PFA_SLASHSTRING:
0005db 38ca          .dw XT_OVER    ; ( -- addr1 u1 n u1)
0005dc 0266          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
0005dd 38dc          .dw XT_ROT     ; ( -- u1 n addr1 )
0005de 38ca          .dw XT_OVER    ; ( -- u1 n addr1 n)
0005df 39a6          .dw XT_PLUS    ; ( -- u1 n addr2 )
0005e0 38dc          .dw XT_ROT     ; ( -- n addr2 u1)
0005e1 38dc          .dw XT_ROT     ; ( -- addr2 u1 n)
0005e2 399c          .dw XT_MINUS   ; ( -- addr2 u2)
0005e3 381a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
0005e4 ff0a          .dw $FF0A 
0005e5 6170
0005e6 7372
0005e7 2d65
0005e8 616e
0005e9 656d          .db "parse-name"
0005ea 05d4          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005eb 3800          .dw DO_COLON 
                 PFA_PARSENAME:
0005ec 01df          .dw XT_BL
0005ed 05ef          .dw XT_SKIPSCANCHAR
0005ee 381a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005ef 3800          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
0005f0 38f3          .dw XT_TO_R
0005f1 05d0          .dw XT_SOURCE 
0005f2 011d          .dw XT_G_IN 
0005f3 3874          .dw XT_FETCH 
0005f4 05da          .dw XT_SLASHSTRING 
                 
0005f5 38fc          .dw XT_R_FETCH
0005f6 0474          .dw XT_CSKIP
0005f7 38ea          .dw XT_R_FROM
0005f8 05b1          .dw XT_CSCAN
                 
                     ; adjust >IN
0005f9 010c          .dw XT_2DUP
0005fa 39a6          .dw XT_PLUS
0005fb 05d0          .dw XT_SOURCE 
0005fc 38d4          .dw XT_DROP
0005fd 399c          .dw XT_MINUS
0005fe 011d          .dw XT_G_IN
0005ff 387c          .dw XT_STORE
000600 381a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
000601 ff09          .dw $ff09
000602 6966
000603 646e
000604 6e2d
000605 6d61
000606 0065          .db "find-name",0
000607 05e4          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000608 3800          .dw DO_COLON
                 PFA_FINDNAME:
000609 3837          .dw XT_DOLITERAL
00060a 0014          .dw EE_ORDERLISTLEN
00060b 3b5b          .dw XT_FETCHE
00060c 3934          .dw XT_ZERO
00060d 3aaa          .dw XT_DOQDO
00060e 0623          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
00060f 010c          .dw XT_2DUP
000610 3837          .dw XT_DOLITERAL
000611 0016          .dw EE_ORDERLIST
000612 3abd          .dw XT_I
000613 00fc          .dw XT_CELLS
000614 39a6          .dw XT_PLUS  
000615 3b5b          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
000616 07e2          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
000617 38b4          .dw XT_QDUP
000618 3830          .dw XT_DOCONDBRANCH
000619 0621          .dw PFA_FINDNAME4
00061a 38f3      	.dw XT_TO_R
00061b 38f3      	.dw XT_TO_R
00061c 0115      	.dw XT_2DROP
00061d 38ea      	.dw XT_R_FROM
00061e 38ea      	.dw XT_R_FROM
00061f 3ae7      	.dw XT_UNLOOP
000620 381a      	.dw XT_EXIT
                 PFA_FINDNAME4:
000621 3ad8          .dw XT_DOLOOP
000622 060f          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000623 0115          .dw XT_2DROP
000624 3934          .dw XT_ZERO
000625 381a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
000626 ff04          .dw $ff04
000627 7571
000628 7469          .db "quit"
000629 0601          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00062a 3800          .dw DO_COLON
                 PFA_QUIT:
00062b 06a2          .dw XT_SP0
00062c 3a93          .dw XT_SP_STORE
00062d 06b7          .dw XT_RP0
00062e 3a7d          .dw XT_RP_STORE
00062f 0a67          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000630 00ef          .dw XT_STATE
000631 3874          .dw XT_FETCH
000632 3918          .dw XT_EQUALZERO
000633 3830          .dw XT_DOCONDBRANCH
000634 0636          .dw PFA_QUIT4
000635 064c          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000636 04d6          .dw XT_REFILL
000637 3830          .dw XT_DOCONDBRANCH
000638 0630          .dw PFA_QUIT2
000639 3837          .dw XT_DOLITERAL
00063a 06d0          .dw XT_INTERPRET
00063b 0445          .dw XT_CATCH
00063c 38b4          .dw XT_QDUP
00063d 3830          .dw XT_DOCONDBRANCH
00063e 0648          .dw PFA_QUIT3
00063f 38ac      	.dw XT_DUP
000640 3837      	.dw XT_DOLITERAL
000641 fffe      	.dw -2
000642 391f      	.dw XT_LESS
000643 3830      	.dw XT_DOCONDBRANCH
000644 0646      	.dw PFA_QUIT5
000645 065a      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000646 3829      	.dw XT_DOBRANCH
000647 062b      	.dw PFA_QUIT
                 PFA_QUIT3:
000648 0653          .dw XT_PROMPTOK
000649 3829          .dw XT_DOBRANCH
00064a 0630          .dw PFA_QUIT2
00064b 381a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
00064c 3800          .dw DO_COLON
                 PFA_PROMPTRDY:
00064d 03fa          .dw XT_CR
00064e 038f          .dw XT_DOSLITERAL
00064f 0002          .dw 2
000650 203e          .db "> "
000651 03c6          .dw XT_ITYPE
000652 381a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000653 3800          .dw DO_COLON
                 PFA_PROMPTOK:
000654 038f          .dw XT_DOSLITERAL
000655 0003          .dw 3
000656 6f20
000657 006b          .db " ok",0
000658 03c6          .dw XT_ITYPE
000659 381a          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00065a 3800          .dw DO_COLON
                 PFA_PROMPTERROR:
00065b 038f      	.dw XT_DOSLITERAL
00065c 0004      	.dw 4
00065d 3f20
00065e 203f      	.db  " ?? "
00065f 03c6          .dw XT_ITYPE
000660 00f5      	.dw XT_BASE
000661 3874      	.dw XT_FETCH
000662 38f3      	.dw XT_TO_R
000663 01cc      	.dw XT_DECIMAL
000664 032c      	.dw XT_DOT
000665 011d      	.dw XT_G_IN
000666 3874      	.dw XT_FETCH
000667 032c      	.dw XT_DOT
000668 38ea      	.dw XT_R_FROM
000669 00f5      	.dw XT_BASE
00066a 387c      	.dw XT_STORE
00066b 381a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00066c ff05          .dw $ff05
00066d 6170
00066e 7375
00066f 0065          .db "pause",0
000670 0626          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000671 07ce          .dw PFA_DODEFER
                 PFA_PAUSE:
000672 0153          .dw ram_pause
000673 079c          .dw XT_RDEFERFETCH
000674 07a1          .dw XT_RDEFERSTORE
                 
                 .dseg
000153           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000675 ff04          .dw $ff04
000676 6f63
000677 646c          .db "cold"
000678 066c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000679 067a          .dw PFA_COLD
                 PFA_COLD:
00067a b6a4          in_ r10, MCUSR
00067b 24bb          clr r11
00067c 2422          clr zerol
00067d 2433          clr zeroh
00067e be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000155           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00067f e5e5          ldi zl, low(ram_user1)
000680 e0f1          ldi zh, high(ram_user1)
000681 012f          movw upl, zl
                     ; init return stack pointer
000682 ef0f          ldi temp0,low(rstackstart)
000683 bf0d          out_ SPL,temp0
000684 8304          std Z+4, temp0
000685 e018          ldi temp1,high(rstackstart)
000686 bf1e          out_ SPH,temp1
000687 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000688 eacf          ldi yl,low(stackstart)
000689 83c6          std Z+6, yl
00068a e0d8          ldi yh,high(stackstart)
00068b 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00068c e9a5          ldi XL, low(PFA_WARM)
00068d e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00068e 940c 3804     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000690 ff04          .dw $ff04
000691 6177
000692 6d72          .db "warm"
000693 0675          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000694 3800          .dw DO_COLON
                 PFA_WARM:
000695 0910          .dw XT_INITUSER
000696 3837          .dw XT_DOLITERAL
000697 076b          .dw XT_NOOP
000698 3837          .dw XT_DOLITERAL
000699 0671          .dw XT_PAUSE
00069a 07b9          .dw XT_DEFERSTORE
00069b 01e7          .dw XT_TURNKEY
00069c 062a          .dw XT_QUIT
00069d 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00069e ff03          .dw $ff03
00069f 7073
0006a0 0030          .db "sp0",0
0006a1 0690          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0006a2 3869          .dw PFA_DOVALUE1
                 PFA_SP0:
0006a3 0006          .dw USER_SP0
0006a4 06ab          .dw XT_UVALUEFETCH
0006a5 06af          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0006a6 ff02          .dw $ff02
0006a7 7073          .db "sp"
0006a8 069e          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0006a9 3852          .dw PFA_DOUSER
                 PFA_SP:
0006aa 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
0006ab 3800          .dw DO_COLON
                 PFA_UVALUEFETCH:
0006ac 3b6f          .dw XT_FETCHI
0006ad 389b          .dw XT_FETCHU
0006ae 381a          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
0006af 3800          .dw DO_COLON
                 PFA_UVALUESTORE:
0006b0 3b6f          .dw XT_FETCHI
0006b1 38a3          .dw XT_STOREU
0006b2 381a          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0006b3 ff03          .dw $ff03
0006b4 7072
0006b5 0030          .db "rp0",0
0006b6 06a6          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0006b7 3800          .dw DO_COLON
                 PFA_RP0:
0006b8 06bb          .dw XT_DORP0
0006b9 3874          .dw XT_FETCH
0006ba 381a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0006bb 3852          .dw PFA_DOUSER
                 PFA_DORP0:
0006bc 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
0006bd ff05          .dw $ff05
0006be 6564
0006bf 7470
0006c0 0068          .db "depth",0
0006c1 06b3          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0006c2 3800          .dw DO_COLON
                 PFA_DEPTH:
0006c3 06a2          .dw XT_SP0
0006c4 3a8a          .dw XT_SP_FETCH
0006c5 399c          .dw XT_MINUS
0006c6 3a0d          .dw XT_2SLASH
0006c7 3a3e          .dw XT_1MINUS
0006c8 381a          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
0006c9 ff09          .dw $ff09
0006ca 6e69
0006cb 6574
0006cc 7072
0006cd 6572
0006ce 0074          .db "interpret",0
0006cf 06bd          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
0006d0 3800          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
0006d1 05eb          .dw XT_PARSENAME ; ( -- addr len )
0006d2 38b4          .dw XT_QDUP   ; ( -- addr len len )
0006d3 395c          .dw XT_GREATERZERO
0006d4 3830          .dw XT_DOCONDBRANCH
0006d5 06f4          .dw PFA_INTERPRET5
0006d6 3837          .dw XT_DOLITERAL
0006d7 0026          .dw EE_RECOGNIZERLISTLEN
0006d8 3b5b          .dw XT_FETCHE       ; ( addr len rec # -- )
0006d9 3934          .dw XT_ZERO
                 
0006da 3aaa          .dw XT_DOQDO
0006db 06f0          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
0006dc 010c          .dw XT_2DUP ; ( -- addr len addr len  )
0006dd 3abd          .dw XT_I    ; ( -- addr len addr len i )
0006de 38dc          .dw XT_ROT  ; ( -- addr len len i addr )
0006df 38dc          .dw XT_ROT  ; ( -- addr len i addr len )
0006e0 38f3          .dw XT_TO_R
0006e1 38f3          .dw XT_TO_R
                 
0006e2 00fc          .dw XT_CELLS
0006e3 3837          .dw XT_DOLITERAL
0006e4 0028          .dw EE_RECOGNIZERLIST
0006e5 39a6          .dw XT_PLUS
0006e6 3b5b          .dw XT_FETCHE
                 
0006e7 3824          .dw XT_EXECUTE
0006e8 38ea          .dw XT_R_FROM
0006e9 38ea          .dw XT_R_FROM
0006ea 38dc          .dw XT_ROT
0006eb 3830          .dw XT_DOCONDBRANCH
0006ec 06ee          .dw PFA_INTERPRET3
0006ed 09b7            .dw XT_LEAVE
                 PFA_INTERPRET3:
0006ee 3ad8          .dw XT_DOLOOP
0006ef 06dc          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
0006f0 0115          .dw XT_2DROP
0006f1 0741          .dw XT_QSTACK
0006f2 3829          .dw XT_DOBRANCH
0006f3 06d1          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
0006f4 38d4          .dw xT_DROP
0006f5 381a          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
0006f6 ff0a          .dw $ff0a
0006f7 6572
0006f8 2d63
0006f9 6e69
0006fa 6e74
0006fb 6d75          .db "rec-intnum"
0006fc 06c9          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
0006fd 3800          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
0006fe 04e8          .dw XT_NUMBER 
0006ff 3830          .dw XT_DOCONDBRANCH 
000700 0712          .dw PFA_REC_NONUMBER
                 
000701 00ef          .dw XT_STATE
000702 3874          .dw XT_FETCH
000703 3830          .dw XT_DOCONDBRANCH
000704 070f          .dw PFA_REC_NUMBER_DONE
000705 3837      	.dw XT_DOLITERAL
000706 0002      	.dw 2
000707 3911      	.dw XT_EQUAL
000708 3830      	.dw XT_DOCONDBRANCH
000709 070c      	.dw PFA_REC_NUMBER_SINGLE
00070a 38bf      	.dw XT_SWAP
00070b 091e              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
00070c 091e              .dw XT_LITERAL
00070d 3829              .dw XT_DOBRANCH
00070e 0710              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
00070f 38d4          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000710 393d          .dw XT_TRUE
000711 381a          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000712 3934          .dw XT_ZERO
000713 381a          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000714 ff08          .dw $ff08
000715 6572
000716 2d63
000717 6966
000718 646e          .db "rec-find"
000719 06f6          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00071a 3800          .dw DO_COLON
                 PFA_REC_FIND:
00071b 0608          .dw XT_FINDNAME
00071c 38ac          .dw XT_DUP
00071d 3830          .dw XT_DOCONDBRANCH 
00071e 072d          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
00071f 395c      	.dw XT_GREATERZERO
000720 3830      	.dw XT_DOCONDBRANCH
000721 0724      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000722 3829      	    .dw XT_DOBRANCH
000723 072b      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000724 00ef      	    .dw XT_STATE
000725 3874      	    .dw XT_FETCH
000726 3830      	    .dw XT_DOCONDBRANCH
000727 072b      	    .dw PFA_REC_FIND_EXECUTE
000728 01aa      	    .dw XT_COMMA
000729 3829      	    .dw XT_DOBRANCH
00072a 072c      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
00072b 3824          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
00072c 393d          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
00072d 381a          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
00072e ff0c          .dw $ff0c
00072f 6572
000730 2d63
000731 6f6e
000732 6674
000733 756f
000734 646e          .db "rec-notfound"
000735 0714          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000736 3800          .dw DO_COLON
                 PFA_REC_NOTFOUND:
000737 041f          .dw XT_TYPE
000738 3837          .dw XT_DOLITERAL
000739 fff3          .dw -13
00073a 045b          .dw XT_THROW
00073b 381a          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
00073c ff06          .dw $ff06
00073d 733f
00073e 6174
00073f 6b63          .db "?stack"
000740 072e          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000741 3800          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
000742 06c2          .dw XT_DEPTH
000743 392d          .dw XT_LESSZERO
000744 3830          .dw XT_DOCONDBRANCH
000745 0749          .dw PFA_QSTACK1
000746 3837            .dw XT_DOLITERAL
000747 fffc            .dw -4
000748 045b            .dw XT_THROW
                 PFA_QSTACK1:
000749 381a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
00074a ff03          .dw $ff03
00074b 6576
00074c 0072          .db "ver",0
00074d 073c          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
00074e 3800          .dw DO_COLON
                 PFA_VER:
00074f 0b3b          .dw XT_ENV_FORTHNAME
000750 03c6          .dw XT_ITYPE
000751 0407          .dw XT_SPACE
000752 00f5          .dw XT_BASE
000753 3874          .dw XT_FETCH
000754 38f3          .dw XT_TO_R
000755 01cc          .dw XT_DECIMAL
                 
000756 0b49          .dw XT_ENV_FORTHVERSION
000757 3b29          .dw XT_S2D
000758 02c6          .dw XT_L_SHARP
000759 02ce          .dw XT_SHARP
00075a 3837          .dw XT_DOLITERAL
00075b 002e          .dw '.'
00075c 02b7          .dw XT_HOLD
00075d 02e4          .dw XT_SHARP_S
00075e 02ef          .dw XT_SHARP_G
00075f 38ea          .dw XT_R_FROM
000760 00f5          .dw XT_BASE
000761 387c          .dw XT_STORE
                 
000762 041f          .dw XT_TYPE
000763 0407          .dw XT_SPACE
000764 0b51          .dw XT_ENV_CPU
000765 03c6          .dw XT_ITYPE
000766 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000767 ff04          .dw $ff04
000768 6f6e
000769 706f          .db "noop"
00076a 074a          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00076b 076c          .dw PFA_NOOP
                 PFA_NOOP:
00076c 940c 3804     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00076e ff06          .dw $ff06
00076f 6e75
000770 7375
000771 6465          .db "unused"
000772 0767          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000773 3800          .dw DO_COLON
                 PFA_UNUSED:
000774 06a2          .dw XT_SP0
000775 0163          .dw XT_HERE
000776 399c          .dw XT_MINUS
000777 381a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
000778 0002          .dw $0002
000779 6f74          .db "to"
00077a 076e          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00077b 3800          .dw DO_COLON
                 PFA_TO:
00077c 042e          .dw XT_TICK
00077d 3a38          .dw XT_1PLUS  		; to body
00077e 00ef          .dw XT_STATE
00077f 3874          .dw XT_FETCH
000780 3830          .dw XT_DOCONDBRANCH
000781 078c          .dw PFA_TO1
000782 019f          .dw XT_COMPILE
000783 0786          .dw XT_DOTO
000784 01aa          .dw XT_COMMA
000785 381a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
000786 3800          .dw DO_COLON
                 PFA_DOTO:
000787 38ea          .dw XT_R_FROM
000788 38ac          .dw XT_DUP
000789 3a38          .dw XT_1PLUS
00078a 38f3          .dw XT_TO_R
00078b 3b6f          .dw XT_FETCHI
                 PFA_TO1:
00078c 38ac          .dw XT_DUP
00078d 3a38          .dw XT_1PLUS
00078e 3a38          .dw XT_1PLUS
00078f 3b6f          .dw XT_FETCHI
000790 3824          .dw XT_EXECUTE
000791 381a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000792 3800          .dw DO_COLON
                 PFA_EDEFERFETCH:
000793 3a38          .dw XT_1PLUS ; >body
000794 3b6f          .dw XT_FETCHI
000795 3b5b          .dw XT_FETCHE
000796 381a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000797 3800          .dw DO_COLON
                 PFA_EDEFERSTORE:
000798 3a38          .dw XT_1PLUS
000799 3b6f          .dw XT_FETCHI
00079a 3b37          .dw XT_STOREE
00079b 381a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00079c 3800          .dw DO_COLON
                 PFA_RDEFERFETCH:
00079d 3a38          .dw XT_1PLUS ; >body
00079e 3b6f          .dw XT_FETCHI
00079f 3874          .dw XT_FETCH
0007a0 381a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
0007a1 3800          .dw DO_COLON
                 PFA_RDEFERSTORE:
0007a2 3a38          .dw XT_1PLUS
0007a3 3b6f          .dw XT_FETCHI
0007a4 387c          .dw XT_STORE
0007a5 381a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
0007a6 3800          .dw DO_COLON
                 PFA_UDEFERFETCH:
0007a7 3a38          .dw XT_1PLUS ; >body
0007a8 3b6f          .dw XT_FETCHI
0007a9 3b17          .dw XT_UP_FETCH
0007aa 39a6          .dw XT_PLUS
0007ab 3874          .dw XT_FETCH
0007ac 381a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
0007ad 3800          .dw DO_COLON
                 PFA_UDEFERSTORE:
0007ae 3a38          .dw XT_1PLUS
0007af 3b6f          .dw XT_FETCHI
0007b0 3b17          .dw XT_UP_FETCH
0007b1 39a6          .dw XT_PLUS
0007b2 387c          .dw XT_STORE
0007b3 381a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
0007b4 ff06          .dw $ff06
0007b5 6564
0007b6 6566
0007b7 2172          .db "defer!"
0007b8 0778          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
0007b9 3800          .dw DO_COLON
                 PFA_DEFERSTORE:
0007ba 38ac          .dw XT_DUP
0007bb 3837          .dw XT_DOLITERAL
0007bc 0003          .dw 3
0007bd 39a6          .dw XT_PLUS   ; >body 2 +
0007be 3b6f          .dw XT_FETCHI
0007bf 3824          .dw XT_EXECUTE
0007c0 381a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
0007c1 ff06          .dw $ff06
0007c2 6564
0007c3 6566
0007c4 4072          .db "defer@"
0007c5 07b4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
0007c6 3800          .dw DO_COLON
                 PFA_DEFERFETCH:
0007c7 38ac          .dw XT_DUP
0007c8 3a38          .dw XT_1PLUS ; >body
0007c9 3a38          .dw XT_1PLUS 
0007ca 3b6f          .dw XT_FETCHI
0007cb 3824          .dw XT_EXECUTE
0007cc 381a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
0007cd 07ce          .dw PFA_DODEFER
                 PFA_DODEFER:
0007ce 940e 0a22     call_ DO_DODOES
0007d0 38ac          .dw XT_DUP
0007d1 3a3e          .dw XT_1MINUS
0007d2 38bf          .dw XT_SWAP
0007d3 3a38          .dw XT_1PLUS
0007d4 3b6f          .dw XT_FETCHI
0007d5 3824          .dw XT_EXECUTE 
0007d6 3824          .dw XT_EXECUTE
0007d7 381a          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0007d8 ff0f          .dw $ff0f
0007d9 6573
0007da 7261
0007db 6863
0007dc 772d
0007dd 726f
0007de 6c64
0007df 7369
0007e0 0074          .db "search-wordlist",0
0007e1 07c1          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0007e2 3800          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0007e3 3934          .dw XT_ZERO
0007e4 38bf          .dw XT_SWAP
0007e5 3837          .dw XT_DOLITERAL
0007e6 07f1          .dw XT_ISWORD
0007e7 38bf          .dw XT_SWAP
0007e8 0828          .dw XT_TRAVERSEWORDLIST
0007e9 38ac          .dw XT_DUP
0007ea 3918          .dw XT_EQUALZERO
0007eb 3830          .dw XT_DOCONDBRANCH
0007ec 07f0          .dw PFA_SEARCH_WORDLIST1
0007ed 0115             .dw XT_2DROP
0007ee 38d4             .dw XT_DROP
0007ef 3934             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
0007f0 381a          .dw XT_EXIT
                 
                 XT_ISWORD:
0007f1 3800          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
0007f2 38f3          .dw XT_TO_R
0007f3 38f3          .dw XT_TO_R
0007f4 010c          .dw XT_2DUP
0007f5 38ea          .dw XT_R_FROM
0007f6 38dc          .dw XT_ROT
0007f7 38dc          .dw XT_ROT
0007f8 38fc          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
0007f9 0817          .dw XT_NAME2STRING
0007fa 0843          .dw XT_ICOMPARE      ; (-- addr len 0 f )
0007fb 3830          .dw XT_DOCONDBRANCH
0007fc 080b          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
0007fd 0115            .dw XT_2DROP
0007fe 38d4            .dw XT_DROP
                       ; ... get the XT ...
0007ff 38fc            .dw XT_R_FETCH
000800 0bdc            .dw XT_NFA2LFA
000801 3a38            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
000802 393d            .dw XT_TRUE
000803 38ea            .dw XT_R_FROM
000804 3b6f            .dw XT_FETCHI
000805 395c            .dw XT_GREATERZERO
000806 3830            .dw XT_DOCONDBRANCH
000807 0809            .dw PFA_ISWORD1
000808 0242               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
000809 3934            .dw XT_ZERO       ; finish traverse-wordlist
00080a 381a            .dw XT_EXIT
                 PFA_ISWORD3:
00080b 38ea          .dw XT_R_FROM
00080c 38d4          .dw XT_DROP
00080d 393d          .dw XT_TRUE         ; maybe next word
00080e 381a          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
00080f ff0b          .dw $ff0b
000810 616e
000811 656d
000812 733e
000813 7274
000814 6e69
000815 0067          .db "name>string",0
000816 07d8          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000817 3800          .dw DO_COLON
                 PFA_NAME2STRING:
000818 03f1          .dw XT_ICOUNT   ; ( -- addr n )
000819 3837          .dw XT_DOLITERAL
00081a 00ff          .dw $00FF
00081b 3a1c          .dw XT_AND      ; mask immediate bit
00081c 381a          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
00081d ff11          .dw $ff11
00081e 7274
00081f 7661
000820 7265
000821 6573
000822 772d
000823 726f
000824 6c64
000825 7369
000826 0074          .db "traverse-wordlist",0
000827 080f          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000828 3800          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
000829 3b5b          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00082a 38ac          .dw XT_DUP           ; ( -- xt nt nt )
00082b 3830          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00082c 083b          .dw PFA_TRAVERSEWORDLIST2       ;
00082d 010c          .dw XT_2DUP
00082e 38f3          .dw XT_TO_R
00082f 38f3          .dw XT_TO_R
000830 38bf          .dw XT_SWAP
000831 3824          .dw XT_EXECUTE
000832 38ea          .dw XT_R_FROM
000833 38ea          .dw XT_R_FROM
000834 38dc          .dw XT_ROT
000835 3830          .dw XT_DOCONDBRANCH
000836 083b          .dw PFA_TRAVERSEWORDLIST2
000837 0bdc          .dw XT_NFA2LFA
000838 3b6f          .dw XT_FETCHI        ; ( -- addr )
000839 3829          .dw XT_DOBRANCH      ; ( -- addr )
00083a 082a          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00083b 0115          .dw XT_2DROP
00083c 381a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
00083d ff08          .dw $ff08
00083e 6369
00083f 6d6f
000840 6170
000841 6572          .db "icompare"
000842 081d          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000843 3800          .dw DO_COLON
                 PFA_ICOMPARE:
000844 38f3          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000845 38ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000846 38ea          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000847 3907          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000848 3830          .dw XT_DOCONDBRANCH
000849 084e          .dw PFA_ICOMPARE_SAMELEN
00084a 0115            .dw XT_2DROP
00084b 38d4            .dw XT_DROP
00084c 3934            .dw XT_ZERO
00084d 381a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00084e 38bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
00084f 3934          .dw XT_ZERO
000850 3aaa          .dw XT_DOQDO
000851 086f          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000852 38ca          .dw XT_OVER
000853 3874          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000854 38ca          .dw XT_OVER
000855 3b6f          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000856 38ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000857 3837          .dw XT_DOLITERAL
000858 0100          .dw $100
000859 3946          .dw XT_ULESS
00085a 3830          .dw XT_DOCONDBRANCH
00085b 0860          .dw PFA_ICOMPARE_LASTCELL
00085c 38bf          .dw XT_SWAP
00085d 3837          .dw XT_DOLITERAL
00085e 00ff          .dw $00FF
00085f 3a1c          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000860 3907          .dw XT_NOTEQUAL
000861 3830          .dw XT_DOCONDBRANCH
000862 0867          .dw PFA_ICOMPARE_NEXTLOOP
000863 0115          .dw XT_2DROP
000864 3934          .dw XT_ZERO
000865 3ae7          .dw XT_UNLOOP
000866 381a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000867 3a38          .dw XT_1PLUS
000868 38bf          .dw XT_SWAP
000869 0104          .dw XT_CELLPLUS
00086a 38bf          .dw XT_SWAP
00086b 3837          .dw XT_DOLITERAL
00086c 0002          .dw 2
00086d 3abe          .dw XT_DOPLUSLOOP
00086e 0852          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00086f 0115          .dw XT_2DROP
000870 393d          .dw XT_TRUE
000871 381a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000872 ff01          .dw $ff01
000873 002a          .db "*",0
000874 083d          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000875 3800          .dw DO_COLON
                 PFA_STAR:
000876 39af          .dw XT_MSTAR
000877 0887          .dw XT_D2S
000878 381a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000879 ff01          .dw $FF01
00087a 006a          .db "j",0
00087b 0872          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00087c 3800          .dw DO_COLON
                 PFA_J:
00087d 3a73          .dw XT_RP_FETCH
00087e 3837          .dw XT_DOLITERAL
00087f 0009          .dw 9
000880 39a6          .dw XT_PLUS
000881 3874          .dw XT_FETCH
000882 381a          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000883 ff03          .dw $ff03
000884 3e64
000885 0073          .db "d>s",0
000886 0879          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
000887 3800          .dw DO_COLON
                 PFA_D2S:
000888 38d4          .dw XT_DROP
000889 381a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00088a ff04          .dw $ff04
00088b 6164
00088c 7362          .db "dabs"
00088d 0883          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00088e 3800          .dw DO_COLON
                 PFA_DABS:
00088f 38ac          .dw XT_DUP
000890 392d          .dw XT_LESSZERO
000891 3830          .dw XT_DOCONDBRANCH
000892 0894          .dw PFA_DABS1
000893 089b          .dw XT_DNEGATE
                 PFA_DABS1:
000894 381a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000895 ff07          .dw $ff07
000896 6e64
000897 6765
000898 7461
000899 0065          .db "dnegate",0
00089a 088a          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00089b 3800          .dw DO_COLON
                 PFA_DNEGATE:
00089c 0cf6          .dw XT_DINVERT
00089d 3837          .dw XT_DOLITERAL
00089e 0001          .dw 1
00089f 3934          .dw XT_ZERO
0008a0 0cce          .dw XT_DPLUS
0008a1 381a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
0008a2 ff05          .dw $ff05
0008a3 6d63
0008a4 766f
0008a5 0065          .db "cmove",0
0008a6 0895          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
0008a7 08a8          .dw PFA_CMOVE
                 PFA_CMOVE:
0008a8 93bf          push xh
0008a9 93af          push xl
0008aa 91e9          ld zl, Y+
0008ab 91f9          ld zh, Y+ ; addr-to
0008ac 91a9          ld xl, Y+
0008ad 91b9          ld xh, Y+ ; addr-from
0008ae 2f09          mov temp0, tosh
0008af 2b08          or temp0, tosl
0008b0 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
0008b1 911d          ld temp1, X+
0008b2 9311          st Z+, temp1
0008b3 9701          sbiw tosl, 1
0008b4 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
0008b5 91af          pop xl
0008b6 91bf          pop xh
0008b7 9189
0008b8 9199          loadtos
0008b9 940c 3804     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
0008bb ff05          .dw $ff05
0008bc 7332
0008bd 6177
0008be 0070          .db "2swap",0
0008bf 08a2          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
0008c0 3800          .dw DO_COLON
                 PFA_2SWAP:
0008c1 38dc          .dw XT_ROT
0008c2 38f3          .dw XT_TO_R
0008c3 38dc          .dw XT_ROT
0008c4 38ea          .dw XT_R_FROM
0008c5 381a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
0008c6 ff03          .dw $ff03
0008c7 6974
0008c8 0062          .db "tib",0
0008c9 08bb          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0008ca 3842          .dw PFA_DOVARIABLE
                 PFA_TIB:
0008cb 017b          .dw ram_tib
                     
                 .dseg
00017b           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
0008cc ff0a          .dw $ff0a
0008cd 6572
0008ce 6966
0008cf 6c6c
0008d0 742d
0008d1 6269          .db "refill-tib"
0008d2 08c6          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
0008d3 3800          .dw DO_COLON
                 PFA_REFILLTIB:
0008d4 08ca          .dw XT_TIB
0008d5 3837          .dw XT_DOLITERAL
0008d6 0064          .dw TIBSIZE
0008d7 048c          .dw XT_ACCEPT
0008d8 0123          .dw XT_NUMBERTIB
0008d9 387c          .dw XT_STORE
0008da 3934          .dw XT_ZERO
0008db 011d          .dw XT_G_IN
0008dc 387c          .dw XT_STORE
0008dd 3837          .dw XT_DOLITERAL
0008de ffff          .dw -1
0008df 381a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0008e0 ff0a          .dw $FF0A
0008e1 6f73
0008e2 7275
0008e3 6563
0008e4 742d
0008e5 6269          .db "source-tib"
0008e6 08cc          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0008e7 3800          .dw DO_COLON
                 PFA_SOURCETIB:
0008e8 08ca          .dw XT_TIB
0008e9 0123          .dw XT_NUMBERTIB
0008ea 3874          .dw XT_FETCH
0008eb 381a          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0008ec ff07        .dw $ff07
0008ed 6565
0008ee 752d
0008ef 6573
0008f0 0072        .db "ee-user",0
0008f1 08e0        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
0008f2 3842        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
0008f3 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0008f4 ff06        .dw $ff06
0008f5 6565
0008f6 723e
0008f7 6d61        .db "ee>ram"
0008f8 08ec        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0008f9 3800        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0008fa 3934          .dw XT_ZERO
0008fb 3aaa          .dw XT_DOQDO
0008fc 0907          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
0008fd 38ca          .dw XT_OVER
0008fe 3b5b          .dw XT_FETCHE
0008ff 38ca          .dw XT_OVER
000900 387c          .dw XT_STORE
000901 0104          .dw XT_CELLPLUS
000902 38bf          .dw XT_SWAP
000903 0104          .dw XT_CELLPLUS
000904 38bf          .dw XT_SWAP
000905 3ad8          .dw XT_DOLOOP
000906 08fd          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000907 0115          .dw XT_2DROP
000908 381a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000909 ff09        .dw $ff09
00090a 6e69
00090b 7469
00090c 752d
00090d 6573
00090e 0072        .db "init-user",0
00090f 08f4        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000910 3800        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000911 08f2          .dw XT_EEUSER
000912 3b17          .dw XT_UP_FETCH
000913 3837          .dw XT_DOLITERAL
000914 001c          .dw SYSUSERSIZE
000915 3a0d          .dw XT_2SLASH
000916 08f9          .dw XT_EE2RAM
000917 381a          .dw XT_EXIT
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
000918 0007          .dw $0007
000919 696c
00091a 6574
00091b 6172
00091c 006c          .db "literal",0
00091d 0909          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
00091e 3800          .dw DO_COLON
                 PFA_LITERAL:
00091f 019f          .dw XT_COMPILE
000920 3837          .dw XT_DOLITERAL
000921 01aa          .dw XT_COMMA
000922 381a          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000923 0008        .dw $0008
000924 6c73
000925 7469
000926 7265
000927 6c61        .db "sliteral"
000928 0918        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000929 3800          .dw DO_COLON
                 PFA_SLITERAL:
00092a 019f          .dw XT_COMPILE
00092b 038f          .dw XT_DOSLITERAL    ; ( -- addr n)
00092c 03a2          .dw XT_SCOMMA
00092d 381a          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
00092e 3800          .dw DO_COLON
                 PFA_GMARK:
00092f 0153          .dw XT_DP
000930 019f          .dw XT_COMPILE
000931 ffff          .dw -1           ; ffff does not erase flash
000932 381a          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000933 3800          .dw DO_COLON
                 PFA_GRESOLVE:
000934 0741          .dw XT_QSTACK
000935 0153          .dw XT_DP
000936 38bf          .dw XT_SWAP
000937 3b79          .dw XT_STOREI
000938 381a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000939 3800          .dw DO_COLON
                 PFA_LMARK:
00093a 0153          .dw XT_DP
00093b 381a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00093c 3800          .dw DO_COLON
                 PFA_LRESOLVE:
00093d 0741          .dw XT_QSTACK
00093e 01aa          .dw XT_COMMA
00093f 381a          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000940 0005          .dw $0005
000941 6861
000942 6165
000943 0064          .db "ahead",0
000944 0923          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000945 3800          .dw DO_COLON
                 PFA_AHEAD:
000946 019f          .dw XT_COMPILE
000947 3829          .dw XT_DOBRANCH
000948 092e          .dw XT_GMARK
000949 381a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
00094a 0002          .dw $0002
00094b 6669          .db "if"
00094c 0940          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
00094d 3800          .dw DO_COLON
                 PFA_IF:
00094e 019f          .dw XT_COMPILE
00094f 3830          .dw XT_DOCONDBRANCH
000950 092e          .dw XT_GMARK
000951 381a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000952 0004          .dw $0004
000953 6c65
000954 6573          .db "else"
000955 094a          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000956 3800          .dw DO_COLON
                 PFA_ELSE:
000957 019f          .dw XT_COMPILE
000958 3829          .dw XT_DOBRANCH
000959 092e          .dw XT_GMARK
00095a 38bf          .dw XT_SWAP
00095b 0933          .dw XT_GRESOLVE
00095c 381a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
00095d 0004          .dw $0004
00095e 6874
00095f 6e65          .db "then"
000960 0952          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000961 3800          .dw DO_COLON
                 PFA_THEN:
000962 0933          .dw XT_GRESOLVE
000963 381a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000964 0005          .dw $0005
000965 6562
000966 6967
000967 006e          .db "begin",0
000968 095d          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000969 3800          .dw DO_COLON
                 PFA_BEGIN:
00096a 0939          .dw XT_LMARK
00096b 381a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
00096c 0005          .dw $0005
00096d 6877
00096e 6c69
00096f 0065          .db "while",0
000970 0964          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000971 3800          .dw DO_COLON
                 PFA_WHILE:
000972 019f          .dw XT_COMPILE
000973 3830          .dw XT_DOCONDBRANCH
000974 092e          .dw XT_GMARK
000975 38bf          .dw XT_SWAP
000976 381a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
000977 0006          .dw $0006
000978 6572
000979 6570
00097a 7461          .db "repeat"
00097b 096c          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
00097c 3800          .dw DO_COLON
                 PFA_REPEAT:
00097d 098f          .dw XT_AGAIN
00097e 0933          .dw XT_GRESOLVE
00097f 381a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000980 0005          .dw $0005
000981 6e75
000982 6974
000983 006c          .db "until",0
000984 0977          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000985 3800          .dw DO_COLON
                 PFA_UNTIL:
000986 019f          .dw XT_COMPILE
000987 3830          .dw XT_DOCONDBRANCH
000988 093c          .dw XT_LRESOLVE
000989 381a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
00098a 0005          .dw $0005
00098b 6761
00098c 6961
00098d 006e          .db "again",0
00098e 0980          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00098f 3800          .dw DO_COLON
                 PFA_AGAIN:
000990 019f          .dw XT_COMPILE
000991 3829          .dw XT_DOBRANCH
000992 093c          .dw XT_LRESOLVE
000993 381a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
000994 0002          .dw $0002
000995 6f64          .db "do"
000996 098a          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000997 3800          .dw DO_COLON
                 PFA_DO:
000998 019f          .dw XT_COMPILE
000999 3a98          .dw XT_DODO
00099a 092e          .dw XT_GMARK
00099b 0939          .dw XT_LMARK
00099c 381a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
00099d 0004          .dw $0004
00099e 6f6c
00099f 706f          .db "loop"
0009a0 0994          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0009a1 3800          .dw DO_COLON
                 PFA_LOOP:
0009a2 019f          .dw XT_COMPILE
0009a3 3ad8          .dw XT_DOLOOP
0009a4 093c          .dw XT_LRESOLVE
0009a5 0933          .dw XT_GRESOLVE
0009a6 381a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
0009a7 0005          .dw $0005
0009a8 6c2b
0009a9 6f6f
0009aa 0070          .db "+loop",0
0009ab 099d          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0009ac 3800          .dw DO_COLON
                 PFA_PLUSLOOP:
0009ad 019f          .dw XT_COMPILE
0009ae 3abe          .dw XT_DOPLUSLOOP
0009af 093c          .dw XT_LRESOLVE
0009b0 0933          .dw XT_GRESOLVE
0009b1 381a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
0009b2 ff05         .dw $FF05
0009b3 656c
0009b4 7661
0009b5 0065         .db "leave",0
0009b6 09a7         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0009b7 09b8          .dw PFA_LEAVE
                 PFA_LEAVE:
0009b8 910f          pop temp0  ; drop limit and counter from returnstack
0009b9 911f          pop temp1
0009ba 910f          pop temp0
0009bb 911f          pop temp1
0009bc 91af          pop xl
0009bd 91bf          pop xh
0009be 940c 3804     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
0009c0 0003          .dw $0003
0009c1 643f
0009c2 006f          .db "?do",0
0009c3 09b2          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0009c4 3800          .dw DO_COLON
                 PFA_QDO:
0009c5 019f          .dw XT_COMPILE
0009c6 3aaa          .dw XT_DOQDO
0009c7 092e          .dw XT_GMARK
0009c8 0939          .dw XT_LMARK
0009c9 381a          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0009ca ff06          .dw $ff06
0009cb 7263
0009cc 6165
0009cd 6574          .db "create"
0009ce 09c0          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0009cf 3800          .dw DO_COLON
                 PFA_CREATE:
0009d0 0178          .dw XT_DOCREATE
0009d1 09fe          .dw XT_REVEAL
0009d2 019f          .dw XT_COMPILE
0009d3 384c          .dw PFA_DOCONSTANT
0009d4 381a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0009d5 ff06          .dw $ff06
0009d6 6568
0009d7 6461
0009d8 7265          .db "header"
0009d9 09ca          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0009da 3800          .dw DO_COLON
                 PFA_HEADER:
0009db 0153          .dw XT_DP           ; the new Name Field
0009dc 38f3          .dw XT_TO_R
0009dd 38f3          .dw XT_TO_R		; ( R: NFA WID )
0009de 38ac          .dw XT_DUP    
0009df 395c          .dw XT_GREATERZERO 
0009e0 3830          .dw XT_DOCONDBRANCH
0009e1 09ec          .dw PFA_HEADER1
0009e2 38ac          .dw XT_DUP
0009e3 3837          .dw XT_DOLITERAL
0009e4 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0009e5 3a25          .dw XT_OR
0009e6 03a6          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0009e7 38ea          .dw XT_R_FROM
0009e8 3b5b          .dw XT_FETCHE
0009e9 01aa          .dw XT_COMMA
0009ea 38ea          .dw XT_R_FROM
0009eb 381a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0009ec 3837          .dw XT_DOLITERAL
0009ed fff0          .dw -16
0009ee 045b          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0009ef ff07          .dw $ff07
0009f0 6c77
0009f1 6373
0009f2 706f
0009f3 0065          .db "wlscope",0
0009f4 09d5          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0009f5 07ce          .dw PFA_DODEFER
                 PFA_WLSCOPE:
0009f6 0034          .dw EE_WLSCOPE
0009f7 0792          .dw XT_EDEFERFETCH
0009f8 0797          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0009f9 ff06          .dw $ff06
0009fa 6572
0009fb 6576
0009fc 6c61          .db "reveal"
0009fd 09ef          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0009fe 3800          .dw DO_COLON
                 PFA_REVEAL:
0009ff 3837          .dw XT_DOLITERAL
000a00 014d          .dw COLON_SMUDGE+0
000a01 3874          .dw XT_FETCH
000a02 38b4          .dw XT_QDUP
000a03 3830          .dw XT_DOCONDBRANCH
000a04 0a0d          .dw PFA_REVEAL1
                 ;
000a05 3837          .dw XT_DOLITERAL
000a06 014f          .dw COLON_SMUDGE+2
000a07 3874          .dw XT_FETCH		; ( NFA WID )
000a08 3b37          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000a09 3934          .dw XT_ZERO
000a0a 3837          .dw XT_DOLITERAL
000a0b 014d          .dw COLON_SMUDGE+0
000a0c 387c          .dw XT_STORE
                 PFA_REVEAL1:
000a0d 381a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000a0e ff06          .dw $ff06
000a0f 616c
000a10 6574
000a11 7473          .db "latest"
000a12 09f9          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000a13 3842          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000a14 01df          .dw ram_LATEST
                 
                 .dseg
0001df           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000a15 0005          .dw $0005
000a16 6f64
000a17 7365
000a18 003e          .db "does>",0
000a19 0a0e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000a1a 3800          .dw DO_COLON
                 PFA_DOES:
000a1b 019f          .dw XT_COMPILE
000a1c 0a2d          .dw XT_DODOES
000a1d 019f          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000a1e 940e          .dw $940e       ; the address of this compiled
000a1f 019f          .dw XT_COMPILE  ; code will replace the XT of the 
000a20 0a22          .dw DO_DODOES   ; word that CREATE created
000a21 381a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000a22 939a
000a23 938a          savetos
000a24 01cb          movw tosl, wl
000a25 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000a26 917f          pop wh
000a27 916f          pop wl
                 
000a28 93bf          push XH
000a29 93af          push XL
000a2a 01db          movw XL, wl
000a2b 940c 3804     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000a2d 3800          .dw DO_COLON
                 PFA_DODOES:
000a2e 38ea          .dw XT_R_FROM
000a2f 3837          .dw XT_DOLITERAL
000a30 014f          .dw COLON_SMUDGE+2
000a31 3874          .dw XT_FETCH
000a32 3b5b          .dw XT_FETCHE
000a33 0bdc          .dw XT_NFA2LFA
000a34 3a38          .dw XT_1PLUS   ; lfa>xt
                 
000a35 3b79          .dw XT_STOREI
000a36 381a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000a37 ff01          .dw $ff01
000a38 003a          .db ":",0
000a39 0a15          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000a3a 3800          .dw DO_COLON
                 PFA_COLON:
000a3b 0178          .dw XT_DOCREATE
000a3c 0153          .dw XT_DP
000a3d 0a13          .dw XT_LATEST
000a3e 387c          .dw XT_STORE
000a3f 019f          .dw XT_COMPILE
000a40 3800          .dw DO_COLON
000a41 0a5e          .dw XT_RBRACKET
000a42 381a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000a43 ff07          .dw $ff07
000a44 6e3a
000a45 6e6f
000a46 6d61
000a47 0065          .db ":noname",0
000a48 0a37          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000a49 3800          .dw DO_COLON
                 PFA_COLONNONAME:
000a4a 0153          .dw XT_DP
000a4b 38ac          .dw XT_DUP
000a4c 0a13          .dw XT_LATEST
000a4d 387c          .dw XT_STORE
                 
000a4e 019f          .dw XT_COMPILE
000a4f 3800          .dw DO_COLON
                 
000a50 0a5e          .dw XT_RBRACKET
000a51 381a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000a52 0001          .dw $0001
000a53 003b          .db $3b,0
000a54 0a43          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000a55 3800          .dw DO_COLON
                 PFA_SEMICOLON:
000a56 019f          .dw XT_COMPILE
000a57 381a          .dw XT_EXIT
000a58 0a67          .dw XT_LBRACKET
000a59 09fe          .dw XT_REVEAL
000a5a 381a          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000a5b ff01          .dw $ff01
000a5c 005d          .db "]",0
000a5d 0a52          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000a5e 3800          .dw DO_COLON
                 PFA_RBRACKET:
000a5f 3837          .dw XT_DOLITERAL
000a60 0001          .dw 1
000a61 00ef          .dw XT_STATE
000a62 387c          .dw XT_STORE
000a63 381a          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000a64 0001          .dw $0001
000a65 005b          .db "[",0
000a66 0a5b          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000a67 3800          .dw DO_COLON
                 PFA_LBRACKET:
000a68 3934          .dw XT_ZERO
000a69 00ef          .dw XT_STATE
000a6a 387c          .dw XT_STORE
000a6b 381a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000a6c ff08          .dw $ff08
000a6d 6176
000a6e 6972
000a6f 6261
000a70 656c          .db "variable"
000a71 0a64          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000a72 3800          .dw DO_COLON
                 PFA_VARIABLE:
000a73 0163          .dw XT_HERE
000a74 0a7f          .dw XT_CONSTANT
000a75 3837          .dw XT_DOLITERAL
000a76 0002          .dw 2
000a77 016c          .dw XT_ALLOT
000a78 381a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000a79 ff08          .dw $ff08
000a7a 6f63
000a7b 736e
000a7c 6174
000a7d 746e          .db "constant"
000a7e 0a6c          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000a7f 3800          .dw DO_COLON
                 PFA_CONSTANT:
000a80 0178          .dw XT_DOCREATE
000a81 09fe          .dw XT_REVEAL
000a82 019f          .dw XT_COMPILE
000a83 3842          .dw PFA_DOVARIABLE
000a84 01aa          .dw XT_COMMA
000a85 381a          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000a86 ff04          .dw $ff04
000a87 7375
000a88 7265          .db "user"
000a89 0a79          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000a8a 3800          .dw DO_COLON
                 PFA_USER:
000a8b 0178          .dw XT_DOCREATE
000a8c 09fe          .dw XT_REVEAL
                 
000a8d 019f          .dw XT_COMPILE
000a8e 3852          .dw PFA_DOUSER
000a8f 01aa          .dw XT_COMMA
000a90 381a          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000a91 ff05          .dw $ff05
000a92 6176
000a93 756c
000a94 0065          .db "value",0
000a95 0a86          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000a96 3800          .dw DO_COLON
                 PFA_VALUE:
000a97 3863          .dw XT_DOVALUE
000a98 015b          .dw XT_EDP
000a99 01aa          .dw XT_COMMA
000a9a 019f          .dw XT_COMPILE
000a9b 0aa6          .dw XT_EVALUEFETCH
000a9c 019f          .dw XT_COMPILE
000a9d 0aaa          .dw XT_EVALUESTORE
000a9e 015b          .dw XT_EDP
000a9f 38ac          .dw XT_DUP
000aa0 3a38          .dw XT_1PLUS
000aa1 3a38          .dw XT_1PLUS
000aa2 0786          .dw XT_DOTO
000aa3 015c          .dw PFA_EDP
000aa4 3b37          .dw XT_STOREE
000aa5 381a          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000aa6 3800          .dw DO_COLON
                 PFA_EVALUEFETCH:
000aa7 3b6f          .dw XT_FETCHI
000aa8 3b5b          .dw XT_FETCHE
000aa9 381a          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000aaa 3800          .dw DO_COLON
                 PFA_EVALUESTORE:
000aab 3b6f          .dw XT_FETCHI
000aac 3b37          .dw XT_STOREE
000aad 381a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000aae 0007          .dw $0007
000aaf 6572
000ab0 7563
000ab1 7372
000ab2 0065          .db "recurse",0
000ab3 0a91          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000ab4 3800          .dw DO_COLON
                 PFA_RECURSE:
000ab5 0a13          .dw XT_LATEST
000ab6 3874          .dw XT_FETCH
000ab7 01aa          .dw XT_COMMA
000ab8 381a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000ab9 ff09          .dw $ff09
000aba 6d69
000abb 656d
000abc 6964
000abd 7461
000abe 0065          .db "immediate",0
000abf 0aae          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000ac0 3800          .dw DO_COLON
                 PFA_IMMEDIATE:
000ac1 0b9d          .dw XT_GET_CURRENT
000ac2 3b5b          .dw XT_FETCHE
000ac3 38ac          .dw XT_DUP
000ac4 3b6f          .dw XT_FETCHI
000ac5 3837          .dw XT_DOLITERAL
000ac6 7fff          .dw $7fff
000ac7 3a1c          .dw XT_AND
000ac8 38bf          .dw XT_SWAP
000ac9 3b79          .dw XT_STOREI
000aca 381a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000acb 0006          .dw $0006
000acc 635b
000acd 6168
000ace 5d72          .db "[char]"
000acf 0ab9          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000ad0 3800          .dw DO_COLON
                 PFA_BRACKETCHAR:
000ad1 019f          .dw XT_COMPILE
000ad2 3837          .dw XT_DOLITERAL
000ad3 04de          .dw XT_CHAR
000ad4 01aa          .dw XT_COMMA
000ad5 381a          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000ad6 0006          .dw $0006
000ad7 6261
000ad8 726f
000ad9 2274          .db "abort", $22
000ada 0acb          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000adb 3800          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000adc 019f          .dw XT_COMPILE
000add 3830          .dw XT_DOCONDBRANCH
000ade 0153          .dw XT_DP
000adf 019f          .dw XT_COMPILE
000ae0 ffff          .dw -1
                     
000ae1 0d2d          .dw XT_DOTSTRING
                     
000ae2 019f          .dw XT_COMPILE
000ae3 3837          .dw XT_DOLITERAL
                     
000ae4 019f          .dw XT_COMPILE
000ae5 fffe          .dw -2
000ae6 019f          .dw XT_COMPILE
000ae7 045b          .dw XT_THROW
                     ; then
000ae8 0153          .dw XT_DP
000ae9 38bf          .dw XT_SWAP
000aea 3b79          .dw XT_STOREI
000aeb 381a          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000aec ff05          .dw $ff05
000aed 6261
000aee 726f
000aef 0074          .db "abort",0
000af0 0ad6          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000af1 3800          .dw DO_COLON
                 PFA_ABORT:
000af2 3837          .dw XT_DOLITERAL
000af3 ffff          .dw -1
000af4 045b          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000af5 ff04          .dw $ff04
000af6 6f63
000af7 6564          .db "code"
000af8 0aec          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000af9 3800          .dw DO_COLON
                 PFA_CODE:
000afa 0178          .dw XT_DOCREATE
000afb 09fe          .dw XT_REVEAL
000afc 0153          .dw XT_DP
000afd 3a38          .dw XT_1PLUS
000afe 01aa          .dw XT_COMMA
000aff 381a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000b00 ff08          .dw $ff08
000b01 6e65
000b02 2d64
000b03 6f63
000b04 6564          .db "end-code"
000b05 0af5          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000b06 3800          .dw DO_COLON
                 PFA_ENDCODE:
000b07 019f          .dw XT_COMPILE
000b08 940c          .dw $940c
000b09 019f          .dw XT_COMPILE
000b0a 3804          .dw DO_NEXT
000b0b 381a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000b0c ff0b          .dw $ff0b
000b0d 6e65
000b0e 6976
000b0f 6f72
000b10 6d6e
000b11 6e65
000b12 0074          .db "environment",0
000b13 0b00          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000b14 3842          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000b15 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000b16 ff09          .dw $ff09
000b17 6f77
000b18 6472
000b19 696c
000b1a 7473
000b1b 0073          .db "wordlists",0
000b1c 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000b1d 3800          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000b1e 3837          .dw XT_DOLITERAL
000b1f 0008          .dw NUMWORDLISTS
000b20 381a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000b21 ff04          .dw $ff04
000b22 702f
000b23 6461          .db "/pad"
000b24 0b16          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000b25 3800          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000b26 3a8a          .dw XT_SP_FETCH
000b27 0129          .dw XT_PAD
000b28 399c          .dw XT_MINUS
000b29 381a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000b2a ff05          .dw $ff05
000b2b 682f
000b2c 6c6f
000b2d 0064          .db "/hold",0
000b2e 0b21          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000b2f 3800          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000b30 0129          .dw XT_PAD
000b31 0163          .dw XT_HERE
000b32 399c          .dw XT_MINUS
000b33 381a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000b34 ff0a          .dw $ff0a
000b35 6f66
000b36 7472
000b37 2d68
000b38 616e
000b39 656d          .db "forth-name"
000b3a 0b2a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000b3b 3800          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000b3c 038f          .dw XT_DOSLITERAL
000b3d 0007          .dw 7
000b3e 6d61
000b3f 6f66
000b40 7472
000b41 0068          .db "amforth",0
000b42 381a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000b43 ff07          .dw $ff07
000b44 6576
000b45 7372
000b46 6f69
000b47 006e          .db "version",0
000b48 0b34          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000b49 3800          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000b4a 3837          .dw XT_DOLITERAL
000b4b 0034          .dw 52
000b4c 381a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000b4d ff03          .dw $ff03
000b4e 7063
000b4f 0075          .db "cpu",0
000b50 0b43          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000b51 3800          .dw DO_COLON
                 PFA_EN_CPU:
000b52 3837          .dw XT_DOLITERAL
000b53 0037          .dw mcu_name
000b54 03f1          .dw XT_ICOUNT
000b55 381a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000b56 ff08          .dw $ff08
000b57 636d
000b58 2d75
000b59 6e69
000b5a 6f66          .db "mcu-info"
000b5b 0b4d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000b5c 3800          .dw DO_COLON
                 PFA_EN_MCUINFO:
000b5d 3837          .dw XT_DOLITERAL
000b5e 0033          .dw mcu_info
000b5f 381a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000b60 ff05          .dw $ff05
000b61 752f
000b62 6573
000b63 0072          .db "/user",0
000b64 0b56          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000b65 3800          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000b66 3837          .dw XT_DOLITERAL
000b67 0026          .dw SYSUSERSIZE + APPUSERSIZE
000b68 381a          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000b69 ff04          .dw $ff04
000b6a 6540
000b6b 5d5b          .db "@e[]"
000b6c 0b0c          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000b6d 3800          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000b6e 38ac          .dw XT_DUP
000b6f 3b5b          .dw XT_FETCHE
000b70 38f3          .dw XT_TO_R    ; save the counter to r-stack
000b71 38fc          .dw XT_R_FETCH
000b72 3934          .dw XT_ZERO
000b73 38bf          .dw XT_SWAP    ; go from bigger to smaller addresses
000b74 3aaa          .dw XT_DOQDO
000b75 0b7f          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000b76 3abd          .dw XT_I
000b77 00fc          .dw XT_CELLS ; ( -- ee-addr i*2 )
000b78 38ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000b79 39a6          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000b7a 3b5b          .dw XT_FETCHE ;( -- ee-addr item_i )
000b7b 38bf          .dw XT_SWAP   ;( -- item_i ee-addr )
000b7c 393d          .dw XT_TRUE  ; shortcut for -1
000b7d 3abe          .dw XT_DOPLUSLOOP
000b7e 0b76          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000b7f 0115          .dw XT_2DROP
000b80 38ea          .dw XT_R_FROM ; get the counter from r-stack
000b81 381a          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000b82 ff04          .dw $ff04
000b83 6521
000b84 5d5b          .db "!e[]"
000b85 0b69          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000b86 3800          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000b87 010c          .dw XT_2DUP
000b88 3b37          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000b89 38bf          .dw XT_SWAP    
000b8a 3934          .dw XT_ZERO
000b8b 3aaa          .dw XT_DOQDO
000b8c 0b93          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000b8d 0104          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000b8e 38bf          .dw XT_SWAP
000b8f 38ca          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000b90 3b37          .dw XT_STOREE
000b91 3ad8          .dw XT_DOLOOP
000b92 0b8d          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000b93 38d4          .dw XT_DROP
000b94 381a          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000b95 ff0b          .dw $ff0b
000b96 6567
000b97 2d74
000b98 7563
000b99 7272
000b9a 6e65
000b9b 0074          .db "get-current",0
000b9c 0b82          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000b9d 3800          .dw DO_COLON
                 PFA_GET_CURRENT:
000b9e 3837          .dw XT_DOLITERAL
000b9f 0010          .dw EE_CURRENT
000ba0 3b5b          .dw XT_FETCHE
000ba1 381a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000ba2 ff09          .dw $ff09
000ba3 6567
000ba4 2d74
000ba5 726f
000ba6 6564
000ba7 0072          .db "get-order",0
000ba8 0b95          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000ba9 3800          .dw DO_COLON
                 PFA_GET_ORDER:
000baa 3837          .dw XT_DOLITERAL
000bab 0014          .dw EE_ORDERLISTLEN
000bac 0b6d          .dw XT_FETCH_EE_ARRAY
000bad 381a          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000bae ff07          .dw $ff07
000baf 6f63
000bb0 706d
000bb1 7261
000bb2 0065          .db "compare",0
000bb3 0ba2          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000bb4 0bb5          .dw PFA_COMPARE
                 PFA_COMPARE:
000bb5 93bf          push xh
000bb6 93af          push xl
000bb7 018c          movw temp0, tosl
000bb8 9189
000bb9 9199          loadtos
000bba 01dc          movw xl, tosl
000bbb 9189
000bbc 9199          loadtos
000bbd 019c          movw temp2, tosl
000bbe 9189
000bbf 9199          loadtos
000bc0 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000bc1 90ed          ld temp4, X+
000bc2 90f1          ld temp5, Z+
000bc3 14ef          cp temp4, temp5
000bc4 f451          brne PFA_COMPARE_NOTEQUAL
000bc5 950a          dec temp0
000bc6 f019          breq PFA_COMPARE_ENDREACHED2
000bc7 952a          dec temp2
000bc8 f7c1          brne PFA_COMPARE_LOOP
000bc9 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000bca 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000bcb 2b02          or temp0, temp2
000bcc f411          brne PFA_COMPARE_CHECKLASTCHAR
000bcd 2788          clr tosl
000bce c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000bcf ef8f          ser tosl
000bd0 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000bd1 2f98          mov tosh, tosl
000bd2 91af          pop xl
000bd3 91bf          pop xh
000bd4 940c 3804     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000bd6 ff07         .dw $ff07
000bd7 666e
000bd8 3e61
000bd9 666c
000bda 0061         .db "nfa>lfa",0
000bdb 0bae         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000bdc 3800          .dw DO_COLON
                 PFA_NFA2LFA:
000bdd 03f1          .dw XT_ICOUNT 
000bde 3837          .dw XT_DOLITERAL
000bdf 00ff          .dw $00ff
000be0 3a1c          .dw XT_AND
000be1 3a38          .dw XT_1PLUS
000be2 3a0d          .dw XT_2SLASH
000be3 39a6          .dw XT_PLUS
000be4 381a          .dw XT_EXIT
                 .include "dict_wl.inc"
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000be5 ff0b          .dw $ff0b
000be6 6573
000be7 2d74
000be8 7563
000be9 7272
000bea 6e65
000beb 0074          .db "set-current",0
000bec 0bd6          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000bed 3800          .dw DO_COLON
                 PFA_SET_CURRENT:
000bee 3837          .dw XT_DOLITERAL
000bef 0010          .dw EE_CURRENT
000bf0 3b37          .dw XT_STOREE
000bf1 381a          .dw XT_EXIT
                 .include "words/previous.asm"
                 
                 ; Search Order
                 ; remove the first entry in the search order list
                 VE_PREVIOUS:
000bf2 ff08          .dw $ff08
000bf3 7270
000bf4 7665
000bf5 6f69
000bf6 7375          .db "previous"
000bf7 0be5          .dw VE_HEAD
                     .set VE_HEAD = VE_PREVIOUS
                 XT_PREVIOUS:
000bf8 3800          .dw DO_COLON	
                 PFA_PREVIOUS:
000bf9 0ba9          .dw XT_GET_ORDER
000bfa 38bf          .dw XT_SWAP
000bfb 38d4          .dw XT_DROP
000bfc 3a3e          .dw XT_1MINUS
000bfd 38ac          .dw XT_DUP
000bfe 3918          .dw XT_EQUALZERO
000bff 3830          .dw XT_DOCONDBRANCH
000c00 0c04          .dw PFA_PREVIOUS1
000c01 3837          .dw XT_DOLITERAL
000c02 ffce          .dw -50
000c03 045b          .dw XT_THROW
                 PFA_PREVIOUS1:
000c04 0c61          .dw XT_SET_ORDER
000c05 381a          .dw XT_EXIT
                 .include "words/definitions.asm"
                 
                 ; Search Order
                 ; Make the compilation word list the same as the current first word list in the search order.
                 VE_DEFINITIONS:
000c06 ff0b          .dw $ff0b
000c07 6564
000c08 6966
000c09 696e
000c0a 6974
000c0b 6e6f
000c0c 0073          .db "definitions",0
000c0d 0bf2          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFINITIONS
                 XT_DEFINITIONS:
000c0e 3800          .dw DO_COLON
                 PFA_DEFINITIONS:
000c0f 0ba9          .dw XT_GET_ORDER
000c10 38ca          .dw XT_OVER
000c11 0bed          .dw XT_SET_CURRENT
                     ; now empty the order list on stack
000c12 3934          .dw XT_ZERO
000c13 3aaa          .dw XT_DOQDO
000c14 0c18          .dw PFA_DEFINITIONS2
                 PFA_DEFINITIONS1:
000c15 38d4          .dw XT_DROP
000c16 3ad8          .dw XT_DOLOOP
000c17 0c15          .dw PFA_DEFINITIONS1
                 PFA_DEFINITIONS2:
000c18 381a          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000c19 ff08          .dw $ff08
000c1a 6f77
000c1b 6472
000c1c 696c
000c1d 7473          .db "wordlist"
000c1e 0c06          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000c1f 3800          .dw DO_COLON
                 PFA_WORDLIST:
000c20 015b          .dw XT_EDP
000c21 3934          .dw XT_ZERO
000c22 38ca          .dw XT_OVER
000c23 3b37          .dw XT_STOREE
000c24 38ac          .dw XT_DUP
000c25 3a38          .dw XT_1PLUS
000c26 3a38          .dw XT_1PLUS
000c27 0786          .dw XT_DOTO
000c28 015c          .dw PFA_EDP
000c29 381a          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000c2a ff04          .dw $ff04
000c2b 6e6f
000c2c 796c          .db "only"
000c2d 0c19          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000c2e 3800          .dw DO_COLON
                 PFA_ONLY:
000c2f 3837          .dw XT_DOLITERAL
000c30 0012          .dw EE_FORTHWORDLIST
000c31 3837          .dw XT_DOLITERAL
000c32 0001          .dw 1
000c33 0c61          .dw XT_SET_ORDER
000c34 381a          .dw XT_EXIT
                 .include "words/forth.asm"
                 
                 ; Search Order
                 ; replace the search order list with the system default list
                 VE_FORTH:
000c35 ff05          .dw $ff05
000c36 6f66
000c37 7472
000c38 0068          .db "forth",0
000c39 0c2a          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH
                 XT_FORTH:
000c3a 3800          .dw DO_COLON
                 PFA_FORTH:
000c3b 0ba9          .dw XT_GET_ORDER
000c3c 38bf          .dw XT_SWAP
000c3d 38d4          .dw XT_DROP
000c3e 0c4b          .dw XT_FORTH_WORDLIST
000c3f 38bf          .dw XT_SWAP
000c40 0c61          .dw XT_SET_ORDER
000c41 381a          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000c42 ff0e          .dw $ff0e
000c43 6f66
000c44 7472
000c45 2d68
000c46 6f77
000c47 6472
000c48 696c
000c49 7473          .db "forth-wordlist"
000c4a 0c35          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000c4b 3869          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000c4c 000e          .dw EE_WL_FORTH
000c4d 0aa6          .dw XT_EVALUEFETCH
000c4e 0aaa          .dw XT_EVALUESTORE
                 .include "words/also.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_ALSO:
000c4f ff04          .dw $ff04
000c50 6c61
000c51 6f73          .db "also"
000c52 0c42          .dw VE_HEAD
                     .set VE_HEAD = VE_ALSO
                 XT_ALSO:
000c53 3800          .dw DO_COLON
                 PFA_ALSO:
000c54 0ba9          .dw XT_GET_ORDER
000c55 38ca          .dw XT_OVER
000c56 38bf          .dw XT_SWAP
000c57 3a38          .dw XT_1PLUS
000c58 0c61          .dw XT_SET_ORDER
000c59 381a          .dw XT_EXIT
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 VE_SET_ORDER:
000c5a ff09          .dw $ff09
000c5b 6573
000c5c 2d74
000c5d 726f
000c5e 6564
000c5f 0072          .db "set-order",0
000c60 0c4f          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000c61 3800          .dw DO_COLON
                 PFA_SET_ORDER:
000c62 3837          .dw XT_DOLITERAL
000c63 0014          .dw EE_ORDERLISTLEN
000c64 0b86          .dw XT_STORE_EE_ARRAY
000c65 381a          .dw XT_EXIT
                 
                 .include "words/order.asm"
                 
                 ; Search Order
                 ; print the wids of the current word list and the search order
                 VE_ORDER:
000c66 ff05          .dw $ff05
000c67 726f
000c68 6564
000c69 0072          .db "order",0
000c6a 0c5a          .dw VE_HEAD
                     .set VE_HEAD = VE_ORDER
                 XT_ORDER:
000c6b 3800          .dw DO_COLON
                 PFA_ORDER:
000c6c 0b9d          .dw XT_GET_CURRENT
000c6d 0d0c          .dw XT_UDOT
000c6e 03fa          .dw XT_CR
000c6f 0ba9          .dw XT_GET_ORDER
000c70 38ac          .dw XT_DUP
000c71 0d0c          .dw XT_UDOT
000c72 3934          .dw XT_ZERO
000c73 3aaa          .dw XT_DOQDO
000c74 0c79          .dw PFA_ORDER2
                 PFA_ORDER1:
000c75 0d0c          .dw XT_UDOT
000c76 0407          .dw XT_SPACE         ; ( -- addr n)
000c77 3ad8          .dw XT_DOLOOP
000c78 0c75          .dw PFA_ORDER1
                 PFA_ORDER2:
000c79 381a          .dw XT_EXIT
                 
                 ;.include "dict_mcu.inc"
                 ;.include "dict_vm.inc"
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000c7a ff04          .dw $ff04
000c7b 692b
000c7c 746e          .db "+int"
000c7d 0c66          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000c7e 0c7f          .dw PFA_INTON
                 PFA_INTON:
000c7f 9478          sei
000c80 940c 3804     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000c82 ff04          .dw $ff04
000c83 692d
000c84 746e          .db "-int"
000c85 0c7a          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000c86 0c87          .dw PFA_INTOFF
                 PFA_INTOFF:
000c87 94f8          cli
000c88 940c 3804     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000c8a ff04          .dw $ff04
000c8b 6e69
000c8c 2174          .db "int!"
000c8d 0c82          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000c8e 3800          .dw DO_COLON
                 PFA_INTSTORE:
000c8f 3837          .dw XT_DOLITERAL
000c90 0115          .dw intvec
000c91 39a6          .dw XT_PLUS
000c92 387c          .dw XT_STORE
000c93 381a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000c94 ff04          .dw $ff04
000c95 6e69
000c96 4074          .db "int@"
000c97 0c8a          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000c98 3800          .dw DO_COLON
                 PFA_INTFETCH:
000c99 3837          .dw XT_DOLITERAL
000c9a 0115          .dw intvec
000c9b 39a6          .dw XT_PLUS
000c9c 3874          .dw XT_FETCH
000c9d 381a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000c9e ff08          .dw $ff08
000c9f 6e69
000ca0 2d74
000ca1 7274
000ca2 7061          .db "int-trap"
000ca3 0c94          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000ca4 0ca5          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000ca5 9380 0114     sts intcur, tosl
000ca7 9189
000ca8 9199          loadtos
000ca9 9468          set ; set the interrupt flag for the inner interpreter
000caa 940c 3804     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000cac 3800          .dw DO_COLON
                 PFA_ISREXEC:
000cad 3837          .dw XT_DOLITERAL
000cae 0114          .dw intcur
000caf 3893          .dw XT_CFETCH
000cb0 3837          .dw XT_DOLITERAL
000cb1 0115          .dw intvec
000cb2 39a6          .dw XT_PLUS
000cb3 3874          .dw XT_FETCH
000cb4 3824          .dw XT_EXECUTE
000cb5 0cb7          .dw XT_ISREND
000cb6 381a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000cb7 0cb8          .dw PFA_ISREND
                 PFA_ISREND:
000cb8 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000cb9 940c 3804     jmp_ DO_NEXT
                 PFA_ISREND1:
000cbb 9518          reti
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000cbc ff03          .dw $ff03
000cbd 3264
000cbe 002a          .db "d2*",0
000cbf 0c9e          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000cc0 0cc1          .dw PFA_D2STAR
                 PFA_D2STAR:
000cc1 9109          ld temp0, Y+
000cc2 9119          ld temp1, Y+
000cc3 0f00          lsl temp0
000cc4 1f11          rol temp1
000cc5 1f88          rol tosl
000cc6 1f99          rol tosh
000cc7 931a          st -Y, temp1
000cc8 930a          st -Y, temp0
000cc9 940c 3804     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000ccb ff02          .dw $ff02
000ccc 2b64          .db "d+"
000ccd 0cbc          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000cce 0ccf          .dw PFA_DPLUS
                 PFA_DPLUS:
000ccf 9129          ld temp2, Y+
000cd0 9139          ld temp3, Y+
                 
000cd1 90e9          ld temp4, Y+
000cd2 90f9          ld temp5, Y+
000cd3 9149          ld temp6, Y+
000cd4 9159          ld temp7, Y+
                 
000cd5 0f24          add temp2, temp6
000cd6 1f35          adc temp3, temp7
000cd7 1d8e          adc tosl, temp4
000cd8 1d9f          adc tosh, temp5
                     
000cd9 933a          st -Y, temp3
000cda 932a          st -Y, temp2
000cdb 940c 3804     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000cdd ff02          .dw $ff02
000cde 2d64          .db "d-"
000cdf 0ccb          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000ce0 0ce1          .dw PFA_DMINUS
                 PFA_DMINUS:
000ce1 9129          ld temp2, Y+
000ce2 9139          ld temp3, Y+
                 
000ce3 90e9          ld temp4, Y+
000ce4 90f9          ld temp5, Y+
000ce5 9149          ld temp6, Y+
000ce6 9159          ld temp7, Y+
                 
000ce7 1b42          sub temp6, temp2
000ce8 0b53          sbc temp7, temp3
000ce9 0ae8          sbc temp4, tosl
000cea 0af9          sbc temp5, tosh
                 
000ceb 935a          st -Y, temp7
000cec 934a          st -Y, temp6
000ced 01c7          movw tosl, temp4
000cee 940c 3804     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000cf0 ff07          .dw $ff07
000cf1 6964
000cf2 766e
000cf3 7265
000cf4 0074          .db "dinvert",0
000cf5 0cdd          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000cf6 0cf7          .dw PFA_DINVERT
                 PFA_DINVERT:
000cf7 9109          ld temp0, Y+
000cf8 9119          ld temp1, Y+
000cf9 9580          com tosl
000cfa 9590          com tosh
000cfb 9500          com temp0
000cfc 9510          com temp1
000cfd 931a          st -Y, temp1
000cfe 930a          st -Y, temp0
000cff 940c 3804     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
000d01 ff02          .dw $ff02
000d02 3d64          .db "d="
000d03 0cf0          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000d04 3800          .dw DO_COLON
                 PFA_DEQUAL:
000d05 0ce0          .dw XT_DMINUS
000d06 3a25          .dw XT_OR
000d07 3918          .dw XT_EQUALZERO
000d08 381a          .dw XT_EXIT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
000d09 ff02          .dw $ff02
000d0a 2e75          .db "u."
000d0b 0d01          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000d0c 3800          .dw DO_COLON
                 PFA_UDOT:
000d0d 3934          .dw XT_ZERO
000d0e 0334          .dw XT_UDDOT
000d0f 381a          .dw XT_EXIT
                 .include "words/udotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 VE_UDOTR:
000d10 ff03          .dw $ff03
000d11 2e75
000d12 0072          .db "u.r",0
000d13 0d09          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
000d14 3800          .dw DO_COLON
                 PFA_UDOTR:
000d15 3934          .dw XT_ZERO
000d16 38bf          .dw XT_SWAP
000d17 033d          .dw XT_UDDOTR
000d18 381a          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
000d19 ff02          .dw $ff02
000d1a 732e          .db ".s"
000d1b 0d10          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000d1c 3800          .dw DO_COLON
                 PFA_DOTS:
000d1d 06a2          .dw XT_SP0
000d1e 3a8a          .dw XT_SP_FETCH
000d1f 0104          .dw XT_CELLPLUS
000d20 3aaa          .dw XT_DOQDO
000d21 0d29          .dw PFA_DOTS2
                 PFA_DOTS1:
000d22 3abd          .dw XT_I
000d23 3874          .dw XT_FETCH 
000d24 0d0c          .dw XT_UDOT
000d25 3837          .dw XT_DOLITERAL
000d26 0002          .dw 2
000d27 3abe          .dw XT_DOPLUSLOOP
000d28 0d22          .dw PFA_DOTS1
                 PFA_DOTS2:
000d29 381a          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
000d2a 0002          .dw $0002
000d2b 222e          .db ".",$22
000d2c 0d19          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000d2d 3800          .dw DO_COLON
                 PFA_DOTSTRING:
000d2e 0d35          .dw XT_SQUOTE
000d2f 019f          .dw XT_COMPILE
000d30 03c6          .dw XT_ITYPE
000d31 381a          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
000d32 0002        .dw $0002
000d33 2273        .db "s",$22
000d34 0d2a        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000d35 3800          .dw DO_COLON
                 PFA_SQUOTE:
000d36 3837          .dw XT_DOLITERAL
000d37 0022          .dw $22
000d38 059c          .dw XT_PARSE       ; ( -- addr n)
000d39 00ef          .dw XT_STATE
000d3a 3874          .dw XT_FETCH
000d3b 3830          .dw XT_DOCONDBRANCH
000d3c 0d40          .dw PFA_SQUOTE1
000d3d 019f            .dw XT_COMPILE
000d3e 038f            .dw XT_DOSLITERAL    ; ( -- addr n)
000d3f 03a2            .dw XT_SCOMMA
                 PFA_SQUOTE1:
000d40 381a          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000d41 ff06          .dw $ff06
000d42 6445
000d43 6665
000d44 7265          .db "Edefer"
000d45 0d32          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000d46 3800          .dw DO_COLON
                 PFA_EDEFER:
000d47 0178          .dw XT_DOCREATE
000d48 09fe          .dw XT_REVEAL
000d49 019f          .dw XT_COMPILE
000d4a 07ce          .dw PFA_DODEFER
                 
000d4b 015b          .dw XT_EDP
000d4c 38ac          .dw XT_DUP
000d4d 01aa          .dw XT_COMMA
000d4e 019f          .dw XT_COMPILE
000d4f 0792          .dw XT_EDEFERFETCH
000d50 019f          .dw XT_COMPILE
000d51 0797          .dw XT_EDEFERSTORE
000d52 0104          .dw XT_CELLPLUS
000d53 0786          .dw XT_DOTO
000d54 015c          .dw PFA_EDP
000d55 381a          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000d56 ff06          .dw $ff06
000d57 6452
000d58 6665
000d59 7265          .db "Rdefer"
000d5a 0d41          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000d5b 3800          .dw DO_COLON
                 PFA_RDEFER:
000d5c 0178          .dw XT_DOCREATE
000d5d 09fe          .dw XT_REVEAL
                 
000d5e 019f          .dw XT_COMPILE
000d5f 07ce          .dw PFA_DODEFER
                 
000d60 0163          .dw XT_HERE
000d61 01aa          .dw XT_COMMA
000d62 3837          .dw XT_DOLITERAL
000d63 0002          .dw 2
000d64 016c          .dw XT_ALLOT
                 
000d65 019f          .dw XT_COMPILE
000d66 079c          .dw XT_RDEFERFETCH
000d67 019f          .dw XT_COMPILE
000d68 07a1          .dw XT_RDEFERSTORE
000d69 381a          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000d6a 0002          .dw $0002
000d6b 7369          .db "is"
000d6c 0d56          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000d6d 3800          .dw DO_COLON
                 PFA_IS:
000d6e 00ef          .dw XT_STATE
000d6f 3874          .dw XT_FETCH
000d70 3830          .dw XT_DOCONDBRANCH
000d71 0d76          .dw PFA_IS1
000d72 01b6          .dw XT_BRACKETTICK
000d73 019f          .dw XT_COMPILE
000d74 07b9          .dw XT_DEFERSTORE
000d75 381a          .dw XT_EXIT
                 PFA_IS1:
000d76 042e          .dw XT_TICK
000d77 07b9          .dw XT_DEFERSTORE
000d78 381a          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000d79 ff0b          .dw $ff0b
000d7a 7061
000d7b 6c70
000d7c 7574
000d7d 6e72
000d7e 656b
000d7f 0079          .db "applturnkey",0
000d80 0d6a          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000d81 3800          .dw DO_COLON
                 PFA_APPLTURNKEY:
000d82 00b0          .dw XT_USART
000d83 0c7e          .dw XT_INTON
000d84 074e          .dw XT_VER
000d85 0407          .dw XT_SPACE
000d86 00d9          .dw XT_F_CPU
000d87 3837          .dw XT_DOLITERAL
000d88 03e8          .dw 1000
000d89 39cb          .dw XT_UMSLASHMOD
000d8a 38bf          .dw XT_SWAP
000d8b 38d4          .dw XT_DROP
000d8c 01cc          .dw XT_DECIMAL
000d8d 032c          .dw XT_DOT
000d8e 038f          .dw XT_DOSLITERAL
000d8f 0004          .dw 4
000d90 486b
000d91 207a          .db "kHz "
000d92 03c6          .dw XT_ITYPE
000d93 381a          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000d94 ff04          .dw $ff04
000d95 6966
000d96 6c6c          .db "fill"
000d97 0d79          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000d98 3800          .dw DO_COLON
                 PFA_FILL:
000d99 38dc          .dw XT_ROT
000d9a 38dc          .dw XT_ROT
000d9b 3934          .dw XT_ZERO
000d9c 3aaa          .dw XT_DOQDO
000d9d 0da3          .dw PFA_FILL2
                 PFA_FILL1:
000d9e 010c          .dw XT_2DUP
000d9f 3888          .dw XT_CSTORE  ; ( -- c c-addr)
000da0 3a38          .dw XT_1PLUS
000da1 3ad8          .dw XT_DOLOOP
000da2 0d9e          .dw PFA_FILL1
                 PFA_FILL2:
000da3 38d4          .dw XT_DROP
000da4 38d4          .dw XT_DROP
000da5 381a          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
000da6 ff0d          .dw $ff0d
000da7 6873
000da8 776f
000da9 772d
000daa 726f
000dab 6c64
000dac 7369
000dad 0074          .db "show-wordlist",0
000dae 0d94          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
000daf 3800          .dw DO_COLON
                 PFA_SHOWWORDLIST:
000db0 3837          .dw XT_DOLITERAL
000db1 0db5          .dw XT_SHOWWORD
000db2 38bf          .dw XT_SWAP
000db3 0828          .dw XT_TRAVERSEWORDLIST
000db4 381a          .dw XT_EXIT
                 
                 XT_SHOWWORD:
000db5 3800          .dw DO_COLON
                 PFA_SHOWWORD:
000db6 0817          .dw XT_NAME2STRING
000db7 03c6          .dw XT_ITYPE
000db8 0407          .dw XT_SPACE         ; ( -- addr n)
000db9 393d          .dw XT_TRUE
000dba 381a          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000dbb ff05          .dw $ff05
000dbc 6f77
000dbd 6472
000dbe 0073          .db "words",0
000dbf 0da6          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000dc0 3800          .dw DO_COLON
                 PFA_WORDS:
000dc1 3837          .dw XT_DOLITERAL
000dc2 0016          .dw EE_ORDERLIST
000dc3 3b5b          .dw XT_FETCHE
000dc4 0daf          .dw XT_SHOWWORDLIST
000dc5 381a          .dw XT_EXIT
                 
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
000dc6 ff03          .dw $ff03
000dc7 6d31
000dc8 0073          .db "1ms",0
000dc9 0dbb          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000dca 0dcb          .dw PFA_1MS
                 PFA_1MS:
000dcb eae0
000dcc e0ff
000dcd 9731
000dce f7f1          delay 1000
000dcf 940c 3804     jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
000dd1 0008          .dw $0008
000dd2 6c32
000dd3 7469
000dd4 7265
000dd5 6c61          .db "2literal"
000dd6 0dc6          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
000dd7 3800          .dw DO_COLON
                 PFA_2LITERAL:
000dd8 38bf          .dw XT_SWAP
000dd9 019f          .dw XT_COMPILE
000dda 3837          .dw XT_DOLITERAL
000ddb 01aa          .dw XT_COMMA
000ddc 019f          .dw XT_COMPILE
000ddd 3837          .dw XT_DOLITERAL
000dde 01aa          .dw XT_COMMA
                     
000ddf 381a          .dw XT_EXIT
                 .include "device.inc"
                 
                 ; generated automatically, no not edit
                 
                 .if WANT_USART0 == 1
                 .endif
                 .if WANT_TWI == 1
                 .endif
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 .if WANT_PORTB == 1
                 .endif
                 .if WANT_PORTC == 1
                 .endif
                 .if WANT_PORTD == 1
                 .endif
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 .if WANT_SPI == 1
                 .endif
                 .if WANT_WATCHDOG == 1
                 .endif
                 .if WANT_CPU == 1
                 .endif
                 .if WANT_EEPROM == 1
                 .endif
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
003800 93bf          push XH
003801 93af          push XL          ; PUSH IP
003802 01db          movw XL, wl
003803 9611          adiw xl, 1
                 DO_NEXT:
003804 f06e          brts DO_INTERRUPT
003805 01fd          movw zl, XL        ; READ IP
003806 0fee
003807 1fff
003808 9165
003809 9175          readflashcell wl, wh
00380a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00380b 01fb          movw zl, wl
00380c 0fee
00380d 1fff
00380e 9105
00380f 9115          readflashcell temp0,temp1
003810 01f8          movw zl, temp0
003811 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
003812 94e8          clt
003813 ea6c          ldi wl, LOW(XT_ISREXEC)
003814 e07c          ldi wh, HIGH(XT_ISREXEC)
003815 cff5          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
003816 ff04          .dw $ff04
003817 7865
003818 7469          .db "exit"
003819 0dd1          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00381a 381b          .dw PFA_EXIT
                 PFA_EXIT:
00381b 91af          pop XL
00381c 91bf          pop XH
00381d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00381e ff07          .dw $ff07
00381f 7865
003820 6365
003821 7475
003822 0065          .db "execute",0
003823 3816          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
003824 3825          .dw PFA_EXECUTE
                 PFA_EXECUTE:
003825 01bc          movw wl, tosl
003826 9189
003827 9199          loadtos
003828 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
003829 382a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00382a 01fd          movw zl, XL
00382b 0fee
00382c 1fff
00382d 91a5
00382e 91b5          readflashcell XL,XH
00382f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
003830 3831          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
003831 2b98          or tosh, tosl
003832 9189
003833 9199          loadtos
003834 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
003835 9611          adiw XL, 1
003836 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
003837 3838          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
003838 939a
003839 938a          savetos
00383a 01fd          movw zl, xl
00383b 0fee
00383c 1fff
00383d 9185
00383e 9195          readflashcell tosl,tosh
00383f 9611          adiw xl, 1
003840 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
003841 3842          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
003842 939a
003843 938a          savetos
003844 01fb          movw zl, wl
003845 9631          adiw zl,1
003846 0fee
003847 1fff
003848 9185
003849 9195          readflashcell tosl,tosh
00384a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00384b 384c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00384c 939a
00384d 938a          savetos
00384e 01cb          movw tosl, wl
00384f 9601          adiw tosl, 1
003850 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
003851 3852          .dw PFA_DOUSER
                 PFA_DOUSER:
003852 939a
003853 938a          savetos
003854 01fb          movw zl, wl
003855 9631          adiw zl, 1
003856 0fee
003857 1fff
003858 9185
003859 9195          readflashcell tosl,tosh
00385a 0d84          add tosl, upl
00385b 1d95          adc tosh, uph
00385c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00385d ff07          .dw $ff07
00385e 7628
00385f 6c61
003860 6575
003861 0029          .db "(value)", 0
003862 381e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
003863 3800          .dw DO_COLON
                 PFA_DOVALUE:
003864 0178          .dw XT_DOCREATE
003865 09fe          .dw XT_REVEAL
003866 019f          .dw XT_COMPILE
003867 3869          .dw PFA_DOVALUE1
003868 381a          .dw XT_EXIT
                 PFA_DOVALUE1:
003869 940e 0a22     call_ DO_DODOES
00386b 38ac          .dw XT_DUP
00386c 38bf          .dw XT_SWAP
00386d 3a38          .dw XT_1PLUS
00386e 3b6f          .dw XT_FETCHI
00386f 3824          .dw XT_EXECUTE
003870 381a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
003871 ff01          .dw $ff01
003872 0040          .db "@",0
003873 385d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
003874 3875          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
003875 01fc          movw zl, tosl
                     ; low byte is read before the high byte
003876 9181          ld tosl, z+
003877 9191          ld tosh, z+
003878 cf8b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
003879 ff01          .dw $ff01
00387a 0021          .db "!",0
00387b 3871          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00387c 387d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00387d 01fc          movw zl, tosl
00387e 9189
00387f 9199          loadtos
                     ; the high byte is written before the low byte
003880 8391          std Z+1, tosh
003881 8380          std Z+0, tosl
003882 9189
003883 9199          loadtos
003884 cf7f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
003885 ff02          .dw $ff02
003886 2163          .db "c!"
003887 3879          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
003888 3889          .dw PFA_CSTORE
                 PFA_CSTORE:
003889 01fc          movw zl, tosl
00388a 9189
00388b 9199          loadtos
00388c 8380          st Z, tosl
00388d 9189
00388e 9199          loadtos
00388f cf74          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
003890 ff02          .dw $ff02
003891 4063          .db "c@"
003892 3885          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
003893 3894          .dw PFA_CFETCH
                 PFA_CFETCH:
003894 01fc          movw zl, tosl
003895 2799          clr tosh
003896 8180          ld tosl, Z
003897 cf6c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
003898 ff02          .dw $ff02
003899 7540          .db "@u"
00389a 3890          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00389b 3800          .dw DO_COLON
                 PFA_FETCHU:
00389c 3b17          .dw XT_UP_FETCH
00389d 39a6          .dw XT_PLUS
00389e 3874          .dw XT_FETCH
00389f 381a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
0038a0 ff02          .dw $ff02
0038a1 7521          .db "!u"
0038a2 3898          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0038a3 3800          .dw DO_COLON
                 PFA_STOREU:
0038a4 3b17          .dw XT_UP_FETCH
0038a5 39a6          .dw XT_PLUS
0038a6 387c          .dw XT_STORE
0038a7 381a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0038a8 ff03          .dw $ff03
0038a9 7564
0038aa 0070          .db "dup",0
0038ab 38a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0038ac 38ad          .dw PFA_DUP
                 PFA_DUP:
0038ad 939a
0038ae 938a          savetos
0038af cf54          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0038b0 ff04          .dw $ff04
0038b1 643f
0038b2 7075          .db "?dup"
0038b3 38a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0038b4 38b5          .dw PFA_QDUP
                 PFA_QDUP:
0038b5 2f08          mov temp0, tosl
0038b6 2b09          or temp0, tosh
0038b7 f011          breq PFA_QDUP1
0038b8 939a
0038b9 938a          savetos
                 PFA_QDUP1:
0038ba cf49          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0038bb ff04          .dw $ff04
0038bc 7773
0038bd 7061          .db "swap"
0038be 38b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0038bf 38c0          .dw PFA_SWAP
                 PFA_SWAP:
0038c0 018c          movw temp0, tosl
0038c1 9189
0038c2 9199          loadtos
0038c3 931a          st -Y, temp1
0038c4 930a          st -Y, temp0
0038c5 cf3e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0038c6 ff04          .dw $ff04
0038c7 766f
0038c8 7265          .db "over"
0038c9 38bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0038ca 38cb          .dw PFA_OVER
                 PFA_OVER:
0038cb 939a
0038cc 938a          savetos
0038cd 818a          ldd tosl, Y+2
0038ce 819b          ldd tosh, Y+3
                 
0038cf cf34          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0038d0 ff04          .dw $ff04
0038d1 7264
0038d2 706f          .db "drop"
0038d3 38c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0038d4 38d5          .dw PFA_DROP
                 PFA_DROP:
0038d5 9189
0038d6 9199          loadtos
0038d7 cf2c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0038d8 ff03          .dw $ff03
0038d9 6f72
0038da 0074          .db "rot",0
0038db 38d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0038dc 38dd          .dw PFA_ROT
                 PFA_ROT:
0038dd 018c          movw temp0, tosl
0038de 9129          ld temp2, Y+
0038df 9139          ld temp3, Y+ 
0038e0 9189
0038e1 9199          loadtos
                         
0038e2 933a          st -Y, temp3
0038e3 932a          st -Y, temp2
0038e4 931a          st -Y, temp1
0038e5 930a          st -Y, temp0
                 
0038e6 cf1d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0038e7 ff02          .dw $ff02
0038e8 3e72          .db "r>"
0038e9 38d8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0038ea 38eb          .dw PFA_R_FROM
                 PFA_R_FROM:
0038eb 939a
0038ec 938a          savetos
0038ed 918f          pop tosl
0038ee 919f          pop tosh
0038ef cf14          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0038f0 ff02          .dw $ff02
0038f1 723e          .db ">r"
0038f2 38e7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0038f3 38f4          .dw PFA_TO_R
                 PFA_TO_R:
0038f4 939f          push tosh
0038f5 938f          push tosl
0038f6 9189
0038f7 9199          loadtos
0038f8 cf0b          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
0038f9 ff02          .dw $ff02
0038fa 4072          .db "r@"
0038fb 38f0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
0038fc 38fd          .dw PFA_R_FETCH
                 PFA_R_FETCH:
0038fd 939a
0038fe 938a          savetos
0038ff 918f          pop tosl
003900 919f          pop tosh
003901 939f          push tosh
003902 938f          push tosl
003903 cf00          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
003904 ff02          .dw $ff02
003905 3e3c          .db "<>"
003906 38f9          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
003907 3908          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
003908 9129          ld temp2, Y+
003909 9139          ld temp3, Y+
00390a 1782          cp tosl, temp2
00390b 0793          cpc tosh, temp3
00390c f151          breq PFA_ZERO1
00390d c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00390e ff01          .dw $ff01
00390f 003d          .db "=",0
003910 3904          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
003911 3800          .dw DO_COLON
                 PFA_EQUAL:
003912 399c          .dw XT_MINUS
003913 3918          .dw XT_EQUALZERO
003914 381a          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
003915 ff02          .dw $ff02
003916 3d30          .db "0="
003917 390e          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
003918 3919          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
003919 2b98          or tosh, tosl
00391a f4e1          brne PFA_ZERO1
00391b c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00391c ff01          .dw $ff01
00391d 003c          .db "<",0
00391e 3915          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00391f 3800          .dw DO_COLON
                 PFA_LESS:
003920 399c          .dw XT_MINUS
003921 392d          .dw XT_LESSZERO
003922 381a          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
003923 ff01          .dw $ff01
003924 003e          .db ">",0
003925 391c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
003926 3800          .dw DO_COLON
                 PFA_GREATER:
003927 399c          .dw XT_MINUS
003928 395c          .dw XT_GREATERZERO
003929 381a          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00392a ff02          .dw $ff02
00392b 3c30          .db "0<"
00392c 3923          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00392d 392e          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00392e fd97          sbrc tosh,7
00392f c010          rjmp PFA_TRUE1
003930 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
003931 ff01          .dw $ff01
003932 0030          .db "0",0
003933 392a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
003934 3935          .dw PFA_ZERO
                 PFA_ZERO:
003935 939a
003936 938a          savetos
                 PFA_ZERO1:
003937 01c1          movw tosl, zerol
003938 cecb          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
003939 ff04          .dw $ff04
00393a 7274
00393b 6575          .db "true"
00393c 3931          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00393d 393e          .dw PFA_TRUE
                 PFA_TRUE:
00393e 939a
00393f 938a          savetos
                 PFA_TRUE1:
003940 ef8f          ser tosl
003941 ef9f          ser tosh
003942 cec1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
003943 ff02          .dw $ff02
003944 3c75          .db "u<"
003945 3939          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
003946 3947          .dw PFA_ULESS
                 PFA_ULESS:
003947 9129          ld temp2, Y+
003948 9139          ld temp3, Y+
003949 1782          cp tosl, temp2
00394a 0793          cpc tosh, temp3
00394b f358          brlo PFA_ZERO1
00394c f351          brbs 1, PFA_ZERO1
00394d cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00394e ff02          .dw $ff02
00394f 3e75          .db "u>"
003950 3943          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
003951 3952          .dw PFA_UGREATER
                 PFA_UGREATER:
003952 9129          ld temp2, Y+
003953 9139          ld temp3, Y+
003954 1728          cp temp2, tosl
003955 0739          cpc temp3, tosh
003956 f300          brlo PFA_ZERO1
003957 f2f9          brbs 1, PFA_ZERO1
003958 cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
003959 ff02          .dw $ff02
00395a 3e30          .db "0>"
00395b 394e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00395c 395d          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00395d 1582          cp tosl, zerol
00395e 0593          cpc tosh, zeroh
00395f f2bc          brlt PFA_ZERO1
003960 f2b1          brbs 1, PFA_ZERO1
003961 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
003962 ff02          .dw $ff02
003963 3e64          .db "d>"
003964 3959          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
003965 3800          .dw DO_COLON
                 PFA_DGREATER:
003966 0ce0          .dw XT_DMINUS
003967 396d          .dw XT_DGREATERZERO
003968 381a          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
003969 ff03          .dw $ff03
00396a 3064
00396b 003e          .db "d0>",0
00396c 3962          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00396d 396e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00396e 1582          cp tosl, zerol
00396f 0593          cpc tosh, zeroh
003970 9189
003971 9199          loadtos
003972 0582          cpc tosl, zerol
003973 0593          cpc tosh, zeroh
003974 f214          brlt PFA_ZERO1
003975 f209          brbs 1, PFA_ZERO1
003976 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
003977 ff02          .dw $ff02
003978 3c64          .db "d<"
003979 3969          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00397a 3800          .dw DO_COLON
                 PFA_DLESS:
00397b 0ce0          .dw XT_DMINUS
00397c 3982          .dw XT_DLESSZERO
00397d 381a          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00397e ff03          .dw $ff03
00397f 3064
003980 003c          .db "d0<",0
003981 3977          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
003982 3983          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
003983 9622          adiw Y,2
003984 fd97          sbrc tosh,7
003985 940c 3940     jmp PFA_TRUE1
003987 940c 3937     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
003989 ff04          .dw $ff04
00398a 6f6c
00398b 3267          .db "log2"
00398c 397e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00398d 398e          .dw PFA_LOG2
                 PFA_LOG2:
00398e 01fc          movw zl, tosl
00398f 2799          clr tosh
003990 e180          ldi tosl, 16
                 PFA_LOG2_1:
003991 958a          dec tosl
003992 f022          brmi PFA_LOG2_2 ; wrong data
003993 0fee          lsl  zl
003994 1fff          rol  zh
003995 f7d8          brcc PFA_LOG2_1
003996 ce6d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
003997 959a          dec tosh
003998 ce6b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
003999 ff01          .dw $ff01
00399a 002d          .db "-",0
00399b 3989          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00399c 399d          .dw PFA_MINUS
                 PFA_MINUS:
00399d 9109          ld temp0, Y+
00399e 9119          ld temp1, Y+
00399f 1b08          sub temp0, tosl
0039a0 0b19          sbc temp1, tosh
0039a1 01c8          movw tosl, temp0
0039a2 ce61          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
0039a3 ff01          .dw $ff01
0039a4 002b          .db "+",0
0039a5 3999          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
0039a6 39a7          .dw PFA_PLUS
                 PFA_PLUS:
0039a7 9109          ld temp0, Y+
0039a8 9119          ld temp1, Y+
0039a9 0f80          add tosl, temp0
0039aa 1f91          adc tosh, temp1
0039ab ce58          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0039ac ff02          .dw $ff02
0039ad 2a6d          .db "m*"
0039ae 39a3          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0039af 39b0          .dw PFA_MSTAR
                 PFA_MSTAR:
0039b0 018c          movw temp0, tosl
0039b1 9189
0039b2 9199          loadtos
0039b3 019c          movw temp2, tosl
                     ; high cell ah*bh
0039b4 0231          muls temp3, temp1
0039b5 0170          movw temp4, r0
                     ; low cell  al*bl
0039b6 9f20          mul  temp2, temp0
0039b7 01c0          movw tosl, r0
                     ; signed ah*bl
0039b8 0330          mulsu temp3, temp0
0039b9 08f3          sbc   temp5, zeroh
0039ba 0d90          add   tosh,  r0
0039bb 1ce1          adc   temp4, r1
0039bc 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0039bd 0312          mulsu temp1, temp2
0039be 08f3          sbc   temp5, zeroh
0039bf 0d90          add   tosh,  r0
0039c0 1ce1          adc   temp4, r1
0039c1 1cf3          adc   temp5, zeroh
                 
0039c2 939a
0039c3 938a          savetos
0039c4 01c7          movw tosl, temp4
0039c5 ce3e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0039c6 ff06          .dw $ff06
0039c7 6d75
0039c8 6d2f
0039c9 646f          .db "um/mod"
0039ca 39ac          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0039cb 39cc          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0039cc 017c          movw temp4, tosl
                 
0039cd 9129          ld temp2, Y+
0039ce 9139          ld temp3, Y+
                   
0039cf 9109          ld temp0, Y+
0039d0 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0039d1 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0039d2 2755          clr temp7
0039d3 0f00          lsl temp0
0039d4 1f11          rol temp1
0039d5 1f22          rol temp2
0039d6 1f33          rol temp3
0039d7 1f55          rol temp7
                 
                   ; try subtracting divisor
0039d8 152e          cp temp2, temp4
0039d9 053f          cpc temp3, temp5
0039da 0552          cpc temp7,zerol
                 
0039db f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0039dc 9503          inc temp0
0039dd 192e          sub temp2, temp4
0039de 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0039df 954a          dec  temp6
0039e0 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0039e1 933a          st -Y,temp3
0039e2 932a          st -Y,temp2
                 
                     ; put quotient on stack
0039e3 01c8          movw tosl, temp0
0039e4 ce1f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0039e5 ff03          .dw $ff03
0039e6 6d75
0039e7 002a          .db "um*",0
0039e8 39c6          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0039e9 39ea          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0039ea 018c          movw temp0, tosl
0039eb 9189
0039ec 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0039ed 9f80          mul tosl,temp0
0039ee 01f0          movw zl, r0
0039ef 2722          clr temp2
0039f0 2733          clr temp3
                     ; middle bytes
0039f1 9f90          mul tosh, temp0
0039f2 0df0          add zh, r0
0039f3 1d21          adc temp2, r1
0039f4 1d33          adc temp3, zeroh
                         
0039f5 9f81          mul tosl, temp1
0039f6 0df0          add zh, r0
0039f7 1d21          adc temp2, r1
0039f8 1d33          adc temp3, zeroh
                     
0039f9 9f91          mul tosh, temp1
0039fa 0d20          add temp2, r0
0039fb 1d31          adc temp3, r1
0039fc 01cf          movw tosl, zl
0039fd 939a
0039fe 938a          savetos
0039ff 01c9          movw tosl, temp2
003a00 ce03          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
003a01 ff06          .dw $ff06
003a02 6e69
003a03 6576
003a04 7472          .db "invert"
003a05 39e5          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
003a06 3a07          .dw PFA_INVERT
                 PFA_INVERT:
003a07 9580          com tosl
003a08 9590          com tosh
003a09 cdfa          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
003a0a ff02          .dw $ff02
003a0b 2f32          .db "2/"
003a0c 3a01          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
003a0d 3a0e          .dw PFA_2SLASH
                 PFA_2SLASH:
003a0e 9595          asr tosh
003a0f 9587          ror tosl
003a10 cdf3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
003a11 ff02          .dw $ff02
003a12 2a32          .db "2*"
003a13 3a0a          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
003a14 3a15          .dw PFA_2STAR
                 PFA_2STAR:
003a15 0f88          lsl tosl
003a16 1f99          rol tosh
003a17 cdec          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
003a18 ff03          .dw $ff03
003a19 6e61
003a1a 0064          .db "and",0
003a1b 3a11          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
003a1c 3a1d          .dw PFA_AND
                 PFA_AND:
003a1d 9109          ld temp0, Y+
003a1e 9119          ld temp1, Y+
003a1f 2380          and tosl, temp0
003a20 2391          and tosh, temp1
003a21 cde2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
003a22 ff02          .dw $ff02
003a23 726f          .db "or"
003a24 3a18          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
003a25 3a26          .dw PFA_OR
                 PFA_OR:
003a26 9109          ld temp0, Y+
003a27 9119          ld temp1, Y+
003a28 2b80          or tosl, temp0
003a29 2b91          or tosh, temp1
003a2a cdd9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
003a2b ff03          .dw $ff03
003a2c 6f78
003a2d 0072          .db "xor",0
003a2e 3a22          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
003a2f 3a30          .dw PFA_XOR
                 PFA_XOR:
003a30 9109          ld temp0, Y+
003a31 9119          ld temp1, Y+
003a32 2780          eor tosl, temp0
003a33 2791          eor tosh, temp1
003a34 cdcf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
003a35 ff02          .dw $ff02
003a36 2b31          .db "1+"
003a37 3a2b          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
003a38 3a39          .dw PFA_1PLUS
                 PFA_1PLUS:
003a39 9601          adiw tosl,1
003a3a cdc9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
003a3b ff02          .dw $ff02 
003a3c 2d31          .db "1-"
003a3d 3a35          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
003a3e 3a3f          .dw PFA_1MINUS
                 PFA_1MINUS:
003a3f 9701          sbiw tosl, 1
003a40 cdc3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
003a41 ff06          .dw $ff06
003a42 736c
003a43 6968
003a44 7466          .db "lshift"
003a45 3a3b          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
003a46 3a47          .dw PFA_LSHIFT
                 PFA_LSHIFT:
003a47 01fc          movw zl, tosl
003a48 9189
003a49 9199          loadtos
                 PFA_LSHIFT1:
003a4a 9731          sbiw zl, 1
003a4b f01a          brmi PFA_LSHIFT2
003a4c 0f88          lsl tosl
003a4d 1f99          rol tosh
003a4e cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
003a4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
003a50 ff06          .dw $ff06
003a51 7372
003a52 6968
003a53 7466          .db "rshift"
003a54 3a41          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
003a55 3a56          .dw PFA_RSHIFT
                 PFA_RSHIFT:
003a56 01fc          movw zl, tosl
003a57 9189
003a58 9199          loadtos
                 PFA_RSHIFT1:
003a59 9731          sbiw zl, 1
003a5a f01a          brmi PFA_RSHIFT2
003a5b 9596          lsr tosh
003a5c 9587          ror tosl
003a5d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
003a5e cda5          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
003a5f ff02          .dw $ff02
003a60 212b          .db "+!"
003a61 3a50          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
003a62 3a63          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
003a63 01fc          movw zl, tosl
003a64 9189
003a65 9199          loadtos
003a66 8120          ldd temp2, Z+0
003a67 8131          ldd temp3, Z+1
003a68 0f82          add tosl, temp2
003a69 1f93          adc tosh, temp3
003a6a 8380          std Z+0, tosl
003a6b 8391          std Z+1, tosh
003a6c 9189
003a6d 9199          loadtos
003a6e cd95          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
003a6f ff03          .dw $ff03
003a70 7072
003a71 0040          .db "rp@",0
003a72 3a5f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
003a73 3a74          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
003a74 939a
003a75 938a          savetos
003a76 b78d          in tosl, SPL
003a77 b79e          in tosh, SPH
003a78 cd8b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
003a79 ff03          .dw $ff03
003a7a 7072
003a7b 0021          .db "rp!",0
003a7c 3a6f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
003a7d 3a7e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
003a7e b72f          in temp2, SREG
003a7f 94f8          cli
003a80 bf8d          out SPL, tosl
003a81 bf9e          out SPH, tosh
003a82 bf2f          out SREG, temp2
003a83 9189
003a84 9199          loadtos
003a85 cd7e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
003a86 ff03          .dw $ff03
003a87 7073
003a88 0040          .db "sp@",0
003a89 3a79          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
003a8a 3a8b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
003a8b 939a
003a8c 938a          savetos
003a8d 01ce          movw tosl, yl
003a8e cd75          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
003a8f ff03          .dw $ff03
003a90 7073
003a91 0021          .db "sp!",0
003a92 3a86          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
003a93 3a94          .dw PFA_SP_STORE
                 PFA_SP_STORE:
003a94 01ec          movw yl, tosl
003a95 9189
003a96 9199          loadtos
003a97 cd6c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
003a98 3a99          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
003a99 01fd          movw zl, xl
003a9a 0fee
003a9b 1fff
003a9c 9105
003a9d 9115          readflashcell temp0,temp1
003a9e 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
003a9f 9129          ld temp2, Y+
003aa0 9139          ld temp3, Y+
                 PFA_DODO1:
003aa1 931f          push temp1
003aa2 930f          push temp0
003aa3 933f          push temp3
003aa4 932f          push temp2
003aa5 939f          push tosh
003aa6 938f          push tosl
003aa7 9189
003aa8 9199          loadtos
003aa9 cd5a          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
003aaa 3aab          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
003aab 01fd          movw zl, xl
003aac 0fee
003aad 1fff
003aae 9105
003aaf 9115          readflashcell temp0,temp1
003ab0 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
003ab1 9129          ld temp2, Y+
003ab2 9139          ld temp3, Y+
                     ; now check for equality
003ab3 1782          cp tosl, temp2
003ab4 0793          cpc tosh, temp3
003ab5 f759          brne PFA_DODO1
                     ; both values are the same -> skip loop
003ab6 01d8          movw xl, temp0
003ab7 9189
003ab8 9199          loadtos
003ab9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
003aba ff01          .dw $FF01
003abb 0069          .db "i",0
003abc 3a8f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
003abd 38fd          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
003abe 3abf          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
003abf 91ef          pop zl
003ac0 91ff          pop zh
003ac1 0fe8          add zl, tosl
003ac2 1ff9          adc zh, tosh
003ac3 2f19          mov temp1, tosh
003ac4 9189
003ac5 9199          loadtos
                 PFA_DOPLUSLOOP4: 
003ac6 912f          pop temp2
003ac7 913f          pop temp3
003ac8 17e2          cp zl, temp2
003ac9 07f3          cpc zh, temp3
003aca ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
003acb c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
003acc f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
003acd c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
003ace f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
003acf 933f          push temp3
003ad0 932f          push temp2
003ad1 93ff          push zh
003ad2 93ef          push zl
003ad3 cd56          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
003ad4 910f          pop  temp0
003ad5 911f          pop  temp1  ; remove leave destination
003ad6 9611          adiw xl, 1 ; skip branch-back address
003ad7 cd2c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
003ad8 3ad9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
003ad9 91ef          pop zl
003ada 91ff          pop zh
003adb 9631          adiw zl,1
003adc 912f          pop temp2
003add 913f          pop temp3
003ade 17e2          cp zl, temp2
003adf 07f3          cpc zh, temp3
003ae0 f399          breq PFA_DOPLUSLOOP1
003ae1 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
003ae2 ff06          .dw $ff06
003ae3 6e75
003ae4 6f6c
003ae5 706f          .db "unloop"
003ae6 3aba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
003ae7 3ae8          .dw PFA_UNLOOP
                 PFA_UNLOOP:
003ae8 911f          pop temp1
003ae9 910f          pop temp0
003aea 911f          pop temp1
003aeb 910f          pop temp0
003aec 911f          pop temp1
003aed 910f          pop temp0
003aee cd15          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
003aef ff06          .dw $ff06
003af0 6d63
003af1 766f
003af2 3e65          .db "cmove>"
003af3 3ae2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
003af4 3af5          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
003af5 93bf          push xh
003af6 93af          push xl
003af7 91e9          ld zl, Y+
003af8 91f9          ld zh, Y+ ; addr-to
003af9 91a9          ld xl, Y+
003afa 91b9          ld xh, Y+ ; addr-from
003afb 2f09          mov temp0, tosh
003afc 2b08          or temp0, tosl
003afd f041          brbs 1, PFA_CMOVE_G1
003afe 0fe8          add zl, tosl
003aff 1ff9          adc zh, tosh
003b00 0fa8          add xl, tosl
003b01 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
003b02 911e          ld temp1, -X
003b03 9312          st -Z, temp1
003b04 9701          sbiw tosl, 1
003b05 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
003b06 91af          pop xl
003b07 91bf          pop xh
003b08 9189
003b09 9199          loadtos
003b0a ccf9          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
003b0b ff02          .dw $ff02
003b0c 3c3e          .db "><"
003b0d 3aef          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
003b0e 3b0f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
003b0f 2f09          mov temp0, tosh
003b10 2f98          mov tosh, tosl
003b11 2f80          mov tosl, temp0
003b12 ccf1          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
003b13 ff03          .dw $ff03
003b14 7075
003b15 0040          .db "up@",0
003b16 3b0b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
003b17 3b18          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
003b18 939a
003b19 938a          savetos
003b1a 01c2          movw tosl, upl
003b1b cce8          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
003b1c ff03          .dw $ff03
003b1d 7075
003b1e 0021          .db "up!",0
003b1f 3b13          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
003b20 3b21          .dw PFA_UP_STORE
                 PFA_UP_STORE:
003b21 012c          movw upl, tosl
003b22 9189
003b23 9199          loadtos
003b24 ccdf          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
003b25 ff03          .dw $ff03
003b26 3e73
003b27 0064          .db "s>d",0
003b28 3b1c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
003b29 3800          .dw DO_COLON
                 PFA_S2D:
003b2a 38ac          .dw XT_DUP
003b2b 392d          .dw XT_LESSZERO
                 .include "words/not.asm"
003b2c 381a      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
003b2d ff03          .dw $ff03
003b2e 6f6e
003b2f 0074          .db "not",0
003b30 3b25          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
003b31 3800          .dw DO_COLON
                 PFA_NOT:
003b32 3918          .dw XT_EQUALZERO
003b33 381a          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
003b34 ff02          .dw $ff02
003b35 6521          .db "!e"
003b36 3b2d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
003b37 3b38          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
003b38 01fc          movw zl, tosl
003b39 9189
003b3a 9199          loadtos
003b3b b72f          in_ temp2, SREG
003b3c 94f8          cli
003b3d d028          rcall PFA_FETCHE2
003b3e b500          in_  temp0, EEDR
003b3f 1708          cp temp0,tosl
003b40 f009          breq PFA_STOREE3
003b41 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
003b42 9631          adiw zl,1
003b43 d022          rcall PFA_FETCHE2
003b44 b500          in_  temp0, EEDR
003b45 1709          cp temp0,tosh
003b46 f011          breq PFA_STOREE4
003b47 2f89          mov tosl, tosh
003b48 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
003b49 bf2f          out_ SREG, temp2
003b4a 9189
003b4b 9199          loadtos
003b4c ccb7          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
003b4d 99f9          sbic EECR, EEPE
003b4e cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
003b4f b707          in_ temp0, SPMCSR
003b50 fd00          sbrc temp0,SPMEN
003b51 cffd          rjmp PFA_STOREE2
                 
003b52 bdf2          out_ EEARH,zh
003b53 bde1          out_ EEARL,zl
003b54 bd80          out_ EEDR, tosl
003b55 9afa          sbi EECR,EEMPE
003b56 9af9          sbi EECR,EEPE
                 
003b57 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
003b58 ff02          .dw $ff02
003b59 6540          .db "@e"
003b5a 3b34          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
003b5b 3b5c          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
003b5c b72f          in_ temp2, SREG
003b5d 94f8          cli
003b5e 01fc          movw zl, tosl
003b5f d006          rcall PFA_FETCHE2
003b60 b580          in_ tosl, EEDR
                 
003b61 9631          adiw zl,1
                 
003b62 d003          rcall PFA_FETCHE2
003b63 b590          in_  tosh, EEDR
003b64 bf2f          out_ SREG, temp2
003b65 cc9e          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
003b66 99f9          sbic EECR, EEPE
003b67 cffe          rjmp PFA_FETCHE2
                 
003b68 bdf2          out_ EEARH,zh
003b69 bde1          out_ EEARL,zl
                 
003b6a 9af8          sbi EECR,EERE
003b6b 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
003b6c ff02          .dw $ff02
003b6d 6940          .db "@i"
003b6e 3b58          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
003b6f 3b70          .dw PFA_FETCHI
                 PFA_FETCHI:
003b70 01fc          movw zl, tosl
003b71 0fee
003b72 1fff
003b73 9185
003b74 9195          readflashcell tosl,tosh
003b75 cc8e          jmp_ DO_NEXT
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
003b76 ff02          .dw $ff02
003b77 6921          .db "!i"
003b78 3b6c          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
003b79 07ce          .dw PFA_DODEFER
                 PFA_STOREI:
003b7a 000a          .dw EE_STOREI
003b7b 0792          .dw XT_EDEFERFETCH
003b7c 0797          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
003b7d ff09          .dw $ff09
003b7e 2128
003b7f 2d69
003b80 726e
003b81 7777
003b82 0029          .db "(!i-nrww)",0
003b83 3b76          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
003b84 3b85          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
003b85 b71f        in temp1,SREG
003b86 931f        push temp1
003b87 94f8        cli
                 
003b88 019c        movw temp2, tosl ; save the (word) address
003b89 9189
003b8a 9199        loadtos          ; get the new value for the flash cell
003b8b 93af        push xl
003b8c 93bf        push xh
003b8d 93cf        push yl
003b8e 93df        push yh
003b8f d009        rcall DO_STOREI_atmega
003b90 91df        pop yh
003b91 91cf        pop yl
003b92 91bf        pop xh
003b93 91af        pop xl
                   ; finally clear the stack
003b94 9189
003b95 9199        loadtos
003b96 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
003b97 bf1f        out SREG,temp1
                 
003b98 cc6b        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
003b99 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
003b9a 94e0        com temp4
003b9b 94f0        com temp5
003b9c 218e        and tosl, temp4
003b9d 219f        and tosh, temp5
003b9e 2b98        or tosh, tosl
003b9f f019        breq DO_STOREI_writepage 
                 
003ba0 01f9          movw zl, temp2
003ba1 e002          ldi temp0,(1<<PGERS)
003ba2 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
003ba3 01f9        movw zl, temp2
003ba4 e004        ldi temp0,(1<<PGWRT)
003ba5 d01d        rcall dospm
                 
                   ; reenable RWW section
003ba6 01f9        movw zl, temp2
003ba7 e100        ldi temp0,(1<<RWWSRE)
003ba8 d01a        rcall dospm
003ba9 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
003baa 01f9        movw zl, temp2
                   ; get the beginning of page
003bab 7ce0        andi zl,low(pagemask)
003bac 7fff        andi zh,high(pagemask)
003bad 01ef        movw y, z
                   ; loop counter (in words)
003bae e4a0        ldi xl,low(pagesize)
003baf e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
003bb0 01fe        movw z, y
003bb1 0fee
003bb2 1fff
003bb3 9145
003bb4 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003bb5 01fe        movw z, y
003bb6 17e2        cp zl, temp2
003bb7 07f3        cpc zh, temp3
003bb8 f011        breq pageload_newdata
003bb9 010a          movw r0, temp6
003bba c002          rjmp pageload_cont
                 pageload_newdata:
003bbb 017a          movw temp4, temp6
003bbc 010c          movw r0, tosl
                 pageload_cont:
003bbd 2700        clr temp0
003bbe d004        rcall dospm
003bbf 9621        adiw y, 1
003bc0 9711        sbiw x, 1
003bc1 f771        brne pageload_loop
                 
                 pageload_done:
003bc2 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
003bc3 99f9        sbic EECR, EEPE
003bc4 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
003bc5 b717        in_  temp1, SPMCSR
003bc6 fd10        sbrc temp1, SPMEN
003bc7 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
003bc8 0fee
003bc9 1fff        writeflashcell
                   ; execute spm
003bca 6001        ori temp0, (1<<SPMEN)
003bcb bf07        out_ SPMCSR,temp0
003bcc 95e8        spm
003bcd 9508        ret
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
003bce ff03          .dw $ff03
003bcf 3e6e
003bd0 0072          .db "n>r",0
003bd1 3b7d          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
003bd2 3bd3          .dw PFA_N_TO_R
                 PFA_N_TO_R:
003bd3 01fc          movw zl, tosl
003bd4 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
003bd5 9189
003bd6 9199          loadtos
003bd7 939f          push tosh
003bd8 938f          push tosl
003bd9 950a          dec temp0
003bda f7d1          brne PFA_N_TO_R1
003bdb 93ef          push zl
003bdc 93ff          push zh
003bdd 9189
003bde 9199          loadtos
003bdf cc24          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
003be0 ff03          .dw $ff03
003be1 726e
003be2 003e          .db "nr>",0
003be3 3bce          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
003be4 3be5          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
003be5 939a
003be6 938a          savetos
003be7 91ff          pop zh
003be8 91ef          pop zl
003be9 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
003bea 918f          pop tosl
003beb 919f          pop tosh
003bec 939a
003bed 938a          savetos
003bee 950a          dec temp0
003bef f7d1          brne PFA_N_R_FROM1
003bf0 01cf          movw tosl, zl
003bf1 cc12          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 e0 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 e1 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 81 0d         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 84 3b         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 60 0b         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 e0 3b         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 1a 07         .dw XT_REC_FIND
00002a fd 06         .dw XT_REC_INTNUMBER
00002c 36 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 9d 0b         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 08         .dw rstackstart  ; USER_RP
00003e af 08         .dw stackstart   ; USER_SP0
000040 af 08         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 8c 00         .dw XT_TX  ; USER_EMIT
000048 9a 00         .dw XT_TXQ ; USER_EMITQ
00004a 62 00         .dw XT_RX  ; USER_KEY
00004c 7c 00         .dw XT_RXQ ; USER_KEYQ
00004e e7 08         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 d3 08         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 67 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 24
000058 f4 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  80 r17:  57 r18:  58 r19:  42 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 173 r25: 123 r26:  45 r27:  22 r28:   6 r29:   4 r30:  71 r31:  35 
x  :   4 y  : 189 z  :  42 
Registers used: 29 out of 35 (82.9%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :  11 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  11 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   2 jmp   :  22 
ld    : 131 ldd   :   4 ldi   :  22 lds   :   2 lpm   :  20 lsl   :  16 
lsr   :   1 mov   :  12 movw  :  66 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  52 
push  :  38 rcall :  38 ret   :   6 reti  :   2 rjmp  :  89 rol   :  25 
ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  62 std   :   8 sts   :   3 
sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0077e4   1860   9240  11100   32768  33.9%
[.dseg] 0x000100 0x0001e1      0    225    225    2048  11.0%
[.eseg] 0x000000 0x00005a      0     90     90    1024   8.8%

Assembly complete, 0 errors, 2 warnings
