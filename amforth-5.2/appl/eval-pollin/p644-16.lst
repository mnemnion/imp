
AVRASM ver. 2.1.51  p644-16.asm Mon Dec 23 20:35:30 2013

p644-16.asm(2): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
p644-16.asm(3): Including file '../../core/devices/atmega644\device.asm'
../../core/devices/atmega644\device.asm(5): Including file '../../Atmel/Appnotes2\m644def.inc'
p644-16.asm(12): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
p644-16.asm(18): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(4): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(5): Including file '../../core\dict_wl.inc'
../../core\dict_wl.inc(2): Including file '../../core\words/set-current.asm'
../../core\dict_wl.inc(3): Including file '../../core\words/previous.asm'
../../core\dict_wl.inc(4): Including file '../../core\words/definitions.asm'
../../core\dict_wl.inc(5): Including file '../../core\words/wordlist.asm'
../../core\dict_wl.inc(7): Including file '../../core\words/only.asm'
../../core\dict_wl.inc(8): Including file '../../core\words/forth.asm'
../../core\dict_wl.inc(9): Including file '../../core\words/forth-wordlist.asm'
../../core\dict_wl.inc(10): Including file '../../core\words/also.asm'
../../core\dict_wl.inc(11): Including file '../../core\words/set-order.asm'
../../core\dict_wl.inc(12): Including file '../../core\words/order.asm'
dict_appl.inc(8): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(10): Including file '../../core\words/d-2star.asm'
dict_appl.inc(11): Including file '../../core\words/d-plus.asm'
dict_appl.inc(12): Including file '../../core\words/d-minus.asm'
dict_appl.inc(13): Including file '../../core\words/d-invert.asm'
dict_appl.inc(14): Including file '../../core\words/d-equal.asm'
dict_appl.inc(15): Including file '../../core\words/udot.asm'
dict_appl.inc(16): Including file '../../core\words/udotr.asm'
dict_appl.inc(17): Including file '../../core\words/dot-s.asm'
dict_appl.inc(19): Including file '../../core\words/dotstring.asm'
dict_appl.inc(20): Including file '../../core\words/squote.asm'
dict_appl.inc(22): Including file '../../core\words/edefer.asm'
dict_appl.inc(23): Including file '../../core\words/rdefer.asm'
dict_appl.inc(24): Including file '../../core\words/is.asm'
dict_appl.inc(26): Including file 'words/applturnkey.asm'
dict_appl.inc(28): Including file '../../core\words/fill.asm'
dict_appl.inc(30): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(31): Including file '../../core\words/words.asm'
dict_appl.inc(33): Including file '../../core\words/1ms.asm'
dict_appl.inc(34): Including file '../../core\words/2literal.asm'
dict_appl.inc(35): Including file '../../core/devices/atmega644\device.inc'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/n_to_r.asm'
dict_appl_core.inc(9): Including file '../../core\words/n_r_from.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 65536 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0c8      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0c6      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0c4      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d0c2      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d0c0      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d0be      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d0bc      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d0ba      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d0b8      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d0b6      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d0b4      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d0b2      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d0b0      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d0ae      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d0ac      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d0aa      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d0a8      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d0a6      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d0a4      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0a2      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0a0      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d09e      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d09c      	 rcall isr ; Analog Comparator
                 .org 48
000030 d09a      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d098      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d096      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d094      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 28
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000037 1000      	.dw 4096
                 mcu_eepromsize:
000038 0800      	.dw 2048
                 mcu_maxdp:
000039 e000      	.dw 57344 
                 mcu_numints:
00003a 001c      	.dw 28
                 mcu_name:
00003b 0009      	.dw  9
00003c 5441
00003d 656d
00003e 6167
00003f 3436
000040 0034      	.db "ATmega644",0
                 .set codestart=pc
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64    ; 80 characters is one line...
                 .equ APPUSERSIZE = 10  ; size of user area
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 ; baud rate of terminal
                 .equ BAUD = 9600
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000028 940c 0041   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000041 93af        push xl
000042 b7af        in xl, SREG
000043 93af        push xl
000044 93bf        push xh
000045 93ef        push zl
000046 93ff        push zh
                 
000047 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
000049 91a0 0100   lds xl,usart_rx_in
00004b e0e2        ldi zl, low(usart_rx_data)
00004c e0f1        ldi zh, high(usart_rx_data)
00004d 0fea        add zl, xl
00004e 1df3        adc zh, zeroh
00004f 83b0        st Z, xh
                 
000050 95a3        inc xl
000051 70af        andi xl,usart_rx_mask
                 
000052 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000054 91ff        pop zh
000055 91ef        pop zl
000056 91bf        pop xh
000057 91af        pop xl
000058 bfaf        out SREG, xl
000059 91af        pop xl
00005a 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00005b 7000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00005c 7134        .dw XT_ZERO
00005d 7037        .dw XT_DOLITERAL
00005e 0100        .dw usart_rx_in
00005f 707c        .dw XT_STORE
                 
000060 701a        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000061 ff06          .dw $ff06
000062 7872
000063 692d
000064 7273          .db "rx-isr"
000065 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000066 7000          .dw DO_COLON
                 PFA_RX_ISR:
000067 0080        .dw XT_RXQ_ISR
000068 7030        .dw XT_DOCONDBRANCH
000069 0067        .dw PFA_RX_ISR
00006a 7037        .dw XT_DOLITERAL
00006b 0101        .dw usart_rx_out
00006c 7093        .dw XT_CFETCH
00006d 70ac        .dw XT_DUP
00006e 7238        .dw XT_1PLUS
00006f 7037        .dw XT_DOLITERAL
000070 000f        .dw usart_rx_mask
000071 721c        .dw XT_AND
000072 7037        .dw XT_DOLITERAL
000073 0101        .dw usart_rx_out
000074 7088        .dw XT_CSTORE
000075 7037        .dw XT_DOLITERAL
000076 0102        .dw usart_rx_data
000077 71a6        .dw XT_PLUS
000078 7093        .dw XT_CFETCH
000079 701a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00007a ff07          .dw $ff07
00007b 7872
00007c 2d3f
00007d 7369
00007e 0072          .db "rx?-isr",0
00007f 0061          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000080 7000          .dw DO_COLON
                 PFA_RXQ_ISR:
000081 0675        .dw XT_PAUSE
000082 7037        .dw XT_DOLITERAL
000083 0101        .dw usart_rx_out
000084 7093        .dw XT_CFETCH
000085 7037        .dw XT_DOLITERAL
000086 0100        .dw usart_rx_in
000087 7093        .dw XT_CFETCH
000088 7107        .dw XT_NOTEQUAL
000089 701a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00008a ff07          .dw $ff07
00008b 7874
00008c 702d
00008d 6c6f
00008e 006c          .db "tx-poll",0
00008f 007a          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000090 7000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000091 009e        .dw XT_TXQ_POLL
000092 7030        .dw XT_DOCONDBRANCH
000093 0091        .dw PFA_TX_POLL
                   ; send to usart
000094 7037        .dw XT_DOLITERAL
000095 00c6        .dw USART_DATA
000096 7088        .dw XT_CSTORE
000097 701a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000098 ff08          .dw $ff08
000099 7874
00009a 2d3f
00009b 6f70
00009c 6c6c          .db "tx?-poll"
00009d 008a          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
00009e 7000          .dw DO_COLON
                 PFA_TXQ_POLL:
00009f 0675        .dw XT_PAUSE
0000a0 7037        .dw XT_DOLITERAL
0000a1 00c0        .dw USART_A
0000a2 7093        .dw XT_CFETCH
0000a3 7037        .dw XT_DOLITERAL
0000a4 0020        .dw bm_USART_TXRD
0000a5 721c        .dw XT_AND
0000a6 701a        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000a7 ff04        .dw $ff04
0000a8 6275
0000a9 7272        .db "ubrr"
0000aa 0098        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000ab 7069        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ac 0054        .dw EE_UBRRVAL
0000ad 0aaa        .dw XT_EVALUEFETCH
0000ae 0aae        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000af ff06        .dw $ff06
0000b0 752b
0000b1 6173
0000b2 7472        .db "+usart"
0000b3 00a7        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000b4 7000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000b5 7037        .dw XT_DOLITERAL
0000b6 0098        .dw USART_B_VALUE
0000b7 7037        .dw XT_DOLITERAL
0000b8 00c1        .dw USART_B
0000b9 7088        .dw XT_CSTORE
                 
0000ba 7037        .dw XT_DOLITERAL
0000bb 0006        .dw USART_C_VALUE
0000bc 7037        .dw XT_DOLITERAL
0000bd 00c2        .dw USART_C | bm_USARTC_en
0000be 7088        .dw XT_CSTORE
                 
0000bf 00ab        .dw XT_UBRR
0000c0 70ac        .dw XT_DUP
0000c1 730e        .dw XT_BYTESWAP
0000c2 7037        .dw XT_DOLITERAL
0000c3 00c5        .dw BAUDRATE_HIGH
0000c4 7088        .dw XT_CSTORE
0000c5 7037        .dw XT_DOLITERAL
0000c6 00c4        .dw BAUDRATE_LOW
0000c7 7088        .dw XT_CSTORE
                 
0000c8 005b        .dw XT_USART_INIT_RX
0000c9 076f        .dw XT_USART_INIT_TX
0000ca 701a        .dw XT_EXIT
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 .set NUMWORDLISTS = 8
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 067e   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000cb 920a          st -Y, r0
0000cc b60f          in r0, SREG
0000cd 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000ce 900f          pop r0
0000cf 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000d0 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000d1 9200 0114     sts intcur, r0
0000d3 9009          ld r0, Y+
0000d4 be0f          out SREG, r0
0000d5 9009          ld r0, Y+
0000d6 9468          set ; set the interrupt flag for the inner interpreter
0000d7 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
0000d8 ff05          .dw $ff05
0000d9 5f66
0000da 7063
0000db 0075          .db "f_cpu",0
0000dc 00af          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0000dd 7069          .dw PFA_DOVALUE1
                 PFA_F_CPU:
0000de 0056          .dw EE_FCPU
0000df 00e1          .dw XT_FETCH2E
0000e0 00ea          .dw XT_STORE2E
                 
                 XT_FETCH2E:
0000e1 7000          .dw DO_COLON
                 PFA_FETCH2E:
0000e2 736f          .dw XT_FETCHI
0000e3 70ac          .dw XT_DUP
0000e4 0108          .dw XT_CELLPLUS
0000e5 735b          .dw XT_FETCHE
0000e6 70bf          .dw XT_SWAP
0000e7 735b          .dw XT_FETCHE
0000e8 70bf          .dw XT_SWAP
0000e9 701a          .dw XT_EXIT
                 
                 XT_STORE2E:
0000ea 7000          .dw DO_COLON
                 PFA_STORE2E:
0000eb 7037          .dw XT_DOLITERAL
0000ec ffeb          .dw -21
0000ed 045f          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0000ee ff05          .dw $ff05
0000ef 7473
0000f0 7461
0000f1 0065          .db "state",0
0000f2 00d8          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0000f3 7042          .dw PFA_DOVARIABLE
                 PFA_STATE:
0000f4 014d          .dw ram_state
                 
                 .dseg
00014d           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
0000f5 ff04          .dw $ff04
0000f6 6162
0000f7 6573          .db "base"
0000f8 00ee          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0000f9 7052          .dw PFA_DOUSER
                 PFA_BASE:
0000fa 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0000fb ff05          .dw $ff05
0000fc 6563
0000fd 6c6c
0000fe 0073          .db "cells",0
0000ff 00f5          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
000100 7000          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
000101 7214          .dw XT_2STAR
                 .else
                 .endif
000102 701a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
000103 ff05          .dw $ff05
000104 6563
000105 6c6c
000106 002b          .db "cell+",0
000107 00fb          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000108 0109          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000109 9602          adiw tosl, CELLSIZE
00010a 940c 7004     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
00010c ff04          .dw $ff04
00010d 6432
00010e 7075          .db "2dup"
00010f 0103          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000110 7000          .dw DO_COLON
                 PFA_2DUP:
000111 70ca          .dw XT_OVER
000112 70ca          .dw XT_OVER
000113 701a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
000114 ff05          .dw $ff05
000115 6432
000116 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
000117 0070          .db "2drop"
000118 010c          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000119 7000          .dw DO_COLON
                 PFA_2DROP:
00011a 70d4          .dw XT_DROP
00011b 70d4          .dw XT_DROP
00011c 701a          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
00011d ff03          .dw $ff03
00011e 693e
00011f 006e          .db ">in",0
000120 0114          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000121 7052          .dw PFA_DOUSER
                 PFA_G_IN:
000122 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
000123 ff04          .dw $ff04
000124 7423
000125 6269          .db "#tib"
000126 011d          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000127 7042          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000128 014f          .dw ram_sharptib
                 
                 .dseg
00014f           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000129 ff03          .dw $ff03
00012a 6170
00012b 0064          .db "pad",0
00012c 0123          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00012d 7000          .dw DO_COLON
                 PFA_PAD:
00012e 0167          .dw XT_HERE
00012f 7037          .dw XT_DOLITERAL
000130 0064          .dw 100
000131 71a6          .dw XT_PLUS
000132 701a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
000133 ff04          .dw $ff04
000134 6d65
000135 7469          .db "emit"
000136 0129          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000137 07d2          .dw PFA_DODEFER
                 PFA_EMIT:
000138 000e          .dw USER_EMIT
000139 07aa          .dw XT_UDEFERFETCH
00013a 07b1          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00013b ff05          .dw $ff05
00013c 6d65
00013d 7469
00013e 003f          .db "emit?",0
00013f 0133          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000140 07d2          .dw PFA_DODEFER
                 PFA_EMITQ:
000141 0010          .dw USER_EMITQ
000142 07aa          .dw XT_UDEFERFETCH
000143 07b1          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
000144 ff03          .dw $ff03
000145 656b
000146 0079          .db "key",0
000147 013b          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000148 07d2          .dw PFA_DODEFER
                 PFA_KEY:
000149 0012          .dw USER_KEY
00014a 07aa          .dw XT_UDEFERFETCH
00014b 07b1          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
00014c ff04          .dw $ff04
00014d 656b
00014e 3f79          .db "key?"
00014f 0144          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000150 07d2          .dw PFA_DODEFER
                 PFA_KEYQ:
000151 0014          .dw USER_KEYQ
000152 07aa          .dw XT_UDEFERFETCH
000153 07b1          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000154 ff02          .dw $ff02
000155 7064          .db "dp"
000156 014c          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000157 7069          .dw PFA_DOVALUE1
                 PFA_DP:
000158 0002          .dw EE_DP
000159 0aaa          .dw XT_EVALUEFETCH
00015a 0aae          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
00015b ff03          .dw $ff03
00015c 6465
00015d 0070          .db "edp",0
00015e 0154          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
00015f 7069          .dw PFA_DOVALUE1
                 PFA_EDP:
000160 0006          .dw EE_EDP
000161 0aaa          .dw XT_EVALUEFETCH
000162 0aae          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000163 ff04          .dw $ff04
000164 6568
000165 6572          .db "here"
000166 015b          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000167 7069          .dw PFA_DOVALUE1
                 PFA_HERE:
000168 0004          .dw EE_HERE
000169 0aaa          .dw XT_EVALUEFETCH
00016a 0aae          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00016b ff05          .dw $ff05
00016c 6c61
00016d 6f6c
00016e 0074          .db "allot",0
00016f 0163          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000170 7000          .dw DO_COLON
                 PFA_ALLOT:
000171 0167          .dw XT_HERE
000172 71a6          .dw XT_PLUS
000173 078a          .dw XT_DOTO
000174 0168          .dw PFA_HERE
000175 701a          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000176 ff08          .dw $ff08
000177 6328
000178 6572
000179 7461
00017a 2965          .db "(create)"
00017b 016b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00017c 7000          .dw DO_COLON
                 PFA_DOCREATE:
00017d 05ef          .dw XT_PARSENAME
00017e 09f9          .dw XT_WLSCOPE
00017f 70ac          .dw XT_DUP
000180 70f3          .dw XT_TO_R
000181 09de          .dw XT_HEADER
000182 70ea          .dw XT_R_FROM
                 .dseg
000151           COLON_SMUDGE: .byte 4
                 .cseg
000183 7037          .dw XT_DOLITERAL
000184 0153          .dw COLON_SMUDGE+2
000185 707c          .dw XT_STORE		; save wid
000186 7037          .dw XT_DOLITERAL
000187 0151          .dw COLON_SMUDGE+0
000188 707c          .dw XT_STORE		; save NFA
                 
000189 701a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
00018a 0001          .dw $0001
00018b 005c          .db "\",0
00018c 0176          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00018d 7000          .dw DO_COLON
                 PFA_BACKSLASH:
00018e 05d4          .dw XT_SOURCE
00018f 70bf          .dw XT_SWAP
000190 70d4          .dw XT_DROP
000191 0121          .dw XT_G_IN
000192 707c          .dw XT_STORE
000193 701a          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
000194 0001          .dw $0001
000195 0028          .db "(" ,0
000196 018a          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
000197 7000          .dw DO_COLON
                 PFA_LPARENTHESIS:
000198 7037          .dw XT_DOLITERAL
000199 0029          .dw $29
00019a 05a0          .dw XT_PARSE
00019b 0119          .dw XT_2DROP
00019c 701a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
00019d ff07          .dw $ff07
00019e 6f63
00019f 706d
0001a0 6c69
0001a1 0065          .db "compile",0
0001a2 0194          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001a3 7000          .dw DO_COLON
                 PFA_COMPILE:
0001a4 70ea          .dw XT_R_FROM
0001a5 70ac          .dw XT_DUP
0001a6 7238          .dw XT_1PLUS
0001a7 70f3          .dw XT_TO_R
0001a8 736f          .dw XT_FETCHI
0001a9 01ae          .dw XT_COMMA
0001aa 701a          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001ab ff01          .dw $ff01
0001ac 002c          .db ',',0 ; ,
0001ad 019d          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001ae 7000          .dw DO_COLON
                 PFA_COMMA:
0001af 0157          .dw XT_DP
0001b0 7379          .dw XT_STOREI
0001b1 0157          .dw XT_DP
0001b2 7238          .dw XT_1PLUS
0001b3 078a          .dw XT_DOTO
0001b4 0158          .dw PFA_DP
0001b5 701a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0001b6 0003          .dw $0003
0001b7 275b
0001b8 005d          .db "[']",0
0001b9 01ab          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001ba 7000          .dw DO_COLON
                 PFA_BRACKETTICK:
0001bb 01a3          .dw XT_COMPILE
0001bc 7037          .dw XT_DOLITERAL
0001bd 0432          .dw XT_TICK
0001be 01ae          .dw XT_COMMA
0001bf 701a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
0001c0 ff03          .dw $ff03
0001c1 6962
0001c2 006e          .db "bin",0
0001c3 01b6          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0001c4 7000          .dw DO_COLON
                 PFA_BIN:
0001c5 7037          .dw XT_DOLITERAL
0001c6 0002          .dw 2
0001c7 00f9          .dw XT_BASE
0001c8 707c          .dw XT_STORE
0001c9 701a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
0001ca ff07          .dw $ff07
0001cb 6564
0001cc 6963
0001cd 616d
0001ce 006c          .db "decimal",0
0001cf 01c0          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0001d0 7000          .dw DO_COLON
                 PFA_DECIMAL:
0001d1 7037          .dw XT_DOLITERAL
0001d2 000a          .dw 10
0001d3 00f9          .dw XT_BASE
0001d4 707c          .dw XT_STORE
0001d5 701a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
0001d6 ff03          .dw $ff03
0001d7 6568
0001d8 0078          .db "hex",0
0001d9 01ca          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0001da 7000          .dw DO_COLON
                 PFA_HEX:
0001db 7037          .dw XT_DOLITERAL
0001dc 0010          .dw 16
0001dd 00f9          .dw XT_BASE
0001de 707c          .dw XT_STORE
0001df 701a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
0001e0 ff02          .dw $ff02
0001e1 6c62          .db "bl"
0001e2 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0001e3 7042          .dw PFA_DOVARIABLE
                 PFA_BL:
0001e4 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0001e5 ff07          .dw $ff07
0001e6 7574
0001e7 6e72
0001e8 656b
0001e9 0079          .db "turnkey",0
0001ea 01e0          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0001eb 07d2          .dw PFA_DODEFER
                 PFA_TURNKEY:
0001ec 0008          .dw EE_TURNKEY
0001ed 0796          .dw XT_EDEFERFETCH
0001ee 079b          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
0001ef ff05          .dw $ff05
0001f0 2f2a
0001f1 6f6d
0001f2 0064          .db "*/mod",0
0001f3 01e5          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
0001f4 7000          .dw DO_COLON
                 PFA_STARSLASHMOD:
0001f5 70f3          .dw XT_TO_R
0001f6 71af          .dw XT_MSTAR
0001f7 70ea          .dw XT_R_FROM
0001f8 71cb          .dw XT_UMSLASHMOD
0001f9 701a          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0001fa ff04          .dw $ff04
0001fb 6d2f
0001fc 646f          .db "/mod"
0001fd 01ef          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0001fe 01ff          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0001ff 019c          movw temp2, tosl
                     
000200 9109          ld temp0, Y+
000201 9119          ld temp1, Y+
                 
000202 2f41          mov	temp6,temp1	;move dividend High to sign register
000203 2743          eor	temp6,temp3	;xor divisor High with sign register
000204 ff17          sbrs	temp1,7	;if MSB in dividend set
000205 c004          rjmp	PFA_SLASHMOD_1
000206 9510          com	temp1		;    change sign of dividend
000207 9500          com	temp0		
000208 5f0f          subi	temp0,low(-1)
000209 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00020a ff37          sbrs	temp3,7	;if MSB in divisor set
00020b c004          rjmp	PFA_SLASHMOD_2
00020c 9530          com	temp3		;    change sign of divisor
00020d 9520          com	temp2		
00020e 5f2f          subi	temp2,low(-1)
00020f 4f3f          sbci	temp3,high(-1)
000210 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000211 18ff          sub	temp5,temp5;clear remainder High byte and carry
000212 e151          ldi	temp7,17	;init loop counter
                 
000213 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000214 1f11          rol	temp1
000215 955a          dec	temp7		;decrement counter
000216 f439          brne	PFA_SLASHMOD_5		;if done
000217 ff47          sbrs	temp6,7		;    if MSB in sign register set
000218 c004          rjmp	PFA_SLASHMOD_4
000219 9510          com	temp1	;        change sign of result
00021a 9500          com	temp0
00021b 5f0f          subi	temp0,low(-1)
00021c 4f1f          sbci	temp1,high(-1)
00021d c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00021e 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00021f 1cff          rol	temp5
000220 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000221 0af3          sbc	temp5,temp3	;
000222 f420          brcc	PFA_SLASHMOD_6		;if result negative
000223 0ee2          add	temp4,temp2	;    restore remainder
000224 1ef3          adc	temp5,temp3
000225 9488          clc			;    clear carry to be shifted into result
000226 cfec          rjmp	PFA_SLASHMOD_3		;else
000227 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000228 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000229 92fa          st -Y,temp5
00022a 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00022b 01c8          movw tosl, temp0
00022c 940c 7004     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
00022e ff02          .dw $ff02
00022f 2f2a          .db "*/"
000230 01fa          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000231 7000          .dw DO_COLON
                 PFA_STARSLASH:
000232 01f4          .dw XT_STARSLASHMOD
000233 70bf          .dw XT_SWAP
000234 70d4          .dw XT_DROP
000235 701a          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000236 ff05          .dw $ff05
000237 2f75
000238 6f6d
000239 0064          .db "u/mod",0
00023a 022e          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00023b 7000          .dw DO_COLON
                 PFA_USLASHMOD:
00023c 70f3          .dw XT_TO_R
00023d 7134          .dw XT_ZERO
00023e 70ea          .dw XT_R_FROM
00023f 71cb          .dw XT_UMSLASHMOD
000240 701a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000241 ff06          .dw $ff06
000242 656e
000243 6167
000244 6574          .db "negate"
000245 0236          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000246 7000          .dw DO_COLON
                 PFA_NEGATE:
000247 7206          .dw XT_INVERT
000248 7238          .dw XT_1PLUS
000249 701a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
00024a ff01          .dw $ff01
00024b 002f          .db "/",0
00024c 0241          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00024d 7000          .dw DO_COLON
                 PFA_SLASH:
00024e 01fe          .dw XT_SLASHMOD
00024f 70bf          .dw XT_SWAP
000250 70d4          .dw XT_DROP
000251 701a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
000252 ff03          .dw $ff03
000253 6f6d
000254 0064          .db "mod",0
000255 024a          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000256 7000          .dw DO_COLON
                 PFA_MOD:
000257 01fe          .dw XT_SLASHMOD
000258 70d4          .dw XT_DROP
000259 701a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
00025a ff03          .dw $ff03
00025b 6261
00025c 0073          .db "abs",0
00025d 0252          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00025e 025f          .dw PFA_ABS
                 PFA_ABS:
00025f 2399          tst tosh
000260 f41a          brpl PFA_ABS1
000261 9580          com tosl
000262 9590          com tosh
000263 9601          adiw tosl, 1
                 PFA_ABS1:
000264 940c 7004     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
000266 ff03          .dw $ff03
000267 696d
000268 006e          .db "min",0
000269 025a          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00026a 7000          .dw DO_COLON
                 PFA_MIN:
00026b 0110          .dw XT_2DUP
00026c 7126          .dw XT_GREATER
00026d 7030          .dw XT_DOCONDBRANCH
00026e 0270          .dw PFA_MIN1
00026f 70bf          .dw XT_SWAP
                 PFA_MIN1:
000270 70d4          .dw XT_DROP
000271 701a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
000272 ff03          .dw $ff03
000273 616d
000274 0078          .db "max",0
000275 0266          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000276 7000          .dw DO_COLON
                 PFA_MAX:
000277 0110          .dw XT_2DUP
000278 711f          .dw XT_LESS
000279 7030          .dw XT_DOCONDBRANCH
00027a 027c          .dw PFA_MAX1
00027b 70bf          .dw XT_SWAP
                 PFA_MAX1:
00027c 70d4          .dw XT_DROP
00027d 701a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
00027e ff06          .dw $ff06
00027f 6977
000280 6874
000281 6e69          .db "within"
000282 0272          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000283 7000          .dw DO_COLON
                 PFA_WITHIN:
000284 70ca          .dw XT_OVER
000285 719c          .dw XT_MINUS
000286 70f3          .dw XT_TO_R
000287 719c          .dw XT_MINUS
000288 70ea          .dw XT_R_FROM
000289 7146          .dw XT_ULESS
00028a 701a          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
00028b ff07          .dw $ff07 
00028c 6f74
00028d 7075
00028e 6570
00028f 0072          .db "toupper",0
000290 027e          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000291 7000          .dw DO_COLON 
                 PFA_TOUPPER:
000292 70ac          .dw XT_DUP 
000293 7037          .dw XT_DOLITERAL 
000294 0061          .dw 'a' 
000295 7037          .dw XT_DOLITERAL 
000296 007b          .dw 'z'+1
000297 0283          .dw XT_WITHIN 
000298 7030          .dw XT_DOCONDBRANCH
000299 029d          .dw PFA_TOUPPER0 
00029a 7037          .dw XT_DOLITERAL
00029b 00df          .dw $df ; inverse of 0x20
00029c 721c          .dw XT_AND 
                 PFA_TOUPPER0:
00029d 701a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
00029e ff07          .dw $ff07
00029f 6f74
0002a0 6f6c
0002a1 6577
0002a2 0072          .db "tolower",0
0002a3 028b          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0002a4 7000          .dw DO_COLON
                 PFA_TOLOWER:
0002a5 70ac          .dw XT_DUP
0002a6 7037          .dw XT_DOLITERAL
0002a7 0041          .dw 'A'
0002a8 7037          .dw XT_DOLITERAL
0002a9 005b          .dw 'Z'+1
0002aa 0283          .dw XT_WITHIN
0002ab 7030          .dw XT_DOCONDBRANCH
0002ac 02b0          .dw PFA_TOLOWER0 
0002ad 7037          .dw XT_DOLITERAL
0002ae 0020          .dw $20 
0002af 7225          .dw XT_OR 
                 PFA_TOLOWER0:
0002b0 701a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002b1 ff03          .dw $ff03
0002b2 6c68
0002b3 0064          .db "hld",0
0002b4 029e          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002b5 7042          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002b6 0155          .dw ram_hld
                 
                 .dseg
000155           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0002b7 ff04          .dw $ff04
0002b8 6f68
0002b9 646c          .db "hold"
0002ba 02b1          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0002bb 7000          .dw DO_COLON
                 PFA_HOLD:
0002bc 02b5          .dw XT_HLD
0002bd 70ac          .dw XT_DUP
0002be 7074          .dw XT_FETCH
0002bf 723e          .dw XT_1MINUS
0002c0 70ac          .dw XT_DUP
0002c1 70f3          .dw XT_TO_R
0002c2 70bf          .dw XT_SWAP
0002c3 707c          .dw XT_STORE
0002c4 70ea          .dw XT_R_FROM
0002c5 7088          .dw XT_CSTORE
0002c6 701a          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
0002c7 ff02          .dw $ff02
0002c8 233c          .db "<#"
0002c9 02b7          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0002ca 7000          .dw DO_COLON
                 PFA_L_SHARP:
0002cb 012d          .dw XT_PAD
0002cc 02b5          .dw XT_HLD
0002cd 707c          .dw XT_STORE
0002ce 701a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
0002cf ff01          .dw $ff01
0002d0 0023          .db "#",0
0002d1 02c7          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0002d2 7000          .dw DO_COLON
                 PFA_SHARP:
0002d3 00f9          .dw XT_BASE
0002d4 7074          .dw XT_FETCH
0002d5 0351          .dw XT_UDSLASHMOD
0002d6 70dc          .dw XT_ROT
0002d7 7037          .dw XT_DOLITERAL
0002d8 0009          .dw 9
0002d9 70ca          .dw XT_OVER
0002da 711f          .dw XT_LESS
0002db 7030          .dw XT_DOCONDBRANCH
0002dc 02e0          .dw PFA_SHARP1
0002dd 7037          .dw XT_DOLITERAL
0002de 0007          .dw 7
0002df 71a6          .dw XT_PLUS
                 PFA_SHARP1:
0002e0 7037          .dw XT_DOLITERAL
0002e1 0030          .dw $30
0002e2 71a6          .dw XT_PLUS
0002e3 02bb          .dw XT_HOLD
0002e4 701a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
0002e5 ff02          .dw $ff02
0002e6 7323          .db "#s"
0002e7 02cf          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0002e8 7000          .dw DO_COLON
                 PFA_SHARP_S:
0002e9 02d2          .dw XT_SHARP
0002ea 0110          .dw XT_2DUP
0002eb 7225          .dw XT_OR
0002ec 7118          .dw XT_EQUALZERO
0002ed 7030          .dw XT_DOCONDBRANCH
0002ee 02e9          .dw PFA_SHARP_S
0002ef 701a          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
0002f0 ff02          .dw $ff02
0002f1 3e23          .db "#>"
0002f2 02e5          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0002f3 7000          .dw DO_COLON
                 PFA_SHARP_G:
0002f4 0119          .dw XT_2DROP
0002f5 02b5          .dw XT_HLD
0002f6 7074          .dw XT_FETCH
0002f7 70ac          .dw XT_DUP
0002f8 012d          .dw XT_PAD
0002f9 70bf          .dw XT_SWAP
0002fa 719c          .dw XT_MINUS
0002fb 701a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
0002fc ff04          .dw $ff04
0002fd 6973
0002fe 6e67          .db "sign"
0002ff 02f0          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000300 7000          .dw DO_COLON
                 PFA_SIGN:
000301 712d          .dw XT_LESSZERO
000302 7030          .dw XT_DOCONDBRANCH
000303 0307          .dw PFA_SIGN1
000304 7037          .dw XT_DOLITERAL
000305 002d          .dw $2d
000306 02bb          .dw XT_HOLD
                 PFA_SIGN1:
000307 701a          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
000308 ff03          .dw $ff03
000309 2e64
00030a 0072          .db "d.r",0
00030b 02fc          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00030c 7000          .dw DO_COLON
                 PFA_DDOTR:
00030d 70f3          .dw XT_TO_R
00030e 70bf          .dw XT_SWAP
00030f 70ca          .dw XT_OVER
000310 0892          .dw XT_DABS
000311 02ca          .dw XT_L_SHARP
000312 02e8          .dw XT_SHARP_S
000313 70dc          .dw XT_ROT
000314 0300          .dw XT_SIGN
000315 02f3          .dw XT_SHARP_G
000316 70ea          .dw XT_R_FROM
000317 70ca          .dw XT_OVER
000318 719c          .dw XT_MINUS
000319 0414          .dw XT_SPACES
00031a 0423          .dw XT_TYPE
00031b 701a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
00031c ff02          .dw $ff02
00031d 722e          .db ".r"
00031e 0308          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00031f 7000          .dw DO_COLON
                 PFA_DOTR:
000320 70f3          .dw XT_TO_R
000321 7329          .dw XT_S2D
000322 70ea          .dw XT_R_FROM
000323 030c          .dw XT_DDOTR
000324 701a          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
000325 ff02          .dw $ff02
000326 2e64          .db "d."
000327 031c          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000328 7000          .dw DO_COLON
                 PFA_DDOT:
000329 7134          .dw XT_ZERO
00032a 030c          .dw XT_DDOTR
00032b 040b          .dw XT_SPACE
00032c 701a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
00032d ff01          .dw $ff01
00032e 002e          .db ".",0
00032f 0325          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000330 7000          .dw DO_COLON
                 PFA_DOT:
000331 7329          .dw XT_S2D
000332 0328          .dw XT_DDOT
000333 701a          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
000334 ff03          .dw $ff03
000335 6475
000336 002e          .db "ud.",0
000337 032d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000338 7000          .dw DO_COLON
                 PFA_UDDOT:
000339 7134          .dw XT_ZERO
00033a 0341          .dw XT_UDDOTR
00033b 040b          .dw XT_SPACE
00033c 701a          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
00033d ff04          .dw $ff04
00033e 6475
00033f 722e          .db "ud.r"
000340 0334          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000341 7000          .dw DO_COLON
                 PFA_UDDOTR:
000342 70f3          .dw XT_TO_R
000343 02ca          .dw XT_L_SHARP
000344 02e8          .dw XT_SHARP_S
000345 02f3          .dw XT_SHARP_G
000346 70ea          .dw XT_R_FROM
000347 70ca          .dw XT_OVER
000348 719c          .dw XT_MINUS
000349 0414          .dw XT_SPACES
00034a 0423          .dw XT_TYPE
00034b 701a          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
00034c ff06          .dw $ff06
00034d 6475
00034e 6d2f
00034f 646f          .db "ud/mod"
000350 033d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000351 7000          .dw DO_COLON
                 PFA_UDSLASHMOD:
000352 70f3          .dw XT_TO_R
000353 7134          .dw XT_ZERO
000354 70fc          .dw XT_R_FETCH
000355 71cb          .dw XT_UMSLASHMOD
000356 70ea          .dw XT_R_FROM
000357 70bf          .dw XT_SWAP
000358 70f3          .dw XT_TO_R
000359 71cb          .dw XT_UMSLASHMOD
00035a 70ea          .dw XT_R_FROM
00035b 701a          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
00035c ff06          .dw $ff06 
00035d 6964
00035e 6967
00035f 3f74          .db "digit?"
000360 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000361 7000          .dw DO_COLON 
                 PFA_DIGITQ:
000362 0291          .dw XT_TOUPPER
000363 7037          .dw XT_DOLITERAL 
000364 0030          .dw $30 
000365 719c          .dw XT_MINUS 
000366 70ac          .dw XT_DUP 
000367 7037          .dw XT_DOLITERAL
000368 0009          .dw $09 
000369 7151          .dw XT_UGREATER 
00036a 7030          .dw XT_DOCONDBRANCH
00036b 0378          .dw PFA_DIGITQ0 
00036c 7037          .dw XT_DOLITERAL
00036d 0007          .dw $07 
00036e 719c          .dw XT_MINUS 
00036f 70ac          .dw XT_DUP 
000370 7037          .dw XT_DOLITERAL
000371 0009          .dw $09 
000372 0387          .dw XT_ULESSEQUAL
000373 7030          .dw XT_DOCONDBRANCH
000374 0378          .dw PFA_DIGITQ1 
000375 70d4          .dw XT_DROP 
000376 7134          .dw XT_ZERO
000377 701a          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
000378 70ac          .dw XT_DUP 
000379 00f9          .dw XT_BASE 
00037a 7074          .dw XT_FETCH 
00037b 038f          .dw XT_UGREATEREQUAL
00037c 7030          .dw XT_DOCONDBRANCH
00037d 0381          .dw PFA_DIGITQ2 
00037e 70d4          .dw XT_DROP 
00037f 7134          .dw XT_ZERO
000380 701a          .dw XT_EXIT 
                 PFA_DIGITQ2:
000381 713d          .dw XT_TRUE
000382 701a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
000383 ff03          .dw $ff03 
000384 3c75
000385 003d          .db "u<=",0
000386 035c          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
000387 7000          .dw DO_COLON 
                 PFA_ULESSEQUAL:
000388 7151          .dw XT_UGREATER 
000389 7206          .dw XT_INVERT 
00038a 701a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
00038b ff03          .dw $ff03 
00038c 3e75
00038d 003d          .db "u>=",0
00038e 0383          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
00038f 7000          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
000390 7146          .dw XT_ULESS 
000391 7206          .dw XT_INVERT 
000392 701a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000393 7000        .dw DO_COLON
                 PFA_DOSLITERAL:
000394 70ea        .dw XT_R_FROM   ; ( -- addr )
000395 70ac        .dw XT_DUP      ; ( -- addr addr )
000396 70ac        .dw XT_DUP
000397 736f        .dw XT_FETCHI   ; ( -- addr addr n )
000398 70bf        .dw XT_SWAP
000399 7238        .dw XT_1PLUS
00039a 70bf        .dw XT_SWAP
00039b 70dc        .dw XT_ROT      ; ( -- addr' n addr )
00039c 70ca        .dw XT_OVER     ; ( -- addr' n addr n)
00039d 7238        .dw XT_1PLUS
00039e 720d        .dw XT_2SLASH   ; ( -- addr' n addr k )
00039f 71a6        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003a0 7238        .dw XT_1PLUS
0003a1 70f3        .dw XT_TO_R     ; ( -- )
0003a2 701a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003a3 ff02        .dw $ff02
0003a4 2c73        .db "s",$2c
0003a5 038b        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003a6 7000          .dw DO_COLON
                 PFA_SCOMMA:
0003a7 70ac          .dw XT_DUP
0003a8 03aa          .dw XT_DOSCOMMA
0003a9 701a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003aa 7000          .dw DO_COLON
                 PFA_DOSCOMMA:
0003ab 01ae          .dw XT_COMMA
0003ac 70ac          .dw XT_DUP   ; ( --addr len len)
0003ad 720d          .dw XT_2SLASH ; ( -- addr len len/2
0003ae 70bf          .dw XT_SWAP   ; ( -- addr len/2 len
0003af 70ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003b0 7214          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003b1 719c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003b2 70f3          .dw XT_TO_R
0003b3 7134          .dw XT_ZERO
0003b4 72aa          .dw XT_DOQDO
0003b5 03bc          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0003b6 70ac          .dw XT_DUP         ; ( -- addr addr )
0003b7 7074          .dw XT_FETCH       ; ( -- addr c1c2 )
0003b8 01ae          .dw XT_COMMA       ; ( -- addr )
0003b9 0108          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003ba 72d8          .dw XT_DOLOOP
0003bb 03b6          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003bc 70ea          .dw XT_R_FROM
0003bd 715c          .dw XT_GREATERZERO
0003be 7030          .dw XT_DOCONDBRANCH
0003bf 03c3          .dw PFA_SCOMMA3
0003c0 70ac            .dw XT_DUP     ; well, tricky
0003c1 7093            .dw XT_CFETCH
0003c2 01ae            .dw XT_COMMA
                 PFA_SCOMMA3:
0003c3 70d4          .dw XT_DROP        ; ( -- )
0003c4 701a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003c5 ff05          .dw $ff05
0003c6 7469
0003c7 7079
0003c8 0065          .db "itype",0
0003c9 03a3          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003ca 7000          .dw DO_COLON
                 PFA_ITYPE:
0003cb 70ac          .dw XT_DUP    ; ( --addr len len)
0003cc 720d          .dw XT_2SLASH ; ( -- addr len len/2
0003cd 70bf          .dw XT_SWAP   ; ( -- addr len/2 len
0003ce 70ca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003cf 7214          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003d0 719c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003d1 70f3          .dw XT_TO_R
0003d2 7134          .dw XT_ZERO
0003d3 72aa          .dw XT_DOQDO
0003d4 03dd          .dw PFA_ITYPE2
                 PFA_ITYPE1:
0003d5 70ac          .dw XT_DUP         ; ( -- addr addr )
0003d6 736f          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003d7 70ac          .dw XT_DUP
0003d8 03ea          .dw XT_LOWEMIT
0003d9 03e6          .dw XT_HIEMIT
0003da 7238          .dw XT_1PLUS    ; ( -- addr+cell )
0003db 72d8          .dw XT_DOLOOP
0003dc 03d5          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0003dd 70ea          .dw XT_R_FROM
0003de 715c          .dw XT_GREATERZERO
0003df 7030          .dw XT_DOCONDBRANCH
0003e0 03e4          .dw PFA_ITYPE3
0003e1 70ac            .dw XT_DUP     ; make sure the drop below has always something to do
0003e2 736f            .dw XT_FETCHI
0003e3 03ea            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0003e4 70d4          .dw XT_DROP
0003e5 701a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0003e6 7000          .dw DO_COLON
                 PFA_HIEMIT:
0003e7 730e          .dw XT_BYTESWAP
0003e8 03ea          .dw XT_LOWEMIT
0003e9 701a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0003ea 7000          .dw DO_COLON
                 PFA_LOWEMIT:
0003eb 7037          .dw XT_DOLITERAL
0003ec 00ff          .dw $00ff
0003ed 721c          .dw XT_AND
0003ee 0137          .dw XT_EMIT
0003ef 701a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0003f0 ff06          .dw $ff06
0003f1 6369
0003f2 756f
0003f3 746e          .db "icount"
0003f4 03c5          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0003f5 7000          .dw DO_COLON
                 PFA_ICOUNT:
0003f6 70ac          .dw XT_DUP
0003f7 7238          .dw XT_1PLUS
0003f8 70bf          .dw XT_SWAP
0003f9 736f          .dw XT_FETCHI
0003fa 701a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
0003fb ff02          .dw $ff02
0003fc 7263          .db "cr"
0003fd 03f0          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0003fe 7000          .dw DO_COLON
                 PFA_CR:
0003ff 7037          .dw XT_DOLITERAL
000400 000d          .dw 13
000401 0137          .dw XT_EMIT
000402 7037          .dw XT_DOLITERAL
000403 000a          .dw 10
000404 0137          .dw XT_EMIT
000405 701a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
000406 ff05          .dw $ff05
000407 7073
000408 6361
000409 0065          .db "space",0
00040a 03fb          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00040b 7000          .dw DO_COLON
                 PFA_SPACE:
00040c 01e3          .dw XT_BL
00040d 0137          .dw XT_EMIT
00040e 701a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
00040f ff06          .dw $ff06
000410 7073
000411 6361
000412 7365          .db "spaces"
000413 0406          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000414 7000          .dw DO_COLON
                 PFA_SPACES:
000415 70ac          .dw XT_DUP
000416 715c          .dw XT_GREATERZERO
000417 721c          .dw XT_AND
000418 7134          .dw XT_ZERO
000419 72aa          .dw XT_DOQDO
00041a 041e          .dw PFA_SPACES2
                 PFA_SPACES1:
00041b 040b          .dw XT_SPACE
00041c 72d8          .dw XT_DOLOOP
00041d 041b          .dw PFA_SPACES1
                 PFA_SPACES2:
00041e 701a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
00041f ff04          .dw $ff04
000420 7974
000421 6570          .db "type"
000422 040f          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000423 7000          .dw DO_COLON
                 PFA_TYPE:
000424 70ca          .dw XT_OVER
000425 71a6          .dw XT_PLUS
000426 70bf          .dW XT_SWAP
000427 72aa          .dw XT_DOQDO
000428 042e          .dw PFA_TYPE2
                 PFA_TYPE1:
000429 72bd          .dw XT_I
00042a 7093          .dw XT_CFETCH
00042b 0137          .dw XT_EMIT
00042c 72d8          .dw XT_DOLOOP
00042d 0429          .dw PFA_TYPE1
                 PFA_TYPE2:
00042e 701a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
00042f ff01          .dw $ff01
000430 0027          .db "'",0
000431 041f          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000432 7000          .dw DO_COLON
                 PFA_TICK:
000433 05ef          .dw XT_PARSENAME
000434 060c          .dw XT_FINDNAME
000435 7118          .dw XT_EQUALZERO
000436 7030          .dw XT_DOCONDBRANCH
000437 043b          .dw PFA_TICK1
000438 7037          .dw XT_DOLITERAL
000439 fff3          .dw -13
00043a 045f          .dw XT_THROW
                 PFA_TICK1:
00043b 701a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
00043c ff07          .dw $ff07
00043d 6168
00043e 646e
00043f 656c
000440 0072          .db "handler",0
000441 042f          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000442 7052          .dw PFA_DOUSER
                 PFA_HANDLER:
000443 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
000444 ff05          .dw $ff05
000445 6163
000446 6374
000447 0068          .db "catch",0
000448 043c          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000449 7000          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
00044a 728a          .dw XT_SP_FETCH
00044b 70f3          .dw XT_TO_R
                     ; handler @ >r
00044c 0442          .dw XT_HANDLER
00044d 7074          .dw XT_FETCH
00044e 70f3          .dw XT_TO_R
                     ; rp@ handler !
00044f 7273          .dw XT_RP_FETCH
000450 0442          .dw XT_HANDLER
000451 707c          .dw XT_STORE
000452 7024          .dw XT_EXECUTE
                     ; r> handler !
000453 70ea          .dw XT_R_FROM
000454 0442          .dw XT_HANDLER
000455 707c          .dw XT_STORE
000456 70ea          .dw XT_R_FROM
000457 70d4          .dw XT_DROP
000458 7134          .dw XT_ZERO
000459 701a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
00045a ff05          .dw $ff05
00045b 6874
00045c 6f72
00045d 0077          .db "throw",0
00045e 0444          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00045f 7000          .dw DO_COLON
                 PFA_THROW:
000460 70ac          .dw XT_DUP
000461 7118          .dw XT_EQUALZERO
000462 7030          .dw XT_DOCONDBRANCH
000463 0466          .dw PFA_THROW1
000464 70d4      	.dw XT_DROP
000465 701a      	.dw XT_EXIT
                 PFA_THROW1:
000466 0442          .dw XT_HANDLER
000467 7074          .dw XT_FETCH
000468 727d          .dw XT_RP_STORE
000469 70ea          .dw XT_R_FROM
00046a 0442          .dw XT_HANDLER
00046b 707c          .dw XT_STORE
00046c 70ea          .dw XT_R_FROM
00046d 70bf          .dw XT_SWAP
00046e 70f3          .dw XT_TO_R
00046f 7293          .dw XT_SP_STORE
000470 70d4          .dw XT_DROP
000471 70ea          .dw XT_R_FROM    
000472 701a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
000473 ff05          .dw $ff05
000474 7363
000475 696b
000476 0070          .db "cskip",0
000477 045a          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000478 7000          .dw DO_COLON
                 PFA_CSKIP:
000479 70f3          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00047a 70ac          .dw XT_DUP            ; ( -- addr' n' n' )
00047b 7030          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00047c 0488          .dw PFA_CSKIP2
00047d 70ca          .dw XT_OVER           ; ( -- addr' n' addr' )
00047e 7093          .dw XT_CFETCH         ; ( -- addr' n' c' )
00047f 70fc          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000480 7111          .dw XT_EQUAL          ; ( -- addr' n' f )
000481 7030          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000482 0488          .dw PFA_CSKIP2
000483 7037          .dw XT_DOLITERAL
000484 0001          .dw 1
000485 05de          .dw XT_SLASHSTRING
000486 7029          .dw XT_DOBRANCH
000487 047a          .dw PFA_CSKIP1
                 PFA_CSKIP2:
000488 70ea          .dw XT_R_FROM
000489 70d4          .dw XT_DROP           ; ( -- addr2 n2)
00048a 701a          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
00048b ff06          .dw $ff06
00048c 6361
00048d 6563
00048e 7470          .db "accept"
00048f 0473          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000490 7000          .dw DO_COLON
                 PFA_ACCEPT:
000491 70ac          .dw XT_DUP        ; ( -- addr n1 n1)
000492 70f3          .dw XT_TO_R
000493 70f3          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
000494 0148          .dw XT_KEY        ; ( -- addr k )
000495 70ac          .dw XT_DUP        ; ( -- addr k k )
000496 7037          .dw XT_DOLITERAL
000497 000a          .dw 10
000498 7107          .dw XT_NOTEQUAL
000499 7030          .dw XT_DOCONDBRANCH
00049a 04ce          .dw PFA_ACCEPT2
00049b 70ac          .dw XT_DUP
00049c 7037          .dw XT_DOLITERAL
00049d 000d          .dw 13
00049e 7107          .dw XT_NOTEQUAL
00049f 7030          .dw XT_DOCONDBRANCH
0004a0 04ce          .dw PFA_ACCEPT2
                     ; check backspace
0004a1 70ac          .dw XT_DUP
0004a2 7037          .dw XT_DOLITERAL
0004a3 0008          .dw 8
0004a4 7111          .dw XT_EQUAL
0004a5 7030          .dw XT_DOCONDBRANCH
0004a6 04ba          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
0004a7 70ea          .dw XT_R_FROM             ; ( -- addr k n1 )
0004a8 70fc          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
0004a9 70ca          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
0004aa 70f3          .dw XT_TO_R
0004ab 7111          .dw XT_EQUAL              ; ( -- addr k f )
0004ac 7030          .dw XT_DOCONDBRANCH
0004ad 04b1          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
0004ae 70d4          .dw XT_DROP               ; ( -- addr )
0004af 7029          .dw XT_DOBRANCH
0004b0 0494          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0004b1 70ac          .dw XT_DUP                ; ( -- addr k k )
0004b2 0137          .dw XT_EMIT               ; ( -- addr k )
0004b3 040b          .dw XT_SPACE              ; ( -- addr k )
0004b4 0137          .dw XT_EMIT               ; ( -- addr )
0004b5 723e          .dw XT_1MINUS             ; ( -- addr--)
0004b6 70ea          .dw XT_R_FROM
0004b7 7238          .dw XT_1PLUS
0004b8 7029          .dw XT_DOBRANCH
0004b9 04c8          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
0004ba 70ac          .dw XT_DUP            ; ( -- addr k k )
0004bb 01e3          .dw XT_BL
0004bc 711f          .dw XT_LESS
0004bd 7030          .dw XT_DOCONDBRANCH
0004be 04c1          .dw PFA_ACCEPT6
0004bf 70d4          .dw XT_DROP
0004c0 01e3          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
0004c1 70ac          .dw XT_DUP            ; ( -- addr k k)
0004c2 0137          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
0004c3 70ca          .dw XT_OVER           ; ( -- addr k addr
0004c4 7088          .dw XT_CSTORE         ; ( -- addr)
0004c5 7238          .dw XT_1PLUS          ; ( -- addr++)
0004c6 70ea          .dw XT_R_FROM         ; ( -- addr n1)
0004c7 723e          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
0004c8 70ac          .dw XT_DUP
0004c9 70f3          .dw XT_TO_R
0004ca 7118          .dw XT_EQUALZERO
0004cb 7030          .dw XT_DOCONDBRANCH
0004cc 0494          .dw PFA_ACCEPT1
0004cd 70ac          .dw XT_DUP
                 PFA_ACCEPT2:
0004ce 0119          .dw XT_2DROP
0004cf 70ea          .dw XT_R_FROM
0004d0 70ea          .dw XT_R_FROM
0004d1 70bf          .dw XT_SWAP
0004d2 719c          .dw XT_MINUS
0004d3 03fe          .dw XT_CR
0004d4 701a          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004d5 ff06          .dw $ff06
0004d6 6572
0004d7 6966
0004d8 6c6c          .db "refill"
0004d9 048b          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004da 07d2          .dw PFA_DODEFER
                 PFA_REFILL:
0004db 001a          .dw USER_REFILL
0004dc 07aa          .dw XT_UDEFERFETCH
0004dd 07b1          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
0004de ff04          .dw $ff04
0004df 6863
0004e0 7261          .db "char"
0004e1 04d5          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004e2 7000          .dw DO_COLON
                 PFA_CHAR:
0004e3 05ef          .dw XT_PARSENAME
0004e4 70d4          .dw XT_DROP
0004e5 7093          .dw XT_CFETCH
0004e6 701a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
0004e7 ff06          .dw $ff06
0004e8 756e
0004e9 626d
0004ea 7265          .db "number"
0004eb 04de          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004ec 7000          .dw DO_COLON
                 PFA_NUMBER:
0004ed 00f9          .dw XT_BASE
0004ee 7074          .dw XT_FETCH
0004ef 70f3          .dw XT_TO_R
0004f0 055d          .dw XT_NUMBERSIGN
0004f1 70f3          .dw XT_TO_R
0004f2 0529          .dw XT_PRAEFIX
0004f3 055d          .dw XT_NUMBERSIGN
0004f4 70ea          .dw XT_R_FROM
0004f5 7225          .dw XT_OR
0004f6 70f3          .dw XT_TO_R
0004f7 70f3          .dw XT_TO_R
0004f8 70f3          .dw XT_TO_R
0004f9 7134          .dw XT_ZERO       ; starting value
0004fa 7134          .dw XT_ZERO
0004fb 70ea          .dw XT_R_FROM
0004fc 70ea          .dw XT_R_FROM
0004fd 057c          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0004fe 70b4          .dw XT_QDUP
0004ff 7030              .dw XT_DOCONDBRANCH
000500 051d      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
000501 7037          .dw XT_DOLITERAL
000502 0001          .dw 1
000503 7111          .dw XT_EQUAL
000504 7030          .dw XT_DOCONDBRANCH
000505 0514          .dw PFA_NUMBER2
                 	; excatly one character is left
000506 7093      	.dw XT_CFETCH
000507 7037      	.dw XT_DOLITERAL
000508 002e      	.dw $2e ; .
000509 7111      	.dw XT_EQUAL
00050a 7030      	.dw XT_DOCONDBRANCH
00050b 0514      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
00050c 70ea      	.dw XT_R_FROM
00050d 7030              .dw XT_DOCONDBRANCH
00050e 0510      	.dw PFA_NUMBER3
00050f 089f              .dw XT_DNEGATE
                 PFA_NUMBER3:
000510 7037      	.dw XT_DOLITERAL
000511 0002      	.dw 2
000512 7029      	.dw XT_DOBRANCH
000513 0524      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
000514 0119      	.dw XT_2DROP
000515 70d4      	.dw XT_DROP
000516 70ea      	.dw XT_R_FROM
000517 70d4      	.dw XT_DROP
000518 70ea              .dw XT_R_FROM
000519 00f9              .dw XT_BASE
00051a 707c              .dw XT_STORE
00051b 7134      	.dw XT_ZERO
00051c 701a      	.dw XT_EXIT
                 PFA_NUMBER1:
00051d 0119          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00051e 70ea          .dw XT_R_FROM
00051f 7030          .dw XT_DOCONDBRANCH
000520 0522          .dw PFA_NUMBER4
000521 0246          .dw XT_NEGATE
                 PFA_NUMBER4:
000522 7037          .dw XT_DOLITERAL
000523 0001          .dw 1
                 PFA_NUMBER5:
000524 70ea          .dw XT_R_FROM
000525 00f9          .dw XT_BASE
000526 707c          .dw XT_STORE
000527 713d          .dw XT_TRUE
000528 701a          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
000529 7000          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
00052a 70ca          .dw XT_OVER 
00052b 7093          .dw XT_CFETCH 
00052c 7037          .dw XT_DOLITERAL
00052d 0029          .dw $29 
00052e 7126          .dw XT_GREATER 
00052f 7030          .dw XT_DOCONDBRANCH
000530 0532          .dw PFA_PRAEFIX0 
000531 701a          .dw XT_EXIT 
                 PFA_PRAEFIX0:
000532 70ca          .dw XT_OVER 
000533 7093          .dw XT_CFETCH 
000534 0539          .dw XT_SETBASE
000535 7037          .dw XT_DOLITERAL
000536 0001          .dw $1 
000537 05de          .dw XT_SLASHSTRING 
000538 701a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000539 7000          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
00053a 70ac          .dw XT_DUP 
00053b 7037          .dw XT_DOLITERAL
00053c 0024          .dw '$' 
00053d 7111          .dw XT_EQUAL 
00053e 7030          .dw XT_DOCONDBRANCH
00053f 0543          .dw PFA_SETBASE0 
000540 70d4          .dw XT_DROP 
000541 01da          .dw XT_HEX 
000542 701a          .dw XT_EXIT 
                 PFA_SETBASE0:
000543 70ac          .dw XT_DUP 
000544 7037          .dw XT_DOLITERAL
000545 0025          .dw '%' 
000546 7111          .dw XT_EQUAL 
000547 7030          .dw XT_DOCONDBRANCH
000548 054c          .dw PFA_SETBASE1 
000549 70d4          .dw XT_DROP 
00054a 01c4          .dw XT_BIN
00054b 701a          .dw XT_EXIT 
                 PFA_SETBASE1:
00054c 70ac          .dw XT_DUP 
00054d 7037          .dw XT_DOLITERAL
00054e 0026          .dw '&'
00054f 7111          .dw XT_EQUAL 
000550 7030          .dw XT_DOCONDBRANCH
000551 0555          .dw PFA_SETBASE2 
000552 70d4          .dw XT_DROP
000553 01d0          .dw XT_DECIMAL 
000554 701a          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
000555 7037          .dw XT_DOLITERAL
000556 0023          .dw '#'
000557 7111          .dw XT_EQUAL 
000558 7030          .dw XT_DOCONDBRANCH
000559 055c          .dw PFA_SETBASE3 
00055a 01d0          .dw XT_DECIMAL 
00055b 701a          .dw XT_EXIT 
                 PFA_SETBASE3:
00055c 701a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
00055d 7000          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
00055e 70ca          .dw XT_OVER
00055f 7093          .dw XT_CFETCH
000560 7037          .dw XT_DOLITERAL
000561 002b          .dw '+'
000562 7111          .dw XT_EQUAL
000563 7030          .dw XT_DOCONDBRANCH
000564 0568          .dw PFA_NUMBERSIGN_MINUS
000565 7037            .dw XT_DOLITERAL
000566 0001            .dw 1
000567 05de            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
000568 70ca          .dw XT_OVER    ; ( -- addr len addr )
000569 7093          .dw XT_CFETCH
00056a 7037          .dw XT_DOLITERAL
00056b 002d          .dw '-'
00056c 7111          .dw XT_EQUAL  ; ( -- addr len flag )
00056d 70ac          .dw XT_DUP
00056e 70f3          .dw XT_TO_R
00056f 7030          .dw XT_DOCONDBRANCH
000570 0574          .dw PFA_NUMBERSIGN_PLUS
000571 7037          .dw XT_DOLITERAL      ; skip sign character
000572 0001          .dw 1
000573 05de          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
000574 70ea          .dw XT_R_FROM
000575 701a          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
000576 ff07          .dw $ff07
000577 6e3e
000578 6d75
000579 6562
00057a 0072          .db ">number",0
00057b 04e7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00057c 7000          .dw DO_COLON
                 PFA_TO_NUMBER:
00057d 70ac          .dw XT_DUP
00057e 7030          .dw XT_DOCONDBRANCH
00057f 059a          .dw PFA_TO_NUMBER1
000580 70ca              .dw XT_OVER
000581 7093              .dw XT_CFETCH
000582 0361              .dw XT_DIGITQ
000583 7118              .dw XT_EQUALZERO
000584 7030              .dw XT_DOCONDBRANCH
000585 0587              .dw PFA_TO_NUMBER2
000586 701a                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
000587 70f3              .dw XT_TO_R
000588 08c4              .dw XT_2SWAP
000589 70ea              .dw XT_R_FROM
00058a 70bf              .dw XT_SWAP
00058b 00f9              .dw XT_BASE
00058c 7074              .dw XT_FETCH
00058d 71e9              .dw XT_UMSTAR
00058e 70d4              .dw XT_DROP
00058f 70dc              .dw XT_ROT
000590 00f9              .dw XT_BASE
000591 7074              .dw XT_FETCH
000592 71e9              .dw XT_UMSTAR
000593 0cd2              .dw XT_DPLUS
000594 08c4              .dw XT_2SWAP
000595 7037              .dw XT_DOLITERAL
000596 0001              .dw 1
000597 05de              .dw XT_SLASHSTRING
000598 7029          .dw XT_DOBRANCH
000599 057d          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
00059a 701a          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
00059b ff05          .dw $ff05
00059c 6170
00059d 7372
00059e 0065          .db "parse",0
00059f 0576          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0005a0 7000          .dw DO_COLON
                 PFA_PARSE:
0005a1 70f3          .dw XT_TO_R     ; ( -- )
0005a2 05d4          .dw XT_SOURCE   ; ( -- addr len)
0005a3 0121          .dw XT_G_IN     ; ( -- addr len >in)
0005a4 7074          .dw XT_FETCH
0005a5 05de          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0005a6 70ea          .dw XT_R_FROM      ; ( -- addr' len' c)
0005a7 05b5          .dw XT_CSCAN       ; ( -- addr' len'')
0005a8 70ac          .dw XT_DUP         ; ( -- addr' len'' len'')
0005a9 7238          .dw XT_1PLUS
0005aa 0121          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
0005ab 7262          .dw XT_PLUSSTORE   ; ( -- addr' len')
0005ac 7037          .dw XT_DOLITERAL
0005ad 0001          .dw 1
0005ae 05de          .dw XT_SLASHSTRING
0005af 701a          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0005b0 ff05          .dw $ff05
0005b1 7363
0005b2 6163
0005b3 006e          .db "cscan",0
0005b4 059b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0005b5 7000          .dw DO_COLON
                 PFA_CSCAN:
0005b6 70bf          .dw XT_SWAP         ; ( -- addr1 c n1 )
0005b7 70ac          .dw XT_DUP          ; ( -- addr1 c n1 n1)
0005b8 70f3          .dw XT_TO_R         ; ( -- addr1 c n1)
0005b9 7134          .dw XT_ZERO         ; ( -- addr1 c n1 0)
0005ba 72aa          .dw XT_DOQDO        ; ( -- addr1 c)
0005bb 05cc          .dw PFA_CSCAN3
                 PFA_CSCAN1:
0005bc 70ca          .dw XT_OVER         ; ( -- addr1 c addr1 )
0005bd 72bd          .dw XT_I            ; ( -- addr1 c addr1 i)
0005be 71a6          .dw XT_PLUS         ; ( -- addr1 c addr')
0005bf 7093          .dw XT_CFETCH       ; ( -- addr1 c c')
0005c0 70ca          .dw XT_OVER         ; ( -- addr1 c c' c)
0005c1 7111          .dw XT_EQUAL        ; ( -- addr1 c f)
0005c2 7030          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
0005c3 05ca          .dw PFA_CSCAN2
0005c4 70d4          .dw XT_DROP         ; ( -- addr1 )
0005c5 72bd          .dw XT_I            ; ( -- addr1 n2)
0005c6 72e7          .dw XT_UNLOOP       ; ( -- addr1 n2)
0005c7 70ea          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
0005c8 70d4          .dw XT_DROP         ; ( -- addr1 n2)
0005c9 701a          .dw XT_EXIT
                 PFA_CSCAN2:
0005ca 72d8          .dw XT_DOLOOP
0005cb 05bc          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
0005cc 70d4          .dw XT_DROP         ; ( -- addr1)
0005cd 70ea          .dw XT_R_FROM       ; ( -- addr1 n1)
0005ce 701a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0005cf ff06          .dw $FF06
0005d0 6f73
0005d1 7275
0005d2 6563          .db "source"
0005d3 05b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0005d4 07d2          .dw PFA_DODEFER
                 PFA_SOURCE:
0005d5 0016          .dw USER_SOURCE
0005d6 07aa          .dw XT_UDEFERFETCH
0005d7 07b1          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0005d8 ff07          .dw $ff07
0005d9 732f
0005da 7274
0005db 6e69
0005dc 0067          .db "/string",0
0005dd 05cf          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005de 7000          .dw DO_COLON
                 PFA_SLASHSTRING:
0005df 70ca          .dw XT_OVER    ; ( -- addr1 u1 n u1)
0005e0 026a          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
0005e1 70dc          .dw XT_ROT     ; ( -- u1 n addr1 )
0005e2 70ca          .dw XT_OVER    ; ( -- u1 n addr1 n)
0005e3 71a6          .dw XT_PLUS    ; ( -- u1 n addr2 )
0005e4 70dc          .dw XT_ROT     ; ( -- n addr2 u1)
0005e5 70dc          .dw XT_ROT     ; ( -- addr2 u1 n)
0005e6 719c          .dw XT_MINUS   ; ( -- addr2 u2)
0005e7 701a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
0005e8 ff0a          .dw $FF0A 
0005e9 6170
0005ea 7372
0005eb 2d65
0005ec 616e
0005ed 656d          .db "parse-name"
0005ee 05d8          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005ef 7000          .dw DO_COLON 
                 PFA_PARSENAME:
0005f0 01e3          .dw XT_BL
0005f1 05f3          .dw XT_SKIPSCANCHAR
0005f2 701a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005f3 7000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
0005f4 70f3          .dw XT_TO_R
0005f5 05d4          .dw XT_SOURCE 
0005f6 0121          .dw XT_G_IN 
0005f7 7074          .dw XT_FETCH 
0005f8 05de          .dw XT_SLASHSTRING 
                 
0005f9 70fc          .dw XT_R_FETCH
0005fa 0478          .dw XT_CSKIP
0005fb 70ea          .dw XT_R_FROM
0005fc 05b5          .dw XT_CSCAN
                 
                     ; adjust >IN
0005fd 0110          .dw XT_2DUP
0005fe 71a6          .dw XT_PLUS
0005ff 05d4          .dw XT_SOURCE 
000600 70d4          .dw XT_DROP
000601 719c          .dw XT_MINUS
000602 0121          .dw XT_G_IN
000603 707c          .dw XT_STORE
000604 701a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
000605 ff09          .dw $ff09
000606 6966
000607 646e
000608 6e2d
000609 6d61
00060a 0065          .db "find-name",0
00060b 05e8          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
00060c 7000          .dw DO_COLON
                 PFA_FINDNAME:
00060d 7037          .dw XT_DOLITERAL
00060e 0014          .dw EE_ORDERLISTLEN
00060f 735b          .dw XT_FETCHE
000610 7134          .dw XT_ZERO
000611 72aa          .dw XT_DOQDO
000612 0627          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
000613 0110          .dw XT_2DUP
000614 7037          .dw XT_DOLITERAL
000615 0016          .dw EE_ORDERLIST
000616 72bd          .dw XT_I
000617 0100          .dw XT_CELLS
000618 71a6          .dw XT_PLUS  
000619 735b          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
00061a 07e6          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
00061b 70b4          .dw XT_QDUP
00061c 7030          .dw XT_DOCONDBRANCH
00061d 0625          .dw PFA_FINDNAME4
00061e 70f3      	.dw XT_TO_R
00061f 70f3      	.dw XT_TO_R
000620 0119      	.dw XT_2DROP
000621 70ea      	.dw XT_R_FROM
000622 70ea      	.dw XT_R_FROM
000623 72e7      	.dw XT_UNLOOP
000624 701a      	.dw XT_EXIT
                 PFA_FINDNAME4:
000625 72d8          .dw XT_DOLOOP
000626 0613          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000627 0119          .dw XT_2DROP
000628 7134          .dw XT_ZERO
000629 701a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
00062a ff04          .dw $ff04
00062b 7571
00062c 7469          .db "quit"
00062d 0605          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00062e 7000          .dw DO_COLON
                 PFA_QUIT:
00062f 06a6          .dw XT_SP0
000630 7293          .dw XT_SP_STORE
000631 06bb          .dw XT_RP0
000632 727d          .dw XT_RP_STORE
000633 0a6b          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000634 00f3          .dw XT_STATE
000635 7074          .dw XT_FETCH
000636 7118          .dw XT_EQUALZERO
000637 7030          .dw XT_DOCONDBRANCH
000638 063a          .dw PFA_QUIT4
000639 0650          .dw XT_PROMPTRDY
                 PFA_QUIT4:
00063a 04da          .dw XT_REFILL
00063b 7030          .dw XT_DOCONDBRANCH
00063c 0634          .dw PFA_QUIT2
00063d 7037          .dw XT_DOLITERAL
00063e 06d4          .dw XT_INTERPRET
00063f 0449          .dw XT_CATCH
000640 70b4          .dw XT_QDUP
000641 7030          .dw XT_DOCONDBRANCH
000642 064c          .dw PFA_QUIT3
000643 70ac      	.dw XT_DUP
000644 7037      	.dw XT_DOLITERAL
000645 fffe      	.dw -2
000646 711f      	.dw XT_LESS
000647 7030      	.dw XT_DOCONDBRANCH
000648 064a      	.dw PFA_QUIT5
000649 065e      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00064a 7029      	.dw XT_DOBRANCH
00064b 062f      	.dw PFA_QUIT
                 PFA_QUIT3:
00064c 0657          .dw XT_PROMPTOK
00064d 7029          .dw XT_DOBRANCH
00064e 0634          .dw PFA_QUIT2
00064f 701a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000650 7000          .dw DO_COLON
                 PFA_PROMPTRDY:
000651 03fe          .dw XT_CR
000652 0393          .dw XT_DOSLITERAL
000653 0002          .dw 2
000654 203e          .db "> "
000655 03ca          .dw XT_ITYPE
000656 701a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000657 7000          .dw DO_COLON
                 PFA_PROMPTOK:
000658 0393          .dw XT_DOSLITERAL
000659 0003          .dw 3
00065a 6f20
00065b 006b          .db " ok",0
00065c 03ca          .dw XT_ITYPE
00065d 701a          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00065e 7000          .dw DO_COLON
                 PFA_PROMPTERROR:
00065f 0393      	.dw XT_DOSLITERAL
000660 0004      	.dw 4
000661 3f20
000662 203f      	.db  " ?? "
000663 03ca          .dw XT_ITYPE
000664 00f9      	.dw XT_BASE
000665 7074      	.dw XT_FETCH
000666 70f3      	.dw XT_TO_R
000667 01d0      	.dw XT_DECIMAL
000668 0330      	.dw XT_DOT
000669 0121      	.dw XT_G_IN
00066a 7074      	.dw XT_FETCH
00066b 0330      	.dw XT_DOT
00066c 70ea      	.dw XT_R_FROM
00066d 00f9      	.dw XT_BASE
00066e 707c      	.dw XT_STORE
00066f 701a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000670 ff05          .dw $ff05
000671 6170
000672 7375
000673 0065          .db "pause",0
000674 062a          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000675 07d2          .dw PFA_DODEFER
                 PFA_PAUSE:
000676 0157          .dw ram_pause
000677 07a0          .dw XT_RDEFERFETCH
000678 07a5          .dw XT_RDEFERSTORE
                 
                 .dseg
000157           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000679 ff04          .dw $ff04
00067a 6f63
00067b 646c          .db "cold"
00067c 0670          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00067d 067e          .dw PFA_COLD
                 PFA_COLD:
00067e b6a4          in_ r10, MCUSR
00067f 24bb          clr r11
000680 2422          clr zerol
000681 2433          clr zeroh
000682 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000159           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000683 e5e9          ldi zl, low(ram_user1)
000684 e0f1          ldi zh, high(ram_user1)
000685 012f          movw upl, zl
                     ; init return stack pointer
000686 ef0f          ldi temp0,low(rstackstart)
000687 bf0d          out_ SPL,temp0
000688 8304          std Z+4, temp0
000689 e110          ldi temp1,high(rstackstart)
00068a bf1e          out_ SPH,temp1
00068b 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00068c eacf          ldi yl,low(stackstart)
00068d 83c6          std Z+6, yl
00068e e1d0          ldi yh,high(stackstart)
00068f 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000690 e9a9          ldi XL, low(PFA_WARM)
000691 e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000692 940c 7004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000694 ff04          .dw $ff04
000695 6177
000696 6d72          .db "warm"
000697 0679          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000698 7000          .dw DO_COLON
                 PFA_WARM:
000699 0914          .dw XT_INITUSER
00069a 7037          .dw XT_DOLITERAL
00069b 076f          .dw XT_NOOP
00069c 7037          .dw XT_DOLITERAL
00069d 0675          .dw XT_PAUSE
00069e 07bd          .dw XT_DEFERSTORE
00069f 01eb          .dw XT_TURNKEY
0006a0 062e          .dw XT_QUIT
0006a1 701a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0006a2 ff03          .dw $ff03
0006a3 7073
0006a4 0030          .db "sp0",0
0006a5 0694          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0006a6 7069          .dw PFA_DOVALUE1
                 PFA_SP0:
0006a7 0006          .dw USER_SP0
0006a8 06af          .dw XT_UVALUEFETCH
0006a9 06b3          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0006aa ff02          .dw $ff02
0006ab 7073          .db "sp"
0006ac 06a2          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0006ad 7052          .dw PFA_DOUSER
                 PFA_SP:
0006ae 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
0006af 7000          .dw DO_COLON
                 PFA_UVALUEFETCH:
0006b0 736f          .dw XT_FETCHI
0006b1 709b          .dw XT_FETCHU
0006b2 701a          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
0006b3 7000          .dw DO_COLON
                 PFA_UVALUESTORE:
0006b4 736f          .dw XT_FETCHI
0006b5 70a3          .dw XT_STOREU
0006b6 701a          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0006b7 ff03          .dw $ff03
0006b8 7072
0006b9 0030          .db "rp0",0
0006ba 06aa          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0006bb 7000          .dw DO_COLON
                 PFA_RP0:
0006bc 06bf          .dw XT_DORP0
0006bd 7074          .dw XT_FETCH
0006be 701a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0006bf 7052          .dw PFA_DOUSER
                 PFA_DORP0:
0006c0 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
0006c1 ff05          .dw $ff05
0006c2 6564
0006c3 7470
0006c4 0068          .db "depth",0
0006c5 06b7          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0006c6 7000          .dw DO_COLON
                 PFA_DEPTH:
0006c7 06a6          .dw XT_SP0
0006c8 728a          .dw XT_SP_FETCH
0006c9 719c          .dw XT_MINUS
0006ca 720d          .dw XT_2SLASH
0006cb 723e          .dw XT_1MINUS
0006cc 701a          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
0006cd ff09          .dw $ff09
0006ce 6e69
0006cf 6574
0006d0 7072
0006d1 6572
0006d2 0074          .db "interpret",0
0006d3 06c1          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
0006d4 7000          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
0006d5 05ef          .dw XT_PARSENAME ; ( -- addr len )
0006d6 70b4          .dw XT_QDUP   ; ( -- addr len len )
0006d7 715c          .dw XT_GREATERZERO
0006d8 7030          .dw XT_DOCONDBRANCH
0006d9 06f8          .dw PFA_INTERPRET5
0006da 7037          .dw XT_DOLITERAL
0006db 0026          .dw EE_RECOGNIZERLISTLEN
0006dc 735b          .dw XT_FETCHE       ; ( addr len rec # -- )
0006dd 7134          .dw XT_ZERO
                 
0006de 72aa          .dw XT_DOQDO
0006df 06f4          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
0006e0 0110          .dw XT_2DUP ; ( -- addr len addr len  )
0006e1 72bd          .dw XT_I    ; ( -- addr len addr len i )
0006e2 70dc          .dw XT_ROT  ; ( -- addr len len i addr )
0006e3 70dc          .dw XT_ROT  ; ( -- addr len i addr len )
0006e4 70f3          .dw XT_TO_R
0006e5 70f3          .dw XT_TO_R
                 
0006e6 0100          .dw XT_CELLS
0006e7 7037          .dw XT_DOLITERAL
0006e8 0028          .dw EE_RECOGNIZERLIST
0006e9 71a6          .dw XT_PLUS
0006ea 735b          .dw XT_FETCHE
                 
0006eb 7024          .dw XT_EXECUTE
0006ec 70ea          .dw XT_R_FROM
0006ed 70ea          .dw XT_R_FROM
0006ee 70dc          .dw XT_ROT
0006ef 7030          .dw XT_DOCONDBRANCH
0006f0 06f2          .dw PFA_INTERPRET3
0006f1 09bb            .dw XT_LEAVE
                 PFA_INTERPRET3:
0006f2 72d8          .dw XT_DOLOOP
0006f3 06e0          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
0006f4 0119          .dw XT_2DROP
0006f5 0745          .dw XT_QSTACK
0006f6 7029          .dw XT_DOBRANCH
0006f7 06d5          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
0006f8 70d4          .dw xT_DROP
0006f9 701a          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
0006fa ff0a          .dw $ff0a
0006fb 6572
0006fc 2d63
0006fd 6e69
0006fe 6e74
0006ff 6d75          .db "rec-intnum"
000700 06cd          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
000701 7000          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
000702 04ec          .dw XT_NUMBER 
000703 7030          .dw XT_DOCONDBRANCH 
000704 0716          .dw PFA_REC_NONUMBER
                 
000705 00f3          .dw XT_STATE
000706 7074          .dw XT_FETCH
000707 7030          .dw XT_DOCONDBRANCH
000708 0713          .dw PFA_REC_NUMBER_DONE
000709 7037      	.dw XT_DOLITERAL
00070a 0002      	.dw 2
00070b 7111      	.dw XT_EQUAL
00070c 7030      	.dw XT_DOCONDBRANCH
00070d 0710      	.dw PFA_REC_NUMBER_SINGLE
00070e 70bf      	.dw XT_SWAP
00070f 0922              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
000710 0922              .dw XT_LITERAL
000711 7029              .dw XT_DOBRANCH
000712 0714              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
000713 70d4          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000714 713d          .dw XT_TRUE
000715 701a          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000716 7134          .dw XT_ZERO
000717 701a          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000718 ff08          .dw $ff08
000719 6572
00071a 2d63
00071b 6966
00071c 646e          .db "rec-find"
00071d 06fa          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00071e 7000          .dw DO_COLON
                 PFA_REC_FIND:
00071f 060c          .dw XT_FINDNAME
000720 70ac          .dw XT_DUP
000721 7030          .dw XT_DOCONDBRANCH 
000722 0731          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
000723 715c      	.dw XT_GREATERZERO
000724 7030      	.dw XT_DOCONDBRANCH
000725 0728      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000726 7029      	    .dw XT_DOBRANCH
000727 072f      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000728 00f3      	    .dw XT_STATE
000729 7074      	    .dw XT_FETCH
00072a 7030      	    .dw XT_DOCONDBRANCH
00072b 072f      	    .dw PFA_REC_FIND_EXECUTE
00072c 01ae      	    .dw XT_COMMA
00072d 7029      	    .dw XT_DOBRANCH
00072e 0730      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
00072f 7024          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
000730 713d          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000731 701a          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
000732 ff0c          .dw $ff0c
000733 6572
000734 2d63
000735 6f6e
000736 6674
000737 756f
000738 646e          .db "rec-notfound"
000739 0718          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
00073a 7000          .dw DO_COLON
                 PFA_REC_NOTFOUND:
00073b 0423          .dw XT_TYPE
00073c 7037          .dw XT_DOLITERAL
00073d fff3          .dw -13
00073e 045f          .dw XT_THROW
00073f 701a          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
000740 ff06          .dw $ff06
000741 733f
000742 6174
000743 6b63          .db "?stack"
000744 0732          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000745 7000          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
000746 06c6          .dw XT_DEPTH
000747 712d          .dw XT_LESSZERO
000748 7030          .dw XT_DOCONDBRANCH
000749 074d          .dw PFA_QSTACK1
00074a 7037            .dw XT_DOLITERAL
00074b fffc            .dw -4
00074c 045f            .dw XT_THROW
                 PFA_QSTACK1:
00074d 701a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
00074e ff03          .dw $ff03
00074f 6576
000750 0072          .db "ver",0
000751 0740          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
000752 7000          .dw DO_COLON
                 PFA_VER:
000753 0b3f          .dw XT_ENV_FORTHNAME
000754 03ca          .dw XT_ITYPE
000755 040b          .dw XT_SPACE
000756 00f9          .dw XT_BASE
000757 7074          .dw XT_FETCH
000758 70f3          .dw XT_TO_R
000759 01d0          .dw XT_DECIMAL
                 
00075a 0b4d          .dw XT_ENV_FORTHVERSION
00075b 7329          .dw XT_S2D
00075c 02ca          .dw XT_L_SHARP
00075d 02d2          .dw XT_SHARP
00075e 7037          .dw XT_DOLITERAL
00075f 002e          .dw '.'
000760 02bb          .dw XT_HOLD
000761 02e8          .dw XT_SHARP_S
000762 02f3          .dw XT_SHARP_G
000763 70ea          .dw XT_R_FROM
000764 00f9          .dw XT_BASE
000765 707c          .dw XT_STORE
                 
000766 0423          .dw XT_TYPE
000767 040b          .dw XT_SPACE
000768 0b55          .dw XT_ENV_CPU
000769 03ca          .dw XT_ITYPE
00076a 701a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
00076b ff04          .dw $ff04
00076c 6f6e
00076d 706f          .db "noop"
00076e 074e          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00076f 0770          .dw PFA_NOOP
                 PFA_NOOP:
000770 940c 7004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000772 ff06          .dw $ff06
000773 6e75
000774 7375
000775 6465          .db "unused"
000776 076b          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000777 7000          .dw DO_COLON
                 PFA_UNUSED:
000778 06a6          .dw XT_SP0
000779 0167          .dw XT_HERE
00077a 719c          .dw XT_MINUS
00077b 701a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
00077c 0002          .dw $0002
00077d 6f74          .db "to"
00077e 0772          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00077f 7000          .dw DO_COLON
                 PFA_TO:
000780 0432          .dw XT_TICK
000781 7238          .dw XT_1PLUS  		; to body
000782 00f3          .dw XT_STATE
000783 7074          .dw XT_FETCH
000784 7030          .dw XT_DOCONDBRANCH
000785 0790          .dw PFA_TO1
000786 01a3          .dw XT_COMPILE
000787 078a          .dw XT_DOTO
000788 01ae          .dw XT_COMMA
000789 701a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
00078a 7000          .dw DO_COLON
                 PFA_DOTO:
00078b 70ea          .dw XT_R_FROM
00078c 70ac          .dw XT_DUP
00078d 7238          .dw XT_1PLUS
00078e 70f3          .dw XT_TO_R
00078f 736f          .dw XT_FETCHI
                 PFA_TO1:
000790 70ac          .dw XT_DUP
000791 7238          .dw XT_1PLUS
000792 7238          .dw XT_1PLUS
000793 736f          .dw XT_FETCHI
000794 7024          .dw XT_EXECUTE
000795 701a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000796 7000          .dw DO_COLON
                 PFA_EDEFERFETCH:
000797 7238          .dw XT_1PLUS ; >body
000798 736f          .dw XT_FETCHI
000799 735b          .dw XT_FETCHE
00079a 701a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00079b 7000          .dw DO_COLON
                 PFA_EDEFERSTORE:
00079c 7238          .dw XT_1PLUS
00079d 736f          .dw XT_FETCHI
00079e 7337          .dw XT_STOREE
00079f 701a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
0007a0 7000          .dw DO_COLON
                 PFA_RDEFERFETCH:
0007a1 7238          .dw XT_1PLUS ; >body
0007a2 736f          .dw XT_FETCHI
0007a3 7074          .dw XT_FETCH
0007a4 701a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
0007a5 7000          .dw DO_COLON
                 PFA_RDEFERSTORE:
0007a6 7238          .dw XT_1PLUS
0007a7 736f          .dw XT_FETCHI
0007a8 707c          .dw XT_STORE
0007a9 701a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
0007aa 7000          .dw DO_COLON
                 PFA_UDEFERFETCH:
0007ab 7238          .dw XT_1PLUS ; >body
0007ac 736f          .dw XT_FETCHI
0007ad 7317          .dw XT_UP_FETCH
0007ae 71a6          .dw XT_PLUS
0007af 7074          .dw XT_FETCH
0007b0 701a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
0007b1 7000          .dw DO_COLON
                 PFA_UDEFERSTORE:
0007b2 7238          .dw XT_1PLUS
0007b3 736f          .dw XT_FETCHI
0007b4 7317          .dw XT_UP_FETCH
0007b5 71a6          .dw XT_PLUS
0007b6 707c          .dw XT_STORE
0007b7 701a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
0007b8 ff06          .dw $ff06
0007b9 6564
0007ba 6566
0007bb 2172          .db "defer!"
0007bc 077c          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
0007bd 7000          .dw DO_COLON
                 PFA_DEFERSTORE:
0007be 70ac          .dw XT_DUP
0007bf 7037          .dw XT_DOLITERAL
0007c0 0003          .dw 3
0007c1 71a6          .dw XT_PLUS   ; >body 2 +
0007c2 736f          .dw XT_FETCHI
0007c3 7024          .dw XT_EXECUTE
0007c4 701a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
0007c5 ff06          .dw $ff06
0007c6 6564
0007c7 6566
0007c8 4072          .db "defer@"
0007c9 07b8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
0007ca 7000          .dw DO_COLON
                 PFA_DEFERFETCH:
0007cb 70ac          .dw XT_DUP
0007cc 7238          .dw XT_1PLUS ; >body
0007cd 7238          .dw XT_1PLUS 
0007ce 736f          .dw XT_FETCHI
0007cf 7024          .dw XT_EXECUTE
0007d0 701a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
0007d1 07d2          .dw PFA_DODEFER
                 PFA_DODEFER:
0007d2 940e 0a26     call_ DO_DODOES
0007d4 70ac          .dw XT_DUP
0007d5 723e          .dw XT_1MINUS
0007d6 70bf          .dw XT_SWAP
0007d7 7238          .dw XT_1PLUS
0007d8 736f          .dw XT_FETCHI
0007d9 7024          .dw XT_EXECUTE 
0007da 7024          .dw XT_EXECUTE
0007db 701a          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0007dc ff0f          .dw $ff0f
0007dd 6573
0007de 7261
0007df 6863
0007e0 772d
0007e1 726f
0007e2 6c64
0007e3 7369
0007e4 0074          .db "search-wordlist",0
0007e5 07c5          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0007e6 7000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0007e7 7134          .dw XT_ZERO
0007e8 70bf          .dw XT_SWAP
0007e9 7037          .dw XT_DOLITERAL
0007ea 07f5          .dw XT_ISWORD
0007eb 70bf          .dw XT_SWAP
0007ec 082c          .dw XT_TRAVERSEWORDLIST
0007ed 70ac          .dw XT_DUP
0007ee 7118          .dw XT_EQUALZERO
0007ef 7030          .dw XT_DOCONDBRANCH
0007f0 07f4          .dw PFA_SEARCH_WORDLIST1
0007f1 0119             .dw XT_2DROP
0007f2 70d4             .dw XT_DROP
0007f3 7134             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
0007f4 701a          .dw XT_EXIT
                 
                 XT_ISWORD:
0007f5 7000          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
0007f6 70f3          .dw XT_TO_R
0007f7 70f3          .dw XT_TO_R
0007f8 0110          .dw XT_2DUP
0007f9 70ea          .dw XT_R_FROM
0007fa 70dc          .dw XT_ROT
0007fb 70dc          .dw XT_ROT
0007fc 70fc          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
0007fd 081b          .dw XT_NAME2STRING
0007fe 0847          .dw XT_ICOMPARE      ; (-- addr len 0 f )
0007ff 7030          .dw XT_DOCONDBRANCH
000800 080f          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
000801 0119            .dw XT_2DROP
000802 70d4            .dw XT_DROP
                       ; ... get the XT ...
000803 70fc            .dw XT_R_FETCH
000804 0be0            .dw XT_NFA2LFA
000805 7238            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
000806 713d            .dw XT_TRUE
000807 70ea            .dw XT_R_FROM
000808 736f            .dw XT_FETCHI
000809 715c            .dw XT_GREATERZERO
00080a 7030            .dw XT_DOCONDBRANCH
00080b 080d            .dw PFA_ISWORD1
00080c 0246               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
00080d 7134            .dw XT_ZERO       ; finish traverse-wordlist
00080e 701a            .dw XT_EXIT
                 PFA_ISWORD3:
00080f 70ea          .dw XT_R_FROM
000810 70d4          .dw XT_DROP
000811 713d          .dw XT_TRUE         ; maybe next word
000812 701a          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
000813 ff0b          .dw $ff0b
000814 616e
000815 656d
000816 733e
000817 7274
000818 6e69
000819 0067          .db "name>string",0
00081a 07dc          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00081b 7000          .dw DO_COLON
                 PFA_NAME2STRING:
00081c 03f5          .dw XT_ICOUNT   ; ( -- addr n )
00081d 7037          .dw XT_DOLITERAL
00081e 00ff          .dw $00FF
00081f 721c          .dw XT_AND      ; mask immediate bit
000820 701a          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000821 ff11          .dw $ff11
000822 7274
000823 7661
000824 7265
000825 6573
000826 772d
000827 726f
000828 6c64
000829 7369
00082a 0074          .db "traverse-wordlist",0
00082b 0813          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00082c 7000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
00082d 735b          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00082e 70ac          .dw XT_DUP           ; ( -- xt nt nt )
00082f 7030          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000830 083f          .dw PFA_TRAVERSEWORDLIST2       ;
000831 0110          .dw XT_2DUP
000832 70f3          .dw XT_TO_R
000833 70f3          .dw XT_TO_R
000834 70bf          .dw XT_SWAP
000835 7024          .dw XT_EXECUTE
000836 70ea          .dw XT_R_FROM
000837 70ea          .dw XT_R_FROM
000838 70dc          .dw XT_ROT
000839 7030          .dw XT_DOCONDBRANCH
00083a 083f          .dw PFA_TRAVERSEWORDLIST2
00083b 0be0          .dw XT_NFA2LFA
00083c 736f          .dw XT_FETCHI        ; ( -- addr )
00083d 7029          .dw XT_DOBRANCH      ; ( -- addr )
00083e 082e          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00083f 0119          .dw XT_2DROP
000840 701a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
000841 ff08          .dw $ff08
000842 6369
000843 6d6f
000844 6170
000845 6572          .db "icompare"
000846 0821          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000847 7000          .dw DO_COLON
                 PFA_ICOMPARE:
000848 70f3          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000849 70ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00084a 70ea          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00084b 7107          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00084c 7030          .dw XT_DOCONDBRANCH
00084d 0852          .dw PFA_ICOMPARE_SAMELEN
00084e 0119            .dw XT_2DROP
00084f 70d4            .dw XT_DROP
000850 7134            .dw XT_ZERO
000851 701a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000852 70bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
000853 7134          .dw XT_ZERO
000854 72aa          .dw XT_DOQDO
000855 0873          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000856 70ca          .dw XT_OVER
000857 7074          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000858 70ca          .dw XT_OVER
000859 736f          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00085a 70ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00085b 7037          .dw XT_DOLITERAL
00085c 0100          .dw $100
00085d 7146          .dw XT_ULESS
00085e 7030          .dw XT_DOCONDBRANCH
00085f 0864          .dw PFA_ICOMPARE_LASTCELL
000860 70bf          .dw XT_SWAP
000861 7037          .dw XT_DOLITERAL
000862 00ff          .dw $00FF
000863 721c          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000864 7107          .dw XT_NOTEQUAL
000865 7030          .dw XT_DOCONDBRANCH
000866 086b          .dw PFA_ICOMPARE_NEXTLOOP
000867 0119          .dw XT_2DROP
000868 7134          .dw XT_ZERO
000869 72e7          .dw XT_UNLOOP
00086a 701a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00086b 7238          .dw XT_1PLUS
00086c 70bf          .dw XT_SWAP
00086d 0108          .dw XT_CELLPLUS
00086e 70bf          .dw XT_SWAP
00086f 7037          .dw XT_DOLITERAL
000870 0002          .dw 2
000871 72be          .dw XT_DOPLUSLOOP
000872 0856          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000873 0119          .dw XT_2DROP
000874 713d          .dw XT_TRUE
000875 701a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000876 ff01          .dw $ff01
000877 002a          .db "*",0
000878 0841          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000879 7000          .dw DO_COLON
                 PFA_STAR:
00087a 71af          .dw XT_MSTAR
00087b 088b          .dw XT_D2S
00087c 701a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00087d ff01          .dw $FF01
00087e 006a          .db "j",0
00087f 0876          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000880 7000          .dw DO_COLON
                 PFA_J:
000881 7273          .dw XT_RP_FETCH
000882 7037          .dw XT_DOLITERAL
000883 0009          .dw 9
000884 71a6          .dw XT_PLUS
000885 7074          .dw XT_FETCH
000886 701a          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000887 ff03          .dw $ff03
000888 3e64
000889 0073          .db "d>s",0
00088a 087d          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
00088b 7000          .dw DO_COLON
                 PFA_D2S:
00088c 70d4          .dw XT_DROP
00088d 701a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00088e ff04          .dw $ff04
00088f 6164
000890 7362          .db "dabs"
000891 0887          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000892 7000          .dw DO_COLON
                 PFA_DABS:
000893 70ac          .dw XT_DUP
000894 712d          .dw XT_LESSZERO
000895 7030          .dw XT_DOCONDBRANCH
000896 0898          .dw PFA_DABS1
000897 089f          .dw XT_DNEGATE
                 PFA_DABS1:
000898 701a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000899 ff07          .dw $ff07
00089a 6e64
00089b 6765
00089c 7461
00089d 0065          .db "dnegate",0
00089e 088e          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00089f 7000          .dw DO_COLON
                 PFA_DNEGATE:
0008a0 0cfa          .dw XT_DINVERT
0008a1 7037          .dw XT_DOLITERAL
0008a2 0001          .dw 1
0008a3 7134          .dw XT_ZERO
0008a4 0cd2          .dw XT_DPLUS
0008a5 701a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
0008a6 ff05          .dw $ff05
0008a7 6d63
0008a8 766f
0008a9 0065          .db "cmove",0
0008aa 0899          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
0008ab 08ac          .dw PFA_CMOVE
                 PFA_CMOVE:
0008ac 93bf          push xh
0008ad 93af          push xl
0008ae 91e9          ld zl, Y+
0008af 91f9          ld zh, Y+ ; addr-to
0008b0 91a9          ld xl, Y+
0008b1 91b9          ld xh, Y+ ; addr-from
0008b2 2f09          mov temp0, tosh
0008b3 2b08          or temp0, tosl
0008b4 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
0008b5 911d          ld temp1, X+
0008b6 9311          st Z+, temp1
0008b7 9701          sbiw tosl, 1
0008b8 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
0008b9 91af          pop xl
0008ba 91bf          pop xh
0008bb 9189
0008bc 9199          loadtos
0008bd 940c 7004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
0008bf ff05          .dw $ff05
0008c0 7332
0008c1 6177
0008c2 0070          .db "2swap",0
0008c3 08a6          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
0008c4 7000          .dw DO_COLON
                 PFA_2SWAP:
0008c5 70dc          .dw XT_ROT
0008c6 70f3          .dw XT_TO_R
0008c7 70dc          .dw XT_ROT
0008c8 70ea          .dw XT_R_FROM
0008c9 701a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
0008ca ff03          .dw $ff03
0008cb 6974
0008cc 0062          .db "tib",0
0008cd 08bf          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0008ce 7042          .dw PFA_DOVARIABLE
                 PFA_TIB:
0008cf 017f          .dw ram_tib
                     
                 .dseg
00017f           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
0008d0 ff0a          .dw $ff0a
0008d1 6572
0008d2 6966
0008d3 6c6c
0008d4 742d
0008d5 6269          .db "refill-tib"
0008d6 08ca          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
0008d7 7000          .dw DO_COLON
                 PFA_REFILLTIB:
0008d8 08ce          .dw XT_TIB
0008d9 7037          .dw XT_DOLITERAL
0008da 0064          .dw TIBSIZE
0008db 0490          .dw XT_ACCEPT
0008dc 0127          .dw XT_NUMBERTIB
0008dd 707c          .dw XT_STORE
0008de 7134          .dw XT_ZERO
0008df 0121          .dw XT_G_IN
0008e0 707c          .dw XT_STORE
0008e1 7037          .dw XT_DOLITERAL
0008e2 ffff          .dw -1
0008e3 701a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0008e4 ff0a          .dw $FF0A
0008e5 6f73
0008e6 7275
0008e7 6563
0008e8 742d
0008e9 6269          .db "source-tib"
0008ea 08d0          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0008eb 7000          .dw DO_COLON
                 PFA_SOURCETIB:
0008ec 08ce          .dw XT_TIB
0008ed 0127          .dw XT_NUMBERTIB
0008ee 7074          .dw XT_FETCH
0008ef 701a          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0008f0 ff07        .dw $ff07
0008f1 6565
0008f2 752d
0008f3 6573
0008f4 0072        .db "ee-user",0
0008f5 08e4        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
0008f6 7042        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
0008f7 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0008f8 ff06        .dw $ff06
0008f9 6565
0008fa 723e
0008fb 6d61        .db "ee>ram"
0008fc 08f0        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0008fd 7000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0008fe 7134          .dw XT_ZERO
0008ff 72aa          .dw XT_DOQDO
000900 090b          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000901 70ca          .dw XT_OVER
000902 735b          .dw XT_FETCHE
000903 70ca          .dw XT_OVER
000904 707c          .dw XT_STORE
000905 0108          .dw XT_CELLPLUS
000906 70bf          .dw XT_SWAP
000907 0108          .dw XT_CELLPLUS
000908 70bf          .dw XT_SWAP
000909 72d8          .dw XT_DOLOOP
00090a 0901          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00090b 0119          .dw XT_2DROP
00090c 701a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00090d ff09        .dw $ff09
00090e 6e69
00090f 7469
000910 752d
000911 6573
000912 0072        .db "init-user",0
000913 08f8        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000914 7000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000915 08f6          .dw XT_EEUSER
000916 7317          .dw XT_UP_FETCH
000917 7037          .dw XT_DOLITERAL
000918 001c          .dw SYSUSERSIZE
000919 720d          .dw XT_2SLASH
00091a 08fd          .dw XT_EE2RAM
00091b 701a          .dw XT_EXIT
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
00091c 0007          .dw $0007
00091d 696c
00091e 6574
00091f 6172
000920 006c          .db "literal",0
000921 090d          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000922 7000          .dw DO_COLON
                 PFA_LITERAL:
000923 01a3          .dw XT_COMPILE
000924 7037          .dw XT_DOLITERAL
000925 01ae          .dw XT_COMMA
000926 701a          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000927 0008        .dw $0008
000928 6c73
000929 7469
00092a 7265
00092b 6c61        .db "sliteral"
00092c 091c        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00092d 7000          .dw DO_COLON
                 PFA_SLITERAL:
00092e 01a3          .dw XT_COMPILE
00092f 0393          .dw XT_DOSLITERAL    ; ( -- addr n)
000930 03a6          .dw XT_SCOMMA
000931 701a          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000932 7000          .dw DO_COLON
                 PFA_GMARK:
000933 0157          .dw XT_DP
000934 01a3          .dw XT_COMPILE
000935 ffff          .dw -1           ; ffff does not erase flash
000936 701a          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000937 7000          .dw DO_COLON
                 PFA_GRESOLVE:
000938 0745          .dw XT_QSTACK
000939 0157          .dw XT_DP
00093a 70bf          .dw XT_SWAP
00093b 7379          .dw XT_STOREI
00093c 701a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00093d 7000          .dw DO_COLON
                 PFA_LMARK:
00093e 0157          .dw XT_DP
00093f 701a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000940 7000          .dw DO_COLON
                 PFA_LRESOLVE:
000941 0745          .dw XT_QSTACK
000942 01ae          .dw XT_COMMA
000943 701a          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000944 0005          .dw $0005
000945 6861
000946 6165
000947 0064          .db "ahead",0
000948 0927          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000949 7000          .dw DO_COLON
                 PFA_AHEAD:
00094a 01a3          .dw XT_COMPILE
00094b 7029          .dw XT_DOBRANCH
00094c 0932          .dw XT_GMARK
00094d 701a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
00094e 0002          .dw $0002
00094f 6669          .db "if"
000950 0944          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000951 7000          .dw DO_COLON
                 PFA_IF:
000952 01a3          .dw XT_COMPILE
000953 7030          .dw XT_DOCONDBRANCH
000954 0932          .dw XT_GMARK
000955 701a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000956 0004          .dw $0004
000957 6c65
000958 6573          .db "else"
000959 094e          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
00095a 7000          .dw DO_COLON
                 PFA_ELSE:
00095b 01a3          .dw XT_COMPILE
00095c 7029          .dw XT_DOBRANCH
00095d 0932          .dw XT_GMARK
00095e 70bf          .dw XT_SWAP
00095f 0937          .dw XT_GRESOLVE
000960 701a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000961 0004          .dw $0004
000962 6874
000963 6e65          .db "then"
000964 0956          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000965 7000          .dw DO_COLON
                 PFA_THEN:
000966 0937          .dw XT_GRESOLVE
000967 701a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000968 0005          .dw $0005
000969 6562
00096a 6967
00096b 006e          .db "begin",0
00096c 0961          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00096d 7000          .dw DO_COLON
                 PFA_BEGIN:
00096e 093d          .dw XT_LMARK
00096f 701a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
000970 0005          .dw $0005
000971 6877
000972 6c69
000973 0065          .db "while",0
000974 0968          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000975 7000          .dw DO_COLON
                 PFA_WHILE:
000976 01a3          .dw XT_COMPILE
000977 7030          .dw XT_DOCONDBRANCH
000978 0932          .dw XT_GMARK
000979 70bf          .dw XT_SWAP
00097a 701a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
00097b 0006          .dw $0006
00097c 6572
00097d 6570
00097e 7461          .db "repeat"
00097f 0970          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000980 7000          .dw DO_COLON
                 PFA_REPEAT:
000981 0993          .dw XT_AGAIN
000982 0937          .dw XT_GRESOLVE
000983 701a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000984 0005          .dw $0005
000985 6e75
000986 6974
000987 006c          .db "until",0
000988 097b          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000989 7000          .dw DO_COLON
                 PFA_UNTIL:
00098a 01a3          .dw XT_COMPILE
00098b 7030          .dw XT_DOCONDBRANCH
00098c 0940          .dw XT_LRESOLVE
00098d 701a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
00098e 0005          .dw $0005
00098f 6761
000990 6961
000991 006e          .db "again",0
000992 0984          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000993 7000          .dw DO_COLON
                 PFA_AGAIN:
000994 01a3          .dw XT_COMPILE
000995 7029          .dw XT_DOBRANCH
000996 0940          .dw XT_LRESOLVE
000997 701a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
000998 0002          .dw $0002
000999 6f64          .db "do"
00099a 098e          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
00099b 7000          .dw DO_COLON
                 PFA_DO:
00099c 01a3          .dw XT_COMPILE
00099d 7298          .dw XT_DODO
00099e 0932          .dw XT_GMARK
00099f 093d          .dw XT_LMARK
0009a0 701a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
0009a1 0004          .dw $0004
0009a2 6f6c
0009a3 706f          .db "loop"
0009a4 0998          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0009a5 7000          .dw DO_COLON
                 PFA_LOOP:
0009a6 01a3          .dw XT_COMPILE
0009a7 72d8          .dw XT_DOLOOP
0009a8 0940          .dw XT_LRESOLVE
0009a9 0937          .dw XT_GRESOLVE
0009aa 701a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
0009ab 0005          .dw $0005
0009ac 6c2b
0009ad 6f6f
0009ae 0070          .db "+loop",0
0009af 09a1          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0009b0 7000          .dw DO_COLON
                 PFA_PLUSLOOP:
0009b1 01a3          .dw XT_COMPILE
0009b2 72be          .dw XT_DOPLUSLOOP
0009b3 0940          .dw XT_LRESOLVE
0009b4 0937          .dw XT_GRESOLVE
0009b5 701a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
0009b6 ff05         .dw $FF05
0009b7 656c
0009b8 7661
0009b9 0065         .db "leave",0
0009ba 09ab         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0009bb 09bc          .dw PFA_LEAVE
                 PFA_LEAVE:
0009bc 910f          pop temp0  ; drop limit and counter from returnstack
0009bd 911f          pop temp1
0009be 910f          pop temp0
0009bf 911f          pop temp1
0009c0 91af          pop xl
0009c1 91bf          pop xh
0009c2 940c 7004     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
0009c4 0003          .dw $0003
0009c5 643f
0009c6 006f          .db "?do",0
0009c7 09b6          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0009c8 7000          .dw DO_COLON
                 PFA_QDO:
0009c9 01a3          .dw XT_COMPILE
0009ca 72aa          .dw XT_DOQDO
0009cb 0932          .dw XT_GMARK
0009cc 093d          .dw XT_LMARK
0009cd 701a          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0009ce ff06          .dw $ff06
0009cf 7263
0009d0 6165
0009d1 6574          .db "create"
0009d2 09c4          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0009d3 7000          .dw DO_COLON
                 PFA_CREATE:
0009d4 017c          .dw XT_DOCREATE
0009d5 0a02          .dw XT_REVEAL
0009d6 01a3          .dw XT_COMPILE
0009d7 704c          .dw PFA_DOCONSTANT
0009d8 701a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0009d9 ff06          .dw $ff06
0009da 6568
0009db 6461
0009dc 7265          .db "header"
0009dd 09ce          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0009de 7000          .dw DO_COLON
                 PFA_HEADER:
0009df 0157          .dw XT_DP           ; the new Name Field
0009e0 70f3          .dw XT_TO_R
0009e1 70f3          .dw XT_TO_R		; ( R: NFA WID )
0009e2 70ac          .dw XT_DUP    
0009e3 715c          .dw XT_GREATERZERO 
0009e4 7030          .dw XT_DOCONDBRANCH
0009e5 09f0          .dw PFA_HEADER1
0009e6 70ac          .dw XT_DUP
0009e7 7037          .dw XT_DOLITERAL
0009e8 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0009e9 7225          .dw XT_OR
0009ea 03aa          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0009eb 70ea          .dw XT_R_FROM
0009ec 735b          .dw XT_FETCHE
0009ed 01ae          .dw XT_COMMA
0009ee 70ea          .dw XT_R_FROM
0009ef 701a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0009f0 7037          .dw XT_DOLITERAL
0009f1 fff0          .dw -16
0009f2 045f          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0009f3 ff07          .dw $ff07
0009f4 6c77
0009f5 6373
0009f6 706f
0009f7 0065          .db "wlscope",0
0009f8 09d9          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0009f9 07d2          .dw PFA_DODEFER
                 PFA_WLSCOPE:
0009fa 0034          .dw EE_WLSCOPE
0009fb 0796          .dw XT_EDEFERFETCH
0009fc 079b          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0009fd ff06          .dw $ff06
0009fe 6572
0009ff 6576
000a00 6c61          .db "reveal"
000a01 09f3          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000a02 7000          .dw DO_COLON
                 PFA_REVEAL:
000a03 7037          .dw XT_DOLITERAL
000a04 0151          .dw COLON_SMUDGE+0
000a05 7074          .dw XT_FETCH
000a06 70b4          .dw XT_QDUP
000a07 7030          .dw XT_DOCONDBRANCH
000a08 0a11          .dw PFA_REVEAL1
                 ;
000a09 7037          .dw XT_DOLITERAL
000a0a 0153          .dw COLON_SMUDGE+2
000a0b 7074          .dw XT_FETCH		; ( NFA WID )
000a0c 7337          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000a0d 7134          .dw XT_ZERO
000a0e 7037          .dw XT_DOLITERAL
000a0f 0151          .dw COLON_SMUDGE+0
000a10 707c          .dw XT_STORE
                 PFA_REVEAL1:
000a11 701a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000a12 ff06          .dw $ff06
000a13 616c
000a14 6574
000a15 7473          .db "latest"
000a16 09fd          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000a17 7042          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000a18 01e3          .dw ram_LATEST
                 
                 .dseg
0001e3           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000a19 0005          .dw $0005
000a1a 6f64
000a1b 7365
000a1c 003e          .db "does>",0
000a1d 0a12          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000a1e 7000          .dw DO_COLON
                 PFA_DOES:
000a1f 01a3          .dw XT_COMPILE
000a20 0a31          .dw XT_DODOES
000a21 01a3          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000a22 940e          .dw $940e       ; the address of this compiled
000a23 01a3          .dw XT_COMPILE  ; code will replace the XT of the 
000a24 0a26          .dw DO_DODOES   ; word that CREATE created
000a25 701a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000a26 939a
000a27 938a          savetos
000a28 01cb          movw tosl, wl
000a29 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000a2a 917f          pop wh
000a2b 916f          pop wl
                 
000a2c 93bf          push XH
000a2d 93af          push XL
000a2e 01db          movw XL, wl
000a2f 940c 7004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000a31 7000          .dw DO_COLON
                 PFA_DODOES:
000a32 70ea          .dw XT_R_FROM
000a33 7037          .dw XT_DOLITERAL
000a34 0153          .dw COLON_SMUDGE+2
000a35 7074          .dw XT_FETCH
000a36 735b          .dw XT_FETCHE
000a37 0be0          .dw XT_NFA2LFA
000a38 7238          .dw XT_1PLUS   ; lfa>xt
                 
000a39 7379          .dw XT_STOREI
000a3a 701a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000a3b ff01          .dw $ff01
000a3c 003a          .db ":",0
000a3d 0a19          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000a3e 7000          .dw DO_COLON
                 PFA_COLON:
000a3f 017c          .dw XT_DOCREATE
000a40 0157          .dw XT_DP
000a41 0a17          .dw XT_LATEST
000a42 707c          .dw XT_STORE
000a43 01a3          .dw XT_COMPILE
000a44 7000          .dw DO_COLON
000a45 0a62          .dw XT_RBRACKET
000a46 701a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000a47 ff07          .dw $ff07
000a48 6e3a
000a49 6e6f
000a4a 6d61
000a4b 0065          .db ":noname",0
000a4c 0a3b          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000a4d 7000          .dw DO_COLON
                 PFA_COLONNONAME:
000a4e 0157          .dw XT_DP
000a4f 70ac          .dw XT_DUP
000a50 0a17          .dw XT_LATEST
000a51 707c          .dw XT_STORE
                 
000a52 01a3          .dw XT_COMPILE
000a53 7000          .dw DO_COLON
                 
000a54 0a62          .dw XT_RBRACKET
000a55 701a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000a56 0001          .dw $0001
000a57 003b          .db $3b,0
000a58 0a47          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000a59 7000          .dw DO_COLON
                 PFA_SEMICOLON:
000a5a 01a3          .dw XT_COMPILE
000a5b 701a          .dw XT_EXIT
000a5c 0a6b          .dw XT_LBRACKET
000a5d 0a02          .dw XT_REVEAL
000a5e 701a          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000a5f ff01          .dw $ff01
000a60 005d          .db "]",0
000a61 0a56          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000a62 7000          .dw DO_COLON
                 PFA_RBRACKET:
000a63 7037          .dw XT_DOLITERAL
000a64 0001          .dw 1
000a65 00f3          .dw XT_STATE
000a66 707c          .dw XT_STORE
000a67 701a          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000a68 0001          .dw $0001
000a69 005b          .db "[",0
000a6a 0a5f          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000a6b 7000          .dw DO_COLON
                 PFA_LBRACKET:
000a6c 7134          .dw XT_ZERO
000a6d 00f3          .dw XT_STATE
000a6e 707c          .dw XT_STORE
000a6f 701a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000a70 ff08          .dw $ff08
000a71 6176
000a72 6972
000a73 6261
000a74 656c          .db "variable"
000a75 0a68          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000a76 7000          .dw DO_COLON
                 PFA_VARIABLE:
000a77 0167          .dw XT_HERE
000a78 0a83          .dw XT_CONSTANT
000a79 7037          .dw XT_DOLITERAL
000a7a 0002          .dw 2
000a7b 0170          .dw XT_ALLOT
000a7c 701a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000a7d ff08          .dw $ff08
000a7e 6f63
000a7f 736e
000a80 6174
000a81 746e          .db "constant"
000a82 0a70          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000a83 7000          .dw DO_COLON
                 PFA_CONSTANT:
000a84 017c          .dw XT_DOCREATE
000a85 0a02          .dw XT_REVEAL
000a86 01a3          .dw XT_COMPILE
000a87 7042          .dw PFA_DOVARIABLE
000a88 01ae          .dw XT_COMMA
000a89 701a          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000a8a ff04          .dw $ff04
000a8b 7375
000a8c 7265          .db "user"
000a8d 0a7d          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000a8e 7000          .dw DO_COLON
                 PFA_USER:
000a8f 017c          .dw XT_DOCREATE
000a90 0a02          .dw XT_REVEAL
                 
000a91 01a3          .dw XT_COMPILE
000a92 7052          .dw PFA_DOUSER
000a93 01ae          .dw XT_COMMA
000a94 701a          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000a95 ff05          .dw $ff05
000a96 6176
000a97 756c
000a98 0065          .db "value",0
000a99 0a8a          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000a9a 7000          .dw DO_COLON
                 PFA_VALUE:
000a9b 7063          .dw XT_DOVALUE
000a9c 015f          .dw XT_EDP
000a9d 01ae          .dw XT_COMMA
000a9e 01a3          .dw XT_COMPILE
000a9f 0aaa          .dw XT_EVALUEFETCH
000aa0 01a3          .dw XT_COMPILE
000aa1 0aae          .dw XT_EVALUESTORE
000aa2 015f          .dw XT_EDP
000aa3 70ac          .dw XT_DUP
000aa4 7238          .dw XT_1PLUS
000aa5 7238          .dw XT_1PLUS
000aa6 078a          .dw XT_DOTO
000aa7 0160          .dw PFA_EDP
000aa8 7337          .dw XT_STOREE
000aa9 701a          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000aaa 7000          .dw DO_COLON
                 PFA_EVALUEFETCH:
000aab 736f          .dw XT_FETCHI
000aac 735b          .dw XT_FETCHE
000aad 701a          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000aae 7000          .dw DO_COLON
                 PFA_EVALUESTORE:
000aaf 736f          .dw XT_FETCHI
000ab0 7337          .dw XT_STOREE
000ab1 701a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000ab2 0007          .dw $0007
000ab3 6572
000ab4 7563
000ab5 7372
000ab6 0065          .db "recurse",0
000ab7 0a95          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000ab8 7000          .dw DO_COLON
                 PFA_RECURSE:
000ab9 0a17          .dw XT_LATEST
000aba 7074          .dw XT_FETCH
000abb 01ae          .dw XT_COMMA
000abc 701a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000abd ff09          .dw $ff09
000abe 6d69
000abf 656d
000ac0 6964
000ac1 7461
000ac2 0065          .db "immediate",0
000ac3 0ab2          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000ac4 7000          .dw DO_COLON
                 PFA_IMMEDIATE:
000ac5 0ba1          .dw XT_GET_CURRENT
000ac6 735b          .dw XT_FETCHE
000ac7 70ac          .dw XT_DUP
000ac8 736f          .dw XT_FETCHI
000ac9 7037          .dw XT_DOLITERAL
000aca 7fff          .dw $7fff
000acb 721c          .dw XT_AND
000acc 70bf          .dw XT_SWAP
000acd 7379          .dw XT_STOREI
000ace 701a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000acf 0006          .dw $0006
000ad0 635b
000ad1 6168
000ad2 5d72          .db "[char]"
000ad3 0abd          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000ad4 7000          .dw DO_COLON
                 PFA_BRACKETCHAR:
000ad5 01a3          .dw XT_COMPILE
000ad6 7037          .dw XT_DOLITERAL
000ad7 04e2          .dw XT_CHAR
000ad8 01ae          .dw XT_COMMA
000ad9 701a          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000ada 0006          .dw $0006
000adb 6261
000adc 726f
000add 2274          .db "abort", $22
000ade 0acf          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000adf 7000          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000ae0 01a3          .dw XT_COMPILE
000ae1 7030          .dw XT_DOCONDBRANCH
000ae2 0157          .dw XT_DP
000ae3 01a3          .dw XT_COMPILE
000ae4 ffff          .dw -1
                     
000ae5 0d31          .dw XT_DOTSTRING
                     
000ae6 01a3          .dw XT_COMPILE
000ae7 7037          .dw XT_DOLITERAL
                     
000ae8 01a3          .dw XT_COMPILE
000ae9 fffe          .dw -2
000aea 01a3          .dw XT_COMPILE
000aeb 045f          .dw XT_THROW
                     ; then
000aec 0157          .dw XT_DP
000aed 70bf          .dw XT_SWAP
000aee 7379          .dw XT_STOREI
000aef 701a          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000af0 ff05          .dw $ff05
000af1 6261
000af2 726f
000af3 0074          .db "abort",0
000af4 0ada          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000af5 7000          .dw DO_COLON
                 PFA_ABORT:
000af6 7037          .dw XT_DOLITERAL
000af7 ffff          .dw -1
000af8 045f          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000af9 ff04          .dw $ff04
000afa 6f63
000afb 6564          .db "code"
000afc 0af0          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000afd 7000          .dw DO_COLON
                 PFA_CODE:
000afe 017c          .dw XT_DOCREATE
000aff 0a02          .dw XT_REVEAL
000b00 0157          .dw XT_DP
000b01 7238          .dw XT_1PLUS
000b02 01ae          .dw XT_COMMA
000b03 701a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000b04 ff08          .dw $ff08
000b05 6e65
000b06 2d64
000b07 6f63
000b08 6564          .db "end-code"
000b09 0af9          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000b0a 7000          .dw DO_COLON
                 PFA_ENDCODE:
000b0b 01a3          .dw XT_COMPILE
000b0c 940c          .dw $940c
000b0d 01a3          .dw XT_COMPILE
000b0e 7004          .dw DO_NEXT
000b0f 701a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000b10 ff0b          .dw $ff0b
000b11 6e65
000b12 6976
000b13 6f72
000b14 6d6e
000b15 6e65
000b16 0074          .db "environment",0
000b17 0b04          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000b18 7042          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000b19 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000b1a ff09          .dw $ff09
000b1b 6f77
000b1c 6472
000b1d 696c
000b1e 7473
000b1f 0073          .db "wordlists",0
000b20 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000b21 7000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000b22 7037          .dw XT_DOLITERAL
000b23 0008          .dw NUMWORDLISTS
000b24 701a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000b25 ff04          .dw $ff04
000b26 702f
000b27 6461          .db "/pad"
000b28 0b1a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000b29 7000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000b2a 728a          .dw XT_SP_FETCH
000b2b 012d          .dw XT_PAD
000b2c 719c          .dw XT_MINUS
000b2d 701a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000b2e ff05          .dw $ff05
000b2f 682f
000b30 6c6f
000b31 0064          .db "/hold",0
000b32 0b25          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000b33 7000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000b34 012d          .dw XT_PAD
000b35 0167          .dw XT_HERE
000b36 719c          .dw XT_MINUS
000b37 701a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000b38 ff0a          .dw $ff0a
000b39 6f66
000b3a 7472
000b3b 2d68
000b3c 616e
000b3d 656d          .db "forth-name"
000b3e 0b2e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000b3f 7000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000b40 0393          .dw XT_DOSLITERAL
000b41 0007          .dw 7
000b42 6d61
000b43 6f66
000b44 7472
000b45 0068          .db "amforth",0
000b46 701a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000b47 ff07          .dw $ff07
000b48 6576
000b49 7372
000b4a 6f69
000b4b 006e          .db "version",0
000b4c 0b38          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000b4d 7000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000b4e 7037          .dw XT_DOLITERAL
000b4f 0034          .dw 52
000b50 701a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000b51 ff03          .dw $ff03
000b52 7063
000b53 0075          .db "cpu",0
000b54 0b47          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000b55 7000          .dw DO_COLON
                 PFA_EN_CPU:
000b56 7037          .dw XT_DOLITERAL
000b57 003b          .dw mcu_name
000b58 03f5          .dw XT_ICOUNT
000b59 701a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000b5a ff08          .dw $ff08
000b5b 636d
000b5c 2d75
000b5d 6e69
000b5e 6f66          .db "mcu-info"
000b5f 0b51          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000b60 7000          .dw DO_COLON
                 PFA_EN_MCUINFO:
000b61 7037          .dw XT_DOLITERAL
000b62 0037          .dw mcu_info
000b63 701a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000b64 ff05          .dw $ff05
000b65 752f
000b66 6573
000b67 0072          .db "/user",0
000b68 0b5a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000b69 7000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000b6a 7037          .dw XT_DOLITERAL
000b6b 0026          .dw SYSUSERSIZE + APPUSERSIZE
000b6c 701a          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000b6d ff04          .dw $ff04
000b6e 6540
000b6f 5d5b          .db "@e[]"
000b70 0b10          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000b71 7000          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000b72 70ac          .dw XT_DUP
000b73 735b          .dw XT_FETCHE
000b74 70f3          .dw XT_TO_R    ; save the counter to r-stack
000b75 70fc          .dw XT_R_FETCH
000b76 7134          .dw XT_ZERO
000b77 70bf          .dw XT_SWAP    ; go from bigger to smaller addresses
000b78 72aa          .dw XT_DOQDO
000b79 0b83          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000b7a 72bd          .dw XT_I
000b7b 0100          .dw XT_CELLS ; ( -- ee-addr i*2 )
000b7c 70ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000b7d 71a6          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000b7e 735b          .dw XT_FETCHE ;( -- ee-addr item_i )
000b7f 70bf          .dw XT_SWAP   ;( -- item_i ee-addr )
000b80 713d          .dw XT_TRUE  ; shortcut for -1
000b81 72be          .dw XT_DOPLUSLOOP
000b82 0b7a          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000b83 0119          .dw XT_2DROP
000b84 70ea          .dw XT_R_FROM ; get the counter from r-stack
000b85 701a          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000b86 ff04          .dw $ff04
000b87 6521
000b88 5d5b          .db "!e[]"
000b89 0b6d          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000b8a 7000          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000b8b 0110          .dw XT_2DUP
000b8c 7337          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000b8d 70bf          .dw XT_SWAP    
000b8e 7134          .dw XT_ZERO
000b8f 72aa          .dw XT_DOQDO
000b90 0b97          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000b91 0108          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000b92 70bf          .dw XT_SWAP
000b93 70ca          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000b94 7337          .dw XT_STOREE
000b95 72d8          .dw XT_DOLOOP
000b96 0b91          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000b97 70d4          .dw XT_DROP
000b98 701a          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000b99 ff0b          .dw $ff0b
000b9a 6567
000b9b 2d74
000b9c 7563
000b9d 7272
000b9e 6e65
000b9f 0074          .db "get-current",0
000ba0 0b86          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000ba1 7000          .dw DO_COLON
                 PFA_GET_CURRENT:
000ba2 7037          .dw XT_DOLITERAL
000ba3 0010          .dw EE_CURRENT
000ba4 735b          .dw XT_FETCHE
000ba5 701a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000ba6 ff09          .dw $ff09
000ba7 6567
000ba8 2d74
000ba9 726f
000baa 6564
000bab 0072          .db "get-order",0
000bac 0b99          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000bad 7000          .dw DO_COLON
                 PFA_GET_ORDER:
000bae 7037          .dw XT_DOLITERAL
000baf 0014          .dw EE_ORDERLISTLEN
000bb0 0b71          .dw XT_FETCH_EE_ARRAY
000bb1 701a          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000bb2 ff07          .dw $ff07
000bb3 6f63
000bb4 706d
000bb5 7261
000bb6 0065          .db "compare",0
000bb7 0ba6          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000bb8 0bb9          .dw PFA_COMPARE
                 PFA_COMPARE:
000bb9 93bf          push xh
000bba 93af          push xl
000bbb 018c          movw temp0, tosl
000bbc 9189
000bbd 9199          loadtos
000bbe 01dc          movw xl, tosl
000bbf 9189
000bc0 9199          loadtos
000bc1 019c          movw temp2, tosl
000bc2 9189
000bc3 9199          loadtos
000bc4 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000bc5 90ed          ld temp4, X+
000bc6 90f1          ld temp5, Z+
000bc7 14ef          cp temp4, temp5
000bc8 f451          brne PFA_COMPARE_NOTEQUAL
000bc9 950a          dec temp0
000bca f019          breq PFA_COMPARE_ENDREACHED2
000bcb 952a          dec temp2
000bcc f7c1          brne PFA_COMPARE_LOOP
000bcd c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000bce 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000bcf 2b02          or temp0, temp2
000bd0 f411          brne PFA_COMPARE_CHECKLASTCHAR
000bd1 2788          clr tosl
000bd2 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000bd3 ef8f          ser tosl
000bd4 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000bd5 2f98          mov tosh, tosl
000bd6 91af          pop xl
000bd7 91bf          pop xh
000bd8 940c 7004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000bda ff07         .dw $ff07
000bdb 666e
000bdc 3e61
000bdd 666c
000bde 0061         .db "nfa>lfa",0
000bdf 0bb2         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000be0 7000          .dw DO_COLON
                 PFA_NFA2LFA:
000be1 03f5          .dw XT_ICOUNT 
000be2 7037          .dw XT_DOLITERAL
000be3 00ff          .dw $00ff
000be4 721c          .dw XT_AND
000be5 7238          .dw XT_1PLUS
000be6 720d          .dw XT_2SLASH
000be7 71a6          .dw XT_PLUS
000be8 701a          .dw XT_EXIT
                 .include "dict_wl.inc"
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000be9 ff0b          .dw $ff0b
000bea 6573
000beb 2d74
000bec 7563
000bed 7272
000bee 6e65
000bef 0074          .db "set-current",0
000bf0 0bda          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000bf1 7000          .dw DO_COLON
                 PFA_SET_CURRENT:
000bf2 7037          .dw XT_DOLITERAL
000bf3 0010          .dw EE_CURRENT
000bf4 7337          .dw XT_STOREE
000bf5 701a          .dw XT_EXIT
                 .include "words/previous.asm"
                 
                 ; Search Order
                 ; remove the first entry in the search order list
                 VE_PREVIOUS:
000bf6 ff08          .dw $ff08
000bf7 7270
000bf8 7665
000bf9 6f69
000bfa 7375          .db "previous"
000bfb 0be9          .dw VE_HEAD
                     .set VE_HEAD = VE_PREVIOUS
                 XT_PREVIOUS:
000bfc 7000          .dw DO_COLON	
                 PFA_PREVIOUS:
000bfd 0bad          .dw XT_GET_ORDER
000bfe 70bf          .dw XT_SWAP
000bff 70d4          .dw XT_DROP
000c00 723e          .dw XT_1MINUS
000c01 70ac          .dw XT_DUP
000c02 7118          .dw XT_EQUALZERO
000c03 7030          .dw XT_DOCONDBRANCH
000c04 0c08          .dw PFA_PREVIOUS1
000c05 7037          .dw XT_DOLITERAL
000c06 ffce          .dw -50
000c07 045f          .dw XT_THROW
                 PFA_PREVIOUS1:
000c08 0c65          .dw XT_SET_ORDER
000c09 701a          .dw XT_EXIT
                 .include "words/definitions.asm"
                 
                 ; Search Order
                 ; Make the compilation word list the same as the current first word list in the search order.
                 VE_DEFINITIONS:
000c0a ff0b          .dw $ff0b
000c0b 6564
000c0c 6966
000c0d 696e
000c0e 6974
000c0f 6e6f
000c10 0073          .db "definitions",0
000c11 0bf6          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFINITIONS
                 XT_DEFINITIONS:
000c12 7000          .dw DO_COLON
                 PFA_DEFINITIONS:
000c13 0bad          .dw XT_GET_ORDER
000c14 70ca          .dw XT_OVER
000c15 0bf1          .dw XT_SET_CURRENT
                     ; now empty the order list on stack
000c16 7134          .dw XT_ZERO
000c17 72aa          .dw XT_DOQDO
000c18 0c1c          .dw PFA_DEFINITIONS2
                 PFA_DEFINITIONS1:
000c19 70d4          .dw XT_DROP
000c1a 72d8          .dw XT_DOLOOP
000c1b 0c19          .dw PFA_DEFINITIONS1
                 PFA_DEFINITIONS2:
000c1c 701a          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000c1d ff08          .dw $ff08
000c1e 6f77
000c1f 6472
000c20 696c
000c21 7473          .db "wordlist"
000c22 0c0a          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000c23 7000          .dw DO_COLON
                 PFA_WORDLIST:
000c24 015f          .dw XT_EDP
000c25 7134          .dw XT_ZERO
000c26 70ca          .dw XT_OVER
000c27 7337          .dw XT_STOREE
000c28 70ac          .dw XT_DUP
000c29 7238          .dw XT_1PLUS
000c2a 7238          .dw XT_1PLUS
000c2b 078a          .dw XT_DOTO
000c2c 0160          .dw PFA_EDP
000c2d 701a          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000c2e ff04          .dw $ff04
000c2f 6e6f
000c30 796c          .db "only"
000c31 0c1d          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000c32 7000          .dw DO_COLON
                 PFA_ONLY:
000c33 7037          .dw XT_DOLITERAL
000c34 0012          .dw EE_FORTHWORDLIST
000c35 7037          .dw XT_DOLITERAL
000c36 0001          .dw 1
000c37 0c65          .dw XT_SET_ORDER
000c38 701a          .dw XT_EXIT
                 .include "words/forth.asm"
                 
                 ; Search Order
                 ; replace the search order list with the system default list
                 VE_FORTH:
000c39 ff05          .dw $ff05
000c3a 6f66
000c3b 7472
000c3c 0068          .db "forth",0
000c3d 0c2e          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH
                 XT_FORTH:
000c3e 7000          .dw DO_COLON
                 PFA_FORTH:
000c3f 0bad          .dw XT_GET_ORDER
000c40 70bf          .dw XT_SWAP
000c41 70d4          .dw XT_DROP
000c42 0c4f          .dw XT_FORTH_WORDLIST
000c43 70bf          .dw XT_SWAP
000c44 0c65          .dw XT_SET_ORDER
000c45 701a          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000c46 ff0e          .dw $ff0e
000c47 6f66
000c48 7472
000c49 2d68
000c4a 6f77
000c4b 6472
000c4c 696c
000c4d 7473          .db "forth-wordlist"
000c4e 0c39          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000c4f 7069          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000c50 000e          .dw EE_WL_FORTH
000c51 0aaa          .dw XT_EVALUEFETCH
000c52 0aae          .dw XT_EVALUESTORE
                 .include "words/also.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_ALSO:
000c53 ff04          .dw $ff04
000c54 6c61
000c55 6f73          .db "also"
000c56 0c46          .dw VE_HEAD
                     .set VE_HEAD = VE_ALSO
                 XT_ALSO:
000c57 7000          .dw DO_COLON
                 PFA_ALSO:
000c58 0bad          .dw XT_GET_ORDER
000c59 70ca          .dw XT_OVER
000c5a 70bf          .dw XT_SWAP
000c5b 7238          .dw XT_1PLUS
000c5c 0c65          .dw XT_SET_ORDER
000c5d 701a          .dw XT_EXIT
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 VE_SET_ORDER:
000c5e ff09          .dw $ff09
000c5f 6573
000c60 2d74
000c61 726f
000c62 6564
000c63 0072          .db "set-order",0
000c64 0c53          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000c65 7000          .dw DO_COLON
                 PFA_SET_ORDER:
000c66 7037          .dw XT_DOLITERAL
000c67 0014          .dw EE_ORDERLISTLEN
000c68 0b8a          .dw XT_STORE_EE_ARRAY
000c69 701a          .dw XT_EXIT
                 
                 .include "words/order.asm"
                 
                 ; Search Order
                 ; print the wids of the current word list and the search order
                 VE_ORDER:
000c6a ff05          .dw $ff05
000c6b 726f
000c6c 6564
000c6d 0072          .db "order",0
000c6e 0c5e          .dw VE_HEAD
                     .set VE_HEAD = VE_ORDER
                 XT_ORDER:
000c6f 7000          .dw DO_COLON
                 PFA_ORDER:
000c70 0ba1          .dw XT_GET_CURRENT
000c71 0d10          .dw XT_UDOT
000c72 03fe          .dw XT_CR
000c73 0bad          .dw XT_GET_ORDER
000c74 70ac          .dw XT_DUP
000c75 0d10          .dw XT_UDOT
000c76 7134          .dw XT_ZERO
000c77 72aa          .dw XT_DOQDO
000c78 0c7d          .dw PFA_ORDER2
                 PFA_ORDER1:
000c79 0d10          .dw XT_UDOT
000c7a 040b          .dw XT_SPACE         ; ( -- addr n)
000c7b 72d8          .dw XT_DOLOOP
000c7c 0c79          .dw PFA_ORDER1
                 PFA_ORDER2:
000c7d 701a          .dw XT_EXIT
                 
                 ;.include "dict_mcu.inc"
                 ;.include "dict_vm.inc"
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000c7e ff04          .dw $ff04
000c7f 692b
000c80 746e          .db "+int"
000c81 0c6a          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000c82 0c83          .dw PFA_INTON
                 PFA_INTON:
000c83 9478          sei
000c84 940c 7004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000c86 ff04          .dw $ff04
000c87 692d
000c88 746e          .db "-int"
000c89 0c7e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000c8a 0c8b          .dw PFA_INTOFF
                 PFA_INTOFF:
000c8b 94f8          cli
000c8c 940c 7004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000c8e ff04          .dw $ff04
000c8f 6e69
000c90 2174          .db "int!"
000c91 0c86          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000c92 7000          .dw DO_COLON
                 PFA_INTSTORE:
000c93 7037          .dw XT_DOLITERAL
000c94 0115          .dw intvec
000c95 71a6          .dw XT_PLUS
000c96 707c          .dw XT_STORE
000c97 701a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000c98 ff04          .dw $ff04
000c99 6e69
000c9a 4074          .db "int@"
000c9b 0c8e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000c9c 7000          .dw DO_COLON
                 PFA_INTFETCH:
000c9d 7037          .dw XT_DOLITERAL
000c9e 0115          .dw intvec
000c9f 71a6          .dw XT_PLUS
000ca0 7074          .dw XT_FETCH
000ca1 701a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000ca2 ff08          .dw $ff08
000ca3 6e69
000ca4 2d74
000ca5 7274
000ca6 7061          .db "int-trap"
000ca7 0c98          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000ca8 0ca9          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000ca9 9380 0114     sts intcur, tosl
000cab 9189
000cac 9199          loadtos
000cad 9468          set ; set the interrupt flag for the inner interpreter
000cae 940c 7004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000cb0 7000          .dw DO_COLON
                 PFA_ISREXEC:
000cb1 7037          .dw XT_DOLITERAL
000cb2 0114          .dw intcur
000cb3 7093          .dw XT_CFETCH
000cb4 7037          .dw XT_DOLITERAL
000cb5 0115          .dw intvec
000cb6 71a6          .dw XT_PLUS
000cb7 7074          .dw XT_FETCH
000cb8 7024          .dw XT_EXECUTE
000cb9 0cbb          .dw XT_ISREND
000cba 701a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000cbb 0cbc          .dw PFA_ISREND
                 PFA_ISREND:
000cbc d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000cbd 940c 7004     jmp_ DO_NEXT
                 PFA_ISREND1:
000cbf 9518          reti
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000cc0 ff03          .dw $ff03
000cc1 3264
000cc2 002a          .db "d2*",0
000cc3 0ca2          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000cc4 0cc5          .dw PFA_D2STAR
                 PFA_D2STAR:
000cc5 9109          ld temp0, Y+
000cc6 9119          ld temp1, Y+
000cc7 0f00          lsl temp0
000cc8 1f11          rol temp1
000cc9 1f88          rol tosl
000cca 1f99          rol tosh
000ccb 931a          st -Y, temp1
000ccc 930a          st -Y, temp0
000ccd 940c 7004     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000ccf ff02          .dw $ff02
000cd0 2b64          .db "d+"
000cd1 0cc0          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000cd2 0cd3          .dw PFA_DPLUS
                 PFA_DPLUS:
000cd3 9129          ld temp2, Y+
000cd4 9139          ld temp3, Y+
                 
000cd5 90e9          ld temp4, Y+
000cd6 90f9          ld temp5, Y+
000cd7 9149          ld temp6, Y+
000cd8 9159          ld temp7, Y+
                 
000cd9 0f24          add temp2, temp6
000cda 1f35          adc temp3, temp7
000cdb 1d8e          adc tosl, temp4
000cdc 1d9f          adc tosh, temp5
                     
000cdd 933a          st -Y, temp3
000cde 932a          st -Y, temp2
000cdf 940c 7004     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000ce1 ff02          .dw $ff02
000ce2 2d64          .db "d-"
000ce3 0ccf          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000ce4 0ce5          .dw PFA_DMINUS
                 PFA_DMINUS:
000ce5 9129          ld temp2, Y+
000ce6 9139          ld temp3, Y+
                 
000ce7 90e9          ld temp4, Y+
000ce8 90f9          ld temp5, Y+
000ce9 9149          ld temp6, Y+
000cea 9159          ld temp7, Y+
                 
000ceb 1b42          sub temp6, temp2
000cec 0b53          sbc temp7, temp3
000ced 0ae8          sbc temp4, tosl
000cee 0af9          sbc temp5, tosh
                 
000cef 935a          st -Y, temp7
000cf0 934a          st -Y, temp6
000cf1 01c7          movw tosl, temp4
000cf2 940c 7004     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000cf4 ff07          .dw $ff07
000cf5 6964
000cf6 766e
000cf7 7265
000cf8 0074          .db "dinvert",0
000cf9 0ce1          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000cfa 0cfb          .dw PFA_DINVERT
                 PFA_DINVERT:
000cfb 9109          ld temp0, Y+
000cfc 9119          ld temp1, Y+
000cfd 9580          com tosl
000cfe 9590          com tosh
000cff 9500          com temp0
000d00 9510          com temp1
000d01 931a          st -Y, temp1
000d02 930a          st -Y, temp0
000d03 940c 7004     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
000d05 ff02          .dw $ff02
000d06 3d64          .db "d="
000d07 0cf4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000d08 7000          .dw DO_COLON
                 PFA_DEQUAL:
000d09 0ce4          .dw XT_DMINUS
000d0a 7225          .dw XT_OR
000d0b 7118          .dw XT_EQUALZERO
000d0c 701a          .dw XT_EXIT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
000d0d ff02          .dw $ff02
000d0e 2e75          .db "u."
000d0f 0d05          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000d10 7000          .dw DO_COLON
                 PFA_UDOT:
000d11 7134          .dw XT_ZERO
000d12 0338          .dw XT_UDDOT
000d13 701a          .dw XT_EXIT
                 .include "words/udotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 VE_UDOTR:
000d14 ff03          .dw $ff03
000d15 2e75
000d16 0072          .db "u.r",0
000d17 0d0d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
000d18 7000          .dw DO_COLON
                 PFA_UDOTR:
000d19 7134          .dw XT_ZERO
000d1a 70bf          .dw XT_SWAP
000d1b 0341          .dw XT_UDDOTR
000d1c 701a          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
000d1d ff02          .dw $ff02
000d1e 732e          .db ".s"
000d1f 0d14          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000d20 7000          .dw DO_COLON
                 PFA_DOTS:
000d21 06a6          .dw XT_SP0
000d22 728a          .dw XT_SP_FETCH
000d23 0108          .dw XT_CELLPLUS
000d24 72aa          .dw XT_DOQDO
000d25 0d2d          .dw PFA_DOTS2
                 PFA_DOTS1:
000d26 72bd          .dw XT_I
000d27 7074          .dw XT_FETCH 
000d28 0d10          .dw XT_UDOT
000d29 7037          .dw XT_DOLITERAL
000d2a 0002          .dw 2
000d2b 72be          .dw XT_DOPLUSLOOP
000d2c 0d26          .dw PFA_DOTS1
                 PFA_DOTS2:
000d2d 701a          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
000d2e 0002          .dw $0002
000d2f 222e          .db ".",$22
000d30 0d1d          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000d31 7000          .dw DO_COLON
                 PFA_DOTSTRING:
000d32 0d39          .dw XT_SQUOTE
000d33 01a3          .dw XT_COMPILE
000d34 03ca          .dw XT_ITYPE
000d35 701a          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
000d36 0002        .dw $0002
000d37 2273        .db "s",$22
000d38 0d2e        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000d39 7000          .dw DO_COLON
                 PFA_SQUOTE:
000d3a 7037          .dw XT_DOLITERAL
000d3b 0022          .dw $22
000d3c 05a0          .dw XT_PARSE       ; ( -- addr n)
000d3d 00f3          .dw XT_STATE
000d3e 7074          .dw XT_FETCH
000d3f 7030          .dw XT_DOCONDBRANCH
000d40 0d44          .dw PFA_SQUOTE1
000d41 01a3            .dw XT_COMPILE
000d42 0393            .dw XT_DOSLITERAL    ; ( -- addr n)
000d43 03a6            .dw XT_SCOMMA
                 PFA_SQUOTE1:
000d44 701a          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000d45 ff06          .dw $ff06
000d46 6445
000d47 6665
000d48 7265          .db "Edefer"
000d49 0d36          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000d4a 7000          .dw DO_COLON
                 PFA_EDEFER:
000d4b 017c          .dw XT_DOCREATE
000d4c 0a02          .dw XT_REVEAL
000d4d 01a3          .dw XT_COMPILE
000d4e 07d2          .dw PFA_DODEFER
                 
000d4f 015f          .dw XT_EDP
000d50 70ac          .dw XT_DUP
000d51 01ae          .dw XT_COMMA
000d52 01a3          .dw XT_COMPILE
000d53 0796          .dw XT_EDEFERFETCH
000d54 01a3          .dw XT_COMPILE
000d55 079b          .dw XT_EDEFERSTORE
000d56 0108          .dw XT_CELLPLUS
000d57 078a          .dw XT_DOTO
000d58 0160          .dw PFA_EDP
000d59 701a          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000d5a ff06          .dw $ff06
000d5b 6452
000d5c 6665
000d5d 7265          .db "Rdefer"
000d5e 0d45          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000d5f 7000          .dw DO_COLON
                 PFA_RDEFER:
000d60 017c          .dw XT_DOCREATE
000d61 0a02          .dw XT_REVEAL
                 
000d62 01a3          .dw XT_COMPILE
000d63 07d2          .dw PFA_DODEFER
                 
000d64 0167          .dw XT_HERE
000d65 01ae          .dw XT_COMMA
000d66 7037          .dw XT_DOLITERAL
000d67 0002          .dw 2
000d68 0170          .dw XT_ALLOT
                 
000d69 01a3          .dw XT_COMPILE
000d6a 07a0          .dw XT_RDEFERFETCH
000d6b 01a3          .dw XT_COMPILE
000d6c 07a5          .dw XT_RDEFERSTORE
000d6d 701a          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000d6e 0002          .dw $0002
000d6f 7369          .db "is"
000d70 0d5a          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000d71 7000          .dw DO_COLON
                 PFA_IS:
000d72 00f3          .dw XT_STATE
000d73 7074          .dw XT_FETCH
000d74 7030          .dw XT_DOCONDBRANCH
000d75 0d7a          .dw PFA_IS1
000d76 01ba          .dw XT_BRACKETTICK
000d77 01a3          .dw XT_COMPILE
000d78 07bd          .dw XT_DEFERSTORE
000d79 701a          .dw XT_EXIT
                 PFA_IS1:
000d7a 0432          .dw XT_TICK
000d7b 07bd          .dw XT_DEFERSTORE
000d7c 701a          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000d7d ff0b          .dw $ff0b
000d7e 7061
000d7f 6c70
000d80 7574
000d81 6e72
000d82 656b
000d83 0079          .db "applturnkey",0
000d84 0d6e          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000d85 7000          .dw DO_COLON
                 PFA_APPLTURNKEY:
000d86 00b4          .dw XT_USART
000d87 0c82          .dw XT_INTON
000d88 0752          .dw XT_VER
000d89 040b          .dw XT_SPACE
000d8a 00dd          .dw XT_F_CPU
000d8b 7037          .dw XT_DOLITERAL
000d8c 03e8          .dw 1000
000d8d 71cb          .dw XT_UMSLASHMOD
000d8e 70bf          .dw XT_SWAP
000d8f 70d4          .dw XT_DROP
000d90 01d0          .dw XT_DECIMAL
000d91 0330          .dw XT_DOT
000d92 0393          .dw XT_DOSLITERAL
000d93 0004          .dw 4
000d94 486b
000d95 207a          .db "kHz "
000d96 03ca          .dw XT_ITYPE
000d97 701a          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000d98 ff04          .dw $ff04
000d99 6966
000d9a 6c6c          .db "fill"
000d9b 0d7d          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000d9c 7000          .dw DO_COLON
                 PFA_FILL:
000d9d 70dc          .dw XT_ROT
000d9e 70dc          .dw XT_ROT
000d9f 7134          .dw XT_ZERO
000da0 72aa          .dw XT_DOQDO
000da1 0da7          .dw PFA_FILL2
                 PFA_FILL1:
000da2 0110          .dw XT_2DUP
000da3 7088          .dw XT_CSTORE  ; ( -- c c-addr)
000da4 7238          .dw XT_1PLUS
000da5 72d8          .dw XT_DOLOOP
000da6 0da2          .dw PFA_FILL1
                 PFA_FILL2:
000da7 70d4          .dw XT_DROP
000da8 70d4          .dw XT_DROP
000da9 701a          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
000daa ff0d          .dw $ff0d
000dab 6873
000dac 776f
000dad 772d
000dae 726f
000daf 6c64
000db0 7369
000db1 0074          .db "show-wordlist",0
000db2 0d98          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
000db3 7000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
000db4 7037          .dw XT_DOLITERAL
000db5 0db9          .dw XT_SHOWWORD
000db6 70bf          .dw XT_SWAP
000db7 082c          .dw XT_TRAVERSEWORDLIST
000db8 701a          .dw XT_EXIT
                 
                 XT_SHOWWORD:
000db9 7000          .dw DO_COLON
                 PFA_SHOWWORD:
000dba 081b          .dw XT_NAME2STRING
000dbb 03ca          .dw XT_ITYPE
000dbc 040b          .dw XT_SPACE         ; ( -- addr n)
000dbd 713d          .dw XT_TRUE
000dbe 701a          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000dbf ff05          .dw $ff05
000dc0 6f77
000dc1 6472
000dc2 0073          .db "words",0
000dc3 0daa          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000dc4 7000          .dw DO_COLON
                 PFA_WORDS:
000dc5 7037          .dw XT_DOLITERAL
000dc6 0016          .dw EE_ORDERLIST
000dc7 735b          .dw XT_FETCHE
000dc8 0db3          .dw XT_SHOWWORDLIST
000dc9 701a          .dw XT_EXIT
                 
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
000dca ff03          .dw $ff03
000dcb 6d31
000dcc 0073          .db "1ms",0
000dcd 0dbf          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000dce 0dcf          .dw PFA_1MS
                 PFA_1MS:
000dcf eae0
000dd0 e0ff
000dd1 9731
000dd2 f7f1          delay 1000
000dd3 940c 7004     jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
000dd5 0008          .dw $0008
000dd6 6c32
000dd7 7469
000dd8 7265
000dd9 6c61          .db "2literal"
000dda 0dca          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
000ddb 7000          .dw DO_COLON
                 PFA_2LITERAL:
000ddc 70bf          .dw XT_SWAP
000ddd 01a3          .dw XT_COMPILE
000dde 7037          .dw XT_DOLITERAL
000ddf 01ae          .dw XT_COMMA
000de0 01a3          .dw XT_COMPILE
000de1 7037          .dw XT_DOLITERAL
000de2 01ae          .dw XT_COMMA
                     
000de3 701a          .dw XT_EXIT
                 .include "device.inc"
                 
                 ; generated automatically, no not edit
                 
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 .if WANT_USART0 == 1
                 .endif
                 .if WANT_PORTA == 1
                 .endif
                 .if WANT_PORTB == 1
                 .endif
                 .if WANT_PORTC == 1
                 .endif
                 .if WANT_PORTD == 1
                 .endif
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 .if WANT_WATCHDOG == 1
                 .endif
                 .if WANT_JTAG == 1
                 .endif
                 .if WANT_BOOT_LOAD == 1
                 .endif
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 .if WANT_EEPROM == 1
                 .endif
                 .if WANT_TWI == 1
                 .endif
                 .if WANT_SPI == 1
                 .endif
                 .if WANT_CPU == 1
                 .endif
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
007000 93bf          push XH
007001 93af          push XL          ; PUSH IP
007002 01db          movw XL, wl
007003 9611          adiw xl, 1
                 DO_NEXT:
007004 f06e          brts DO_INTERRUPT
007005 01fd          movw zl, XL        ; READ IP
007006 0fee
007007 1fff
007008 9165
007009 9175          readflashcell wl, wh
00700a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00700b 01fb          movw zl, wl
00700c 0fee
00700d 1fff
00700e 9105
00700f 9115          readflashcell temp0,temp1
007010 01f8          movw zl, temp0
007011 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
007012 94e8          clt
007013 eb60          ldi wl, LOW(XT_ISREXEC)
007014 e07c          ldi wh, HIGH(XT_ISREXEC)
007015 cff5          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
007016 ff04          .dw $ff04
007017 7865
007018 7469          .db "exit"
007019 0dd5          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00701a 701b          .dw PFA_EXIT
                 PFA_EXIT:
00701b 91af          pop XL
00701c 91bf          pop XH
00701d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00701e ff07          .dw $ff07
00701f 7865
007020 6365
007021 7475
007022 0065          .db "execute",0
007023 7016          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
007024 7025          .dw PFA_EXECUTE
                 PFA_EXECUTE:
007025 01bc          movw wl, tosl
007026 9189
007027 9199          loadtos
007028 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
007029 702a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00702a 01fd          movw zl, XL
00702b 0fee
00702c 1fff
00702d 91a5
00702e 91b5          readflashcell XL,XH
00702f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
007030 7031          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
007031 2b98          or tosh, tosl
007032 9189
007033 9199          loadtos
007034 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
007035 9611          adiw XL, 1
007036 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
007037 7038          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
007038 939a
007039 938a          savetos
00703a 01fd          movw zl, xl
00703b 0fee
00703c 1fff
00703d 9185
00703e 9195          readflashcell tosl,tosh
00703f 9611          adiw xl, 1
007040 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
007041 7042          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
007042 939a
007043 938a          savetos
007044 01fb          movw zl, wl
007045 9631          adiw zl,1
007046 0fee
007047 1fff
007048 9185
007049 9195          readflashcell tosl,tosh
00704a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00704b 704c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00704c 939a
00704d 938a          savetos
00704e 01cb          movw tosl, wl
00704f 9601          adiw tosl, 1
007050 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
007051 7052          .dw PFA_DOUSER
                 PFA_DOUSER:
007052 939a
007053 938a          savetos
007054 01fb          movw zl, wl
007055 9631          adiw zl, 1
007056 0fee
007057 1fff
007058 9185
007059 9195          readflashcell tosl,tosh
00705a 0d84          add tosl, upl
00705b 1d95          adc tosh, uph
00705c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00705d ff07          .dw $ff07
00705e 7628
00705f 6c61
007060 6575
007061 0029          .db "(value)", 0
007062 701e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
007063 7000          .dw DO_COLON
                 PFA_DOVALUE:
007064 017c          .dw XT_DOCREATE
007065 0a02          .dw XT_REVEAL
007066 01a3          .dw XT_COMPILE
007067 7069          .dw PFA_DOVALUE1
007068 701a          .dw XT_EXIT
                 PFA_DOVALUE1:
007069 940e 0a26     call_ DO_DODOES
00706b 70ac          .dw XT_DUP
00706c 70bf          .dw XT_SWAP
00706d 7238          .dw XT_1PLUS
00706e 736f          .dw XT_FETCHI
00706f 7024          .dw XT_EXECUTE
007070 701a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
007071 ff01          .dw $ff01
007072 0040          .db "@",0
007073 705d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
007074 7075          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
007075 01fc          movw zl, tosl
                     ; low byte is read before the high byte
007076 9181          ld tosl, z+
007077 9191          ld tosh, z+
007078 cf8b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
007079 ff01          .dw $ff01
00707a 0021          .db "!",0
00707b 7071          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00707c 707d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00707d 01fc          movw zl, tosl
00707e 9189
00707f 9199          loadtos
                     ; the high byte is written before the low byte
007080 8391          std Z+1, tosh
007081 8380          std Z+0, tosl
007082 9189
007083 9199          loadtos
007084 cf7f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
007085 ff02          .dw $ff02
007086 2163          .db "c!"
007087 7079          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
007088 7089          .dw PFA_CSTORE
                 PFA_CSTORE:
007089 01fc          movw zl, tosl
00708a 9189
00708b 9199          loadtos
00708c 8380          st Z, tosl
00708d 9189
00708e 9199          loadtos
00708f cf74          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
007090 ff02          .dw $ff02
007091 4063          .db "c@"
007092 7085          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
007093 7094          .dw PFA_CFETCH
                 PFA_CFETCH:
007094 01fc          movw zl, tosl
007095 2799          clr tosh
007096 8180          ld tosl, Z
007097 cf6c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
007098 ff02          .dw $ff02
007099 7540          .db "@u"
00709a 7090          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00709b 7000          .dw DO_COLON
                 PFA_FETCHU:
00709c 7317          .dw XT_UP_FETCH
00709d 71a6          .dw XT_PLUS
00709e 7074          .dw XT_FETCH
00709f 701a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
0070a0 ff02          .dw $ff02
0070a1 7521          .db "!u"
0070a2 7098          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0070a3 7000          .dw DO_COLON
                 PFA_STOREU:
0070a4 7317          .dw XT_UP_FETCH
0070a5 71a6          .dw XT_PLUS
0070a6 707c          .dw XT_STORE
0070a7 701a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0070a8 ff03          .dw $ff03
0070a9 7564
0070aa 0070          .db "dup",0
0070ab 70a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0070ac 70ad          .dw PFA_DUP
                 PFA_DUP:
0070ad 939a
0070ae 938a          savetos
0070af cf54          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0070b0 ff04          .dw $ff04
0070b1 643f
0070b2 7075          .db "?dup"
0070b3 70a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0070b4 70b5          .dw PFA_QDUP
                 PFA_QDUP:
0070b5 2f08          mov temp0, tosl
0070b6 2b09          or temp0, tosh
0070b7 f011          breq PFA_QDUP1
0070b8 939a
0070b9 938a          savetos
                 PFA_QDUP1:
0070ba cf49          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0070bb ff04          .dw $ff04
0070bc 7773
0070bd 7061          .db "swap"
0070be 70b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0070bf 70c0          .dw PFA_SWAP
                 PFA_SWAP:
0070c0 018c          movw temp0, tosl
0070c1 9189
0070c2 9199          loadtos
0070c3 931a          st -Y, temp1
0070c4 930a          st -Y, temp0
0070c5 cf3e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0070c6 ff04          .dw $ff04
0070c7 766f
0070c8 7265          .db "over"
0070c9 70bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0070ca 70cb          .dw PFA_OVER
                 PFA_OVER:
0070cb 939a
0070cc 938a          savetos
0070cd 818a          ldd tosl, Y+2
0070ce 819b          ldd tosh, Y+3
                 
0070cf cf34          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0070d0 ff04          .dw $ff04
0070d1 7264
0070d2 706f          .db "drop"
0070d3 70c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0070d4 70d5          .dw PFA_DROP
                 PFA_DROP:
0070d5 9189
0070d6 9199          loadtos
0070d7 cf2c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0070d8 ff03          .dw $ff03
0070d9 6f72
0070da 0074          .db "rot",0
0070db 70d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0070dc 70dd          .dw PFA_ROT
                 PFA_ROT:
0070dd 018c          movw temp0, tosl
0070de 9129          ld temp2, Y+
0070df 9139          ld temp3, Y+ 
0070e0 9189
0070e1 9199          loadtos
                         
0070e2 933a          st -Y, temp3
0070e3 932a          st -Y, temp2
0070e4 931a          st -Y, temp1
0070e5 930a          st -Y, temp0
                 
0070e6 cf1d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0070e7 ff02          .dw $ff02
0070e8 3e72          .db "r>"
0070e9 70d8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0070ea 70eb          .dw PFA_R_FROM
                 PFA_R_FROM:
0070eb 939a
0070ec 938a          savetos
0070ed 918f          pop tosl
0070ee 919f          pop tosh
0070ef cf14          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0070f0 ff02          .dw $ff02
0070f1 723e          .db ">r"
0070f2 70e7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0070f3 70f4          .dw PFA_TO_R
                 PFA_TO_R:
0070f4 939f          push tosh
0070f5 938f          push tosl
0070f6 9189
0070f7 9199          loadtos
0070f8 cf0b          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
0070f9 ff02          .dw $ff02
0070fa 4072          .db "r@"
0070fb 70f0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
0070fc 70fd          .dw PFA_R_FETCH
                 PFA_R_FETCH:
0070fd 939a
0070fe 938a          savetos
0070ff 918f          pop tosl
007100 919f          pop tosh
007101 939f          push tosh
007102 938f          push tosl
007103 cf00          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
007104 ff02          .dw $ff02
007105 3e3c          .db "<>"
007106 70f9          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
007107 7108          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
007108 9129          ld temp2, Y+
007109 9139          ld temp3, Y+
00710a 1782          cp tosl, temp2
00710b 0793          cpc tosh, temp3
00710c f151          breq PFA_ZERO1
00710d c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00710e ff01          .dw $ff01
00710f 003d          .db "=",0
007110 7104          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
007111 7000          .dw DO_COLON
                 PFA_EQUAL:
007112 719c          .dw XT_MINUS
007113 7118          .dw XT_EQUALZERO
007114 701a          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
007115 ff02          .dw $ff02
007116 3d30          .db "0="
007117 710e          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
007118 7119          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
007119 2b98          or tosh, tosl
00711a f4e1          brne PFA_ZERO1
00711b c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00711c ff01          .dw $ff01
00711d 003c          .db "<",0
00711e 7115          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00711f 7000          .dw DO_COLON
                 PFA_LESS:
007120 719c          .dw XT_MINUS
007121 712d          .dw XT_LESSZERO
007122 701a          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
007123 ff01          .dw $ff01
007124 003e          .db ">",0
007125 711c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
007126 7000          .dw DO_COLON
                 PFA_GREATER:
007127 719c          .dw XT_MINUS
007128 715c          .dw XT_GREATERZERO
007129 701a          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00712a ff02          .dw $ff02
00712b 3c30          .db "0<"
00712c 7123          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00712d 712e          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00712e fd97          sbrc tosh,7
00712f c010          rjmp PFA_TRUE1
007130 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
007131 ff01          .dw $ff01
007132 0030          .db "0",0
007133 712a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
007134 7135          .dw PFA_ZERO
                 PFA_ZERO:
007135 939a
007136 938a          savetos
                 PFA_ZERO1:
007137 01c1          movw tosl, zerol
007138 cecb          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
007139 ff04          .dw $ff04
00713a 7274
00713b 6575          .db "true"
00713c 7131          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00713d 713e          .dw PFA_TRUE
                 PFA_TRUE:
00713e 939a
00713f 938a          savetos
                 PFA_TRUE1:
007140 ef8f          ser tosl
007141 ef9f          ser tosh
007142 cec1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
007143 ff02          .dw $ff02
007144 3c75          .db "u<"
007145 7139          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
007146 7147          .dw PFA_ULESS
                 PFA_ULESS:
007147 9129          ld temp2, Y+
007148 9139          ld temp3, Y+
007149 1782          cp tosl, temp2
00714a 0793          cpc tosh, temp3
00714b f358          brlo PFA_ZERO1
00714c f351          brbs 1, PFA_ZERO1
00714d cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00714e ff02          .dw $ff02
00714f 3e75          .db "u>"
007150 7143          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
007151 7152          .dw PFA_UGREATER
                 PFA_UGREATER:
007152 9129          ld temp2, Y+
007153 9139          ld temp3, Y+
007154 1728          cp temp2, tosl
007155 0739          cpc temp3, tosh
007156 f300          brlo PFA_ZERO1
007157 f2f9          brbs 1, PFA_ZERO1
007158 cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
007159 ff02          .dw $ff02
00715a 3e30          .db "0>"
00715b 714e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00715c 715d          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00715d 1582          cp tosl, zerol
00715e 0593          cpc tosh, zeroh
00715f f2bc          brlt PFA_ZERO1
007160 f2b1          brbs 1, PFA_ZERO1
007161 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
007162 ff02          .dw $ff02
007163 3e64          .db "d>"
007164 7159          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
007165 7000          .dw DO_COLON
                 PFA_DGREATER:
007166 0ce4          .dw XT_DMINUS
007167 716d          .dw XT_DGREATERZERO
007168 701a          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
007169 ff03          .dw $ff03
00716a 3064
00716b 003e          .db "d0>",0
00716c 7162          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00716d 716e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00716e 1582          cp tosl, zerol
00716f 0593          cpc tosh, zeroh
007170 9189
007171 9199          loadtos
007172 0582          cpc tosl, zerol
007173 0593          cpc tosh, zeroh
007174 f214          brlt PFA_ZERO1
007175 f209          brbs 1, PFA_ZERO1
007176 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
007177 ff02          .dw $ff02
007178 3c64          .db "d<"
007179 7169          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00717a 7000          .dw DO_COLON
                 PFA_DLESS:
00717b 0ce4          .dw XT_DMINUS
00717c 7182          .dw XT_DLESSZERO
00717d 701a          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00717e ff03          .dw $ff03
00717f 3064
007180 003c          .db "d0<",0
007181 7177          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
007182 7183          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
007183 9622          adiw Y,2
007184 fd97          sbrc tosh,7
007185 940c 7140     jmp PFA_TRUE1
007187 940c 7137     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
007189 ff04          .dw $ff04
00718a 6f6c
00718b 3267          .db "log2"
00718c 717e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00718d 718e          .dw PFA_LOG2
                 PFA_LOG2:
00718e 01fc          movw zl, tosl
00718f 2799          clr tosh
007190 e180          ldi tosl, 16
                 PFA_LOG2_1:
007191 958a          dec tosl
007192 f022          brmi PFA_LOG2_2 ; wrong data
007193 0fee          lsl  zl
007194 1fff          rol  zh
007195 f7d8          brcc PFA_LOG2_1
007196 ce6d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
007197 959a          dec tosh
007198 ce6b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
007199 ff01          .dw $ff01
00719a 002d          .db "-",0
00719b 7189          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00719c 719d          .dw PFA_MINUS
                 PFA_MINUS:
00719d 9109          ld temp0, Y+
00719e 9119          ld temp1, Y+
00719f 1b08          sub temp0, tosl
0071a0 0b19          sbc temp1, tosh
0071a1 01c8          movw tosl, temp0
0071a2 ce61          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
0071a3 ff01          .dw $ff01
0071a4 002b          .db "+",0
0071a5 7199          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
0071a6 71a7          .dw PFA_PLUS
                 PFA_PLUS:
0071a7 9109          ld temp0, Y+
0071a8 9119          ld temp1, Y+
0071a9 0f80          add tosl, temp0
0071aa 1f91          adc tosh, temp1
0071ab ce58          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0071ac ff02          .dw $ff02
0071ad 2a6d          .db "m*"
0071ae 71a3          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0071af 71b0          .dw PFA_MSTAR
                 PFA_MSTAR:
0071b0 018c          movw temp0, tosl
0071b1 9189
0071b2 9199          loadtos
0071b3 019c          movw temp2, tosl
                     ; high cell ah*bh
0071b4 0231          muls temp3, temp1
0071b5 0170          movw temp4, r0
                     ; low cell  al*bl
0071b6 9f20          mul  temp2, temp0
0071b7 01c0          movw tosl, r0
                     ; signed ah*bl
0071b8 0330          mulsu temp3, temp0
0071b9 08f3          sbc   temp5, zeroh
0071ba 0d90          add   tosh,  r0
0071bb 1ce1          adc   temp4, r1
0071bc 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0071bd 0312          mulsu temp1, temp2
0071be 08f3          sbc   temp5, zeroh
0071bf 0d90          add   tosh,  r0
0071c0 1ce1          adc   temp4, r1
0071c1 1cf3          adc   temp5, zeroh
                 
0071c2 939a
0071c3 938a          savetos
0071c4 01c7          movw tosl, temp4
0071c5 ce3e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0071c6 ff06          .dw $ff06
0071c7 6d75
0071c8 6d2f
0071c9 646f          .db "um/mod"
0071ca 71ac          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0071cb 71cc          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0071cc 017c          movw temp4, tosl
                 
0071cd 9129          ld temp2, Y+
0071ce 9139          ld temp3, Y+
                   
0071cf 9109          ld temp0, Y+
0071d0 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0071d1 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0071d2 2755          clr temp7
0071d3 0f00          lsl temp0
0071d4 1f11          rol temp1
0071d5 1f22          rol temp2
0071d6 1f33          rol temp3
0071d7 1f55          rol temp7
                 
                   ; try subtracting divisor
0071d8 152e          cp temp2, temp4
0071d9 053f          cpc temp3, temp5
0071da 0552          cpc temp7,zerol
                 
0071db f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0071dc 9503          inc temp0
0071dd 192e          sub temp2, temp4
0071de 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0071df 954a          dec  temp6
0071e0 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0071e1 933a          st -Y,temp3
0071e2 932a          st -Y,temp2
                 
                     ; put quotient on stack
0071e3 01c8          movw tosl, temp0
0071e4 ce1f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0071e5 ff03          .dw $ff03
0071e6 6d75
0071e7 002a          .db "um*",0
0071e8 71c6          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0071e9 71ea          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0071ea 018c          movw temp0, tosl
0071eb 9189
0071ec 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0071ed 9f80          mul tosl,temp0
0071ee 01f0          movw zl, r0
0071ef 2722          clr temp2
0071f0 2733          clr temp3
                     ; middle bytes
0071f1 9f90          mul tosh, temp0
0071f2 0df0          add zh, r0
0071f3 1d21          adc temp2, r1
0071f4 1d33          adc temp3, zeroh
                         
0071f5 9f81          mul tosl, temp1
0071f6 0df0          add zh, r0
0071f7 1d21          adc temp2, r1
0071f8 1d33          adc temp3, zeroh
                     
0071f9 9f91          mul tosh, temp1
0071fa 0d20          add temp2, r0
0071fb 1d31          adc temp3, r1
0071fc 01cf          movw tosl, zl
0071fd 939a
0071fe 938a          savetos
0071ff 01c9          movw tosl, temp2
007200 ce03          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
007201 ff06          .dw $ff06
007202 6e69
007203 6576
007204 7472          .db "invert"
007205 71e5          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
007206 7207          .dw PFA_INVERT
                 PFA_INVERT:
007207 9580          com tosl
007208 9590          com tosh
007209 cdfa          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00720a ff02          .dw $ff02
00720b 2f32          .db "2/"
00720c 7201          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00720d 720e          .dw PFA_2SLASH
                 PFA_2SLASH:
00720e 9595          asr tosh
00720f 9587          ror tosl
007210 cdf3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
007211 ff02          .dw $ff02
007212 2a32          .db "2*"
007213 720a          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
007214 7215          .dw PFA_2STAR
                 PFA_2STAR:
007215 0f88          lsl tosl
007216 1f99          rol tosh
007217 cdec          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
007218 ff03          .dw $ff03
007219 6e61
00721a 0064          .db "and",0
00721b 7211          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00721c 721d          .dw PFA_AND
                 PFA_AND:
00721d 9109          ld temp0, Y+
00721e 9119          ld temp1, Y+
00721f 2380          and tosl, temp0
007220 2391          and tosh, temp1
007221 cde2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
007222 ff02          .dw $ff02
007223 726f          .db "or"
007224 7218          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
007225 7226          .dw PFA_OR
                 PFA_OR:
007226 9109          ld temp0, Y+
007227 9119          ld temp1, Y+
007228 2b80          or tosl, temp0
007229 2b91          or tosh, temp1
00722a cdd9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00722b ff03          .dw $ff03
00722c 6f78
00722d 0072          .db "xor",0
00722e 7222          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00722f 7230          .dw PFA_XOR
                 PFA_XOR:
007230 9109          ld temp0, Y+
007231 9119          ld temp1, Y+
007232 2780          eor tosl, temp0
007233 2791          eor tosh, temp1
007234 cdcf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
007235 ff02          .dw $ff02
007236 2b31          .db "1+"
007237 722b          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
007238 7239          .dw PFA_1PLUS
                 PFA_1PLUS:
007239 9601          adiw tosl,1
00723a cdc9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00723b ff02          .dw $ff02 
00723c 2d31          .db "1-"
00723d 7235          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00723e 723f          .dw PFA_1MINUS
                 PFA_1MINUS:
00723f 9701          sbiw tosl, 1
007240 cdc3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
007241 ff06          .dw $ff06
007242 736c
007243 6968
007244 7466          .db "lshift"
007245 723b          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
007246 7247          .dw PFA_LSHIFT
                 PFA_LSHIFT:
007247 01fc          movw zl, tosl
007248 9189
007249 9199          loadtos
                 PFA_LSHIFT1:
00724a 9731          sbiw zl, 1
00724b f01a          brmi PFA_LSHIFT2
00724c 0f88          lsl tosl
00724d 1f99          rol tosh
00724e cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00724f cdb4          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
007250 ff06          .dw $ff06
007251 7372
007252 6968
007253 7466          .db "rshift"
007254 7241          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
007255 7256          .dw PFA_RSHIFT
                 PFA_RSHIFT:
007256 01fc          movw zl, tosl
007257 9189
007258 9199          loadtos
                 PFA_RSHIFT1:
007259 9731          sbiw zl, 1
00725a f01a          brmi PFA_RSHIFT2
00725b 9596          lsr tosh
00725c 9587          ror tosl
00725d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00725e cda5          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00725f ff02          .dw $ff02
007260 212b          .db "+!"
007261 7250          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
007262 7263          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
007263 01fc          movw zl, tosl
007264 9189
007265 9199          loadtos
007266 8120          ldd temp2, Z+0
007267 8131          ldd temp3, Z+1
007268 0f82          add tosl, temp2
007269 1f93          adc tosh, temp3
00726a 8380          std Z+0, tosl
00726b 8391          std Z+1, tosh
00726c 9189
00726d 9199          loadtos
00726e cd95          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00726f ff03          .dw $ff03
007270 7072
007271 0040          .db "rp@",0
007272 725f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
007273 7274          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
007274 939a
007275 938a          savetos
007276 b78d          in tosl, SPL
007277 b79e          in tosh, SPH
007278 cd8b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
007279 ff03          .dw $ff03
00727a 7072
00727b 0021          .db "rp!",0
00727c 726f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00727d 727e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00727e b72f          in temp2, SREG
00727f 94f8          cli
007280 bf8d          out SPL, tosl
007281 bf9e          out SPH, tosh
007282 bf2f          out SREG, temp2
007283 9189
007284 9199          loadtos
007285 cd7e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
007286 ff03          .dw $ff03
007287 7073
007288 0040          .db "sp@",0
007289 7279          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00728a 728b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00728b 939a
00728c 938a          savetos
00728d 01ce          movw tosl, yl
00728e cd75          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00728f ff03          .dw $ff03
007290 7073
007291 0021          .db "sp!",0
007292 7286          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
007293 7294          .dw PFA_SP_STORE
                 PFA_SP_STORE:
007294 01ec          movw yl, tosl
007295 9189
007296 9199          loadtos
007297 cd6c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
007298 7299          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
007299 01fd          movw zl, xl
00729a 0fee
00729b 1fff
00729c 9105
00729d 9115          readflashcell temp0,temp1
00729e 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00729f 9129          ld temp2, Y+
0072a0 9139          ld temp3, Y+
                 PFA_DODO1:
0072a1 931f          push temp1
0072a2 930f          push temp0
0072a3 933f          push temp3
0072a4 932f          push temp2
0072a5 939f          push tosh
0072a6 938f          push tosl
0072a7 9189
0072a8 9199          loadtos
0072a9 cd5a          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
0072aa 72ab          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
0072ab 01fd          movw zl, xl
0072ac 0fee
0072ad 1fff
0072ae 9105
0072af 9115          readflashcell temp0,temp1
0072b0 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
0072b1 9129          ld temp2, Y+
0072b2 9139          ld temp3, Y+
                     ; now check for equality
0072b3 1782          cp tosl, temp2
0072b4 0793          cpc tosh, temp3
0072b5 f759          brne PFA_DODO1
                     ; both values are the same -> skip loop
0072b6 01d8          movw xl, temp0
0072b7 9189
0072b8 9199          loadtos
0072b9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
0072ba ff01          .dw $FF01
0072bb 0069          .db "i",0
0072bc 728f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
0072bd 70fd          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
0072be 72bf          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
0072bf 91ef          pop zl
0072c0 91ff          pop zh
0072c1 0fe8          add zl, tosl
0072c2 1ff9          adc zh, tosh
0072c3 2f19          mov temp1, tosh
0072c4 9189
0072c5 9199          loadtos
                 PFA_DOPLUSLOOP4: 
0072c6 912f          pop temp2
0072c7 913f          pop temp3
0072c8 17e2          cp zl, temp2
0072c9 07f3          cpc zh, temp3
0072ca ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
0072cb c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
0072cc f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
0072cd c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
0072ce f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
0072cf 933f          push temp3
0072d0 932f          push temp2
0072d1 93ff          push zh
0072d2 93ef          push zl
0072d3 cd56          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
0072d4 910f          pop  temp0
0072d5 911f          pop  temp1  ; remove leave destination
0072d6 9611          adiw xl, 1 ; skip branch-back address
0072d7 cd2c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
0072d8 72d9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
0072d9 91ef          pop zl
0072da 91ff          pop zh
0072db 9631          adiw zl,1
0072dc 912f          pop temp2
0072dd 913f          pop temp3
0072de 17e2          cp zl, temp2
0072df 07f3          cpc zh, temp3
0072e0 f399          breq PFA_DOPLUSLOOP1
0072e1 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
0072e2 ff06          .dw $ff06
0072e3 6e75
0072e4 6f6c
0072e5 706f          .db "unloop"
0072e6 72ba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
0072e7 72e8          .dw PFA_UNLOOP
                 PFA_UNLOOP:
0072e8 911f          pop temp1
0072e9 910f          pop temp0
0072ea 911f          pop temp1
0072eb 910f          pop temp0
0072ec 911f          pop temp1
0072ed 910f          pop temp0
0072ee cd15          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
0072ef ff06          .dw $ff06
0072f0 6d63
0072f1 766f
0072f2 3e65          .db "cmove>"
0072f3 72e2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
0072f4 72f5          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
0072f5 93bf          push xh
0072f6 93af          push xl
0072f7 91e9          ld zl, Y+
0072f8 91f9          ld zh, Y+ ; addr-to
0072f9 91a9          ld xl, Y+
0072fa 91b9          ld xh, Y+ ; addr-from
0072fb 2f09          mov temp0, tosh
0072fc 2b08          or temp0, tosl
0072fd f041          brbs 1, PFA_CMOVE_G1
0072fe 0fe8          add zl, tosl
0072ff 1ff9          adc zh, tosh
007300 0fa8          add xl, tosl
007301 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
007302 911e          ld temp1, -X
007303 9312          st -Z, temp1
007304 9701          sbiw tosl, 1
007305 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
007306 91af          pop xl
007307 91bf          pop xh
007308 9189
007309 9199          loadtos
00730a ccf9          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00730b ff02          .dw $ff02
00730c 3c3e          .db "><"
00730d 72ef          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00730e 730f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00730f 2f09          mov temp0, tosh
007310 2f98          mov tosh, tosl
007311 2f80          mov tosl, temp0
007312 ccf1          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
007313 ff03          .dw $ff03
007314 7075
007315 0040          .db "up@",0
007316 730b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
007317 7318          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
007318 939a
007319 938a          savetos
00731a 01c2          movw tosl, upl
00731b cce8          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00731c ff03          .dw $ff03
00731d 7075
00731e 0021          .db "up!",0
00731f 7313          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
007320 7321          .dw PFA_UP_STORE
                 PFA_UP_STORE:
007321 012c          movw upl, tosl
007322 9189
007323 9199          loadtos
007324 ccdf          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
007325 ff03          .dw $ff03
007326 3e73
007327 0064          .db "s>d",0
007328 731c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
007329 7000          .dw DO_COLON
                 PFA_S2D:
00732a 70ac          .dw XT_DUP
00732b 712d          .dw XT_LESSZERO
                 .include "words/not.asm"
00732c 701a      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
00732d ff03          .dw $ff03
00732e 6f6e
00732f 0074          .db "not",0
007330 7325          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
007331 7000          .dw DO_COLON
                 PFA_NOT:
007332 7118          .dw XT_EQUALZERO
007333 701a          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
007334 ff02          .dw $ff02
007335 6521          .db "!e"
007336 732d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
007337 7338          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
007338 01fc          movw zl, tosl
007339 9189
00733a 9199          loadtos
00733b b72f          in_ temp2, SREG
00733c 94f8          cli
00733d d028          rcall PFA_FETCHE2
00733e b500          in_  temp0, EEDR
00733f 1708          cp temp0,tosl
007340 f009          breq PFA_STOREE3
007341 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
007342 9631          adiw zl,1
007343 d022          rcall PFA_FETCHE2
007344 b500          in_  temp0, EEDR
007345 1709          cp temp0,tosh
007346 f011          breq PFA_STOREE4
007347 2f89          mov tosl, tosh
007348 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
007349 bf2f          out_ SREG, temp2
00734a 9189
00734b 9199          loadtos
00734c ccb7          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00734d 99f9          sbic EECR, EEPE
00734e cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00734f b707          in_ temp0, SPMCSR
007350 fd00          sbrc temp0,SPMEN
007351 cffd          rjmp PFA_STOREE2
                 
007352 bdf2          out_ EEARH,zh
007353 bde1          out_ EEARL,zl
007354 bd80          out_ EEDR, tosl
007355 9afa          sbi EECR,EEMPE
007356 9af9          sbi EECR,EEPE
                 
007357 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
007358 ff02          .dw $ff02
007359 6540          .db "@e"
00735a 7334          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00735b 735c          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00735c b72f          in_ temp2, SREG
00735d 94f8          cli
00735e 01fc          movw zl, tosl
00735f d006          rcall PFA_FETCHE2
007360 b580          in_ tosl, EEDR
                 
007361 9631          adiw zl,1
                 
007362 d003          rcall PFA_FETCHE2
007363 b590          in_  tosh, EEDR
007364 bf2f          out_ SREG, temp2
007365 cc9e          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
007366 99f9          sbic EECR, EEPE
007367 cffe          rjmp PFA_FETCHE2
                 
007368 bdf2          out_ EEARH,zh
007369 bde1          out_ EEARL,zl
                 
00736a 9af8          sbi EECR,EERE
00736b 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00736c ff02          .dw $ff02
00736d 6940          .db "@i"
00736e 7358          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00736f 7370          .dw PFA_FETCHI
                 PFA_FETCHI:
007370 01fc          movw zl, tosl
007371 0fee
007372 1fff
007373 9185
007374 9195          readflashcell tosl,tosh
007375 cc8e          jmp_ DO_NEXT
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
007376 ff02          .dw $ff02
007377 6921          .db "!i"
007378 736c          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
007379 07d2          .dw PFA_DODEFER
                 PFA_STOREI:
00737a 000a          .dw EE_STOREI
00737b 0796          .dw XT_EDEFERFETCH
00737c 079b          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00737d ff09          .dw $ff09
00737e 2128
00737f 2d69
007380 726e
007381 7777
007382 0029          .db "(!i-nrww)",0
007383 7376          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
007384 7385          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
007385 b71f        in temp1,SREG
007386 931f        push temp1
007387 94f8        cli
                 
007388 019c        movw temp2, tosl ; save the (word) address
007389 9189
00738a 9199        loadtos          ; get the new value for the flash cell
00738b 93af        push xl
00738c 93bf        push xh
00738d 93cf        push yl
00738e 93df        push yh
00738f d009        rcall DO_STOREI_atmega
007390 91df        pop yh
007391 91cf        pop yl
007392 91bf        pop xh
007393 91af        pop xl
                   ; finally clear the stack
007394 9189
007395 9199        loadtos
007396 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
007397 bf1f        out SREG,temp1
                 
007398 cc6b        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
007399 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00739a 94e0        com temp4
00739b 94f0        com temp5
00739c 218e        and tosl, temp4
00739d 219f        and tosh, temp5
00739e 2b98        or tosh, tosl
00739f f019        breq DO_STOREI_writepage 
                 
0073a0 01f9          movw zl, temp2
0073a1 e002          ldi temp0,(1<<PGERS)
0073a2 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
0073a3 01f9        movw zl, temp2
0073a4 e004        ldi temp0,(1<<PGWRT)
0073a5 d01d        rcall dospm
                 
                   ; reenable RWW section
0073a6 01f9        movw zl, temp2
0073a7 e100        ldi temp0,(1<<RWWSRE)
0073a8 d01a        rcall dospm
0073a9 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
0073aa 01f9        movw zl, temp2
                   ; get the beginning of page
0073ab 78e0        andi zl,low(pagemask)
0073ac 7fff        andi zh,high(pagemask)
0073ad 01ef        movw y, z
                   ; loop counter (in words)
0073ae e8a0        ldi xl,low(pagesize)
0073af e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
0073b0 01fe        movw z, y
0073b1 0fee
0073b2 1fff
0073b3 9145
0073b4 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
0073b5 01fe        movw z, y
0073b6 17e2        cp zl, temp2
0073b7 07f3        cpc zh, temp3
0073b8 f011        breq pageload_newdata
0073b9 010a          movw r0, temp6
0073ba c002          rjmp pageload_cont
                 pageload_newdata:
0073bb 017a          movw temp4, temp6
0073bc 010c          movw r0, tosl
                 pageload_cont:
0073bd 2700        clr temp0
0073be d004        rcall dospm
0073bf 9621        adiw y, 1
0073c0 9711        sbiw x, 1
0073c1 f771        brne pageload_loop
                 
                 pageload_done:
0073c2 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
0073c3 99f9        sbic EECR, EEPE
0073c4 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
0073c5 b717        in_  temp1, SPMCSR
0073c6 fd10        sbrc temp1, SPMEN
0073c7 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
0073c8 0fee
0073c9 1fff        writeflashcell
                   ; execute spm
0073ca 6001        ori temp0, (1<<SPMEN)
0073cb bf07        out_ SPMCSR,temp0
0073cc 95e8        spm
0073cd 9508        ret
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
0073ce ff03          .dw $ff03
0073cf 3e6e
0073d0 0072          .db "n>r",0
0073d1 737d          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
0073d2 73d3          .dw PFA_N_TO_R
                 PFA_N_TO_R:
0073d3 01fc          movw zl, tosl
0073d4 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
0073d5 9189
0073d6 9199          loadtos
0073d7 939f          push tosh
0073d8 938f          push tosl
0073d9 950a          dec temp0
0073da f7d1          brne PFA_N_TO_R1
0073db 93ef          push zl
0073dc 93ff          push zh
0073dd 9189
0073de 9199          loadtos
0073df cc24          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
0073e0 ff03          .dw $ff03
0073e1 726e
0073e2 003e          .db "nr>",0
0073e3 73ce          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
0073e4 73e5          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
0073e5 939a
0073e6 938a          savetos
0073e7 91ff          pop zh
0073e8 91ef          pop zl
0073e9 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
0073ea 918f          pop tosl
0073eb 919f          pop tosh
0073ec 939a
0073ed 938a          savetos
0073ee 950a          dec temp0
0073ef f7d1          brne PFA_N_R_FROM1
0073f0 01cf          movw tosl, zl
0073f1 cc12          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 e4 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 e5 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 85 0d         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 84 73         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 64 0b         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 e0 73         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 1e 07         .dw XT_REC_FIND
00002a 01 07         .dw XT_REC_INTNUMBER
00002c 3a 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 a1 0b         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 10         .dw rstackstart  ; USER_RP
00003e af 10         .dw stackstart   ; USER_SP0
000040 af 10         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 90 00         .dw XT_TX  ; USER_EMIT
000048 9e 00         .dw XT_TXQ ; USER_EMITQ
00004a 66 00         .dw XT_RX  ; USER_KEY
00004c 80 00         .dw XT_RXQ ; USER_KEYQ
00004e eb 08         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 d7 08         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 67 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 24
000058 f4 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega644" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  80 r17:  57 r18:  58 r19:  42 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 173 r25: 123 r26:  45 r27:  22 r28:   6 r29:   4 r30:  71 r31:  35 
x  :   4 y  : 189 z  :  42 
Registers used: 29 out of 35 (82.9%)

"ATmega644" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :  11 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  11 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   2 jmp   :  22 
ld    : 131 ldd   :   4 ldi   :  22 lds   :   2 lpm   :  20 lsl   :  16 
lsr   :   1 mov   :  12 movw  :  66 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  52 
push  :  38 rcall :  40 ret   :   6 reti  :   2 rjmp  :  89 rol   :  25 
ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  62 std   :   8 sts   :   3 
sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega644" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00e7e4   1864   9240  11104   65536  16.9%
[.dseg] 0x000100 0x0001e5      0    229    229    4096   5.6%
[.eseg] 0x000000 0x00005a      0     90     90    2048   4.4%

Assembly complete, 0 errors, 2 warnings
