
AVRASM ver. 2.1.51  bf.asm Mon Dec 23 20:35:22 2013

bf.asm(2): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
bf.asm(3): Including file '../../core/devices/atmega169\device.asm'
../../core/devices/atmega169\device.asm(6): Including file '../../Atmel/Appnotes2\m169def.inc'
bf.asm(12): Including file '../../core\drivers/usart.asm'
../../core\drivers/usart.asm(30): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
bf.asm(20): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(1): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(2): Including file '../../core/devices/atmega169\device.inc'
dict_appl.inc(3): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(4): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(5): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../core\words/udot.asm'
dict_appl.inc(8): Including file '../../core\words/dot-s.asm'
dict_appl.inc(10): Including file '../../core\words/dotstring.asm'
dict_appl.inc(11): Including file '../../core\words/squote.asm'
dict_appl.inc(12): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(13): Including file '../../core\words/words.asm'
dict_appl.inc(15): Including file '../../core\words/edefer.asm'
dict_appl.inc(16): Including file '../../core\words/rdefer.asm'
dict_appl.inc(17): Including file '../../core\words/is.asm'
dict_appl.inc(19): Including file '../../core\words/d-invert.asm'
dict_appl.inc(20): Including file '../../core\words/d-plus.asm'
dict_appl.inc(21): Including file '../../core\words/d-minus.asm'
dict_appl.inc(22): Including file '../../core\words/spirw.asm'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(7): Including file '../../core\words/fetch-i.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; Built using part description XML file version 300
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  $100
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 
                 ; the following definitions are shortcuts for the respective forth source segments if set to 1
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_JTAG = 0
                 .set WANT_LCD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_SPI = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_USART0 = 0
                 .set WANT_USI = 0
                 .set WANT_WATCHDOG = 0
                 
                 
                 .ifndef SPMEN
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef EEPE
                  .equ EEPE = EEWE
                 .endif
                 
                 .ifndef EEMPE
                  .equ EEMPE = EEMWE
                 .endif
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .equ INTVECTORS = 23
                 .org $002
000002 d0be      	 rcall isr ; External Interrupt Request 0
                 .org $004
000004 d0bc      	 rcall isr ; Pin Change Interrupt Request 0
                 .org $006
000006 d0ba      	 rcall isr ; Pin Change Interrupt Request 1
                 .org $008
000008 d0b8      	 rcall isr ; Timer/Counter2 Compare Match
                 .org $00A
00000a d0b6      	 rcall isr ; Timer/Counter2 Overflow
                 .org $00C
00000c d0b4      	 rcall isr ; Timer/Counter1 Capture Event
                 .org $00E
00000e d0b2      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org $010
000010 d0b0      	 rcall isr ; Timer/Counter Compare Match B
                 .org $012
000012 d0ae      	 rcall isr ; Timer/Counter1 Overflow
                 .org $014
000014 d0ac      	 rcall isr ; Timer/Counter0 Compare Match
                 .org $016
000016 d0aa      	 rcall isr ; Timer/Counter0 Overflow
                 .org $018
000018 d0a8      	 rcall isr ; SPI Serial Transfer Complete
                 .org $01A
00001a d0a6      	 rcall isr ; USART0, Rx Complete
                 .org $01C
00001c d0a4      	 rcall isr ; USART0 Data register Empty
                 .org $01E
00001e d0a2      	 rcall isr ; USART0, Tx Complete
                 .org $020
000020 d0a0      	 rcall isr ; USI Start Condition
                 .org $022
000022 d09e      	 rcall isr ; USI Overflow
                 .org $024
000024 d09c      	 rcall isr ; Analog Comparator
                 .org $026
000026 d09a      	 rcall isr ; ADC Conversion Complete
                 .org $028
000028 d098      	 rcall isr ; EEPROM Ready
                 .org $02A
00002a d096      	 rcall isr ; Store Program Memory Read
                 .org $02C
00002c d094      	 rcall isr ; LCD Start of Frame
                 .nooverlap
                 mcu_info:
                 mcu_ramsize:
00002d 0400      	.dw 1024
                 mcu_eepromsize:
00002e 0200      	.dw 512
                 mcu_maxdp:
00002f 1c00      	.dw 7168 ; minimum of 0x1C00 (from XML) and 0xffff
                 mcu_numints:
000030 0017      	.dw 23
                 mcu_name:
000031 0009      	.dw  9
000032 5441
000033 656d
000034 6167
000035 3631
000036 0039      	.db "ATmega169",0
                 .set codestart=pc
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64    ; 80 characters is one line...
                 .equ APPUSERSIZE = 10  ; size of user area
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 8000000
                 ; baud rate of terminal
                 .equ BAUD = 9600
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
00001a 940c 0037   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000037 93af        push xl
000038 b7af        in xl, SREG
000039 93af        push xl
00003a 93bf        push xh
00003b 93ef        push zl
00003c 93ff        push zh
                 
00003d 91b0 00e6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
00003f 91a0 0100   lds xl,usart_rx_in
000041 e0e2        ldi zl, low(usart_rx_data)
000042 e0f1        ldi zh, high(usart_rx_data)
000043 0fea        add zl, xl
000044 1df3        adc zh, zeroh
000045 83b0        st Z, xh
                 
000046 95a3        inc xl
000047 70af        andi xl,usart_rx_mask
                 
000048 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00004a 91ff        pop zh
00004b 91ef        pop zl
00004c 91bf        pop xh
00004d 91af        pop xl
00004e bfaf        out SREG, xl
00004f 91af        pop xl
000050 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000051 1c00        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000052 1d34        .dw XT_ZERO
000053 1c37        .dw XT_DOLITERAL
000054 0100        .dw usart_rx_in
000055 1c7c        .dw XT_STORE
                 
000056 1c1a        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000057 ff06          .dw $ff06
000058 7872
000059 692d
00005a 7273          .db "rx-isr"
00005b 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
00005c 1c00          .dw DO_COLON
                 PFA_RX_ISR:
00005d 0076        .dw XT_RXQ_ISR
00005e 1c30        .dw XT_DOCONDBRANCH
00005f 005d        .dw PFA_RX_ISR
000060 1c37        .dw XT_DOLITERAL
000061 0101        .dw usart_rx_out
000062 1c93        .dw XT_CFETCH
000063 1cac        .dw XT_DUP
000064 1e38        .dw XT_1PLUS
000065 1c37        .dw XT_DOLITERAL
000066 000f        .dw usart_rx_mask
000067 1e1c        .dw XT_AND
000068 1c37        .dw XT_DOLITERAL
000069 0101        .dw usart_rx_out
00006a 1c88        .dw XT_CSTORE
00006b 1c37        .dw XT_DOLITERAL
00006c 0102        .dw usart_rx_data
00006d 1da6        .dw XT_PLUS
00006e 1c93        .dw XT_CFETCH
00006f 1c1a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000070 ff07          .dw $ff07
000071 7872
000072 2d3f
000073 7369
000074 0072          .db "rx?-isr",0
000075 0057          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000076 1c00          .dw DO_COLON
                 PFA_RXQ_ISR:
000077 066b        .dw XT_PAUSE
000078 1c37        .dw XT_DOLITERAL
000079 0101        .dw usart_rx_out
00007a 1c93        .dw XT_CFETCH
00007b 1c37        .dw XT_DOLITERAL
00007c 0100        .dw usart_rx_in
00007d 1c93        .dw XT_CFETCH
00007e 1d07        .dw XT_NOTEQUAL
00007f 1c1a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000080 ff07          .dw $ff07
000081 7874
000082 702d
000083 6c6f
000084 006c          .db "tx-poll",0
000085 0070          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000086 1c00          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000087 0094        .dw XT_TXQ_POLL
000088 1c30        .dw XT_DOCONDBRANCH
000089 0087        .dw PFA_TX_POLL
                   ; send to usart
00008a 1c37        .dw XT_DOLITERAL
00008b 00e6        .dw USART_DATA
00008c 1c88        .dw XT_CSTORE
00008d 1c1a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00008e ff08          .dw $ff08
00008f 7874
000090 2d3f
000091 6f70
000092 6c6c          .db "tx?-poll"
000093 0080          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
000094 1c00          .dw DO_COLON
                 PFA_TXQ_POLL:
000095 066b        .dw XT_PAUSE
000096 1c37        .dw XT_DOLITERAL
000097 00e0        .dw USART_A
000098 1c93        .dw XT_CFETCH
000099 1c37        .dw XT_DOLITERAL
00009a 0020        .dw bm_USART_TXRD
00009b 1e1c        .dw XT_AND
00009c 1c1a        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
00009d ff04        .dw $ff04
00009e 6275
00009f 7272        .db "ubrr"
0000a0 008e        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000a1 1c69        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000a2 0054        .dw EE_UBRRVAL
0000a3 0ab2        .dw XT_EVALUEFETCH
0000a4 0ab6        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000a5 ff06        .dw $ff06
0000a6 752b
0000a7 6173
0000a8 7472        .db "+usart"
0000a9 009d        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000aa 1c00        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000ab 1c37        .dw XT_DOLITERAL
0000ac 0098        .dw USART_B_VALUE
0000ad 1c37        .dw XT_DOLITERAL
0000ae 00e1        .dw USART_B
0000af 1c88        .dw XT_CSTORE
                 
0000b0 1c37        .dw XT_DOLITERAL
0000b1 0006        .dw USART_C_VALUE
0000b2 1c37        .dw XT_DOLITERAL
0000b3 00e2        .dw USART_C | bm_USARTC_en
0000b4 1c88        .dw XT_CSTORE
                 
0000b5 00a1        .dw XT_UBRR
0000b6 1cac        .dw XT_DUP
0000b7 1f0e        .dw XT_BYTESWAP
0000b8 1c37        .dw XT_DOLITERAL
0000b9 00e5        .dw BAUDRATE_HIGH
0000ba 1c88        .dw XT_CSTORE
0000bb 1c37        .dw XT_DOLITERAL
0000bc 00e4        .dw BAUDRATE_LOW
0000bd 1c88        .dw XT_CSTORE
                 
0000be 0051        .dw XT_USART_INIT_RX
0000bf 0765        .dw XT_USART_INIT_TX
0000c0 1c1a        .dw XT_EXIT
                 
                 .set NUMWORDLISTS=8
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 .set WANT_SPI = 1
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 0674   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000c1 920a          st -Y, r0
0000c2 b60f          in r0, SREG
0000c3 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000c4 900f          pop r0
0000c5 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000c6 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000c7 9200 0114     sts intcur, r0
0000c9 9009          ld r0, Y+
0000ca be0f          out SREG, r0
0000cb 9009          ld r0, Y+
0000cc 9468          set ; set the interrupt flag for the inner interpreter
0000cd 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
0000ce ff05          .dw $ff05
0000cf 5f66
0000d0 7063
0000d1 0075          .db "f_cpu",0
0000d2 00a5          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0000d3 1c69          .dw PFA_DOVALUE1
                 PFA_F_CPU:
0000d4 0056          .dw EE_FCPU
0000d5 00d7          .dw XT_FETCH2E
0000d6 00e0          .dw XT_STORE2E
                 
                 XT_FETCH2E:
0000d7 1c00          .dw DO_COLON
                 PFA_FETCH2E:
0000d8 1fc7          .dw XT_FETCHI
0000d9 1cac          .dw XT_DUP
0000da 00fe          .dw XT_CELLPLUS
0000db 1f5b          .dw XT_FETCHE
0000dc 1cbf          .dw XT_SWAP
0000dd 1f5b          .dw XT_FETCHE
0000de 1cbf          .dw XT_SWAP
0000df 1c1a          .dw XT_EXIT
                 
                 XT_STORE2E:
0000e0 1c00          .dw DO_COLON
                 PFA_STORE2E:
0000e1 1c37          .dw XT_DOLITERAL
0000e2 ffeb          .dw -21
0000e3 0455          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0000e4 ff05          .dw $ff05
0000e5 7473
0000e6 7461
0000e7 0065          .db "state",0
0000e8 00ce          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0000e9 1c42          .dw PFA_DOVARIABLE
                 PFA_STATE:
0000ea 0143          .dw ram_state
                 
                 .dseg
000143           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
0000eb ff04          .dw $ff04
0000ec 6162
0000ed 6573          .db "base"
0000ee 00e4          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0000ef 1c52          .dw PFA_DOUSER
                 PFA_BASE:
0000f0 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0000f1 ff05          .dw $ff05
0000f2 6563
0000f3 6c6c
0000f4 0073          .db "cells",0
0000f5 00eb          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0000f6 1c00          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
0000f7 1e14          .dw XT_2STAR
                 .else
                 .endif
0000f8 1c1a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0000f9 ff05          .dw $ff05
0000fa 6563
0000fb 6c6c
0000fc 002b          .db "cell+",0
0000fd 00f1          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0000fe 00ff          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0000ff 9602          adiw tosl, CELLSIZE
000100 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
000102 ff04          .dw $ff04
000103 6432
000104 7075          .db "2dup"
000105 00f9          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000106 1c00          .dw DO_COLON
                 PFA_2DUP:
000107 1cca          .dw XT_OVER
000108 1cca          .dw XT_OVER
000109 1c1a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
00010a ff05          .dw $ff05
00010b 6432
00010c 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
00010d 0070          .db "2drop"
00010e 0102          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00010f 1c00          .dw DO_COLON
                 PFA_2DROP:
000110 1cd4          .dw XT_DROP
000111 1cd4          .dw XT_DROP
000112 1c1a          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
000113 ff03          .dw $ff03
000114 693e
000115 006e          .db ">in",0
000116 010a          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000117 1c52          .dw PFA_DOUSER
                 PFA_G_IN:
000118 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
000119 ff04          .dw $ff04
00011a 7423
00011b 6269          .db "#tib"
00011c 0113          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00011d 1c42          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00011e 0145          .dw ram_sharptib
                 
                 .dseg
000145           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
00011f ff03          .dw $ff03
000120 6170
000121 0064          .db "pad",0
000122 0119          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
000123 1c00          .dw DO_COLON
                 PFA_PAD:
000124 015d          .dw XT_HERE
000125 1c37          .dw XT_DOLITERAL
000126 0064          .dw 100
000127 1da6          .dw XT_PLUS
000128 1c1a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
000129 ff04          .dw $ff04
00012a 6d65
00012b 7469          .db "emit"
00012c 011f          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00012d 07c8          .dw PFA_DODEFER
                 PFA_EMIT:
00012e 000e          .dw USER_EMIT
00012f 07a0          .dw XT_UDEFERFETCH
000130 07a7          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
000131 ff05          .dw $ff05
000132 6d65
000133 7469
000134 003f          .db "emit?",0
000135 0129          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000136 07c8          .dw PFA_DODEFER
                 PFA_EMITQ:
000137 0010          .dw USER_EMITQ
000138 07a0          .dw XT_UDEFERFETCH
000139 07a7          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
00013a ff03          .dw $ff03
00013b 656b
00013c 0079          .db "key",0
00013d 0131          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00013e 07c8          .dw PFA_DODEFER
                 PFA_KEY:
00013f 0012          .dw USER_KEY
000140 07a0          .dw XT_UDEFERFETCH
000141 07a7          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
000142 ff04          .dw $ff04
000143 656b
000144 3f79          .db "key?"
000145 013a          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000146 07c8          .dw PFA_DODEFER
                 PFA_KEYQ:
000147 0014          .dw USER_KEYQ
000148 07a0          .dw XT_UDEFERFETCH
000149 07a7          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00014a ff02          .dw $ff02
00014b 7064          .db "dp"
00014c 0142          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00014d 1c69          .dw PFA_DOVALUE1
                 PFA_DP:
00014e 0002          .dw EE_DP
00014f 0ab2          .dw XT_EVALUEFETCH
000150 0ab6          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
000151 ff03          .dw $ff03
000152 6465
000153 0070          .db "edp",0
000154 014a          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
000155 1c69          .dw PFA_DOVALUE1
                 PFA_EDP:
000156 0006          .dw EE_EDP
000157 0ab2          .dw XT_EVALUEFETCH
000158 0ab6          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000159 ff04          .dw $ff04
00015a 6568
00015b 6572          .db "here"
00015c 0151          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00015d 1c69          .dw PFA_DOVALUE1
                 PFA_HERE:
00015e 0004          .dw EE_HERE
00015f 0ab2          .dw XT_EVALUEFETCH
000160 0ab6          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000161 ff05          .dw $ff05
000162 6c61
000163 6f6c
000164 0074          .db "allot",0
000165 0159          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000166 1c00          .dw DO_COLON
                 PFA_ALLOT:
000167 015d          .dw XT_HERE
000168 1da6          .dw XT_PLUS
000169 0780          .dw XT_DOTO
00016a 015e          .dw PFA_HERE
00016b 1c1a          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
00016c ff08          .dw $ff08
00016d 6328
00016e 6572
00016f 7461
000170 2965          .db "(create)"
000171 0161          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000172 1c00          .dw DO_COLON
                 PFA_DOCREATE:
000173 05e5          .dw XT_PARSENAME
000174 0a01          .dw XT_WLSCOPE
000175 1cac          .dw XT_DUP
000176 1cf3          .dw XT_TO_R
000177 09e6          .dw XT_HEADER
000178 1cea          .dw XT_R_FROM
                 .dseg
000147           COLON_SMUDGE: .byte 4
                 .cseg
000179 1c37          .dw XT_DOLITERAL
00017a 0149          .dw COLON_SMUDGE+2
00017b 1c7c          .dw XT_STORE		; save wid
00017c 1c37          .dw XT_DOLITERAL
00017d 0147          .dw COLON_SMUDGE+0
00017e 1c7c          .dw XT_STORE		; save NFA
                 
00017f 1c1a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
000180 0001          .dw $0001
000181 005c          .db "\",0
000182 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000183 1c00          .dw DO_COLON
                 PFA_BACKSLASH:
000184 05ca          .dw XT_SOURCE
000185 1cbf          .dw XT_SWAP
000186 1cd4          .dw XT_DROP
000187 0117          .dw XT_G_IN
000188 1c7c          .dw XT_STORE
000189 1c1a          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
00018a 0001          .dw $0001
00018b 0028          .db "(" ,0
00018c 0180          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
00018d 1c00          .dw DO_COLON
                 PFA_LPARENTHESIS:
00018e 1c37          .dw XT_DOLITERAL
00018f 0029          .dw $29
000190 0596          .dw XT_PARSE
000191 010f          .dw XT_2DROP
000192 1c1a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
000193 ff07          .dw $ff07
000194 6f63
000195 706d
000196 6c69
000197 0065          .db "compile",0
000198 018a          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000199 1c00          .dw DO_COLON
                 PFA_COMPILE:
00019a 1cea          .dw XT_R_FROM
00019b 1cac          .dw XT_DUP
00019c 1e38          .dw XT_1PLUS
00019d 1cf3          .dw XT_TO_R
00019e 1fc7          .dw XT_FETCHI
00019f 01a4          .dw XT_COMMA
0001a0 1c1a          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001a1 ff01          .dw $ff01
0001a2 002c          .db ',',0 ; ,
0001a3 0193          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001a4 1c00          .dw DO_COLON
                 PFA_COMMA:
0001a5 014d          .dw XT_DP
0001a6 1f6f          .dw XT_STOREI
0001a7 014d          .dw XT_DP
0001a8 1e38          .dw XT_1PLUS
0001a9 0780          .dw XT_DOTO
0001aa 014e          .dw PFA_DP
0001ab 1c1a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0001ac 0003          .dw $0003
0001ad 275b
0001ae 005d          .db "[']",0
0001af 01a1          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001b0 1c00          .dw DO_COLON
                 PFA_BRACKETTICK:
0001b1 0199          .dw XT_COMPILE
0001b2 1c37          .dw XT_DOLITERAL
0001b3 0428          .dw XT_TICK
0001b4 01a4          .dw XT_COMMA
0001b5 1c1a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
0001b6 ff03          .dw $ff03
0001b7 6962
0001b8 006e          .db "bin",0
0001b9 01ac          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0001ba 1c00          .dw DO_COLON
                 PFA_BIN:
0001bb 1c37          .dw XT_DOLITERAL
0001bc 0002          .dw 2
0001bd 00ef          .dw XT_BASE
0001be 1c7c          .dw XT_STORE
0001bf 1c1a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
0001c0 ff07          .dw $ff07
0001c1 6564
0001c2 6963
0001c3 616d
0001c4 006c          .db "decimal",0
0001c5 01b6          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0001c6 1c00          .dw DO_COLON
                 PFA_DECIMAL:
0001c7 1c37          .dw XT_DOLITERAL
0001c8 000a          .dw 10
0001c9 00ef          .dw XT_BASE
0001ca 1c7c          .dw XT_STORE
0001cb 1c1a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
0001cc ff03          .dw $ff03
0001cd 6568
0001ce 0078          .db "hex",0
0001cf 01c0          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0001d0 1c00          .dw DO_COLON
                 PFA_HEX:
0001d1 1c37          .dw XT_DOLITERAL
0001d2 0010          .dw 16
0001d3 00ef          .dw XT_BASE
0001d4 1c7c          .dw XT_STORE
0001d5 1c1a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
0001d6 ff02          .dw $ff02
0001d7 6c62          .db "bl"
0001d8 01cc          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0001d9 1c42          .dw PFA_DOVARIABLE
                 PFA_BL:
0001da 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0001db ff07          .dw $ff07
0001dc 7574
0001dd 6e72
0001de 656b
0001df 0079          .db "turnkey",0
0001e0 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0001e1 07c8          .dw PFA_DODEFER
                 PFA_TURNKEY:
0001e2 0008          .dw EE_TURNKEY
0001e3 078c          .dw XT_EDEFERFETCH
0001e4 0791          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
0001e5 ff05          .dw $ff05
0001e6 2f2a
0001e7 6f6d
0001e8 0064          .db "*/mod",0
0001e9 01db          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
0001ea 1c00          .dw DO_COLON
                 PFA_STARSLASHMOD:
0001eb 1cf3          .dw XT_TO_R
0001ec 1daf          .dw XT_MSTAR
0001ed 1cea          .dw XT_R_FROM
0001ee 1dcb          .dw XT_UMSLASHMOD
0001ef 1c1a          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0001f0 ff04          .dw $ff04
0001f1 6d2f
0001f2 646f          .db "/mod"
0001f3 01e5          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0001f4 01f5          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0001f5 019c          movw temp2, tosl
                     
0001f6 9109          ld temp0, Y+
0001f7 9119          ld temp1, Y+
                 
0001f8 2f41          mov	temp6,temp1	;move dividend High to sign register
0001f9 2743          eor	temp6,temp3	;xor divisor High with sign register
0001fa ff17          sbrs	temp1,7	;if MSB in dividend set
0001fb c004          rjmp	PFA_SLASHMOD_1
0001fc 9510          com	temp1		;    change sign of dividend
0001fd 9500          com	temp0		
0001fe 5f0f          subi	temp0,low(-1)
0001ff 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000200 ff37          sbrs	temp3,7	;if MSB in divisor set
000201 c004          rjmp	PFA_SLASHMOD_2
000202 9530          com	temp3		;    change sign of divisor
000203 9520          com	temp2		
000204 5f2f          subi	temp2,low(-1)
000205 4f3f          sbci	temp3,high(-1)
000206 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000207 18ff          sub	temp5,temp5;clear remainder High byte and carry
000208 e151          ldi	temp7,17	;init loop counter
                 
000209 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00020a 1f11          rol	temp1
00020b 955a          dec	temp7		;decrement counter
00020c f439          brne	PFA_SLASHMOD_5		;if done
00020d ff47          sbrs	temp6,7		;    if MSB in sign register set
00020e c004          rjmp	PFA_SLASHMOD_4
00020f 9510          com	temp1	;        change sign of result
000210 9500          com	temp0
000211 5f0f          subi	temp0,low(-1)
000212 4f1f          sbci	temp1,high(-1)
000213 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000214 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000215 1cff          rol	temp5
000216 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000217 0af3          sbc	temp5,temp3	;
000218 f420          brcc	PFA_SLASHMOD_6		;if result negative
000219 0ee2          add	temp4,temp2	;    restore remainder
00021a 1ef3          adc	temp5,temp3
00021b 9488          clc			;    clear carry to be shifted into result
00021c cfec          rjmp	PFA_SLASHMOD_3		;else
00021d 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00021e cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00021f 92fa          st -Y,temp5
000220 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000221 01c8          movw tosl, temp0
000222 940c 1c04     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
000224 ff02          .dw $ff02
000225 2f2a          .db "*/"
000226 01f0          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000227 1c00          .dw DO_COLON
                 PFA_STARSLASH:
000228 01ea          .dw XT_STARSLASHMOD
000229 1cbf          .dw XT_SWAP
00022a 1cd4          .dw XT_DROP
00022b 1c1a          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00022c ff05          .dw $ff05
00022d 2f75
00022e 6f6d
00022f 0064          .db "u/mod",0
000230 0224          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000231 1c00          .dw DO_COLON
                 PFA_USLASHMOD:
000232 1cf3          .dw XT_TO_R
000233 1d34          .dw XT_ZERO
000234 1cea          .dw XT_R_FROM
000235 1dcb          .dw XT_UMSLASHMOD
000236 1c1a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000237 ff06          .dw $ff06
000238 656e
000239 6167
00023a 6574          .db "negate"
00023b 022c          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00023c 1c00          .dw DO_COLON
                 PFA_NEGATE:
00023d 1e06          .dw XT_INVERT
00023e 1e38          .dw XT_1PLUS
00023f 1c1a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
000240 ff01          .dw $ff01
000241 002f          .db "/",0
000242 0237          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000243 1c00          .dw DO_COLON
                 PFA_SLASH:
000244 01f4          .dw XT_SLASHMOD
000245 1cbf          .dw XT_SWAP
000246 1cd4          .dw XT_DROP
000247 1c1a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
000248 ff03          .dw $ff03
000249 6f6d
00024a 0064          .db "mod",0
00024b 0240          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00024c 1c00          .dw DO_COLON
                 PFA_MOD:
00024d 01f4          .dw XT_SLASHMOD
00024e 1cd4          .dw XT_DROP
00024f 1c1a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000250 ff03          .dw $ff03
000251 6261
000252 0073          .db "abs",0
000253 0248          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000254 0255          .dw PFA_ABS
                 PFA_ABS:
000255 2399          tst tosh
000256 f41a          brpl PFA_ABS1
000257 9580          com tosl
000258 9590          com tosh
000259 9601          adiw tosl, 1
                 PFA_ABS1:
00025a 940c 1c04     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
00025c ff03          .dw $ff03
00025d 696d
00025e 006e          .db "min",0
00025f 0250          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000260 1c00          .dw DO_COLON
                 PFA_MIN:
000261 0106          .dw XT_2DUP
000262 1d26          .dw XT_GREATER
000263 1c30          .dw XT_DOCONDBRANCH
000264 0266          .dw PFA_MIN1
000265 1cbf          .dw XT_SWAP
                 PFA_MIN1:
000266 1cd4          .dw XT_DROP
000267 1c1a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
000268 ff03          .dw $ff03
000269 616d
00026a 0078          .db "max",0
00026b 025c          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00026c 1c00          .dw DO_COLON
                 PFA_MAX:
00026d 0106          .dw XT_2DUP
00026e 1d1f          .dw XT_LESS
00026f 1c30          .dw XT_DOCONDBRANCH
000270 0272          .dw PFA_MAX1
000271 1cbf          .dw XT_SWAP
                 PFA_MAX1:
000272 1cd4          .dw XT_DROP
000273 1c1a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
000274 ff06          .dw $ff06
000275 6977
000276 6874
000277 6e69          .db "within"
000278 0268          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000279 1c00          .dw DO_COLON
                 PFA_WITHIN:
00027a 1cca          .dw XT_OVER
00027b 1d9c          .dw XT_MINUS
00027c 1cf3          .dw XT_TO_R
00027d 1d9c          .dw XT_MINUS
00027e 1cea          .dw XT_R_FROM
00027f 1d46          .dw XT_ULESS
000280 1c1a          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
000281 ff07          .dw $ff07 
000282 6f74
000283 7075
000284 6570
000285 0072          .db "toupper",0
000286 0274          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000287 1c00          .dw DO_COLON 
                 PFA_TOUPPER:
000288 1cac          .dw XT_DUP 
000289 1c37          .dw XT_DOLITERAL 
00028a 0061          .dw 'a' 
00028b 1c37          .dw XT_DOLITERAL 
00028c 007b          .dw 'z'+1
00028d 0279          .dw XT_WITHIN 
00028e 1c30          .dw XT_DOCONDBRANCH
00028f 0293          .dw PFA_TOUPPER0 
000290 1c37          .dw XT_DOLITERAL
000291 00df          .dw $df ; inverse of 0x20
000292 1e1c          .dw XT_AND 
                 PFA_TOUPPER0:
000293 1c1a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
000294 ff07          .dw $ff07
000295 6f74
000296 6f6c
000297 6577
000298 0072          .db "tolower",0
000299 0281          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00029a 1c00          .dw DO_COLON
                 PFA_TOLOWER:
00029b 1cac          .dw XT_DUP
00029c 1c37          .dw XT_DOLITERAL
00029d 0041          .dw 'A'
00029e 1c37          .dw XT_DOLITERAL
00029f 005b          .dw 'Z'+1
0002a0 0279          .dw XT_WITHIN
0002a1 1c30          .dw XT_DOCONDBRANCH
0002a2 02a6          .dw PFA_TOLOWER0 
0002a3 1c37          .dw XT_DOLITERAL
0002a4 0020          .dw $20 
0002a5 1e25          .dw XT_OR 
                 PFA_TOLOWER0:
0002a6 1c1a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002a7 ff03          .dw $ff03
0002a8 6c68
0002a9 0064          .db "hld",0
0002aa 0294          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002ab 1c42          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002ac 014b          .dw ram_hld
                 
                 .dseg
00014b           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0002ad ff04          .dw $ff04
0002ae 6f68
0002af 646c          .db "hold"
0002b0 02a7          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0002b1 1c00          .dw DO_COLON
                 PFA_HOLD:
0002b2 02ab          .dw XT_HLD
0002b3 1cac          .dw XT_DUP
0002b4 1c74          .dw XT_FETCH
0002b5 1e3e          .dw XT_1MINUS
0002b6 1cac          .dw XT_DUP
0002b7 1cf3          .dw XT_TO_R
0002b8 1cbf          .dw XT_SWAP
0002b9 1c7c          .dw XT_STORE
0002ba 1cea          .dw XT_R_FROM
0002bb 1c88          .dw XT_CSTORE
0002bc 1c1a          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
0002bd ff02          .dw $ff02
0002be 233c          .db "<#"
0002bf 02ad          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0002c0 1c00          .dw DO_COLON
                 PFA_L_SHARP:
0002c1 0123          .dw XT_PAD
0002c2 02ab          .dw XT_HLD
0002c3 1c7c          .dw XT_STORE
0002c4 1c1a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
0002c5 ff01          .dw $ff01
0002c6 0023          .db "#",0
0002c7 02bd          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0002c8 1c00          .dw DO_COLON
                 PFA_SHARP:
0002c9 00ef          .dw XT_BASE
0002ca 1c74          .dw XT_FETCH
0002cb 0347          .dw XT_UDSLASHMOD
0002cc 1cdc          .dw XT_ROT
0002cd 1c37          .dw XT_DOLITERAL
0002ce 0009          .dw 9
0002cf 1cca          .dw XT_OVER
0002d0 1d1f          .dw XT_LESS
0002d1 1c30          .dw XT_DOCONDBRANCH
0002d2 02d6          .dw PFA_SHARP1
0002d3 1c37          .dw XT_DOLITERAL
0002d4 0007          .dw 7
0002d5 1da6          .dw XT_PLUS
                 PFA_SHARP1:
0002d6 1c37          .dw XT_DOLITERAL
0002d7 0030          .dw $30
0002d8 1da6          .dw XT_PLUS
0002d9 02b1          .dw XT_HOLD
0002da 1c1a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
0002db ff02          .dw $ff02
0002dc 7323          .db "#s"
0002dd 02c5          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0002de 1c00          .dw DO_COLON
                 PFA_SHARP_S:
0002df 02c8          .dw XT_SHARP
0002e0 0106          .dw XT_2DUP
0002e1 1e25          .dw XT_OR
0002e2 1d18          .dw XT_EQUALZERO
0002e3 1c30          .dw XT_DOCONDBRANCH
0002e4 02df          .dw PFA_SHARP_S
0002e5 1c1a          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
0002e6 ff02          .dw $ff02
0002e7 3e23          .db "#>"
0002e8 02db          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0002e9 1c00          .dw DO_COLON
                 PFA_SHARP_G:
0002ea 010f          .dw XT_2DROP
0002eb 02ab          .dw XT_HLD
0002ec 1c74          .dw XT_FETCH
0002ed 1cac          .dw XT_DUP
0002ee 0123          .dw XT_PAD
0002ef 1cbf          .dw XT_SWAP
0002f0 1d9c          .dw XT_MINUS
0002f1 1c1a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
0002f2 ff04          .dw $ff04
0002f3 6973
0002f4 6e67          .db "sign"
0002f5 02e6          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0002f6 1c00          .dw DO_COLON
                 PFA_SIGN:
0002f7 1d2d          .dw XT_LESSZERO
0002f8 1c30          .dw XT_DOCONDBRANCH
0002f9 02fd          .dw PFA_SIGN1
0002fa 1c37          .dw XT_DOLITERAL
0002fb 002d          .dw $2d
0002fc 02b1          .dw XT_HOLD
                 PFA_SIGN1:
0002fd 1c1a          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
0002fe ff03          .dw $ff03
0002ff 2e64
000300 0072          .db "d.r",0
000301 02f2          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000302 1c00          .dw DO_COLON
                 PFA_DDOTR:
000303 1cf3          .dw XT_TO_R
000304 1cbf          .dw XT_SWAP
000305 1cca          .dw XT_OVER
000306 0888          .dw XT_DABS
000307 02c0          .dw XT_L_SHARP
000308 02de          .dw XT_SHARP_S
000309 1cdc          .dw XT_ROT
00030a 02f6          .dw XT_SIGN
00030b 02e9          .dw XT_SHARP_G
00030c 1cea          .dw XT_R_FROM
00030d 1cca          .dw XT_OVER
00030e 1d9c          .dw XT_MINUS
00030f 040a          .dw XT_SPACES
000310 0419          .dw XT_TYPE
000311 1c1a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
000312 ff02          .dw $ff02
000313 722e          .db ".r"
000314 02fe          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000315 1c00          .dw DO_COLON
                 PFA_DOTR:
000316 1cf3          .dw XT_TO_R
000317 1f29          .dw XT_S2D
000318 1cea          .dw XT_R_FROM
000319 0302          .dw XT_DDOTR
00031a 1c1a          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
00031b ff02          .dw $ff02
00031c 2e64          .db "d."
00031d 0312          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00031e 1c00          .dw DO_COLON
                 PFA_DDOT:
00031f 1d34          .dw XT_ZERO
000320 0302          .dw XT_DDOTR
000321 0401          .dw XT_SPACE
000322 1c1a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
000323 ff01          .dw $ff01
000324 002e          .db ".",0
000325 031b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000326 1c00          .dw DO_COLON
                 PFA_DOT:
000327 1f29          .dw XT_S2D
000328 031e          .dw XT_DDOT
000329 1c1a          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
00032a ff03          .dw $ff03
00032b 6475
00032c 002e          .db "ud.",0
00032d 0323          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00032e 1c00          .dw DO_COLON
                 PFA_UDDOT:
00032f 1d34          .dw XT_ZERO
000330 0337          .dw XT_UDDOTR
000331 0401          .dw XT_SPACE
000332 1c1a          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
000333 ff04          .dw $ff04
000334 6475
000335 722e          .db "ud.r"
000336 032a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000337 1c00          .dw DO_COLON
                 PFA_UDDOTR:
000338 1cf3          .dw XT_TO_R
000339 02c0          .dw XT_L_SHARP
00033a 02de          .dw XT_SHARP_S
00033b 02e9          .dw XT_SHARP_G
00033c 1cea          .dw XT_R_FROM
00033d 1cca          .dw XT_OVER
00033e 1d9c          .dw XT_MINUS
00033f 040a          .dw XT_SPACES
000340 0419          .dw XT_TYPE
000341 1c1a          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
000342 ff06          .dw $ff06
000343 6475
000344 6d2f
000345 646f          .db "ud/mod"
000346 0333          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000347 1c00          .dw DO_COLON
                 PFA_UDSLASHMOD:
000348 1cf3          .dw XT_TO_R
000349 1d34          .dw XT_ZERO
00034a 1cfc          .dw XT_R_FETCH
00034b 1dcb          .dw XT_UMSLASHMOD
00034c 1cea          .dw XT_R_FROM
00034d 1cbf          .dw XT_SWAP
00034e 1cf3          .dw XT_TO_R
00034f 1dcb          .dw XT_UMSLASHMOD
000350 1cea          .dw XT_R_FROM
000351 1c1a          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
000352 ff06          .dw $ff06 
000353 6964
000354 6967
000355 3f74          .db "digit?"
000356 0342          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000357 1c00          .dw DO_COLON 
                 PFA_DIGITQ:
000358 0287          .dw XT_TOUPPER
000359 1c37          .dw XT_DOLITERAL 
00035a 0030          .dw $30 
00035b 1d9c          .dw XT_MINUS 
00035c 1cac          .dw XT_DUP 
00035d 1c37          .dw XT_DOLITERAL
00035e 0009          .dw $09 
00035f 1d51          .dw XT_UGREATER 
000360 1c30          .dw XT_DOCONDBRANCH
000361 036e          .dw PFA_DIGITQ0 
000362 1c37          .dw XT_DOLITERAL
000363 0007          .dw $07 
000364 1d9c          .dw XT_MINUS 
000365 1cac          .dw XT_DUP 
000366 1c37          .dw XT_DOLITERAL
000367 0009          .dw $09 
000368 037d          .dw XT_ULESSEQUAL
000369 1c30          .dw XT_DOCONDBRANCH
00036a 036e          .dw PFA_DIGITQ1 
00036b 1cd4          .dw XT_DROP 
00036c 1d34          .dw XT_ZERO
00036d 1c1a          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
00036e 1cac          .dw XT_DUP 
00036f 00ef          .dw XT_BASE 
000370 1c74          .dw XT_FETCH 
000371 0385          .dw XT_UGREATEREQUAL
000372 1c30          .dw XT_DOCONDBRANCH
000373 0377          .dw PFA_DIGITQ2 
000374 1cd4          .dw XT_DROP 
000375 1d34          .dw XT_ZERO
000376 1c1a          .dw XT_EXIT 
                 PFA_DIGITQ2:
000377 1d3d          .dw XT_TRUE
000378 1c1a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
000379 ff03          .dw $ff03 
00037a 3c75
00037b 003d          .db "u<=",0
00037c 0352          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
00037d 1c00          .dw DO_COLON 
                 PFA_ULESSEQUAL:
00037e 1d51          .dw XT_UGREATER 
00037f 1e06          .dw XT_INVERT 
000380 1c1a          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
000381 ff03          .dw $ff03 
000382 3e75
000383 003d          .db "u>=",0
000384 0379          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
000385 1c00          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
000386 1d46          .dw XT_ULESS 
000387 1e06          .dw XT_INVERT 
000388 1c1a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000389 1c00        .dw DO_COLON
                 PFA_DOSLITERAL:
00038a 1cea        .dw XT_R_FROM   ; ( -- addr )
00038b 1cac        .dw XT_DUP      ; ( -- addr addr )
00038c 1cac        .dw XT_DUP
00038d 1fc7        .dw XT_FETCHI   ; ( -- addr addr n )
00038e 1cbf        .dw XT_SWAP
00038f 1e38        .dw XT_1PLUS
000390 1cbf        .dw XT_SWAP
000391 1cdc        .dw XT_ROT      ; ( -- addr' n addr )
000392 1cca        .dw XT_OVER     ; ( -- addr' n addr n)
000393 1e38        .dw XT_1PLUS
000394 1e0d        .dw XT_2SLASH   ; ( -- addr' n addr k )
000395 1da6        .dw XT_PLUS     ; ( -- addr' n addr'' )
000396 1e38        .dw XT_1PLUS
000397 1cf3        .dw XT_TO_R     ; ( -- )
000398 1c1a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000399 ff02        .dw $ff02
00039a 2c73        .db "s",$2c
00039b 0381        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00039c 1c00          .dw DO_COLON
                 PFA_SCOMMA:
00039d 1cac          .dw XT_DUP
00039e 03a0          .dw XT_DOSCOMMA
00039f 1c1a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003a0 1c00          .dw DO_COLON
                 PFA_DOSCOMMA:
0003a1 01a4          .dw XT_COMMA
0003a2 1cac          .dw XT_DUP   ; ( --addr len len)
0003a3 1e0d          .dw XT_2SLASH ; ( -- addr len len/2
0003a4 1cbf          .dw XT_SWAP   ; ( -- addr len/2 len
0003a5 1cca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003a6 1e14          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003a7 1d9c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003a8 1cf3          .dw XT_TO_R
0003a9 1d34          .dw XT_ZERO
0003aa 1eaa          .dw XT_DOQDO
0003ab 03b2          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0003ac 1cac          .dw XT_DUP         ; ( -- addr addr )
0003ad 1c74          .dw XT_FETCH       ; ( -- addr c1c2 )
0003ae 01a4          .dw XT_COMMA       ; ( -- addr )
0003af 00fe          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003b0 1ed8          .dw XT_DOLOOP
0003b1 03ac          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003b2 1cea          .dw XT_R_FROM
0003b3 1d5c          .dw XT_GREATERZERO
0003b4 1c30          .dw XT_DOCONDBRANCH
0003b5 03b9          .dw PFA_SCOMMA3
0003b6 1cac            .dw XT_DUP     ; well, tricky
0003b7 1c93            .dw XT_CFETCH
0003b8 01a4            .dw XT_COMMA
                 PFA_SCOMMA3:
0003b9 1cd4          .dw XT_DROP        ; ( -- )
0003ba 1c1a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003bb ff05          .dw $ff05
0003bc 7469
0003bd 7079
0003be 0065          .db "itype",0
0003bf 0399          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003c0 1c00          .dw DO_COLON
                 PFA_ITYPE:
0003c1 1cac          .dw XT_DUP    ; ( --addr len len)
0003c2 1e0d          .dw XT_2SLASH ; ( -- addr len len/2
0003c3 1cbf          .dw XT_SWAP   ; ( -- addr len/2 len
0003c4 1cca          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003c5 1e14          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003c6 1d9c          .dw XT_MINUS  ; ( -- addr len/2 rem
0003c7 1cf3          .dw XT_TO_R
0003c8 1d34          .dw XT_ZERO
0003c9 1eaa          .dw XT_DOQDO
0003ca 03d3          .dw PFA_ITYPE2
                 PFA_ITYPE1:
0003cb 1cac          .dw XT_DUP         ; ( -- addr addr )
0003cc 1fc7          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003cd 1cac          .dw XT_DUP
0003ce 03e0          .dw XT_LOWEMIT
0003cf 03dc          .dw XT_HIEMIT
0003d0 1e38          .dw XT_1PLUS    ; ( -- addr+cell )
0003d1 1ed8          .dw XT_DOLOOP
0003d2 03cb          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0003d3 1cea          .dw XT_R_FROM
0003d4 1d5c          .dw XT_GREATERZERO
0003d5 1c30          .dw XT_DOCONDBRANCH
0003d6 03da          .dw PFA_ITYPE3
0003d7 1cac            .dw XT_DUP     ; make sure the drop below has always something to do
0003d8 1fc7            .dw XT_FETCHI
0003d9 03e0            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0003da 1cd4          .dw XT_DROP
0003db 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0003dc 1c00          .dw DO_COLON
                 PFA_HIEMIT:
0003dd 1f0e          .dw XT_BYTESWAP
0003de 03e0          .dw XT_LOWEMIT
0003df 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0003e0 1c00          .dw DO_COLON
                 PFA_LOWEMIT:
0003e1 1c37          .dw XT_DOLITERAL
0003e2 00ff          .dw $00ff
0003e3 1e1c          .dw XT_AND
0003e4 012d          .dw XT_EMIT
0003e5 1c1a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0003e6 ff06          .dw $ff06
0003e7 6369
0003e8 756f
0003e9 746e          .db "icount"
0003ea 03bb          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0003eb 1c00          .dw DO_COLON
                 PFA_ICOUNT:
0003ec 1cac          .dw XT_DUP
0003ed 1e38          .dw XT_1PLUS
0003ee 1cbf          .dw XT_SWAP
0003ef 1fc7          .dw XT_FETCHI
0003f0 1c1a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
0003f1 ff02          .dw $ff02
0003f2 7263          .db "cr"
0003f3 03e6          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0003f4 1c00          .dw DO_COLON
                 PFA_CR:
0003f5 1c37          .dw XT_DOLITERAL
0003f6 000d          .dw 13
0003f7 012d          .dw XT_EMIT
0003f8 1c37          .dw XT_DOLITERAL
0003f9 000a          .dw 10
0003fa 012d          .dw XT_EMIT
0003fb 1c1a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
0003fc ff05          .dw $ff05
0003fd 7073
0003fe 6361
0003ff 0065          .db "space",0
000400 03f1          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000401 1c00          .dw DO_COLON
                 PFA_SPACE:
000402 01d9          .dw XT_BL
000403 012d          .dw XT_EMIT
000404 1c1a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
000405 ff06          .dw $ff06
000406 7073
000407 6361
000408 7365          .db "spaces"
000409 03fc          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00040a 1c00          .dw DO_COLON
                 PFA_SPACES:
00040b 1cac          .dw XT_DUP
00040c 1d5c          .dw XT_GREATERZERO
00040d 1e1c          .dw XT_AND
00040e 1d34          .dw XT_ZERO
00040f 1eaa          .dw XT_DOQDO
000410 0414          .dw PFA_SPACES2
                 PFA_SPACES1:
000411 0401          .dw XT_SPACE
000412 1ed8          .dw XT_DOLOOP
000413 0411          .dw PFA_SPACES1
                 PFA_SPACES2:
000414 1c1a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
000415 ff04          .dw $ff04
000416 7974
000417 6570          .db "type"
000418 0405          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000419 1c00          .dw DO_COLON
                 PFA_TYPE:
00041a 1cca          .dw XT_OVER
00041b 1da6          .dw XT_PLUS
00041c 1cbf          .dW XT_SWAP
00041d 1eaa          .dw XT_DOQDO
00041e 0424          .dw PFA_TYPE2
                 PFA_TYPE1:
00041f 1ebd          .dw XT_I
000420 1c93          .dw XT_CFETCH
000421 012d          .dw XT_EMIT
000422 1ed8          .dw XT_DOLOOP
000423 041f          .dw PFA_TYPE1
                 PFA_TYPE2:
000424 1c1a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
000425 ff01          .dw $ff01
000426 0027          .db "'",0
000427 0415          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000428 1c00          .dw DO_COLON
                 PFA_TICK:
000429 05e5          .dw XT_PARSENAME
00042a 0602          .dw XT_FINDNAME
00042b 1d18          .dw XT_EQUALZERO
00042c 1c30          .dw XT_DOCONDBRANCH
00042d 0431          .dw PFA_TICK1
00042e 1c37          .dw XT_DOLITERAL
00042f fff3          .dw -13
000430 0455          .dw XT_THROW
                 PFA_TICK1:
000431 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
000432 ff07          .dw $ff07
000433 6168
000434 646e
000435 656c
000436 0072          .db "handler",0
000437 0425          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000438 1c52          .dw PFA_DOUSER
                 PFA_HANDLER:
000439 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
00043a ff05          .dw $ff05
00043b 6163
00043c 6374
00043d 0068          .db "catch",0
00043e 0432          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00043f 1c00          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
000440 1e8a          .dw XT_SP_FETCH
000441 1cf3          .dw XT_TO_R
                     ; handler @ >r
000442 0438          .dw XT_HANDLER
000443 1c74          .dw XT_FETCH
000444 1cf3          .dw XT_TO_R
                     ; rp@ handler !
000445 1e73          .dw XT_RP_FETCH
000446 0438          .dw XT_HANDLER
000447 1c7c          .dw XT_STORE
000448 1c24          .dw XT_EXECUTE
                     ; r> handler !
000449 1cea          .dw XT_R_FROM
00044a 0438          .dw XT_HANDLER
00044b 1c7c          .dw XT_STORE
00044c 1cea          .dw XT_R_FROM
00044d 1cd4          .dw XT_DROP
00044e 1d34          .dw XT_ZERO
00044f 1c1a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
000450 ff05          .dw $ff05
000451 6874
000452 6f72
000453 0077          .db "throw",0
000454 043a          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000455 1c00          .dw DO_COLON
                 PFA_THROW:
000456 1cac          .dw XT_DUP
000457 1d18          .dw XT_EQUALZERO
000458 1c30          .dw XT_DOCONDBRANCH
000459 045c          .dw PFA_THROW1
00045a 1cd4      	.dw XT_DROP
00045b 1c1a      	.dw XT_EXIT
                 PFA_THROW1:
00045c 0438          .dw XT_HANDLER
00045d 1c74          .dw XT_FETCH
00045e 1e7d          .dw XT_RP_STORE
00045f 1cea          .dw XT_R_FROM
000460 0438          .dw XT_HANDLER
000461 1c7c          .dw XT_STORE
000462 1cea          .dw XT_R_FROM
000463 1cbf          .dw XT_SWAP
000464 1cf3          .dw XT_TO_R
000465 1e93          .dw XT_SP_STORE
000466 1cd4          .dw XT_DROP
000467 1cea          .dw XT_R_FROM    
000468 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
000469 ff05          .dw $ff05
00046a 7363
00046b 696b
00046c 0070          .db "cskip",0
00046d 0450          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00046e 1c00          .dw DO_COLON
                 PFA_CSKIP:
00046f 1cf3          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000470 1cac          .dw XT_DUP            ; ( -- addr' n' n' )
000471 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000472 047e          .dw PFA_CSKIP2
000473 1cca          .dw XT_OVER           ; ( -- addr' n' addr' )
000474 1c93          .dw XT_CFETCH         ; ( -- addr' n' c' )
000475 1cfc          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000476 1d11          .dw XT_EQUAL          ; ( -- addr' n' f )
000477 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000478 047e          .dw PFA_CSKIP2
000479 1c37          .dw XT_DOLITERAL
00047a 0001          .dw 1
00047b 05d4          .dw XT_SLASHSTRING
00047c 1c29          .dw XT_DOBRANCH
00047d 0470          .dw PFA_CSKIP1
                 PFA_CSKIP2:
00047e 1cea          .dw XT_R_FROM
00047f 1cd4          .dw XT_DROP           ; ( -- addr2 n2)
000480 1c1a          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
000481 ff06          .dw $ff06
000482 6361
000483 6563
000484 7470          .db "accept"
000485 0469          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000486 1c00          .dw DO_COLON
                 PFA_ACCEPT:
000487 1cac          .dw XT_DUP        ; ( -- addr n1 n1)
000488 1cf3          .dw XT_TO_R
000489 1cf3          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
00048a 013e          .dw XT_KEY        ; ( -- addr k )
00048b 1cac          .dw XT_DUP        ; ( -- addr k k )
00048c 1c37          .dw XT_DOLITERAL
00048d 000a          .dw 10
00048e 1d07          .dw XT_NOTEQUAL
00048f 1c30          .dw XT_DOCONDBRANCH
000490 04c4          .dw PFA_ACCEPT2
000491 1cac          .dw XT_DUP
000492 1c37          .dw XT_DOLITERAL
000493 000d          .dw 13
000494 1d07          .dw XT_NOTEQUAL
000495 1c30          .dw XT_DOCONDBRANCH
000496 04c4          .dw PFA_ACCEPT2
                     ; check backspace
000497 1cac          .dw XT_DUP
000498 1c37          .dw XT_DOLITERAL
000499 0008          .dw 8
00049a 1d11          .dw XT_EQUAL
00049b 1c30          .dw XT_DOCONDBRANCH
00049c 04b0          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
00049d 1cea          .dw XT_R_FROM             ; ( -- addr k n1 )
00049e 1cfc          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
00049f 1cca          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
0004a0 1cf3          .dw XT_TO_R
0004a1 1d11          .dw XT_EQUAL              ; ( -- addr k f )
0004a2 1c30          .dw XT_DOCONDBRANCH
0004a3 04a7          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
0004a4 1cd4          .dw XT_DROP               ; ( -- addr )
0004a5 1c29          .dw XT_DOBRANCH
0004a6 048a          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0004a7 1cac          .dw XT_DUP                ; ( -- addr k k )
0004a8 012d          .dw XT_EMIT               ; ( -- addr k )
0004a9 0401          .dw XT_SPACE              ; ( -- addr k )
0004aa 012d          .dw XT_EMIT               ; ( -- addr )
0004ab 1e3e          .dw XT_1MINUS             ; ( -- addr--)
0004ac 1cea          .dw XT_R_FROM
0004ad 1e38          .dw XT_1PLUS
0004ae 1c29          .dw XT_DOBRANCH
0004af 04be          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
0004b0 1cac          .dw XT_DUP            ; ( -- addr k k )
0004b1 01d9          .dw XT_BL
0004b2 1d1f          .dw XT_LESS
0004b3 1c30          .dw XT_DOCONDBRANCH
0004b4 04b7          .dw PFA_ACCEPT6
0004b5 1cd4          .dw XT_DROP
0004b6 01d9          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
0004b7 1cac          .dw XT_DUP            ; ( -- addr k k)
0004b8 012d          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
0004b9 1cca          .dw XT_OVER           ; ( -- addr k addr
0004ba 1c88          .dw XT_CSTORE         ; ( -- addr)
0004bb 1e38          .dw XT_1PLUS          ; ( -- addr++)
0004bc 1cea          .dw XT_R_FROM         ; ( -- addr n1)
0004bd 1e3e          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
0004be 1cac          .dw XT_DUP
0004bf 1cf3          .dw XT_TO_R
0004c0 1d18          .dw XT_EQUALZERO
0004c1 1c30          .dw XT_DOCONDBRANCH
0004c2 048a          .dw PFA_ACCEPT1
0004c3 1cac          .dw XT_DUP
                 PFA_ACCEPT2:
0004c4 010f          .dw XT_2DROP
0004c5 1cea          .dw XT_R_FROM
0004c6 1cea          .dw XT_R_FROM
0004c7 1cbf          .dw XT_SWAP
0004c8 1d9c          .dw XT_MINUS
0004c9 03f4          .dw XT_CR
0004ca 1c1a          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004cb ff06          .dw $ff06
0004cc 6572
0004cd 6966
0004ce 6c6c          .db "refill"
0004cf 0481          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004d0 07c8          .dw PFA_DODEFER
                 PFA_REFILL:
0004d1 001a          .dw USER_REFILL
0004d2 07a0          .dw XT_UDEFERFETCH
0004d3 07a7          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
0004d4 ff04          .dw $ff04
0004d5 6863
0004d6 7261          .db "char"
0004d7 04cb          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004d8 1c00          .dw DO_COLON
                 PFA_CHAR:
0004d9 05e5          .dw XT_PARSENAME
0004da 1cd4          .dw XT_DROP
0004db 1c93          .dw XT_CFETCH
0004dc 1c1a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
0004dd ff06          .dw $ff06
0004de 756e
0004df 626d
0004e0 7265          .db "number"
0004e1 04d4          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004e2 1c00          .dw DO_COLON
                 PFA_NUMBER:
0004e3 00ef          .dw XT_BASE
0004e4 1c74          .dw XT_FETCH
0004e5 1cf3          .dw XT_TO_R
0004e6 0553          .dw XT_NUMBERSIGN
0004e7 1cf3          .dw XT_TO_R
0004e8 051f          .dw XT_PRAEFIX
0004e9 0553          .dw XT_NUMBERSIGN
0004ea 1cea          .dw XT_R_FROM
0004eb 1e25          .dw XT_OR
0004ec 1cf3          .dw XT_TO_R
0004ed 1cf3          .dw XT_TO_R
0004ee 1cf3          .dw XT_TO_R
0004ef 1d34          .dw XT_ZERO       ; starting value
0004f0 1d34          .dw XT_ZERO
0004f1 1cea          .dw XT_R_FROM
0004f2 1cea          .dw XT_R_FROM
0004f3 0572          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0004f4 1cb4          .dw XT_QDUP
0004f5 1c30              .dw XT_DOCONDBRANCH
0004f6 0513      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
0004f7 1c37          .dw XT_DOLITERAL
0004f8 0001          .dw 1
0004f9 1d11          .dw XT_EQUAL
0004fa 1c30          .dw XT_DOCONDBRANCH
0004fb 050a          .dw PFA_NUMBER2
                 	; excatly one character is left
0004fc 1c93      	.dw XT_CFETCH
0004fd 1c37      	.dw XT_DOLITERAL
0004fe 002e      	.dw $2e ; .
0004ff 1d11      	.dw XT_EQUAL
000500 1c30      	.dw XT_DOCONDBRANCH
000501 050a      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
000502 1cea      	.dw XT_R_FROM
000503 1c30              .dw XT_DOCONDBRANCH
000504 0506      	.dw PFA_NUMBER3
000505 0895              .dw XT_DNEGATE
                 PFA_NUMBER3:
000506 1c37      	.dw XT_DOLITERAL
000507 0002      	.dw 2
000508 1c29      	.dw XT_DOBRANCH
000509 051a      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
00050a 010f      	.dw XT_2DROP
00050b 1cd4      	.dw XT_DROP
00050c 1cea      	.dw XT_R_FROM
00050d 1cd4      	.dw XT_DROP
00050e 1cea              .dw XT_R_FROM
00050f 00ef              .dw XT_BASE
000510 1c7c              .dw XT_STORE
000511 1d34      	.dw XT_ZERO
000512 1c1a      	.dw XT_EXIT
                 PFA_NUMBER1:
000513 010f          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000514 1cea          .dw XT_R_FROM
000515 1c30          .dw XT_DOCONDBRANCH
000516 0518          .dw PFA_NUMBER4
000517 023c          .dw XT_NEGATE
                 PFA_NUMBER4:
000518 1c37          .dw XT_DOLITERAL
000519 0001          .dw 1
                 PFA_NUMBER5:
00051a 1cea          .dw XT_R_FROM
00051b 00ef          .dw XT_BASE
00051c 1c7c          .dw XT_STORE
00051d 1d3d          .dw XT_TRUE
00051e 1c1a          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
00051f 1c00          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
000520 1cca          .dw XT_OVER 
000521 1c93          .dw XT_CFETCH 
000522 1c37          .dw XT_DOLITERAL
000523 0029          .dw $29 
000524 1d26          .dw XT_GREATER 
000525 1c30          .dw XT_DOCONDBRANCH
000526 0528          .dw PFA_PRAEFIX0 
000527 1c1a          .dw XT_EXIT 
                 PFA_PRAEFIX0:
000528 1cca          .dw XT_OVER 
000529 1c93          .dw XT_CFETCH 
00052a 052f          .dw XT_SETBASE
00052b 1c37          .dw XT_DOLITERAL
00052c 0001          .dw $1 
00052d 05d4          .dw XT_SLASHSTRING 
00052e 1c1a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
00052f 1c00          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000530 1cac          .dw XT_DUP 
000531 1c37          .dw XT_DOLITERAL
000532 0024          .dw '$' 
000533 1d11          .dw XT_EQUAL 
000534 1c30          .dw XT_DOCONDBRANCH
000535 0539          .dw PFA_SETBASE0 
000536 1cd4          .dw XT_DROP 
000537 01d0          .dw XT_HEX 
000538 1c1a          .dw XT_EXIT 
                 PFA_SETBASE0:
000539 1cac          .dw XT_DUP 
00053a 1c37          .dw XT_DOLITERAL
00053b 0025          .dw '%' 
00053c 1d11          .dw XT_EQUAL 
00053d 1c30          .dw XT_DOCONDBRANCH
00053e 0542          .dw PFA_SETBASE1 
00053f 1cd4          .dw XT_DROP 
000540 01ba          .dw XT_BIN
000541 1c1a          .dw XT_EXIT 
                 PFA_SETBASE1:
000542 1cac          .dw XT_DUP 
000543 1c37          .dw XT_DOLITERAL
000544 0026          .dw '&'
000545 1d11          .dw XT_EQUAL 
000546 1c30          .dw XT_DOCONDBRANCH
000547 054b          .dw PFA_SETBASE2 
000548 1cd4          .dw XT_DROP
000549 01c6          .dw XT_DECIMAL 
00054a 1c1a          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
00054b 1c37          .dw XT_DOLITERAL
00054c 0023          .dw '#'
00054d 1d11          .dw XT_EQUAL 
00054e 1c30          .dw XT_DOCONDBRANCH
00054f 0552          .dw PFA_SETBASE3 
000550 01c6          .dw XT_DECIMAL 
000551 1c1a          .dw XT_EXIT 
                 PFA_SETBASE3:
000552 1c1a          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
000553 1c00          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
000554 1cca          .dw XT_OVER
000555 1c93          .dw XT_CFETCH
000556 1c37          .dw XT_DOLITERAL
000557 002b          .dw '+'
000558 1d11          .dw XT_EQUAL
000559 1c30          .dw XT_DOCONDBRANCH
00055a 055e          .dw PFA_NUMBERSIGN_MINUS
00055b 1c37            .dw XT_DOLITERAL
00055c 0001            .dw 1
00055d 05d4            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
00055e 1cca          .dw XT_OVER    ; ( -- addr len addr )
00055f 1c93          .dw XT_CFETCH
000560 1c37          .dw XT_DOLITERAL
000561 002d          .dw '-'
000562 1d11          .dw XT_EQUAL  ; ( -- addr len flag )
000563 1cac          .dw XT_DUP
000564 1cf3          .dw XT_TO_R
000565 1c30          .dw XT_DOCONDBRANCH
000566 056a          .dw PFA_NUMBERSIGN_PLUS
000567 1c37          .dw XT_DOLITERAL      ; skip sign character
000568 0001          .dw 1
000569 05d4          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
00056a 1cea          .dw XT_R_FROM
00056b 1c1a          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
00056c ff07          .dw $ff07
00056d 6e3e
00056e 6d75
00056f 6562
000570 0072          .db ">number",0
000571 04dd          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000572 1c00          .dw DO_COLON
                 PFA_TO_NUMBER:
000573 1cac          .dw XT_DUP
000574 1c30          .dw XT_DOCONDBRANCH
000575 0590          .dw PFA_TO_NUMBER1
000576 1cca              .dw XT_OVER
000577 1c93              .dw XT_CFETCH
000578 0357              .dw XT_DIGITQ
000579 1d18              .dw XT_EQUALZERO
00057a 1c30              .dw XT_DOCONDBRANCH
00057b 057d              .dw PFA_TO_NUMBER2
00057c 1c1a                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
00057d 1cf3              .dw XT_TO_R
00057e 08ba              .dw XT_2SWAP
00057f 1cea              .dw XT_R_FROM
000580 1cbf              .dw XT_SWAP
000581 00ef              .dw XT_BASE
000582 1c74              .dw XT_FETCH
000583 1de9              .dw XT_UMSTAR
000584 1cd4              .dw XT_DROP
000585 1cdc              .dw XT_ROT
000586 00ef              .dw XT_BASE
000587 1c74              .dw XT_FETCH
000588 1de9              .dw XT_UMSTAR
000589 0cdb              .dw XT_DPLUS
00058a 08ba              .dw XT_2SWAP
00058b 1c37              .dw XT_DOLITERAL
00058c 0001              .dw 1
00058d 05d4              .dw XT_SLASHSTRING
00058e 1c29          .dw XT_DOBRANCH
00058f 0573          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
000590 1c1a          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
000591 ff05          .dw $ff05
000592 6170
000593 7372
000594 0065          .db "parse",0
000595 056c          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000596 1c00          .dw DO_COLON
                 PFA_PARSE:
000597 1cf3          .dw XT_TO_R     ; ( -- )
000598 05ca          .dw XT_SOURCE   ; ( -- addr len)
000599 0117          .dw XT_G_IN     ; ( -- addr len >in)
00059a 1c74          .dw XT_FETCH
00059b 05d4          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00059c 1cea          .dw XT_R_FROM      ; ( -- addr' len' c)
00059d 05ab          .dw XT_CSCAN       ; ( -- addr' len'')
00059e 1cac          .dw XT_DUP         ; ( -- addr' len'' len'')
00059f 1e38          .dw XT_1PLUS
0005a0 0117          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
0005a1 1e62          .dw XT_PLUSSTORE   ; ( -- addr' len')
0005a2 1c37          .dw XT_DOLITERAL
0005a3 0001          .dw 1
0005a4 05d4          .dw XT_SLASHSTRING
0005a5 1c1a          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0005a6 ff05          .dw $ff05
0005a7 7363
0005a8 6163
0005a9 006e          .db "cscan",0
0005aa 0591          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0005ab 1c00          .dw DO_COLON
                 PFA_CSCAN:
0005ac 1cbf          .dw XT_SWAP         ; ( -- addr1 c n1 )
0005ad 1cac          .dw XT_DUP          ; ( -- addr1 c n1 n1)
0005ae 1cf3          .dw XT_TO_R         ; ( -- addr1 c n1)
0005af 1d34          .dw XT_ZERO         ; ( -- addr1 c n1 0)
0005b0 1eaa          .dw XT_DOQDO        ; ( -- addr1 c)
0005b1 05c2          .dw PFA_CSCAN3
                 PFA_CSCAN1:
0005b2 1cca          .dw XT_OVER         ; ( -- addr1 c addr1 )
0005b3 1ebd          .dw XT_I            ; ( -- addr1 c addr1 i)
0005b4 1da6          .dw XT_PLUS         ; ( -- addr1 c addr')
0005b5 1c93          .dw XT_CFETCH       ; ( -- addr1 c c')
0005b6 1cca          .dw XT_OVER         ; ( -- addr1 c c' c)
0005b7 1d11          .dw XT_EQUAL        ; ( -- addr1 c f)
0005b8 1c30          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
0005b9 05c0          .dw PFA_CSCAN2
0005ba 1cd4          .dw XT_DROP         ; ( -- addr1 )
0005bb 1ebd          .dw XT_I            ; ( -- addr1 n2)
0005bc 1ee7          .dw XT_UNLOOP       ; ( -- addr1 n2)
0005bd 1cea          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
0005be 1cd4          .dw XT_DROP         ; ( -- addr1 n2)
0005bf 1c1a          .dw XT_EXIT
                 PFA_CSCAN2:
0005c0 1ed8          .dw XT_DOLOOP
0005c1 05b2          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
0005c2 1cd4          .dw XT_DROP         ; ( -- addr1)
0005c3 1cea          .dw XT_R_FROM       ; ( -- addr1 n1)
0005c4 1c1a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0005c5 ff06          .dw $FF06
0005c6 6f73
0005c7 7275
0005c8 6563          .db "source"
0005c9 05a6          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0005ca 07c8          .dw PFA_DODEFER
                 PFA_SOURCE:
0005cb 0016          .dw USER_SOURCE
0005cc 07a0          .dw XT_UDEFERFETCH
0005cd 07a7          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0005ce ff07          .dw $ff07
0005cf 732f
0005d0 7274
0005d1 6e69
0005d2 0067          .db "/string",0
0005d3 05c5          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005d4 1c00          .dw DO_COLON
                 PFA_SLASHSTRING:
0005d5 1cca          .dw XT_OVER    ; ( -- addr1 u1 n u1)
0005d6 0260          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
0005d7 1cdc          .dw XT_ROT     ; ( -- u1 n addr1 )
0005d8 1cca          .dw XT_OVER    ; ( -- u1 n addr1 n)
0005d9 1da6          .dw XT_PLUS    ; ( -- u1 n addr2 )
0005da 1cdc          .dw XT_ROT     ; ( -- n addr2 u1)
0005db 1cdc          .dw XT_ROT     ; ( -- addr2 u1 n)
0005dc 1d9c          .dw XT_MINUS   ; ( -- addr2 u2)
0005dd 1c1a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
0005de ff0a          .dw $FF0A 
0005df 6170
0005e0 7372
0005e1 2d65
0005e2 616e
0005e3 656d          .db "parse-name"
0005e4 05ce          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005e5 1c00          .dw DO_COLON 
                 PFA_PARSENAME:
0005e6 01d9          .dw XT_BL
0005e7 05e9          .dw XT_SKIPSCANCHAR
0005e8 1c1a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005e9 1c00          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
0005ea 1cf3          .dw XT_TO_R
0005eb 05ca          .dw XT_SOURCE 
0005ec 0117          .dw XT_G_IN 
0005ed 1c74          .dw XT_FETCH 
0005ee 05d4          .dw XT_SLASHSTRING 
                 
0005ef 1cfc          .dw XT_R_FETCH
0005f0 046e          .dw XT_CSKIP
0005f1 1cea          .dw XT_R_FROM
0005f2 05ab          .dw XT_CSCAN
                 
                     ; adjust >IN
0005f3 0106          .dw XT_2DUP
0005f4 1da6          .dw XT_PLUS
0005f5 05ca          .dw XT_SOURCE 
0005f6 1cd4          .dw XT_DROP
0005f7 1d9c          .dw XT_MINUS
0005f8 0117          .dw XT_G_IN
0005f9 1c7c          .dw XT_STORE
0005fa 1c1a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
0005fb ff09          .dw $ff09
0005fc 6966
0005fd 646e
0005fe 6e2d
0005ff 6d61
000600 0065          .db "find-name",0
000601 05de          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000602 1c00          .dw DO_COLON
                 PFA_FINDNAME:
000603 1c37          .dw XT_DOLITERAL
000604 0014          .dw EE_ORDERLISTLEN
000605 1f5b          .dw XT_FETCHE
000606 1d34          .dw XT_ZERO
000607 1eaa          .dw XT_DOQDO
000608 061d          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
000609 0106          .dw XT_2DUP
00060a 1c37          .dw XT_DOLITERAL
00060b 0016          .dw EE_ORDERLIST
00060c 1ebd          .dw XT_I
00060d 00f6          .dw XT_CELLS
00060e 1da6          .dw XT_PLUS  
00060f 1f5b          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
000610 07dc          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
000611 1cb4          .dw XT_QDUP
000612 1c30          .dw XT_DOCONDBRANCH
000613 061b          .dw PFA_FINDNAME4
000614 1cf3      	.dw XT_TO_R
000615 1cf3      	.dw XT_TO_R
000616 010f      	.dw XT_2DROP
000617 1cea      	.dw XT_R_FROM
000618 1cea      	.dw XT_R_FROM
000619 1ee7      	.dw XT_UNLOOP
00061a 1c1a      	.dw XT_EXIT
                 PFA_FINDNAME4:
00061b 1ed8          .dw XT_DOLOOP
00061c 0609          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
00061d 010f          .dw XT_2DROP
00061e 1d34          .dw XT_ZERO
00061f 1c1a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
000620 ff04          .dw $ff04
000621 7571
000622 7469          .db "quit"
000623 05fb          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000624 1c00          .dw DO_COLON
                 PFA_QUIT:
000625 069c          .dw XT_SP0
000626 1e93          .dw XT_SP_STORE
000627 06b1          .dw XT_RP0
000628 1e7d          .dw XT_RP_STORE
000629 0a73          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00062a 00e9          .dw XT_STATE
00062b 1c74          .dw XT_FETCH
00062c 1d18          .dw XT_EQUALZERO
00062d 1c30          .dw XT_DOCONDBRANCH
00062e 0630          .dw PFA_QUIT4
00062f 0646          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000630 04d0          .dw XT_REFILL
000631 1c30          .dw XT_DOCONDBRANCH
000632 062a          .dw PFA_QUIT2
000633 1c37          .dw XT_DOLITERAL
000634 06ca          .dw XT_INTERPRET
000635 043f          .dw XT_CATCH
000636 1cb4          .dw XT_QDUP
000637 1c30          .dw XT_DOCONDBRANCH
000638 0642          .dw PFA_QUIT3
000639 1cac      	.dw XT_DUP
00063a 1c37      	.dw XT_DOLITERAL
00063b fffe      	.dw -2
00063c 1d1f      	.dw XT_LESS
00063d 1c30      	.dw XT_DOCONDBRANCH
00063e 0640      	.dw PFA_QUIT5
00063f 0654      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000640 1c29      	.dw XT_DOBRANCH
000641 0625      	.dw PFA_QUIT
                 PFA_QUIT3:
000642 064d          .dw XT_PROMPTOK
000643 1c29          .dw XT_DOBRANCH
000644 062a          .dw PFA_QUIT2
000645 1c1a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000646 1c00          .dw DO_COLON
                 PFA_PROMPTRDY:
000647 03f4          .dw XT_CR
000648 0389          .dw XT_DOSLITERAL
000649 0002          .dw 2
00064a 203e          .db "> "
00064b 03c0          .dw XT_ITYPE
00064c 1c1a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00064d 1c00          .dw DO_COLON
                 PFA_PROMPTOK:
00064e 0389          .dw XT_DOSLITERAL
00064f 0003          .dw 3
000650 6f20
000651 006b          .db " ok",0
000652 03c0          .dw XT_ITYPE
000653 1c1a          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000654 1c00          .dw DO_COLON
                 PFA_PROMPTERROR:
000655 0389      	.dw XT_DOSLITERAL
000656 0004      	.dw 4
000657 3f20
000658 203f      	.db  " ?? "
000659 03c0          .dw XT_ITYPE
00065a 00ef      	.dw XT_BASE
00065b 1c74      	.dw XT_FETCH
00065c 1cf3      	.dw XT_TO_R
00065d 01c6      	.dw XT_DECIMAL
00065e 0326      	.dw XT_DOT
00065f 0117      	.dw XT_G_IN
000660 1c74      	.dw XT_FETCH
000661 0326      	.dw XT_DOT
000662 1cea      	.dw XT_R_FROM
000663 00ef      	.dw XT_BASE
000664 1c7c      	.dw XT_STORE
000665 1c1a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000666 ff05          .dw $ff05
000667 6170
000668 7375
000669 0065          .db "pause",0
00066a 0620          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00066b 07c8          .dw PFA_DODEFER
                 PFA_PAUSE:
00066c 014d          .dw ram_pause
00066d 0796          .dw XT_RDEFERFETCH
00066e 079b          .dw XT_RDEFERSTORE
                 
                 .dseg
00014d           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00066f ff04          .dw $ff04
000670 6f63
000671 646c          .db "cold"
000672 0666          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000673 0674          .dw PFA_COLD
                 PFA_COLD:
000674 b6a4          in_ r10, MCUSR
000675 24bb          clr r11
000676 2422          clr zerol
000677 2433          clr zeroh
000678 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
00014f           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000679 e4ef          ldi zl, low(ram_user1)
00067a e0f1          ldi zh, high(ram_user1)
00067b 012f          movw upl, zl
                     ; init return stack pointer
00067c ef0f          ldi temp0,low(rstackstart)
00067d bf0d          out_ SPL,temp0
00067e 8304          std Z+4, temp0
00067f e014          ldi temp1,high(rstackstart)
000680 bf1e          out_ SPH,temp1
000681 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000682 eacf          ldi yl,low(stackstart)
000683 83c6          std Z+6, yl
000684 e0d4          ldi yh,high(stackstart)
000685 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000686 e8af          ldi XL, low(PFA_WARM)
000687 e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000688 940c 1c04     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
00068a ff04          .dw $ff04
00068b 6177
00068c 6d72          .db "warm"
00068d 066f          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00068e 1c00          .dw DO_COLON
                 PFA_WARM:
00068f 090a          .dw XT_INITUSER
000690 1c37          .dw XT_DOLITERAL
000691 0765          .dw XT_NOOP
000692 1c37          .dw XT_DOLITERAL
000693 066b          .dw XT_PAUSE
000694 07b3          .dw XT_DEFERSTORE
000695 01e1          .dw XT_TURNKEY
000696 0624          .dw XT_QUIT
000697 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000698 ff03          .dw $ff03
000699 7073
00069a 0030          .db "sp0",0
00069b 068a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00069c 1c69          .dw PFA_DOVALUE1
                 PFA_SP0:
00069d 0006          .dw USER_SP0
00069e 06a5          .dw XT_UVALUEFETCH
00069f 06a9          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0006a0 ff02          .dw $ff02
0006a1 7073          .db "sp"
0006a2 0698          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0006a3 1c52          .dw PFA_DOUSER
                 PFA_SP:
0006a4 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
0006a5 1c00          .dw DO_COLON
                 PFA_UVALUEFETCH:
0006a6 1fc7          .dw XT_FETCHI
0006a7 1c9b          .dw XT_FETCHU
0006a8 1c1a          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
0006a9 1c00          .dw DO_COLON
                 PFA_UVALUESTORE:
0006aa 1fc7          .dw XT_FETCHI
0006ab 1ca3          .dw XT_STOREU
0006ac 1c1a          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0006ad ff03          .dw $ff03
0006ae 7072
0006af 0030          .db "rp0",0
0006b0 06a0          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0006b1 1c00          .dw DO_COLON
                 PFA_RP0:
0006b2 06b5          .dw XT_DORP0
0006b3 1c74          .dw XT_FETCH
0006b4 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0006b5 1c52          .dw PFA_DOUSER
                 PFA_DORP0:
0006b6 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
0006b7 ff05          .dw $ff05
0006b8 6564
0006b9 7470
0006ba 0068          .db "depth",0
0006bb 06ad          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0006bc 1c00          .dw DO_COLON
                 PFA_DEPTH:
0006bd 069c          .dw XT_SP0
0006be 1e8a          .dw XT_SP_FETCH
0006bf 1d9c          .dw XT_MINUS
0006c0 1e0d          .dw XT_2SLASH
0006c1 1e3e          .dw XT_1MINUS
0006c2 1c1a          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
0006c3 ff09          .dw $ff09
0006c4 6e69
0006c5 6574
0006c6 7072
0006c7 6572
0006c8 0074          .db "interpret",0
0006c9 06b7          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
0006ca 1c00          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
0006cb 05e5          .dw XT_PARSENAME ; ( -- addr len )
0006cc 1cb4          .dw XT_QDUP   ; ( -- addr len len )
0006cd 1d5c          .dw XT_GREATERZERO
0006ce 1c30          .dw XT_DOCONDBRANCH
0006cf 06ee          .dw PFA_INTERPRET5
0006d0 1c37          .dw XT_DOLITERAL
0006d1 0026          .dw EE_RECOGNIZERLISTLEN
0006d2 1f5b          .dw XT_FETCHE       ; ( addr len rec # -- )
0006d3 1d34          .dw XT_ZERO
                 
0006d4 1eaa          .dw XT_DOQDO
0006d5 06ea          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
0006d6 0106          .dw XT_2DUP ; ( -- addr len addr len  )
0006d7 1ebd          .dw XT_I    ; ( -- addr len addr len i )
0006d8 1cdc          .dw XT_ROT  ; ( -- addr len len i addr )
0006d9 1cdc          .dw XT_ROT  ; ( -- addr len i addr len )
0006da 1cf3          .dw XT_TO_R
0006db 1cf3          .dw XT_TO_R
                 
0006dc 00f6          .dw XT_CELLS
0006dd 1c37          .dw XT_DOLITERAL
0006de 0028          .dw EE_RECOGNIZERLIST
0006df 1da6          .dw XT_PLUS
0006e0 1f5b          .dw XT_FETCHE
                 
0006e1 1c24          .dw XT_EXECUTE
0006e2 1cea          .dw XT_R_FROM
0006e3 1cea          .dw XT_R_FROM
0006e4 1cdc          .dw XT_ROT
0006e5 1c30          .dw XT_DOCONDBRANCH
0006e6 06e8          .dw PFA_INTERPRET3
0006e7 09c3            .dw XT_LEAVE
                 PFA_INTERPRET3:
0006e8 1ed8          .dw XT_DOLOOP
0006e9 06d6          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
0006ea 010f          .dw XT_2DROP
0006eb 073b          .dw XT_QSTACK
0006ec 1c29          .dw XT_DOBRANCH
0006ed 06cb          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
0006ee 1cd4          .dw xT_DROP
0006ef 1c1a          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
0006f0 ff0a          .dw $ff0a
0006f1 6572
0006f2 2d63
0006f3 6e69
0006f4 6e74
0006f5 6d75          .db "rec-intnum"
0006f6 06c3          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
0006f7 1c00          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
0006f8 04e2          .dw XT_NUMBER 
0006f9 1c30          .dw XT_DOCONDBRANCH 
0006fa 070c          .dw PFA_REC_NONUMBER
                 
0006fb 00e9          .dw XT_STATE
0006fc 1c74          .dw XT_FETCH
0006fd 1c30          .dw XT_DOCONDBRANCH
0006fe 0709          .dw PFA_REC_NUMBER_DONE
0006ff 1c37      	.dw XT_DOLITERAL
000700 0002      	.dw 2
000701 1d11      	.dw XT_EQUAL
000702 1c30      	.dw XT_DOCONDBRANCH
000703 0706      	.dw PFA_REC_NUMBER_SINGLE
000704 1cbf      	.dw XT_SWAP
000705 092a              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
000706 092a              .dw XT_LITERAL
000707 1c29              .dw XT_DOBRANCH
000708 070a              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
000709 1cd4          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
00070a 1d3d          .dw XT_TRUE
00070b 1c1a          .dw XT_EXIT
                 PFA_REC_NONUMBER:
00070c 1d34          .dw XT_ZERO
00070d 1c1a          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
00070e ff08          .dw $ff08
00070f 6572
000710 2d63
000711 6966
000712 646e          .db "rec-find"
000713 06f0          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
000714 1c00          .dw DO_COLON
                 PFA_REC_FIND:
000715 0602          .dw XT_FINDNAME
000716 1cac          .dw XT_DUP
000717 1c30          .dw XT_DOCONDBRANCH 
000718 0727          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
000719 1d5c      	.dw XT_GREATERZERO
00071a 1c30      	.dw XT_DOCONDBRANCH
00071b 071e      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
00071c 1c29      	    .dw XT_DOBRANCH
00071d 0725      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
00071e 00e9      	    .dw XT_STATE
00071f 1c74      	    .dw XT_FETCH
000720 1c30      	    .dw XT_DOCONDBRANCH
000721 0725      	    .dw PFA_REC_FIND_EXECUTE
000722 01a4      	    .dw XT_COMMA
000723 1c29      	    .dw XT_DOBRANCH
000724 0726      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
000725 1c24          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
000726 1d3d          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000727 1c1a          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
000728 ff0c          .dw $ff0c
000729 6572
00072a 2d63
00072b 6f6e
00072c 6674
00072d 756f
00072e 646e          .db "rec-notfound"
00072f 070e          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000730 1c00          .dw DO_COLON
                 PFA_REC_NOTFOUND:
000731 0419          .dw XT_TYPE
000732 1c37          .dw XT_DOLITERAL
000733 fff3          .dw -13
000734 0455          .dw XT_THROW
000735 1c1a          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
000736 ff06          .dw $ff06
000737 733f
000738 6174
000739 6b63          .db "?stack"
00073a 0728          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00073b 1c00          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
00073c 06bc          .dw XT_DEPTH
00073d 1d2d          .dw XT_LESSZERO
00073e 1c30          .dw XT_DOCONDBRANCH
00073f 0743          .dw PFA_QSTACK1
000740 1c37            .dw XT_DOLITERAL
000741 fffc            .dw -4
000742 0455            .dw XT_THROW
                 PFA_QSTACK1:
000743 1c1a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
000744 ff03          .dw $ff03
000745 6576
000746 0072          .db "ver",0
000747 0736          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
000748 1c00          .dw DO_COLON
                 PFA_VER:
000749 0b47          .dw XT_ENV_FORTHNAME
00074a 03c0          .dw XT_ITYPE
00074b 0401          .dw XT_SPACE
00074c 00ef          .dw XT_BASE
00074d 1c74          .dw XT_FETCH
00074e 1cf3          .dw XT_TO_R
00074f 01c6          .dw XT_DECIMAL
                 
000750 0b55          .dw XT_ENV_FORTHVERSION
000751 1f29          .dw XT_S2D
000752 02c0          .dw XT_L_SHARP
000753 02c8          .dw XT_SHARP
000754 1c37          .dw XT_DOLITERAL
000755 002e          .dw '.'
000756 02b1          .dw XT_HOLD
000757 02de          .dw XT_SHARP_S
000758 02e9          .dw XT_SHARP_G
000759 1cea          .dw XT_R_FROM
00075a 00ef          .dw XT_BASE
00075b 1c7c          .dw XT_STORE
                 
00075c 0419          .dw XT_TYPE
00075d 0401          .dw XT_SPACE
00075e 0b5d          .dw XT_ENV_CPU
00075f 03c0          .dw XT_ITYPE
000760 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000761 ff04          .dw $ff04
000762 6f6e
000763 706f          .db "noop"
000764 0744          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000765 0766          .dw PFA_NOOP
                 PFA_NOOP:
000766 940c 1c04     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000768 ff06          .dw $ff06
000769 6e75
00076a 7375
00076b 6465          .db "unused"
00076c 0761          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
00076d 1c00          .dw DO_COLON
                 PFA_UNUSED:
00076e 069c          .dw XT_SP0
00076f 015d          .dw XT_HERE
000770 1d9c          .dw XT_MINUS
000771 1c1a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
000772 0002          .dw $0002
000773 6f74          .db "to"
000774 0768          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000775 1c00          .dw DO_COLON
                 PFA_TO:
000776 0428          .dw XT_TICK
000777 1e38          .dw XT_1PLUS  		; to body
000778 00e9          .dw XT_STATE
000779 1c74          .dw XT_FETCH
00077a 1c30          .dw XT_DOCONDBRANCH
00077b 0786          .dw PFA_TO1
00077c 0199          .dw XT_COMPILE
00077d 0780          .dw XT_DOTO
00077e 01a4          .dw XT_COMMA
00077f 1c1a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
000780 1c00          .dw DO_COLON
                 PFA_DOTO:
000781 1cea          .dw XT_R_FROM
000782 1cac          .dw XT_DUP
000783 1e38          .dw XT_1PLUS
000784 1cf3          .dw XT_TO_R
000785 1fc7          .dw XT_FETCHI
                 PFA_TO1:
000786 1cac          .dw XT_DUP
000787 1e38          .dw XT_1PLUS
000788 1e38          .dw XT_1PLUS
000789 1fc7          .dw XT_FETCHI
00078a 1c24          .dw XT_EXECUTE
00078b 1c1a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00078c 1c00          .dw DO_COLON
                 PFA_EDEFERFETCH:
00078d 1e38          .dw XT_1PLUS ; >body
00078e 1fc7          .dw XT_FETCHI
00078f 1f5b          .dw XT_FETCHE
000790 1c1a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000791 1c00          .dw DO_COLON
                 PFA_EDEFERSTORE:
000792 1e38          .dw XT_1PLUS
000793 1fc7          .dw XT_FETCHI
000794 1f37          .dw XT_STOREE
000795 1c1a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000796 1c00          .dw DO_COLON
                 PFA_RDEFERFETCH:
000797 1e38          .dw XT_1PLUS ; >body
000798 1fc7          .dw XT_FETCHI
000799 1c74          .dw XT_FETCH
00079a 1c1a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00079b 1c00          .dw DO_COLON
                 PFA_RDEFERSTORE:
00079c 1e38          .dw XT_1PLUS
00079d 1fc7          .dw XT_FETCHI
00079e 1c7c          .dw XT_STORE
00079f 1c1a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
0007a0 1c00          .dw DO_COLON
                 PFA_UDEFERFETCH:
0007a1 1e38          .dw XT_1PLUS ; >body
0007a2 1fc7          .dw XT_FETCHI
0007a3 1f17          .dw XT_UP_FETCH
0007a4 1da6          .dw XT_PLUS
0007a5 1c74          .dw XT_FETCH
0007a6 1c1a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
0007a7 1c00          .dw DO_COLON
                 PFA_UDEFERSTORE:
0007a8 1e38          .dw XT_1PLUS
0007a9 1fc7          .dw XT_FETCHI
0007aa 1f17          .dw XT_UP_FETCH
0007ab 1da6          .dw XT_PLUS
0007ac 1c7c          .dw XT_STORE
0007ad 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
0007ae ff06          .dw $ff06
0007af 6564
0007b0 6566
0007b1 2172          .db "defer!"
0007b2 0772          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
0007b3 1c00          .dw DO_COLON
                 PFA_DEFERSTORE:
0007b4 1cac          .dw XT_DUP
0007b5 1c37          .dw XT_DOLITERAL
0007b6 0003          .dw 3
0007b7 1da6          .dw XT_PLUS   ; >body 2 +
0007b8 1fc7          .dw XT_FETCHI
0007b9 1c24          .dw XT_EXECUTE
0007ba 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
0007bb ff06          .dw $ff06
0007bc 6564
0007bd 6566
0007be 4072          .db "defer@"
0007bf 07ae          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
0007c0 1c00          .dw DO_COLON
                 PFA_DEFERFETCH:
0007c1 1cac          .dw XT_DUP
0007c2 1e38          .dw XT_1PLUS ; >body
0007c3 1e38          .dw XT_1PLUS 
0007c4 1fc7          .dw XT_FETCHI
0007c5 1c24          .dw XT_EXECUTE
0007c6 1c1a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
0007c7 07c8          .dw PFA_DODEFER
                 PFA_DODEFER:
0007c8 940e 0a2e     call_ DO_DODOES
0007ca 1cac          .dw XT_DUP
0007cb 1e3e          .dw XT_1MINUS
0007cc 1cbf          .dw XT_SWAP
0007cd 1e38          .dw XT_1PLUS
0007ce 1fc7          .dw XT_FETCHI
0007cf 1c24          .dw XT_EXECUTE 
0007d0 1c24          .dw XT_EXECUTE
0007d1 1c1a          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0007d2 ff0f          .dw $ff0f
0007d3 6573
0007d4 7261
0007d5 6863
0007d6 772d
0007d7 726f
0007d8 6c64
0007d9 7369
0007da 0074          .db "search-wordlist",0
0007db 07bb          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0007dc 1c00          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0007dd 1d34          .dw XT_ZERO
0007de 1cbf          .dw XT_SWAP
0007df 1c37          .dw XT_DOLITERAL
0007e0 07eb          .dw XT_ISWORD
0007e1 1cbf          .dw XT_SWAP
0007e2 0822          .dw XT_TRAVERSEWORDLIST
0007e3 1cac          .dw XT_DUP
0007e4 1d18          .dw XT_EQUALZERO
0007e5 1c30          .dw XT_DOCONDBRANCH
0007e6 07ea          .dw PFA_SEARCH_WORDLIST1
0007e7 010f             .dw XT_2DROP
0007e8 1cd4             .dw XT_DROP
0007e9 1d34             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
0007ea 1c1a          .dw XT_EXIT
                 
                 XT_ISWORD:
0007eb 1c00          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
0007ec 1cf3          .dw XT_TO_R
0007ed 1cf3          .dw XT_TO_R
0007ee 0106          .dw XT_2DUP
0007ef 1cea          .dw XT_R_FROM
0007f0 1cdc          .dw XT_ROT
0007f1 1cdc          .dw XT_ROT
0007f2 1cfc          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
0007f3 0811          .dw XT_NAME2STRING
0007f4 083d          .dw XT_ICOMPARE      ; (-- addr len 0 f )
0007f5 1c30          .dw XT_DOCONDBRANCH
0007f6 0805          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
0007f7 010f            .dw XT_2DROP
0007f8 1cd4            .dw XT_DROP
                       ; ... get the XT ...
0007f9 1cfc            .dw XT_R_FETCH
0007fa 0be8            .dw XT_NFA2LFA
0007fb 1e38            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
0007fc 1d3d            .dw XT_TRUE
0007fd 1cea            .dw XT_R_FROM
0007fe 1fc7            .dw XT_FETCHI
0007ff 1d5c            .dw XT_GREATERZERO
000800 1c30            .dw XT_DOCONDBRANCH
000801 0803            .dw PFA_ISWORD1
000802 023c               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
000803 1d34            .dw XT_ZERO       ; finish traverse-wordlist
000804 1c1a            .dw XT_EXIT
                 PFA_ISWORD3:
000805 1cea          .dw XT_R_FROM
000806 1cd4          .dw XT_DROP
000807 1d3d          .dw XT_TRUE         ; maybe next word
000808 1c1a          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
000809 ff0b          .dw $ff0b
00080a 616e
00080b 656d
00080c 733e
00080d 7274
00080e 6e69
00080f 0067          .db "name>string",0
000810 07d2          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000811 1c00          .dw DO_COLON
                 PFA_NAME2STRING:
000812 03eb          .dw XT_ICOUNT   ; ( -- addr n )
000813 1c37          .dw XT_DOLITERAL
000814 00ff          .dw $00FF
000815 1e1c          .dw XT_AND      ; mask immediate bit
000816 1c1a          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000817 ff11          .dw $ff11
000818 7274
000819 7661
00081a 7265
00081b 6573
00081c 772d
00081d 726f
00081e 6c64
00081f 7369
000820 0074          .db "traverse-wordlist",0
000821 0809          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000822 1c00          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
000823 1f5b          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000824 1cac          .dw XT_DUP           ; ( -- xt nt nt )
000825 1c30          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000826 0835          .dw PFA_TRAVERSEWORDLIST2       ;
000827 0106          .dw XT_2DUP
000828 1cf3          .dw XT_TO_R
000829 1cf3          .dw XT_TO_R
00082a 1cbf          .dw XT_SWAP
00082b 1c24          .dw XT_EXECUTE
00082c 1cea          .dw XT_R_FROM
00082d 1cea          .dw XT_R_FROM
00082e 1cdc          .dw XT_ROT
00082f 1c30          .dw XT_DOCONDBRANCH
000830 0835          .dw PFA_TRAVERSEWORDLIST2
000831 0be8          .dw XT_NFA2LFA
000832 1fc7          .dw XT_FETCHI        ; ( -- addr )
000833 1c29          .dw XT_DOBRANCH      ; ( -- addr )
000834 0824          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000835 010f          .dw XT_2DROP
000836 1c1a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
000837 ff08          .dw $ff08
000838 6369
000839 6d6f
00083a 6170
00083b 6572          .db "icompare"
00083c 0817          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00083d 1c00          .dw DO_COLON
                 PFA_ICOMPARE:
00083e 1cf3          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00083f 1cca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000840 1cea          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000841 1d07          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000842 1c30          .dw XT_DOCONDBRANCH
000843 0848          .dw PFA_ICOMPARE_SAMELEN
000844 010f            .dw XT_2DROP
000845 1cd4            .dw XT_DROP
000846 1d34            .dw XT_ZERO
000847 1c1a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000848 1cbf          .dw XT_SWAP ; ( -- r-addr f-addr len )
000849 1d34          .dw XT_ZERO
00084a 1eaa          .dw XT_DOQDO
00084b 0869          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00084c 1cca          .dw XT_OVER
00084d 1c74          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
00084e 1cca          .dw XT_OVER
00084f 1fc7          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000850 1cac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000851 1c37          .dw XT_DOLITERAL
000852 0100          .dw $100
000853 1d46          .dw XT_ULESS
000854 1c30          .dw XT_DOCONDBRANCH
000855 085a          .dw PFA_ICOMPARE_LASTCELL
000856 1cbf          .dw XT_SWAP
000857 1c37          .dw XT_DOLITERAL
000858 00ff          .dw $00FF
000859 1e1c          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00085a 1d07          .dw XT_NOTEQUAL
00085b 1c30          .dw XT_DOCONDBRANCH
00085c 0861          .dw PFA_ICOMPARE_NEXTLOOP
00085d 010f          .dw XT_2DROP
00085e 1d34          .dw XT_ZERO
00085f 1ee7          .dw XT_UNLOOP
000860 1c1a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000861 1e38          .dw XT_1PLUS
000862 1cbf          .dw XT_SWAP
000863 00fe          .dw XT_CELLPLUS
000864 1cbf          .dw XT_SWAP
000865 1c37          .dw XT_DOLITERAL
000866 0002          .dw 2
000867 1ebe          .dw XT_DOPLUSLOOP
000868 084c          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000869 010f          .dw XT_2DROP
00086a 1d3d          .dw XT_TRUE
00086b 1c1a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
00086c ff01          .dw $ff01
00086d 002a          .db "*",0
00086e 0837          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00086f 1c00          .dw DO_COLON
                 PFA_STAR:
000870 1daf          .dw XT_MSTAR
000871 0881          .dw XT_D2S
000872 1c1a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000873 ff01          .dw $FF01
000874 006a          .db "j",0
000875 086c          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000876 1c00          .dw DO_COLON
                 PFA_J:
000877 1e73          .dw XT_RP_FETCH
000878 1c37          .dw XT_DOLITERAL
000879 0009          .dw 9
00087a 1da6          .dw XT_PLUS
00087b 1c74          .dw XT_FETCH
00087c 1c1a          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
00087d ff03          .dw $ff03
00087e 3e64
00087f 0073          .db "d>s",0
000880 0873          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
000881 1c00          .dw DO_COLON
                 PFA_D2S:
000882 1cd4          .dw XT_DROP
000883 1c1a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000884 ff04          .dw $ff04
000885 6164
000886 7362          .db "dabs"
000887 087d          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000888 1c00          .dw DO_COLON
                 PFA_DABS:
000889 1cac          .dw XT_DUP
00088a 1d2d          .dw XT_LESSZERO
00088b 1c30          .dw XT_DOCONDBRANCH
00088c 088e          .dw PFA_DABS1
00088d 0895          .dw XT_DNEGATE
                 PFA_DABS1:
00088e 1c1a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00088f ff07          .dw $ff07
000890 6e64
000891 6765
000892 7461
000893 0065          .db "dnegate",0
000894 0884          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000895 1c00          .dw DO_COLON
                 PFA_DNEGATE:
000896 0ccd          .dw XT_DINVERT
000897 1c37          .dw XT_DOLITERAL
000898 0001          .dw 1
000899 1d34          .dw XT_ZERO
00089a 0cdb          .dw XT_DPLUS
00089b 1c1a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00089c ff05          .dw $ff05
00089d 6d63
00089e 766f
00089f 0065          .db "cmove",0
0008a0 088f          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
0008a1 08a2          .dw PFA_CMOVE
                 PFA_CMOVE:
0008a2 93bf          push xh
0008a3 93af          push xl
0008a4 91e9          ld zl, Y+
0008a5 91f9          ld zh, Y+ ; addr-to
0008a6 91a9          ld xl, Y+
0008a7 91b9          ld xh, Y+ ; addr-from
0008a8 2f09          mov temp0, tosh
0008a9 2b08          or temp0, tosl
0008aa f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
0008ab 911d          ld temp1, X+
0008ac 9311          st Z+, temp1
0008ad 9701          sbiw tosl, 1
0008ae f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
0008af 91af          pop xl
0008b0 91bf          pop xh
0008b1 9189
0008b2 9199          loadtos
0008b3 940c 1c04     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
0008b5 ff05          .dw $ff05
0008b6 7332
0008b7 6177
0008b8 0070          .db "2swap",0
0008b9 089c          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
0008ba 1c00          .dw DO_COLON
                 PFA_2SWAP:
0008bb 1cdc          .dw XT_ROT
0008bc 1cf3          .dw XT_TO_R
0008bd 1cdc          .dw XT_ROT
0008be 1cea          .dw XT_R_FROM
0008bf 1c1a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
0008c0 ff03          .dw $ff03
0008c1 6974
0008c2 0062          .db "tib",0
0008c3 08b5          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0008c4 1c42          .dw PFA_DOVARIABLE
                 PFA_TIB:
0008c5 0175          .dw ram_tib
                     
                 .dseg
000175           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
0008c6 ff0a          .dw $ff0a
0008c7 6572
0008c8 6966
0008c9 6c6c
0008ca 742d
0008cb 6269          .db "refill-tib"
0008cc 08c0          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
0008cd 1c00          .dw DO_COLON
                 PFA_REFILLTIB:
0008ce 08c4          .dw XT_TIB
0008cf 1c37          .dw XT_DOLITERAL
0008d0 0064          .dw TIBSIZE
0008d1 0486          .dw XT_ACCEPT
0008d2 011d          .dw XT_NUMBERTIB
0008d3 1c7c          .dw XT_STORE
0008d4 1d34          .dw XT_ZERO
0008d5 0117          .dw XT_G_IN
0008d6 1c7c          .dw XT_STORE
0008d7 1c37          .dw XT_DOLITERAL
0008d8 ffff          .dw -1
0008d9 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0008da ff0a          .dw $FF0A
0008db 6f73
0008dc 7275
0008dd 6563
0008de 742d
0008df 6269          .db "source-tib"
0008e0 08c6          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0008e1 1c00          .dw DO_COLON
                 PFA_SOURCETIB:
0008e2 08c4          .dw XT_TIB
0008e3 011d          .dw XT_NUMBERTIB
0008e4 1c74          .dw XT_FETCH
0008e5 1c1a          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0008e6 ff07        .dw $ff07
0008e7 6565
0008e8 752d
0008e9 6573
0008ea 0072        .db "ee-user",0
0008eb 08da        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
0008ec 1c42        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
0008ed 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0008ee ff06        .dw $ff06
0008ef 6565
0008f0 723e
0008f1 6d61        .db "ee>ram"
0008f2 08e6        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0008f3 1c00        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0008f4 1d34          .dw XT_ZERO
0008f5 1eaa          .dw XT_DOQDO
0008f6 0901          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
0008f7 1cca          .dw XT_OVER
0008f8 1f5b          .dw XT_FETCHE
0008f9 1cca          .dw XT_OVER
0008fa 1c7c          .dw XT_STORE
0008fb 00fe          .dw XT_CELLPLUS
0008fc 1cbf          .dw XT_SWAP
0008fd 00fe          .dw XT_CELLPLUS
0008fe 1cbf          .dw XT_SWAP
0008ff 1ed8          .dw XT_DOLOOP
000900 08f7          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000901 010f          .dw XT_2DROP
000902 1c1a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000903 ff09        .dw $ff09
000904 6e69
000905 7469
000906 752d
000907 6573
000908 0072        .db "init-user",0
000909 08ee        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
00090a 1c00        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
00090b 08ec          .dw XT_EEUSER
00090c 1f17          .dw XT_UP_FETCH
00090d 1c37          .dw XT_DOLITERAL
00090e 001c          .dw SYSUSERSIZE
00090f 1e0d          .dw XT_2SLASH
000910 08f3          .dw XT_EE2RAM
000911 1c1a          .dw XT_EXIT
                 .include "device.inc"
                 
                 ; Built using part description XML file version 300
                 ; generated automatically, no not edit
                 
                 ; ********
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 
                 ; ********
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 
                 ; ********
                 .if WANT_BOOT_LOAD == 1
                 .endif
                 
                 ; ********
                 .if WANT_CPU == 1
                 .endif
                 
                 ; ********
                 .if WANT_EEPROM == 1
                 .endif
                 
                 ; ********
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 
                 ; ********
                 .if WANT_JTAG == 1
                 .endif
                 
                 ; ********
                 .if WANT_LCD == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTA == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTB == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTC == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTD == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTE == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTF == 1
                 .endif
                 
                 ; ********
                 .if WANT_PORTG == 1
                 .endif
                 
                 ; ********
                 .if WANT_SPI == 1
                 ; ********
                 ; ( -- addr ) System Constant
                 ; R( -- )
                 ; SPI Control Register
                 VE_SPCR:
000912 ff04      	.dw $ff04
000913 5053
000914 5243      	.db "SPCR"
000915 0903      	.dw VE_HEAD
                 	.set VE_HEAD=VE_SPCR
                 XT_SPCR:
000916 1c42      	.dw PFA_DOVARIABLE
                 PFA_SPCR:
000917 004c      	.dw $4C
                 ; ( -- addr ) System Constant
                 ; R( -- )
                 ; SPI Data Register
                 VE_SPDR:
000918 ff04      	.dw $ff04
000919 5053
00091a 5244      	.db "SPDR"
00091b 0912      	.dw VE_HEAD
                 	.set VE_HEAD=VE_SPDR
                 XT_SPDR:
00091c 1c42      	.dw PFA_DOVARIABLE
                 PFA_SPDR:
00091d 004e      	.dw $4E
                 ; ( -- addr ) System Constant
                 ; R( -- )
                 ; SPI Status Register
                 VE_SPSR:
00091e ff04      	.dw $ff04
00091f 5053
000920 5253      	.db "SPSR"
000921 0918      	.dw VE_HEAD
                 	.set VE_HEAD=VE_SPSR
                 XT_SPSR:
000922 1c42      	.dw PFA_DOVARIABLE
                 PFA_SPSR:
000923 004d      	.dw $4D
                 
                 .endif
                 
                 ; ********
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 
                 ; ********
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 
                 ; ********
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 
                 ; ********
                 .if WANT_USART0 == 1
                 .endif
                 
                 ; ********
                 .if WANT_USI == 1
                 .endif
                 
                 ; ********
                 .if WANT_WATCHDOG == 1
                 .endif
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
000924 0007          .dw $0007
000925 696c
000926 6574
000927 6172
000928 006c          .db "literal",0
000929 091e          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
00092a 1c00          .dw DO_COLON
                 PFA_LITERAL:
00092b 0199          .dw XT_COMPILE
00092c 1c37          .dw XT_DOLITERAL
00092d 01a4          .dw XT_COMMA
00092e 1c1a          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
00092f 0008        .dw $0008
000930 6c73
000931 7469
000932 7265
000933 6c61        .db "sliteral"
000934 0924        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000935 1c00          .dw DO_COLON
                 PFA_SLITERAL:
000936 0199          .dw XT_COMPILE
000937 0389          .dw XT_DOSLITERAL    ; ( -- addr n)
000938 039c          .dw XT_SCOMMA
000939 1c1a          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
00093a 1c00          .dw DO_COLON
                 PFA_GMARK:
00093b 014d          .dw XT_DP
00093c 0199          .dw XT_COMPILE
00093d ffff          .dw -1           ; ffff does not erase flash
00093e 1c1a          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00093f 1c00          .dw DO_COLON
                 PFA_GRESOLVE:
000940 073b          .dw XT_QSTACK
000941 014d          .dw XT_DP
000942 1cbf          .dw XT_SWAP
000943 1f6f          .dw XT_STOREI
000944 1c1a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000945 1c00          .dw DO_COLON
                 PFA_LMARK:
000946 014d          .dw XT_DP
000947 1c1a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000948 1c00          .dw DO_COLON
                 PFA_LRESOLVE:
000949 073b          .dw XT_QSTACK
00094a 01a4          .dw XT_COMMA
00094b 1c1a          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
00094c 0005          .dw $0005
00094d 6861
00094e 6165
00094f 0064          .db "ahead",0
000950 092f          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000951 1c00          .dw DO_COLON
                 PFA_AHEAD:
000952 0199          .dw XT_COMPILE
000953 1c29          .dw XT_DOBRANCH
000954 093a          .dw XT_GMARK
000955 1c1a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
000956 0002          .dw $0002
000957 6669          .db "if"
000958 094c          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000959 1c00          .dw DO_COLON
                 PFA_IF:
00095a 0199          .dw XT_COMPILE
00095b 1c30          .dw XT_DOCONDBRANCH
00095c 093a          .dw XT_GMARK
00095d 1c1a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
00095e 0004          .dw $0004
00095f 6c65
000960 6573          .db "else"
000961 0956          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000962 1c00          .dw DO_COLON
                 PFA_ELSE:
000963 0199          .dw XT_COMPILE
000964 1c29          .dw XT_DOBRANCH
000965 093a          .dw XT_GMARK
000966 1cbf          .dw XT_SWAP
000967 093f          .dw XT_GRESOLVE
000968 1c1a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000969 0004          .dw $0004
00096a 6874
00096b 6e65          .db "then"
00096c 095e          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00096d 1c00          .dw DO_COLON
                 PFA_THEN:
00096e 093f          .dw XT_GRESOLVE
00096f 1c1a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000970 0005          .dw $0005
000971 6562
000972 6967
000973 006e          .db "begin",0
000974 0969          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000975 1c00          .dw DO_COLON
                 PFA_BEGIN:
000976 0945          .dw XT_LMARK
000977 1c1a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
000978 0005          .dw $0005
000979 6877
00097a 6c69
00097b 0065          .db "while",0
00097c 0970          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00097d 1c00          .dw DO_COLON
                 PFA_WHILE:
00097e 0199          .dw XT_COMPILE
00097f 1c30          .dw XT_DOCONDBRANCH
000980 093a          .dw XT_GMARK
000981 1cbf          .dw XT_SWAP
000982 1c1a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
000983 0006          .dw $0006
000984 6572
000985 6570
000986 7461          .db "repeat"
000987 0978          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000988 1c00          .dw DO_COLON
                 PFA_REPEAT:
000989 099b          .dw XT_AGAIN
00098a 093f          .dw XT_GRESOLVE
00098b 1c1a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
00098c 0005          .dw $0005
00098d 6e75
00098e 6974
00098f 006c          .db "until",0
000990 0983          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000991 1c00          .dw DO_COLON
                 PFA_UNTIL:
000992 0199          .dw XT_COMPILE
000993 1c30          .dw XT_DOCONDBRANCH
000994 0948          .dw XT_LRESOLVE
000995 1c1a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
000996 0005          .dw $0005
000997 6761
000998 6961
000999 006e          .db "again",0
00099a 098c          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00099b 1c00          .dw DO_COLON
                 PFA_AGAIN:
00099c 0199          .dw XT_COMPILE
00099d 1c29          .dw XT_DOBRANCH
00099e 0948          .dw XT_LRESOLVE
00099f 1c1a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
0009a0 0002          .dw $0002
0009a1 6f64          .db "do"
0009a2 0996          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0009a3 1c00          .dw DO_COLON
                 PFA_DO:
0009a4 0199          .dw XT_COMPILE
0009a5 1e98          .dw XT_DODO
0009a6 093a          .dw XT_GMARK
0009a7 0945          .dw XT_LMARK
0009a8 1c1a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
0009a9 0004          .dw $0004
0009aa 6f6c
0009ab 706f          .db "loop"
0009ac 09a0          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0009ad 1c00          .dw DO_COLON
                 PFA_LOOP:
0009ae 0199          .dw XT_COMPILE
0009af 1ed8          .dw XT_DOLOOP
0009b0 0948          .dw XT_LRESOLVE
0009b1 093f          .dw XT_GRESOLVE
0009b2 1c1a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
0009b3 0005          .dw $0005
0009b4 6c2b
0009b5 6f6f
0009b6 0070          .db "+loop",0
0009b7 09a9          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0009b8 1c00          .dw DO_COLON
                 PFA_PLUSLOOP:
0009b9 0199          .dw XT_COMPILE
0009ba 1ebe          .dw XT_DOPLUSLOOP
0009bb 0948          .dw XT_LRESOLVE
0009bc 093f          .dw XT_GRESOLVE
0009bd 1c1a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
0009be ff05         .dw $FF05
0009bf 656c
0009c0 7661
0009c1 0065         .db "leave",0
0009c2 09b3         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0009c3 09c4          .dw PFA_LEAVE
                 PFA_LEAVE:
0009c4 910f          pop temp0  ; drop limit and counter from returnstack
0009c5 911f          pop temp1
0009c6 910f          pop temp0
0009c7 911f          pop temp1
0009c8 91af          pop xl
0009c9 91bf          pop xh
0009ca 940c 1c04     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
0009cc 0003          .dw $0003
0009cd 643f
0009ce 006f          .db "?do",0
0009cf 09be          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0009d0 1c00          .dw DO_COLON
                 PFA_QDO:
0009d1 0199          .dw XT_COMPILE
0009d2 1eaa          .dw XT_DOQDO
0009d3 093a          .dw XT_GMARK
0009d4 0945          .dw XT_LMARK
0009d5 1c1a          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0009d6 ff06          .dw $ff06
0009d7 7263
0009d8 6165
0009d9 6574          .db "create"
0009da 09cc          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0009db 1c00          .dw DO_COLON
                 PFA_CREATE:
0009dc 0172          .dw XT_DOCREATE
0009dd 0a0a          .dw XT_REVEAL
0009de 0199          .dw XT_COMPILE
0009df 1c4c          .dw PFA_DOCONSTANT
0009e0 1c1a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0009e1 ff06          .dw $ff06
0009e2 6568
0009e3 6461
0009e4 7265          .db "header"
0009e5 09d6          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0009e6 1c00          .dw DO_COLON
                 PFA_HEADER:
0009e7 014d          .dw XT_DP           ; the new Name Field
0009e8 1cf3          .dw XT_TO_R
0009e9 1cf3          .dw XT_TO_R		; ( R: NFA WID )
0009ea 1cac          .dw XT_DUP    
0009eb 1d5c          .dw XT_GREATERZERO 
0009ec 1c30          .dw XT_DOCONDBRANCH
0009ed 09f8          .dw PFA_HEADER1
0009ee 1cac          .dw XT_DUP
0009ef 1c37          .dw XT_DOLITERAL
0009f0 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0009f1 1e25          .dw XT_OR
0009f2 03a0          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0009f3 1cea          .dw XT_R_FROM
0009f4 1f5b          .dw XT_FETCHE
0009f5 01a4          .dw XT_COMMA
0009f6 1cea          .dw XT_R_FROM
0009f7 1c1a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0009f8 1c37          .dw XT_DOLITERAL
0009f9 fff0          .dw -16
0009fa 0455          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0009fb ff07          .dw $ff07
0009fc 6c77
0009fd 6373
0009fe 706f
0009ff 0065          .db "wlscope",0
000a00 09e1          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000a01 07c8          .dw PFA_DODEFER
                 PFA_WLSCOPE:
000a02 0034          .dw EE_WLSCOPE
000a03 078c          .dw XT_EDEFERFETCH
000a04 0791          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000a05 ff06          .dw $ff06
000a06 6572
000a07 6576
000a08 6c61          .db "reveal"
000a09 09fb          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000a0a 1c00          .dw DO_COLON
                 PFA_REVEAL:
000a0b 1c37          .dw XT_DOLITERAL
000a0c 0147          .dw COLON_SMUDGE+0
000a0d 1c74          .dw XT_FETCH
000a0e 1cb4          .dw XT_QDUP
000a0f 1c30          .dw XT_DOCONDBRANCH
000a10 0a19          .dw PFA_REVEAL1
                 ;
000a11 1c37          .dw XT_DOLITERAL
000a12 0149          .dw COLON_SMUDGE+2
000a13 1c74          .dw XT_FETCH		; ( NFA WID )
000a14 1f37          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000a15 1d34          .dw XT_ZERO
000a16 1c37          .dw XT_DOLITERAL
000a17 0147          .dw COLON_SMUDGE+0
000a18 1c7c          .dw XT_STORE
                 PFA_REVEAL1:
000a19 1c1a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000a1a ff06          .dw $ff06
000a1b 616c
000a1c 6574
000a1d 7473          .db "latest"
000a1e 0a05          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000a1f 1c42          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000a20 01d9          .dw ram_LATEST
                 
                 .dseg
0001d9           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000a21 0005          .dw $0005
000a22 6f64
000a23 7365
000a24 003e          .db "does>",0
000a25 0a1a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000a26 1c00          .dw DO_COLON
                 PFA_DOES:
000a27 0199          .dw XT_COMPILE
000a28 0a39          .dw XT_DODOES
000a29 0199          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000a2a 940e          .dw $940e       ; the address of this compiled
000a2b 0199          .dw XT_COMPILE  ; code will replace the XT of the 
000a2c 0a2e          .dw DO_DODOES   ; word that CREATE created
000a2d 1c1a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000a2e 939a
000a2f 938a          savetos
000a30 01cb          movw tosl, wl
000a31 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000a32 917f          pop wh
000a33 916f          pop wl
                 
000a34 93bf          push XH
000a35 93af          push XL
000a36 01db          movw XL, wl
000a37 940c 1c04     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000a39 1c00          .dw DO_COLON
                 PFA_DODOES:
000a3a 1cea          .dw XT_R_FROM
000a3b 1c37          .dw XT_DOLITERAL
000a3c 0149          .dw COLON_SMUDGE+2
000a3d 1c74          .dw XT_FETCH
000a3e 1f5b          .dw XT_FETCHE
000a3f 0be8          .dw XT_NFA2LFA
000a40 1e38          .dw XT_1PLUS   ; lfa>xt
                 
000a41 1f6f          .dw XT_STOREI
000a42 1c1a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000a43 ff01          .dw $ff01
000a44 003a          .db ":",0
000a45 0a21          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000a46 1c00          .dw DO_COLON
                 PFA_COLON:
000a47 0172          .dw XT_DOCREATE
000a48 014d          .dw XT_DP
000a49 0a1f          .dw XT_LATEST
000a4a 1c7c          .dw XT_STORE
000a4b 0199          .dw XT_COMPILE
000a4c 1c00          .dw DO_COLON
000a4d 0a6a          .dw XT_RBRACKET
000a4e 1c1a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000a4f ff07          .dw $ff07
000a50 6e3a
000a51 6e6f
000a52 6d61
000a53 0065          .db ":noname",0
000a54 0a43          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000a55 1c00          .dw DO_COLON
                 PFA_COLONNONAME:
000a56 014d          .dw XT_DP
000a57 1cac          .dw XT_DUP
000a58 0a1f          .dw XT_LATEST
000a59 1c7c          .dw XT_STORE
                 
000a5a 0199          .dw XT_COMPILE
000a5b 1c00          .dw DO_COLON
                 
000a5c 0a6a          .dw XT_RBRACKET
000a5d 1c1a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000a5e 0001          .dw $0001
000a5f 003b          .db $3b,0
000a60 0a4f          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000a61 1c00          .dw DO_COLON
                 PFA_SEMICOLON:
000a62 0199          .dw XT_COMPILE
000a63 1c1a          .dw XT_EXIT
000a64 0a73          .dw XT_LBRACKET
000a65 0a0a          .dw XT_REVEAL
000a66 1c1a          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000a67 ff01          .dw $ff01
000a68 005d          .db "]",0
000a69 0a5e          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000a6a 1c00          .dw DO_COLON
                 PFA_RBRACKET:
000a6b 1c37          .dw XT_DOLITERAL
000a6c 0001          .dw 1
000a6d 00e9          .dw XT_STATE
000a6e 1c7c          .dw XT_STORE
000a6f 1c1a          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000a70 0001          .dw $0001
000a71 005b          .db "[",0
000a72 0a67          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000a73 1c00          .dw DO_COLON
                 PFA_LBRACKET:
000a74 1d34          .dw XT_ZERO
000a75 00e9          .dw XT_STATE
000a76 1c7c          .dw XT_STORE
000a77 1c1a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000a78 ff08          .dw $ff08
000a79 6176
000a7a 6972
000a7b 6261
000a7c 656c          .db "variable"
000a7d 0a70          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000a7e 1c00          .dw DO_COLON
                 PFA_VARIABLE:
000a7f 015d          .dw XT_HERE
000a80 0a8b          .dw XT_CONSTANT
000a81 1c37          .dw XT_DOLITERAL
000a82 0002          .dw 2
000a83 0166          .dw XT_ALLOT
000a84 1c1a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000a85 ff08          .dw $ff08
000a86 6f63
000a87 736e
000a88 6174
000a89 746e          .db "constant"
000a8a 0a78          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000a8b 1c00          .dw DO_COLON
                 PFA_CONSTANT:
000a8c 0172          .dw XT_DOCREATE
000a8d 0a0a          .dw XT_REVEAL
000a8e 0199          .dw XT_COMPILE
000a8f 1c42          .dw PFA_DOVARIABLE
000a90 01a4          .dw XT_COMMA
000a91 1c1a          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000a92 ff04          .dw $ff04
000a93 7375
000a94 7265          .db "user"
000a95 0a85          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000a96 1c00          .dw DO_COLON
                 PFA_USER:
000a97 0172          .dw XT_DOCREATE
000a98 0a0a          .dw XT_REVEAL
                 
000a99 0199          .dw XT_COMPILE
000a9a 1c52          .dw PFA_DOUSER
000a9b 01a4          .dw XT_COMMA
000a9c 1c1a          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000a9d ff05          .dw $ff05
000a9e 6176
000a9f 756c
000aa0 0065          .db "value",0
000aa1 0a92          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000aa2 1c00          .dw DO_COLON
                 PFA_VALUE:
000aa3 1c63          .dw XT_DOVALUE
000aa4 0155          .dw XT_EDP
000aa5 01a4          .dw XT_COMMA
000aa6 0199          .dw XT_COMPILE
000aa7 0ab2          .dw XT_EVALUEFETCH
000aa8 0199          .dw XT_COMPILE
000aa9 0ab6          .dw XT_EVALUESTORE
000aaa 0155          .dw XT_EDP
000aab 1cac          .dw XT_DUP
000aac 1e38          .dw XT_1PLUS
000aad 1e38          .dw XT_1PLUS
000aae 0780          .dw XT_DOTO
000aaf 0156          .dw PFA_EDP
000ab0 1f37          .dw XT_STOREE
000ab1 1c1a          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000ab2 1c00          .dw DO_COLON
                 PFA_EVALUEFETCH:
000ab3 1fc7          .dw XT_FETCHI
000ab4 1f5b          .dw XT_FETCHE
000ab5 1c1a          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000ab6 1c00          .dw DO_COLON
                 PFA_EVALUESTORE:
000ab7 1fc7          .dw XT_FETCHI
000ab8 1f37          .dw XT_STOREE
000ab9 1c1a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000aba 0007          .dw $0007
000abb 6572
000abc 7563
000abd 7372
000abe 0065          .db "recurse",0
000abf 0a9d          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000ac0 1c00          .dw DO_COLON
                 PFA_RECURSE:
000ac1 0a1f          .dw XT_LATEST
000ac2 1c74          .dw XT_FETCH
000ac3 01a4          .dw XT_COMMA
000ac4 1c1a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000ac5 ff09          .dw $ff09
000ac6 6d69
000ac7 656d
000ac8 6964
000ac9 7461
000aca 0065          .db "immediate",0
000acb 0aba          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000acc 1c00          .dw DO_COLON
                 PFA_IMMEDIATE:
000acd 0ba9          .dw XT_GET_CURRENT
000ace 1f5b          .dw XT_FETCHE
000acf 1cac          .dw XT_DUP
000ad0 1fc7          .dw XT_FETCHI
000ad1 1c37          .dw XT_DOLITERAL
000ad2 7fff          .dw $7fff
000ad3 1e1c          .dw XT_AND
000ad4 1cbf          .dw XT_SWAP
000ad5 1f6f          .dw XT_STOREI
000ad6 1c1a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000ad7 0006          .dw $0006
000ad8 635b
000ad9 6168
000ada 5d72          .db "[char]"
000adb 0ac5          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000adc 1c00          .dw DO_COLON
                 PFA_BRACKETCHAR:
000add 0199          .dw XT_COMPILE
000ade 1c37          .dw XT_DOLITERAL
000adf 04d8          .dw XT_CHAR
000ae0 01a4          .dw XT_COMMA
000ae1 1c1a          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000ae2 0006          .dw $0006
000ae3 6261
000ae4 726f
000ae5 2274          .db "abort", $22
000ae6 0ad7          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000ae7 1c00          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000ae8 0199          .dw XT_COMPILE
000ae9 1c30          .dw XT_DOCONDBRANCH
000aea 014d          .dw XT_DP
000aeb 0199          .dw XT_COMPILE
000aec ffff          .dw -1
                     
000aed 0c5b          .dw XT_DOTSTRING
                     
000aee 0199          .dw XT_COMPILE
000aef 1c37          .dw XT_DOLITERAL
                     
000af0 0199          .dw XT_COMPILE
000af1 fffe          .dw -2
000af2 0199          .dw XT_COMPILE
000af3 0455          .dw XT_THROW
                     ; then
000af4 014d          .dw XT_DP
000af5 1cbf          .dw XT_SWAP
000af6 1f6f          .dw XT_STOREI
000af7 1c1a          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000af8 ff05          .dw $ff05
000af9 6261
000afa 726f
000afb 0074          .db "abort",0
000afc 0ae2          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000afd 1c00          .dw DO_COLON
                 PFA_ABORT:
000afe 1c37          .dw XT_DOLITERAL
000aff ffff          .dw -1
000b00 0455          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000b01 ff04          .dw $ff04
000b02 6f63
000b03 6564          .db "code"
000b04 0af8          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000b05 1c00          .dw DO_COLON
                 PFA_CODE:
000b06 0172          .dw XT_DOCREATE
000b07 0a0a          .dw XT_REVEAL
000b08 014d          .dw XT_DP
000b09 1e38          .dw XT_1PLUS
000b0a 01a4          .dw XT_COMMA
000b0b 1c1a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000b0c ff08          .dw $ff08
000b0d 6e65
000b0e 2d64
000b0f 6f63
000b10 6564          .db "end-code"
000b11 0b01          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000b12 1c00          .dw DO_COLON
                 PFA_ENDCODE:
000b13 0199          .dw XT_COMPILE
000b14 940c          .dw $940c
000b15 0199          .dw XT_COMPILE
000b16 1c04          .dw DO_NEXT
000b17 1c1a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000b18 ff0b          .dw $ff0b
000b19 6e65
000b1a 6976
000b1b 6f72
000b1c 6d6e
000b1d 6e65
000b1e 0074          .db "environment",0
000b1f 0b0c          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000b20 1c42          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000b21 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000b22 ff09          .dw $ff09
000b23 6f77
000b24 6472
000b25 696c
000b26 7473
000b27 0073          .db "wordlists",0
000b28 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000b29 1c00          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000b2a 1c37          .dw XT_DOLITERAL
000b2b 0008          .dw NUMWORDLISTS
000b2c 1c1a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000b2d ff04          .dw $ff04
000b2e 702f
000b2f 6461          .db "/pad"
000b30 0b22          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000b31 1c00          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000b32 1e8a          .dw XT_SP_FETCH
000b33 0123          .dw XT_PAD
000b34 1d9c          .dw XT_MINUS
000b35 1c1a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000b36 ff05          .dw $ff05
000b37 682f
000b38 6c6f
000b39 0064          .db "/hold",0
000b3a 0b2d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000b3b 1c00          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000b3c 0123          .dw XT_PAD
000b3d 015d          .dw XT_HERE
000b3e 1d9c          .dw XT_MINUS
000b3f 1c1a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000b40 ff0a          .dw $ff0a
000b41 6f66
000b42 7472
000b43 2d68
000b44 616e
000b45 656d          .db "forth-name"
000b46 0b36          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000b47 1c00          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000b48 0389          .dw XT_DOSLITERAL
000b49 0007          .dw 7
000b4a 6d61
000b4b 6f66
000b4c 7472
000b4d 0068          .db "amforth",0
000b4e 1c1a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000b4f ff07          .dw $ff07
000b50 6576
000b51 7372
000b52 6f69
000b53 006e          .db "version",0
000b54 0b40          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000b55 1c00          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000b56 1c37          .dw XT_DOLITERAL
000b57 0034          .dw 52
000b58 1c1a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000b59 ff03          .dw $ff03
000b5a 7063
000b5b 0075          .db "cpu",0
000b5c 0b4f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000b5d 1c00          .dw DO_COLON
                 PFA_EN_CPU:
000b5e 1c37          .dw XT_DOLITERAL
000b5f 0031          .dw mcu_name
000b60 03eb          .dw XT_ICOUNT
000b61 1c1a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000b62 ff08          .dw $ff08
000b63 636d
000b64 2d75
000b65 6e69
000b66 6f66          .db "mcu-info"
000b67 0b59          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000b68 1c00          .dw DO_COLON
                 PFA_EN_MCUINFO:
000b69 1c37          .dw XT_DOLITERAL
000b6a 002d          .dw mcu_info
000b6b 1c1a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000b6c ff05          .dw $ff05
000b6d 752f
000b6e 6573
000b6f 0072          .db "/user",0
000b70 0b62          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000b71 1c00          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000b72 1c37          .dw XT_DOLITERAL
000b73 0026          .dw SYSUSERSIZE + APPUSERSIZE
000b74 1c1a          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000b75 ff04          .dw $ff04
000b76 6540
000b77 5d5b          .db "@e[]"
000b78 0b18          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000b79 1c00          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000b7a 1cac          .dw XT_DUP
000b7b 1f5b          .dw XT_FETCHE
000b7c 1cf3          .dw XT_TO_R    ; save the counter to r-stack
000b7d 1cfc          .dw XT_R_FETCH
000b7e 1d34          .dw XT_ZERO
000b7f 1cbf          .dw XT_SWAP    ; go from bigger to smaller addresses
000b80 1eaa          .dw XT_DOQDO
000b81 0b8b          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000b82 1ebd          .dw XT_I
000b83 00f6          .dw XT_CELLS ; ( -- ee-addr i*2 )
000b84 1cca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000b85 1da6          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000b86 1f5b          .dw XT_FETCHE ;( -- ee-addr item_i )
000b87 1cbf          .dw XT_SWAP   ;( -- item_i ee-addr )
000b88 1d3d          .dw XT_TRUE  ; shortcut for -1
000b89 1ebe          .dw XT_DOPLUSLOOP
000b8a 0b82          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000b8b 010f          .dw XT_2DROP
000b8c 1cea          .dw XT_R_FROM ; get the counter from r-stack
000b8d 1c1a          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000b8e ff04          .dw $ff04
000b8f 6521
000b90 5d5b          .db "!e[]"
000b91 0b75          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000b92 1c00          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000b93 0106          .dw XT_2DUP
000b94 1f37          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000b95 1cbf          .dw XT_SWAP    
000b96 1d34          .dw XT_ZERO
000b97 1eaa          .dw XT_DOQDO
000b98 0b9f          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000b99 00fe          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000b9a 1cbf          .dw XT_SWAP
000b9b 1cca          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000b9c 1f37          .dw XT_STOREE
000b9d 1ed8          .dw XT_DOLOOP
000b9e 0b99          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000b9f 1cd4          .dw XT_DROP
000ba0 1c1a          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000ba1 ff0b          .dw $ff0b
000ba2 6567
000ba3 2d74
000ba4 7563
000ba5 7272
000ba6 6e65
000ba7 0074          .db "get-current",0
000ba8 0b8e          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000ba9 1c00          .dw DO_COLON
                 PFA_GET_CURRENT:
000baa 1c37          .dw XT_DOLITERAL
000bab 0010          .dw EE_CURRENT
000bac 1f5b          .dw XT_FETCHE
000bad 1c1a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000bae ff09          .dw $ff09
000baf 6567
000bb0 2d74
000bb1 726f
000bb2 6564
000bb3 0072          .db "get-order",0
000bb4 0ba1          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000bb5 1c00          .dw DO_COLON
                 PFA_GET_ORDER:
000bb6 1c37          .dw XT_DOLITERAL
000bb7 0014          .dw EE_ORDERLISTLEN
000bb8 0b79          .dw XT_FETCH_EE_ARRAY
000bb9 1c1a          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000bba ff07          .dw $ff07
000bbb 6f63
000bbc 706d
000bbd 7261
000bbe 0065          .db "compare",0
000bbf 0bae          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000bc0 0bc1          .dw PFA_COMPARE
                 PFA_COMPARE:
000bc1 93bf          push xh
000bc2 93af          push xl
000bc3 018c          movw temp0, tosl
000bc4 9189
000bc5 9199          loadtos
000bc6 01dc          movw xl, tosl
000bc7 9189
000bc8 9199          loadtos
000bc9 019c          movw temp2, tosl
000bca 9189
000bcb 9199          loadtos
000bcc 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000bcd 90ed          ld temp4, X+
000bce 90f1          ld temp5, Z+
000bcf 14ef          cp temp4, temp5
000bd0 f451          brne PFA_COMPARE_NOTEQUAL
000bd1 950a          dec temp0
000bd2 f019          breq PFA_COMPARE_ENDREACHED2
000bd3 952a          dec temp2
000bd4 f7c1          brne PFA_COMPARE_LOOP
000bd5 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000bd6 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000bd7 2b02          or temp0, temp2
000bd8 f411          brne PFA_COMPARE_CHECKLASTCHAR
000bd9 2788          clr tosl
000bda c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000bdb ef8f          ser tosl
000bdc c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000bdd 2f98          mov tosh, tosl
000bde 91af          pop xl
000bdf 91bf          pop xh
000be0 940c 1c04     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000be2 ff07         .dw $ff07
000be3 666e
000be4 3e61
000be5 666c
000be6 0061         .db "nfa>lfa",0
000be7 0bba         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000be8 1c00          .dw DO_COLON
                 PFA_NFA2LFA:
000be9 03eb          .dw XT_ICOUNT 
000bea 1c37          .dw XT_DOLITERAL
000beb 00ff          .dw $00ff
000bec 1e1c          .dw XT_AND
000bed 1e38          .dw XT_1PLUS
000bee 1e0d          .dw XT_2SLASH
000bef 1da6          .dw XT_PLUS
000bf0 1c1a          .dw XT_EXIT
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000bf1 ff04          .dw $ff04
000bf2 692b
000bf3 746e          .db "+int"
000bf4 0be2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000bf5 0bf6          .dw PFA_INTON
                 PFA_INTON:
000bf6 9478          sei
000bf7 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000bf9 ff04          .dw $ff04
000bfa 692d
000bfb 746e          .db "-int"
000bfc 0bf1          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000bfd 0bfe          .dw PFA_INTOFF
                 PFA_INTOFF:
000bfe 94f8          cli
000bff 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000c01 ff04          .dw $ff04
000c02 6e69
000c03 2174          .db "int!"
000c04 0bf9          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000c05 1c00          .dw DO_COLON
                 PFA_INTSTORE:
000c06 1c37          .dw XT_DOLITERAL
000c07 0115          .dw intvec
000c08 1da6          .dw XT_PLUS
000c09 1c7c          .dw XT_STORE
000c0a 1c1a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000c0b ff04          .dw $ff04
000c0c 6e69
000c0d 4074          .db "int@"
000c0e 0c01          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000c0f 1c00          .dw DO_COLON
                 PFA_INTFETCH:
000c10 1c37          .dw XT_DOLITERAL
000c11 0115          .dw intvec
000c12 1da6          .dw XT_PLUS
000c13 1c74          .dw XT_FETCH
000c14 1c1a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000c15 ff08          .dw $ff08
000c16 6e69
000c17 2d74
000c18 7274
000c19 7061          .db "int-trap"
000c1a 0c0b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000c1b 0c1c          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000c1c 9380 0114     sts intcur, tosl
000c1e 9189
000c1f 9199          loadtos
000c20 9468          set ; set the interrupt flag for the inner interpreter
000c21 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000c23 1c00          .dw DO_COLON
                 PFA_ISREXEC:
000c24 1c37          .dw XT_DOLITERAL
000c25 0114          .dw intcur
000c26 1c93          .dw XT_CFETCH
000c27 1c37          .dw XT_DOLITERAL
000c28 0115          .dw intvec
000c29 1da6          .dw XT_PLUS
000c2a 1c74          .dw XT_FETCH
000c2b 1c24          .dw XT_EXECUTE
000c2c 0c2e          .dw XT_ISREND
000c2d 1c1a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000c2e 0c2f          .dw PFA_ISREND
                 PFA_ISREND:
000c2f d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000c30 940c 1c04     jmp_ DO_NEXT
                 PFA_ISREND1:
000c32 9518          reti
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000c33 ff0b          .dw $ff0b
000c34 7061
000c35 6c70
000c36 7574
000c37 6e72
000c38 656b
000c39 0079          .db "applturnkey",0
000c3a 0c15          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000c3b 1c00          .dw DO_COLON
                 PFA_APPLTURNKEY:
000c3c 00aa          .dw XT_USART
000c3d 0bf5          .dw XT_INTON
000c3e 0748          .dw XT_VER
000c3f 1c1a          .dw XT_EXIT
                 
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
000c40 ff02          .dw $ff02
000c41 2e75          .db "u."
000c42 0c33          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000c43 1c00          .dw DO_COLON
                 PFA_UDOT:
000c44 1d34          .dw XT_ZERO
000c45 032e          .dw XT_UDDOT
000c46 1c1a          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
000c47 ff02          .dw $ff02
000c48 732e          .db ".s"
000c49 0c40          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000c4a 1c00          .dw DO_COLON
                 PFA_DOTS:
000c4b 069c          .dw XT_SP0
000c4c 1e8a          .dw XT_SP_FETCH
000c4d 00fe          .dw XT_CELLPLUS
000c4e 1eaa          .dw XT_DOQDO
000c4f 0c57          .dw PFA_DOTS2
                 PFA_DOTS1:
000c50 1ebd          .dw XT_I
000c51 1c74          .dw XT_FETCH 
000c52 0c43          .dw XT_UDOT
000c53 1c37          .dw XT_DOLITERAL
000c54 0002          .dw 2
000c55 1ebe          .dw XT_DOPLUSLOOP
000c56 0c50          .dw PFA_DOTS1
                 PFA_DOTS2:
000c57 1c1a          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
000c58 0002          .dw $0002
000c59 222e          .db ".",$22
000c5a 0c47          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000c5b 1c00          .dw DO_COLON
                 PFA_DOTSTRING:
000c5c 0c63          .dw XT_SQUOTE
000c5d 0199          .dw XT_COMPILE
000c5e 03c0          .dw XT_ITYPE
000c5f 1c1a          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
000c60 0002        .dw $0002
000c61 2273        .db "s",$22
000c62 0c58        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000c63 1c00          .dw DO_COLON
                 PFA_SQUOTE:
000c64 1c37          .dw XT_DOLITERAL
000c65 0022          .dw $22
000c66 0596          .dw XT_PARSE       ; ( -- addr n)
000c67 00e9          .dw XT_STATE
000c68 1c74          .dw XT_FETCH
000c69 1c30          .dw XT_DOCONDBRANCH
000c6a 0c6e          .dw PFA_SQUOTE1
000c6b 0199            .dw XT_COMPILE
000c6c 0389            .dw XT_DOSLITERAL    ; ( -- addr n)
000c6d 039c            .dw XT_SCOMMA
                 PFA_SQUOTE1:
000c6e 1c1a          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
000c6f ff0d          .dw $ff0d
000c70 6873
000c71 776f
000c72 772d
000c73 726f
000c74 6c64
000c75 7369
000c76 0074          .db "show-wordlist",0
000c77 0c60          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
000c78 1c00          .dw DO_COLON
                 PFA_SHOWWORDLIST:
000c79 1c37          .dw XT_DOLITERAL
000c7a 0c7e          .dw XT_SHOWWORD
000c7b 1cbf          .dw XT_SWAP
000c7c 0822          .dw XT_TRAVERSEWORDLIST
000c7d 1c1a          .dw XT_EXIT
                 
                 XT_SHOWWORD:
000c7e 1c00          .dw DO_COLON
                 PFA_SHOWWORD:
000c7f 0811          .dw XT_NAME2STRING
000c80 03c0          .dw XT_ITYPE
000c81 0401          .dw XT_SPACE         ; ( -- addr n)
000c82 1d3d          .dw XT_TRUE
000c83 1c1a          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000c84 ff05          .dw $ff05
000c85 6f77
000c86 6472
000c87 0073          .db "words",0
000c88 0c6f          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000c89 1c00          .dw DO_COLON
                 PFA_WORDS:
000c8a 1c37          .dw XT_DOLITERAL
000c8b 0016          .dw EE_ORDERLIST
000c8c 1f5b          .dw XT_FETCHE
000c8d 0c78          .dw XT_SHOWWORDLIST
000c8e 1c1a          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000c8f ff06          .dw $ff06
000c90 6445
000c91 6665
000c92 7265          .db "Edefer"
000c93 0c84          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000c94 1c00          .dw DO_COLON
                 PFA_EDEFER:
000c95 0172          .dw XT_DOCREATE
000c96 0a0a          .dw XT_REVEAL
000c97 0199          .dw XT_COMPILE
000c98 07c8          .dw PFA_DODEFER
                 
000c99 0155          .dw XT_EDP
000c9a 1cac          .dw XT_DUP
000c9b 01a4          .dw XT_COMMA
000c9c 0199          .dw XT_COMPILE
000c9d 078c          .dw XT_EDEFERFETCH
000c9e 0199          .dw XT_COMPILE
000c9f 0791          .dw XT_EDEFERSTORE
000ca0 00fe          .dw XT_CELLPLUS
000ca1 0780          .dw XT_DOTO
000ca2 0156          .dw PFA_EDP
000ca3 1c1a          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000ca4 ff06          .dw $ff06
000ca5 6452
000ca6 6665
000ca7 7265          .db "Rdefer"
000ca8 0c8f          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000ca9 1c00          .dw DO_COLON
                 PFA_RDEFER:
000caa 0172          .dw XT_DOCREATE
000cab 0a0a          .dw XT_REVEAL
                 
000cac 0199          .dw XT_COMPILE
000cad 07c8          .dw PFA_DODEFER
                 
000cae 015d          .dw XT_HERE
000caf 01a4          .dw XT_COMMA
000cb0 1c37          .dw XT_DOLITERAL
000cb1 0002          .dw 2
000cb2 0166          .dw XT_ALLOT
                 
000cb3 0199          .dw XT_COMPILE
000cb4 0796          .dw XT_RDEFERFETCH
000cb5 0199          .dw XT_COMPILE
000cb6 079b          .dw XT_RDEFERSTORE
000cb7 1c1a          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000cb8 0002          .dw $0002
000cb9 7369          .db "is"
000cba 0ca4          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000cbb 1c00          .dw DO_COLON
                 PFA_IS:
000cbc 00e9          .dw XT_STATE
000cbd 1c74          .dw XT_FETCH
000cbe 1c30          .dw XT_DOCONDBRANCH
000cbf 0cc4          .dw PFA_IS1
000cc0 01b0          .dw XT_BRACKETTICK
000cc1 0199          .dw XT_COMPILE
000cc2 07b3          .dw XT_DEFERSTORE
000cc3 1c1a          .dw XT_EXIT
                 PFA_IS1:
000cc4 0428          .dw XT_TICK
000cc5 07b3          .dw XT_DEFERSTORE
000cc6 1c1a          .dw XT_EXIT
                 
                 
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000cc7 ff07          .dw $ff07
000cc8 6964
000cc9 766e
000cca 7265
000ccb 0074          .db "dinvert",0
000ccc 0cb8          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000ccd 0cce          .dw PFA_DINVERT
                 PFA_DINVERT:
000cce 9109          ld temp0, Y+
000ccf 9119          ld temp1, Y+
000cd0 9580          com tosl
000cd1 9590          com tosh
000cd2 9500          com temp0
000cd3 9510          com temp1
000cd4 931a          st -Y, temp1
000cd5 930a          st -Y, temp0
000cd6 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000cd8 ff02          .dw $ff02
000cd9 2b64          .db "d+"
000cda 0cc7          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000cdb 0cdc          .dw PFA_DPLUS
                 PFA_DPLUS:
000cdc 9129          ld temp2, Y+
000cdd 9139          ld temp3, Y+
                 
000cde 90e9          ld temp4, Y+
000cdf 90f9          ld temp5, Y+
000ce0 9149          ld temp6, Y+
000ce1 9159          ld temp7, Y+
                 
000ce2 0f24          add temp2, temp6
000ce3 1f35          adc temp3, temp7
000ce4 1d8e          adc tosl, temp4
000ce5 1d9f          adc tosh, temp5
                     
000ce6 933a          st -Y, temp3
000ce7 932a          st -Y, temp2
000ce8 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000cea ff02          .dw $ff02
000ceb 2d64          .db "d-"
000cec 0cd8          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000ced 0cee          .dw PFA_DMINUS
                 PFA_DMINUS:
000cee 9129          ld temp2, Y+
000cef 9139          ld temp3, Y+
                 
000cf0 90e9          ld temp4, Y+
000cf1 90f9          ld temp5, Y+
000cf2 9149          ld temp6, Y+
000cf3 9159          ld temp7, Y+
                 
000cf4 1b42          sub temp6, temp2
000cf5 0b53          sbc temp7, temp3
000cf6 0ae8          sbc temp4, tosl
000cf7 0af9          sbc temp5, tosh
                 
000cf8 935a          st -Y, temp7
000cf9 934a          st -Y, temp6
000cfa 01c7          movw tosl, temp4
000cfb 940c 1c04     jmp_ DO_NEXT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000cfd ff06          .dw $ff06
000cfe 2163
000cff 7340
000d00 6970          .db "c!@spi"
000d01 0cea          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000d02 0d03          .dw PFA_SPIRW
                 PFA_SPIRW:
000d03 d003          rcall do_spirw
000d04 2799          clr tosh
000d05 940c 1c04     jmp_ DO_NEXT
                 
                 do_spirw:
000d07 bd8e          out_ SPDR, tosl
                 do_spirw1:
000d08 b50d          in_ temp0, SPSR
000d09 7f08          cbr temp0,7
000d0a bd0d          out_ SPSR, temp0
000d0b b50d          in_ temp0, SPSR
000d0c ff07          sbrs temp0, 7
000d0d cffa          rjmp do_spirw1   ; wait until complete
000d0e b58e          in_ tosl, SPDR
000d0f 9508          ret
                 
                 
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c00 93bf          push XH
001c01 93af          push XL          ; PUSH IP
001c02 01db          movw XL, wl
001c03 9611          adiw xl, 1
                 DO_NEXT:
001c04 f06e          brts DO_INTERRUPT
001c05 01fd          movw zl, XL        ; READ IP
001c06 0fee
001c07 1fff
001c08 9165
001c09 9175          readflashcell wl, wh
001c0a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0b 01fb          movw zl, wl
001c0c 0fee
001c0d 1fff
001c0e 9105
001c0f 9115          readflashcell temp0,temp1
001c10 01f8          movw zl, temp0
001c11 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c12 94e8          clt
001c13 e263          ldi wl, LOW(XT_ISREXEC)
001c14 e07c          ldi wh, HIGH(XT_ISREXEC)
001c15 cff5          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c16 ff04          .dw $ff04
001c17 7865
001c18 7469          .db "exit"
001c19 0cfd          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c1a 1c1b          .dw PFA_EXIT
                 PFA_EXIT:
001c1b 91af          pop XL
001c1c 91bf          pop XH
001c1d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c1e ff07          .dw $ff07
001c1f 7865
001c20 6365
001c21 7475
001c22 0065          .db "execute",0
001c23 1c16          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c24 1c25          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c25 01bc          movw wl, tosl
001c26 9189
001c27 9199          loadtos
001c28 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c29 1c2a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c2a 01fd          movw zl, XL
001c2b 0fee
001c2c 1fff
001c2d 91a5
001c2e 91b5          readflashcell XL,XH
001c2f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c30 1c31          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c31 2b98          or tosh, tosl
001c32 9189
001c33 9199          loadtos
001c34 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c35 9611          adiw XL, 1
001c36 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c37 1c38          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c38 939a
001c39 938a          savetos
001c3a 01fd          movw zl, xl
001c3b 0fee
001c3c 1fff
001c3d 9185
001c3e 9195          readflashcell tosl,tosh
001c3f 9611          adiw xl, 1
001c40 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c41 1c42          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c42 939a
001c43 938a          savetos
001c44 01fb          movw zl, wl
001c45 9631          adiw zl,1
001c46 0fee
001c47 1fff
001c48 9185
001c49 9195          readflashcell tosl,tosh
001c4a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c4b 1c4c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c4c 939a
001c4d 938a          savetos
001c4e 01cb          movw tosl, wl
001c4f 9601          adiw tosl, 1
001c50 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c51 1c52          .dw PFA_DOUSER
                 PFA_DOUSER:
001c52 939a
001c53 938a          savetos
001c54 01fb          movw zl, wl
001c55 9631          adiw zl, 1
001c56 0fee
001c57 1fff
001c58 9185
001c59 9195          readflashcell tosl,tosh
001c5a 0d84          add tosl, upl
001c5b 1d95          adc tosh, uph
001c5c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c5d ff07          .dw $ff07
001c5e 7628
001c5f 6c61
001c60 6575
001c61 0029          .db "(value)", 0
001c62 1c1e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c63 1c00          .dw DO_COLON
                 PFA_DOVALUE:
001c64 0172          .dw XT_DOCREATE
001c65 0a0a          .dw XT_REVEAL
001c66 0199          .dw XT_COMPILE
001c67 1c69          .dw PFA_DOVALUE1
001c68 1c1a          .dw XT_EXIT
                 PFA_DOVALUE1:
001c69 940e 0a2e     call_ DO_DODOES
001c6b 1cac          .dw XT_DUP
001c6c 1cbf          .dw XT_SWAP
001c6d 1e38          .dw XT_1PLUS
001c6e 1fc7          .dw XT_FETCHI
001c6f 1c24          .dw XT_EXECUTE
001c70 1c1a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c71 ff01          .dw $ff01
001c72 0040          .db "@",0
001c73 1c5d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c74 1c75          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c75 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c76 9181          ld tosl, z+
001c77 9191          ld tosh, z+
001c78 cf8b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c79 ff01          .dw $ff01
001c7a 0021          .db "!",0
001c7b 1c71          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c7c 1c7d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c7d 01fc          movw zl, tosl
001c7e 9189
001c7f 9199          loadtos
                     ; the high byte is written before the low byte
001c80 8391          std Z+1, tosh
001c81 8380          std Z+0, tosl
001c82 9189
001c83 9199          loadtos
001c84 cf7f          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c85 ff02          .dw $ff02
001c86 2163          .db "c!"
001c87 1c79          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c88 1c89          .dw PFA_CSTORE
                 PFA_CSTORE:
001c89 01fc          movw zl, tosl
001c8a 9189
001c8b 9199          loadtos
001c8c 8380          st Z, tosl
001c8d 9189
001c8e 9199          loadtos
001c8f cf74          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c90 ff02          .dw $ff02
001c91 4063          .db "c@"
001c92 1c85          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c93 1c94          .dw PFA_CFETCH
                 PFA_CFETCH:
001c94 01fc          movw zl, tosl
001c95 2799          clr tosh
001c96 8180          ld tosl, Z
001c97 cf6c          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
001c98 ff02          .dw $ff02
001c99 7540          .db "@u"
001c9a 1c90          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001c9b 1c00          .dw DO_COLON
                 PFA_FETCHU:
001c9c 1f17          .dw XT_UP_FETCH
001c9d 1da6          .dw XT_PLUS
001c9e 1c74          .dw XT_FETCH
001c9f 1c1a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
001ca0 ff02          .dw $ff02
001ca1 7521          .db "!u"
001ca2 1c98          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca3 1c00          .dw DO_COLON
                 PFA_STOREU:
001ca4 1f17          .dw XT_UP_FETCH
001ca5 1da6          .dw XT_PLUS
001ca6 1c7c          .dw XT_STORE
001ca7 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001ca8 ff03          .dw $ff03
001ca9 7564
001caa 0070          .db "dup",0
001cab 1ca0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cac 1cad          .dw PFA_DUP
                 PFA_DUP:
001cad 939a
001cae 938a          savetos
001caf cf54          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001cb0 ff04          .dw $ff04
001cb1 643f
001cb2 7075          .db "?dup"
001cb3 1ca8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb4 1cb5          .dw PFA_QDUP
                 PFA_QDUP:
001cb5 2f08          mov temp0, tosl
001cb6 2b09          or temp0, tosh
001cb7 f011          breq PFA_QDUP1
001cb8 939a
001cb9 938a          savetos
                 PFA_QDUP1:
001cba cf49          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cbb ff04          .dw $ff04
001cbc 7773
001cbd 7061          .db "swap"
001cbe 1cb0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cbf 1cc0          .dw PFA_SWAP
                 PFA_SWAP:
001cc0 018c          movw temp0, tosl
001cc1 9189
001cc2 9199          loadtos
001cc3 931a          st -Y, temp1
001cc4 930a          st -Y, temp0
001cc5 cf3e          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001cc6 ff04          .dw $ff04
001cc7 766f
001cc8 7265          .db "over"
001cc9 1cbb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001cca 1ccb          .dw PFA_OVER
                 PFA_OVER:
001ccb 939a
001ccc 938a          savetos
001ccd 818a          ldd tosl, Y+2
001cce 819b          ldd tosh, Y+3
                 
001ccf cf34          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001cd0 ff04          .dw $ff04
001cd1 7264
001cd2 706f          .db "drop"
001cd3 1cc6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd4 1cd5          .dw PFA_DROP
                 PFA_DROP:
001cd5 9189
001cd6 9199          loadtos
001cd7 cf2c          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cd8 ff03          .dw $ff03
001cd9 6f72
001cda 0074          .db "rot",0
001cdb 1cd0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001cdc 1cdd          .dw PFA_ROT
                 PFA_ROT:
001cdd 018c          movw temp0, tosl
001cde 9129          ld temp2, Y+
001cdf 9139          ld temp3, Y+ 
001ce0 9189
001ce1 9199          loadtos
                         
001ce2 933a          st -Y, temp3
001ce3 932a          st -Y, temp2
001ce4 931a          st -Y, temp1
001ce5 930a          st -Y, temp0
                 
001ce6 cf1d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001ce7 ff02          .dw $ff02
001ce8 3e72          .db "r>"
001ce9 1cd8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cea 1ceb          .dw PFA_R_FROM
                 PFA_R_FROM:
001ceb 939a
001cec 938a          savetos
001ced 918f          pop tosl
001cee 919f          pop tosh
001cef cf14          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cf0 ff02          .dw $ff02
001cf1 723e          .db ">r"
001cf2 1ce7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cf3 1cf4          .dw PFA_TO_R
                 PFA_TO_R:
001cf4 939f          push tosh
001cf5 938f          push tosl
001cf6 9189
001cf7 9199          loadtos
001cf8 cf0b          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001cf9 ff02          .dw $ff02
001cfa 4072          .db "r@"
001cfb 1cf0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001cfc 1cfd          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001cfd 939a
001cfe 938a          savetos
001cff 918f          pop tosl
001d00 919f          pop tosh
001d01 939f          push tosh
001d02 938f          push tosl
001d03 cf00          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
001d04 ff02          .dw $ff02
001d05 3e3c          .db "<>"
001d06 1cf9          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d07 1d08          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
001d08 9129          ld temp2, Y+
001d09 9139          ld temp3, Y+
001d0a 1782          cp tosl, temp2
001d0b 0793          cpc tosh, temp3
001d0c f151          breq PFA_ZERO1
001d0d c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001d0e ff01          .dw $ff01
001d0f 003d          .db "=",0
001d10 1d04          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001d11 1c00          .dw DO_COLON
                 PFA_EQUAL:
001d12 1d9c          .dw XT_MINUS
001d13 1d18          .dw XT_EQUALZERO
001d14 1c1a          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
001d15 ff02          .dw $ff02
001d16 3d30          .db "0="
001d17 1d0e          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
001d18 1d19          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
001d19 2b98          or tosh, tosl
001d1a f4e1          brne PFA_ZERO1
001d1b c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d1c ff01          .dw $ff01
001d1d 003c          .db "<",0
001d1e 1d15          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d1f 1c00          .dw DO_COLON
                 PFA_LESS:
001d20 1d9c          .dw XT_MINUS
001d21 1d2d          .dw XT_LESSZERO
001d22 1c1a          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d23 ff01          .dw $ff01
001d24 003e          .db ">",0
001d25 1d1c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d26 1c00          .dw DO_COLON
                 PFA_GREATER:
001d27 1d9c          .dw XT_MINUS
001d28 1d5c          .dw XT_GREATERZERO
001d29 1c1a          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
001d2a ff02          .dw $ff02
001d2b 3c30          .db "0<"
001d2c 1d23          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
001d2d 1d2e          .dw PFA_LESSZERO
                 PFA_LESSZERO:
001d2e fd97          sbrc tosh,7
001d2f c010          rjmp PFA_TRUE1
001d30 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d31 ff01          .dw $ff01
001d32 0030          .db "0",0
001d33 1d2a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d34 1d35          .dw PFA_ZERO
                 PFA_ZERO:
001d35 939a
001d36 938a          savetos
                 PFA_ZERO1:
001d37 01c1          movw tosl, zerol
001d38 cecb          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d39 ff04          .dw $ff04
001d3a 7274
001d3b 6575          .db "true"
001d3c 1d31          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d3d 1d3e          .dw PFA_TRUE
                 PFA_TRUE:
001d3e 939a
001d3f 938a          savetos
                 PFA_TRUE1:
001d40 ef8f          ser tosl
001d41 ef9f          ser tosh
001d42 cec1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d43 ff02          .dw $ff02
001d44 3c75          .db "u<"
001d45 1d39          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d46 1d47          .dw PFA_ULESS
                 PFA_ULESS:
001d47 9129          ld temp2, Y+
001d48 9139          ld temp3, Y+
001d49 1782          cp tosl, temp2
001d4a 0793          cpc tosh, temp3
001d4b f358          brlo PFA_ZERO1
001d4c f351          brbs 1, PFA_ZERO1
001d4d cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
001d4e ff02          .dw $ff02
001d4f 3e75          .db "u>"
001d50 1d43          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d51 1d52          .dw PFA_UGREATER
                 PFA_UGREATER:
001d52 9129          ld temp2, Y+
001d53 9139          ld temp3, Y+
001d54 1728          cp temp2, tosl
001d55 0739          cpc temp3, tosh
001d56 f300          brlo PFA_ZERO1
001d57 f2f9          brbs 1, PFA_ZERO1
001d58 cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d59 ff02          .dw $ff02
001d5a 3e30          .db "0>"
001d5b 1d4e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d5c 1d5d          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d5d 1582          cp tosl, zerol
001d5e 0593          cpc tosh, zeroh
001d5f f2bc          brlt PFA_ZERO1
001d60 f2b1          brbs 1, PFA_ZERO1
001d61 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
001d62 ff02          .dw $ff02
001d63 3e64          .db "d>"
001d64 1d59          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
001d65 1c00          .dw DO_COLON
                 PFA_DGREATER:
001d66 0ced          .dw XT_DMINUS
001d67 1d6d          .dw XT_DGREATERZERO
001d68 1c1a          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d69 ff03          .dw $ff03
001d6a 3064
001d6b 003e          .db "d0>",0
001d6c 1d62          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d6d 1d6e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d6e 1582          cp tosl, zerol
001d6f 0593          cpc tosh, zeroh
001d70 9189
001d71 9199          loadtos
001d72 0582          cpc tosl, zerol
001d73 0593          cpc tosh, zeroh
001d74 f214          brlt PFA_ZERO1
001d75 f209          brbs 1, PFA_ZERO1
001d76 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
001d77 ff02          .dw $ff02
001d78 3c64          .db "d<"
001d79 1d69          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
001d7a 1c00          .dw DO_COLON
                 PFA_DLESS:
001d7b 0ced          .dw XT_DMINUS
001d7c 1d82          .dw XT_DLESSZERO
001d7d 1c1a          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
001d7e ff03          .dw $ff03
001d7f 3064
001d80 003c          .db "d0<",0
001d81 1d77          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
001d82 1d83          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
001d83 9622          adiw Y,2
001d84 fd97          sbrc tosh,7
001d85 940c 1d40     jmp PFA_TRUE1
001d87 940c 1d37     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d89 ff04          .dw $ff04
001d8a 6f6c
001d8b 3267          .db "log2"
001d8c 1d7e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d8d 1d8e          .dw PFA_LOG2
                 PFA_LOG2:
001d8e 01fc          movw zl, tosl
001d8f 2799          clr tosh
001d90 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d91 958a          dec tosl
001d92 f022          brmi PFA_LOG2_2 ; wrong data
001d93 0fee          lsl  zl
001d94 1fff          rol  zh
001d95 f7d8          brcc PFA_LOG2_1
001d96 ce6d          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d97 959a          dec tosh
001d98 ce6b          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d99 ff01          .dw $ff01
001d9a 002d          .db "-",0
001d9b 1d89          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d9c 1d9d          .dw PFA_MINUS
                 PFA_MINUS:
001d9d 9109          ld temp0, Y+
001d9e 9119          ld temp1, Y+
001d9f 1b08          sub temp0, tosl
001da0 0b19          sbc temp1, tosh
001da1 01c8          movw tosl, temp0
001da2 ce61          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001da3 ff01          .dw $ff01
001da4 002b          .db "+",0
001da5 1d99          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001da6 1da7          .dw PFA_PLUS
                 PFA_PLUS:
001da7 9109          ld temp0, Y+
001da8 9119          ld temp1, Y+
001da9 0f80          add tosl, temp0
001daa 1f91          adc tosh, temp1
001dab ce58          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001dac ff02          .dw $ff02
001dad 2a6d          .db "m*"
001dae 1da3          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001daf 1db0          .dw PFA_MSTAR
                 PFA_MSTAR:
001db0 018c          movw temp0, tosl
001db1 9189
001db2 9199          loadtos
001db3 019c          movw temp2, tosl
                     ; high cell ah*bh
001db4 0231          muls temp3, temp1
001db5 0170          movw temp4, r0
                     ; low cell  al*bl
001db6 9f20          mul  temp2, temp0
001db7 01c0          movw tosl, r0
                     ; signed ah*bl
001db8 0330          mulsu temp3, temp0
001db9 08f3          sbc   temp5, zeroh
001dba 0d90          add   tosh,  r0
001dbb 1ce1          adc   temp4, r1
001dbc 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001dbd 0312          mulsu temp1, temp2
001dbe 08f3          sbc   temp5, zeroh
001dbf 0d90          add   tosh,  r0
001dc0 1ce1          adc   temp4, r1
001dc1 1cf3          adc   temp5, zeroh
                 
001dc2 939a
001dc3 938a          savetos
001dc4 01c7          movw tosl, temp4
001dc5 ce3e          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001dc6 ff06          .dw $ff06
001dc7 6d75
001dc8 6d2f
001dc9 646f          .db "um/mod"
001dca 1dac          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dcb 1dcc          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dcc 017c          movw temp4, tosl
                 
001dcd 9129          ld temp2, Y+
001dce 9139          ld temp3, Y+
                   
001dcf 9109          ld temp0, Y+
001dd0 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dd1 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dd2 2755          clr temp7
001dd3 0f00          lsl temp0
001dd4 1f11          rol temp1
001dd5 1f22          rol temp2
001dd6 1f33          rol temp3
001dd7 1f55          rol temp7
                 
                   ; try subtracting divisor
001dd8 152e          cp temp2, temp4
001dd9 053f          cpc temp3, temp5
001dda 0552          cpc temp7,zerol
                 
001ddb f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001ddc 9503          inc temp0
001ddd 192e          sub temp2, temp4
001dde 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001ddf 954a          dec  temp6
001de0 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001de1 933a          st -Y,temp3
001de2 932a          st -Y,temp2
                 
                     ; put quotient on stack
001de3 01c8          movw tosl, temp0
001de4 ce1f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001de5 ff03          .dw $ff03
001de6 6d75
001de7 002a          .db "um*",0
001de8 1dc6          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001de9 1dea          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001dea 018c          movw temp0, tosl
001deb 9189
001dec 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001ded 9f80          mul tosl,temp0
001dee 01f0          movw zl, r0
001def 2722          clr temp2
001df0 2733          clr temp3
                     ; middle bytes
001df1 9f90          mul tosh, temp0
001df2 0df0          add zh, r0
001df3 1d21          adc temp2, r1
001df4 1d33          adc temp3, zeroh
                         
001df5 9f81          mul tosl, temp1
001df6 0df0          add zh, r0
001df7 1d21          adc temp2, r1
001df8 1d33          adc temp3, zeroh
                     
001df9 9f91          mul tosh, temp1
001dfa 0d20          add temp2, r0
001dfb 1d31          adc temp3, r1
001dfc 01cf          movw tosl, zl
001dfd 939a
001dfe 938a          savetos
001dff 01c9          movw tosl, temp2
001e00 ce03          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001e01 ff06          .dw $ff06
001e02 6e69
001e03 6576
001e04 7472          .db "invert"
001e05 1de5          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001e06 1e07          .dw PFA_INVERT
                 PFA_INVERT:
001e07 9580          com tosl
001e08 9590          com tosh
001e09 cdfa          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001e0a ff02          .dw $ff02
001e0b 2f32          .db "2/"
001e0c 1e01          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001e0d 1e0e          .dw PFA_2SLASH
                 PFA_2SLASH:
001e0e 9595          asr tosh
001e0f 9587          ror tosl
001e10 cdf3          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e11 ff02          .dw $ff02
001e12 2a32          .db "2*"
001e13 1e0a          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e14 1e15          .dw PFA_2STAR
                 PFA_2STAR:
001e15 0f88          lsl tosl
001e16 1f99          rol tosh
001e17 cdec          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e18 ff03          .dw $ff03
001e19 6e61
001e1a 0064          .db "and",0
001e1b 1e11          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e1c 1e1d          .dw PFA_AND
                 PFA_AND:
001e1d 9109          ld temp0, Y+
001e1e 9119          ld temp1, Y+
001e1f 2380          and tosl, temp0
001e20 2391          and tosh, temp1
001e21 cde2          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e22 ff02          .dw $ff02
001e23 726f          .db "or"
001e24 1e18          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e25 1e26          .dw PFA_OR
                 PFA_OR:
001e26 9109          ld temp0, Y+
001e27 9119          ld temp1, Y+
001e28 2b80          or tosl, temp0
001e29 2b91          or tosh, temp1
001e2a cdd9          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e2b ff03          .dw $ff03
001e2c 6f78
001e2d 0072          .db "xor",0
001e2e 1e22          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e2f 1e30          .dw PFA_XOR
                 PFA_XOR:
001e30 9109          ld temp0, Y+
001e31 9119          ld temp1, Y+
001e32 2780          eor tosl, temp0
001e33 2791          eor tosh, temp1
001e34 cdcf          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e35 ff02          .dw $ff02
001e36 2b31          .db "1+"
001e37 1e2b          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e38 1e39          .dw PFA_1PLUS
                 PFA_1PLUS:
001e39 9601          adiw tosl,1
001e3a cdc9          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e3b ff02          .dw $ff02 
001e3c 2d31          .db "1-"
001e3d 1e35          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e3e 1e3f          .dw PFA_1MINUS
                 PFA_1MINUS:
001e3f 9701          sbiw tosl, 1
001e40 cdc3          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e41 ff06          .dw $ff06
001e42 736c
001e43 6968
001e44 7466          .db "lshift"
001e45 1e3b          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e46 1e47          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e47 01fc          movw zl, tosl
001e48 9189
001e49 9199          loadtos
                 PFA_LSHIFT1:
001e4a 9731          sbiw zl, 1
001e4b f01a          brmi PFA_LSHIFT2
001e4c 0f88          lsl tosl
001e4d 1f99          rol tosh
001e4e cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e50 ff06          .dw $ff06
001e51 7372
001e52 6968
001e53 7466          .db "rshift"
001e54 1e41          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e55 1e56          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e56 01fc          movw zl, tosl
001e57 9189
001e58 9199          loadtos
                 PFA_RSHIFT1:
001e59 9731          sbiw zl, 1
001e5a f01a          brmi PFA_RSHIFT2
001e5b 9596          lsr tosh
001e5c 9587          ror tosl
001e5d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e5e cda5          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e5f ff02          .dw $ff02
001e60 212b          .db "+!"
001e61 1e50          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e62 1e63          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e63 01fc          movw zl, tosl
001e64 9189
001e65 9199          loadtos
001e66 8120          ldd temp2, Z+0
001e67 8131          ldd temp3, Z+1
001e68 0f82          add tosl, temp2
001e69 1f93          adc tosh, temp3
001e6a 8380          std Z+0, tosl
001e6b 8391          std Z+1, tosh
001e6c 9189
001e6d 9199          loadtos
001e6e cd95          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e6f ff03          .dw $ff03
001e70 7072
001e71 0040          .db "rp@",0
001e72 1e5f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e73 1e74          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e74 939a
001e75 938a          savetos
001e76 b78d          in tosl, SPL
001e77 b79e          in tosh, SPH
001e78 cd8b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e79 ff03          .dw $ff03
001e7a 7072
001e7b 0021          .db "rp!",0
001e7c 1e6f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e7d 1e7e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e7e b72f          in temp2, SREG
001e7f 94f8          cli
001e80 bf8d          out SPL, tosl
001e81 bf9e          out SPH, tosh
001e82 bf2f          out SREG, temp2
001e83 9189
001e84 9199          loadtos
001e85 cd7e          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e86 ff03          .dw $ff03
001e87 7073
001e88 0040          .db "sp@",0
001e89 1e79          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e8a 1e8b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e8b 939a
001e8c 938a          savetos
001e8d 01ce          movw tosl, yl
001e8e cd75          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e8f ff03          .dw $ff03
001e90 7073
001e91 0021          .db "sp!",0
001e92 1e86          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e93 1e94          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e94 01ec          movw yl, tosl
001e95 9189
001e96 9199          loadtos
001e97 cd6c          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e98 1e99          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
001e99 01fd          movw zl, xl
001e9a 0fee
001e9b 1fff
001e9c 9105
001e9d 9115          readflashcell temp0,temp1
001e9e 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
001e9f 9129          ld temp2, Y+
001ea0 9139          ld temp3, Y+
                 PFA_DODO1:
001ea1 931f          push temp1
001ea2 930f          push temp0
001ea3 933f          push temp3
001ea4 932f          push temp2
001ea5 939f          push tosh
001ea6 938f          push tosl
001ea7 9189
001ea8 9199          loadtos
001ea9 cd5a          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
001eaa 1eab          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
001eab 01fd          movw zl, xl
001eac 0fee
001ead 1fff
001eae 9105
001eaf 9115          readflashcell temp0,temp1
001eb0 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
001eb1 9129          ld temp2, Y+
001eb2 9139          ld temp3, Y+
                     ; now check for equality
001eb3 1782          cp tosl, temp2
001eb4 0793          cpc tosh, temp3
001eb5 f759          brne PFA_DODO1
                     ; both values are the same -> skip loop
001eb6 01d8          movw xl, temp0
001eb7 9189
001eb8 9199          loadtos
001eb9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001eba ff01          .dw $FF01
001ebb 0069          .db "i",0
001ebc 1e8f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001ebd 1cfd          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001ebe 1ebf          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001ebf 91ef          pop zl
001ec0 91ff          pop zh
001ec1 0fe8          add zl, tosl
001ec2 1ff9          adc zh, tosh
001ec3 2f19          mov temp1, tosh
001ec4 9189
001ec5 9199          loadtos
                 PFA_DOPLUSLOOP4: 
001ec6 912f          pop temp2
001ec7 913f          pop temp3
001ec8 17e2          cp zl, temp2
001ec9 07f3          cpc zh, temp3
001eca ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
001ecb c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
001ecc f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
001ecd c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
001ece f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
001ecf 933f          push temp3
001ed0 932f          push temp2
001ed1 93ff          push zh
001ed2 93ef          push zl
001ed3 cd56          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
001ed4 910f          pop  temp0
001ed5 911f          pop  temp1  ; remove leave destination
001ed6 9611          adiw xl, 1 ; skip branch-back address
001ed7 cd2c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001ed8 1ed9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001ed9 91ef          pop zl
001eda 91ff          pop zh
001edb 9631          adiw zl,1
001edc 912f          pop temp2
001edd 913f          pop temp3
001ede 17e2          cp zl, temp2
001edf 07f3          cpc zh, temp3
001ee0 f399          breq PFA_DOPLUSLOOP1
001ee1 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ee2 ff06          .dw $ff06
001ee3 6e75
001ee4 6f6c
001ee5 706f          .db "unloop"
001ee6 1eba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ee7 1ee8          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ee8 911f          pop temp1
001ee9 910f          pop temp0
001eea 911f          pop temp1
001eeb 910f          pop temp0
001eec 911f          pop temp1
001eed 910f          pop temp0
001eee cd15          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001eef ff06          .dw $ff06
001ef0 6d63
001ef1 766f
001ef2 3e65          .db "cmove>"
001ef3 1ee2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001ef4 1ef5          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ef5 93bf          push xh
001ef6 93af          push xl
001ef7 91e9          ld zl, Y+
001ef8 91f9          ld zh, Y+ ; addr-to
001ef9 91a9          ld xl, Y+
001efa 91b9          ld xh, Y+ ; addr-from
001efb 2f09          mov temp0, tosh
001efc 2b08          or temp0, tosl
001efd f041          brbs 1, PFA_CMOVE_G1
001efe 0fe8          add zl, tosl
001eff 1ff9          adc zh, tosh
001f00 0fa8          add xl, tosl
001f01 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001f02 911e          ld temp1, -X
001f03 9312          st -Z, temp1
001f04 9701          sbiw tosl, 1
001f05 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001f06 91af          pop xl
001f07 91bf          pop xh
001f08 9189
001f09 9199          loadtos
001f0a ccf9          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001f0b ff02          .dw $ff02
001f0c 3c3e          .db "><"
001f0d 1eef          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001f0e 1f0f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001f0f 2f09          mov temp0, tosh
001f10 2f98          mov tosh, tosl
001f11 2f80          mov tosl, temp0
001f12 ccf1          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001f13 ff03          .dw $ff03
001f14 7075
001f15 0040          .db "up@",0
001f16 1f0b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001f17 1f18          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001f18 939a
001f19 938a          savetos
001f1a 01c2          movw tosl, upl
001f1b cce8          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001f1c ff03          .dw $ff03
001f1d 7075
001f1e 0021          .db "up!",0
001f1f 1f13          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001f20 1f21          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001f21 012c          movw upl, tosl
001f22 9189
001f23 9199          loadtos
001f24 ccdf          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
001f25 ff03          .dw $ff03
001f26 3e73
001f27 0064          .db "s>d",0
001f28 1f1c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
001f29 1c00          .dw DO_COLON
                 PFA_S2D:
001f2a 1cac          .dw XT_DUP
001f2b 1d2d          .dw XT_LESSZERO
                 .include "words/not.asm"
001f2c 1c1a      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
001f2d ff03          .dw $ff03
001f2e 6f6e
001f2f 0074          .db "not",0
001f30 1f25          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
001f31 1c00          .dw DO_COLON
                 PFA_NOT:
001f32 1d18          .dw XT_EQUALZERO
001f33 1c1a          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f34 ff02          .dw $ff02
001f35 6521          .db "!e"
001f36 1f2d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f37 1f38          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f38 01fc          movw zl, tosl
001f39 9189
001f3a 9199          loadtos
001f3b b72f          in_ temp2, SREG
001f3c 94f8          cli
001f3d d028          rcall PFA_FETCHE2
001f3e b500          in_  temp0, EEDR
001f3f 1708          cp temp0,tosl
001f40 f009          breq PFA_STOREE3
001f41 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f42 9631          adiw zl,1
001f43 d022          rcall PFA_FETCHE2
001f44 b500          in_  temp0, EEDR
001f45 1709          cp temp0,tosh
001f46 f011          breq PFA_STOREE4
001f47 2f89          mov tosl, tosh
001f48 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f49 bf2f          out_ SREG, temp2
001f4a 9189
001f4b 9199          loadtos
001f4c ccb7          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f4d 99f9          sbic EECR, EEPE
001f4e cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f4f b707          in_ temp0, SPMCSR
001f50 fd00          sbrc temp0,SPMEN
001f51 cffd          rjmp PFA_STOREE2
                 
001f52 bdf2          out_ EEARH,zh
001f53 bde1          out_ EEARL,zl
001f54 bd80          out_ EEDR, tosl
001f55 9afa          sbi EECR,EEMPE
001f56 9af9          sbi EECR,EEPE
                 
001f57 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f58 ff02          .dw $ff02
001f59 6540          .db "@e"
001f5a 1f34          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f5b 1f5c          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f5c b72f          in_ temp2, SREG
001f5d 94f8          cli
001f5e 01fc          movw zl, tosl
001f5f d006          rcall PFA_FETCHE2
001f60 b580          in_ tosl, EEDR
                 
001f61 9631          adiw zl,1
                 
001f62 d003          rcall PFA_FETCHE2
001f63 b590          in_  tosh, EEDR
001f64 bf2f          out_ SREG, temp2
001f65 cc9e          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f66 99f9          sbic EECR, EEPE
001f67 cffe          rjmp PFA_FETCHE2
                 
001f68 bdf2          out_ EEARH,zh
001f69 bde1          out_ EEARL,zl
                 
001f6a 9af8          sbi EECR,EERE
001f6b 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f6c ff02          .dw $ff02
001f6d 6921          .db "!i"
001f6e 1f58          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f6f 07c8          .dw PFA_DODEFER
                 PFA_STOREI:
001f70 000a          .dw EE_STOREI
001f71 078c          .dw XT_EDEFERFETCH
001f72 0791          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f73 ff09          .dw $ff09
001f74 2128
001f75 2d69
001f76 726e
001f77 7777
001f78 0029          .db "(!i-nrww)",0
001f79 1f6c          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f7a 1f7b          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f7b b71f        in temp1,SREG
001f7c 931f        push temp1
001f7d 94f8        cli
                 
001f7e 019c        movw temp2, tosl ; save the (word) address
001f7f 9189
001f80 9199        loadtos          ; get the new value for the flash cell
001f81 93af        push xl
001f82 93bf        push xh
001f83 93cf        push yl
001f84 93df        push yh
001f85 d009        rcall DO_STOREI_atmega
001f86 91df        pop yh
001f87 91cf        pop yl
001f88 91bf        pop xh
001f89 91af        pop xl
                   ; finally clear the stack
001f8a 9189
001f8b 9199        loadtos
001f8c 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f8d bf1f        out SREG,temp1
                 
001f8e cc75        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f8f d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f90 94e0        com temp4
001f91 94f0        com temp5
001f92 218e        and tosl, temp4
001f93 219f        and tosh, temp5
001f94 2b98        or tosh, tosl
001f95 f019        breq DO_STOREI_writepage 
                 
001f96 01f9          movw zl, temp2
001f97 e002          ldi temp0,(1<<PGERS)
001f98 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001f99 01f9        movw zl, temp2
001f9a e004        ldi temp0,(1<<PGWRT)
001f9b d01d        rcall dospm
                 
                   ; reenable RWW section
001f9c 01f9        movw zl, temp2
001f9d e100        ldi temp0,(1<<RWWSRE)
001f9e d01a        rcall dospm
001f9f 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001fa0 01f9        movw zl, temp2
                   ; get the beginning of page
001fa1 7ce0        andi zl,low(pagemask)
001fa2 7fff        andi zh,high(pagemask)
001fa3 01ef        movw y, z
                   ; loop counter (in words)
001fa4 e4a0        ldi xl,low(pagesize)
001fa5 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001fa6 01fe        movw z, y
001fa7 0fee
001fa8 1fff
001fa9 9145
001faa 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001fab 01fe        movw z, y
001fac 17e2        cp zl, temp2
001fad 07f3        cpc zh, temp3
001fae f011        breq pageload_newdata
001faf 010a          movw r0, temp6
001fb0 c002          rjmp pageload_cont
                 pageload_newdata:
001fb1 017a          movw temp4, temp6
001fb2 010c          movw r0, tosl
                 pageload_cont:
001fb3 2700        clr temp0
001fb4 d004        rcall dospm
001fb5 9621        adiw y, 1
001fb6 9711        sbiw x, 1
001fb7 f771        brne pageload_loop
                 
                 pageload_done:
001fb8 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fb9 99f9        sbic EECR, EEPE
001fba cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001fbb b717        in_  temp1, SPMCSR
001fbc fd10        sbrc temp1, SPMEN
001fbd cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fbe 0fee
001fbf 1fff        writeflashcell
                   ; execute spm
001fc0 6001        ori temp0, (1<<SPMEN)
001fc1 bf07        out_ SPMCSR,temp0
001fc2 95e8        spm
001fc3 9508        ret
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001fc4 ff02          .dw $ff02
001fc5 6940          .db "@i"
001fc6 1f73          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001fc7 1fc8          .dw PFA_FETCHI
                 PFA_FETCHI:
001fc8 01fc          movw zl, tosl
001fc9 0fee
001fca 1fff
001fcb 9185
001fcc 9195          readflashcell tosl,tosh
001fcd cc36          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 10 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 db 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 3b 0c         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 7a 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 6c 0b         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 c4 1f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 14 07         .dw XT_REC_FIND
00002a f7 06         .dw XT_REC_INTNUMBER
00002c 30 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 a9 0b         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 04         .dw rstackstart  ; USER_RP
00003e af 04         .dw stackstart   ; USER_SP0
000040 af 04         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 86 00         .dw XT_TX  ; USER_EMIT
000048 94 00         .dw XT_TXQ ; USER_EMITQ
00004a 5c 00         .dw XT_RX  ; USER_KEY
00004c 76 00         .dw XT_RXQ ; USER_KEYQ
00004e e1 08         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 cd 08         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 33 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 12
000058 7a 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega169" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  54 r18:  58 r19:  42 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 165 r25: 117 r26:  45 r27:  22 r28:   6 r29:   4 r30:  65 r31:  32 
x  :   4 y  : 177 z  :  41 
Registers used: 29 out of 35 (82.9%)

"ATmega169" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :   8 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   1 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  12 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  18 inc   :   2 jmp   :  21 
ld    : 125 ldd   :   4 ldi   :  20 lds   :   2 lpm   :  20 lsl   :  15 
lsr   :   1 mov   :  10 movw  :  64 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  19 pop   :  48 
push  :  34 rcall :  36 ret   :   7 reti  :   2 rjmp  :  88 rol   :  22 
ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   6 sbr   :   0 sbrc  :   4 sbrs  :   5 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  56 std   :   8 sts   :   3 
sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 74 out of 113 (65.5%)

"ATmega169" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003f9c   1796   8750  10546   16384  64.4%
[.dseg] 0x000100 0x0001db      0    219    219    1024  21.4%
[.eseg] 0x000000 0x00005a      0     90     90     512  17.6%

Assembly complete, 0 errors, 2 warnings
