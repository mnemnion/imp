
AVRASM ver. 2.1.51  p1284-16.asm Mon Dec 23 20:35:29 2013

p1284-16.asm(2): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
p1284-16.asm(3): Including file '../../core/devices/atmega1284p\device.asm'
../../core/devices/atmega1284p\device.asm(5): Including file '../../Atmel/Appnotes2\m1284Pdef.inc'
p1284-16.asm(12): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
p1284-16.asm(18): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(4): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(5): Including file '../../core\dict_wl.inc'
../../core\dict_wl.inc(2): Including file '../../core\words/set-current.asm'
../../core\dict_wl.inc(3): Including file '../../core\words/previous.asm'
../../core\dict_wl.inc(4): Including file '../../core\words/definitions.asm'
../../core\dict_wl.inc(5): Including file '../../core\words/wordlist.asm'
../../core\dict_wl.inc(7): Including file '../../core\words/only.asm'
../../core\dict_wl.inc(8): Including file '../../core\words/forth.asm'
../../core\dict_wl.inc(9): Including file '../../core\words/forth-wordlist.asm'
../../core\dict_wl.inc(10): Including file '../../core\words/also.asm'
../../core\dict_wl.inc(11): Including file '../../core\words/set-order.asm'
../../core\dict_wl.inc(12): Including file '../../core\words/order.asm'
dict_appl.inc(8): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(10): Including file '../../core\words/d-2star.asm'
dict_appl.inc(11): Including file '../../core\words/d-plus.asm'
dict_appl.inc(12): Including file '../../core\words/d-minus.asm'
dict_appl.inc(13): Including file '../../core\words/d-invert.asm'
dict_appl.inc(14): Including file '../../core\words/d-equal.asm'
dict_appl.inc(15): Including file '../../core\words/udot.asm'
dict_appl.inc(16): Including file '../../core\words/udotr.asm'
dict_appl.inc(17): Including file '../../core\words/dot-s.asm'
dict_appl.inc(19): Including file '../../core\words/dotstring.asm'
dict_appl.inc(20): Including file '../../core\words/squote.asm'
dict_appl.inc(22): Including file '../../core\words/edefer.asm'
dict_appl.inc(23): Including file '../../core\words/rdefer.asm'
dict_appl.inc(24): Including file '../../core\words/is.asm'
dict_appl.inc(26): Including file 'words/applturnkey.asm'
dict_appl.inc(28): Including file '../../core\words/fill.asm'
dict_appl.inc(30): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(31): Including file '../../core\words/words.asm'
dict_appl.inc(33): Including file '../../core\words/1ms.asm'
dict_appl.inc(34): Including file '../../core\words/2literal.asm'
dict_appl.inc(35): Including file '../../core/devices/atmega1284p\device.inc'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(3): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(4): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/fetch-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(7): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(8): Including file '../../core\words/n_to_r.asm'
dict_appl_core.inc(9): Including file '../../core\words/n_r_from.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_USART1 = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0d7      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0d5      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0d3      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d0d1      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d0cf      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d0cd      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d0cb      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d0c9      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d0c7      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d0c5      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d0c3      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d0c1      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d0bf      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d0bd      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d0bb      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d0b9      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d0b7      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d0b5      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d0b3      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0b1      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0af      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0ad      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0ab      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0a9      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0a7      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0a5      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0a3      	 rcall isr ; Store Program Memory Read
                 .org 56
000038 d0a1      	 rcall isr ; USART1 RX complete
                 .org 58
00003a d09f      	 rcall isr ; USART1 Data Register Empty
                 .org 60
00003c d09d      	 rcall isr ; USART1 TX complete
                 .org 62
00003e d09b      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d099      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d097      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d095      	 rcall isr ; Timer/Counter3 Overflow
                 .equ INTVECTORS = 35
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000045 4000      	.dw 16384
                 mcu_eepromsize:
000046 1000      	.dw 4096
                 mcu_maxdp:
000047 ffff      	.dw 65535 
                 mcu_numints:
000048 0023      	.dw 35
                 mcu_name:
000049 000b      	.dw 11
00004a 5441
00004b 656d
00004c 6167
00004d 3231
00004e 3438
00004f 0050      	.db "ATmega1284P",0
                 .set codestart=pc
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 .equ TIBSIZE  = $64    ; 80 characters is one line...
                 .equ APPUSERSIZE = 10  ; size of user area
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 ; baud rate of terminal
                 .equ BAUD = 9600
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000028 940c 0050   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000050 93af        push xl
000051 b7af        in xl, SREG
000052 93af        push xl
000053 93bf        push xh
000054 93ef        push zl
000055 93ff        push zh
                 
000056 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
000058 91a0 0100   lds xl,usart_rx_in
00005a e0e2        ldi zl, low(usart_rx_data)
00005b e0f1        ldi zh, high(usart_rx_data)
00005c 0fea        add zl, xl
00005d 1df3        adc zh, zeroh
00005e 83b0        st Z, xh
                 
00005f 95a3        inc xl
000060 70af        andi xl,usart_rx_mask
                 
000061 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000063 91ff        pop zh
000064 91ef        pop zl
000065 91bf        pop xh
000066 91af        pop xl
000067 bfaf        out SREG, xl
000068 91af        pop xl
000069 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00006a f000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00006b f146        .dw XT_ZERO
00006c f040        .dw XT_DOLITERAL
00006d 0100        .dw usart_rx_in
00006e f08e        .dw XT_STORE
                 
00006f f020        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000070 ff06          .dw $ff06
000071 7872
000072 692d
000073 7273          .db "rx-isr"
000074 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000075 f000          .dw DO_COLON
                 PFA_RX_ISR:
000076 008f        .dw XT_RXQ_ISR
000077 f039        .dw XT_DOCONDBRANCH
000078 0076        .dw PFA_RX_ISR
000079 f040        .dw XT_DOLITERAL
00007a 0101        .dw usart_rx_out
00007b f0a5        .dw XT_CFETCH
00007c f0be        .dw XT_DUP
00007d f24a        .dw XT_1PLUS
00007e f040        .dw XT_DOLITERAL
00007f 000f        .dw usart_rx_mask
000080 f22e        .dw XT_AND
000081 f040        .dw XT_DOLITERAL
000082 0101        .dw usart_rx_out
000083 f09a        .dw XT_CSTORE
000084 f040        .dw XT_DOLITERAL
000085 0102        .dw usart_rx_data
000086 f1b8        .dw XT_PLUS
000087 f0a5        .dw XT_CFETCH
000088 f020        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000089 ff07          .dw $ff07
00008a 7872
00008b 2d3f
00008c 7369
00008d 0072          .db "rx?-isr",0
00008e 0070          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
00008f f000          .dw DO_COLON
                 PFA_RXQ_ISR:
000090 0684        .dw XT_PAUSE
000091 f040        .dw XT_DOLITERAL
000092 0101        .dw usart_rx_out
000093 f0a5        .dw XT_CFETCH
000094 f040        .dw XT_DOLITERAL
000095 0100        .dw usart_rx_in
000096 f0a5        .dw XT_CFETCH
000097 f119        .dw XT_NOTEQUAL
000098 f020        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000099 ff07          .dw $ff07
00009a 7874
00009b 702d
00009c 6c6f
00009d 006c          .db "tx-poll",0
00009e 0089          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
00009f f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000a0 00ad        .dw XT_TXQ_POLL
0000a1 f039        .dw XT_DOCONDBRANCH
0000a2 00a0        .dw PFA_TX_POLL
                   ; send to usart
0000a3 f040        .dw XT_DOLITERAL
0000a4 00c6        .dw USART_DATA
0000a5 f09a        .dw XT_CSTORE
0000a6 f020        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000a7 ff08          .dw $ff08
0000a8 7874
0000a9 2d3f
0000aa 6f70
0000ab 6c6c          .db "tx?-poll"
0000ac 0099          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000ad f000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000ae 0684        .dw XT_PAUSE
0000af f040        .dw XT_DOLITERAL
0000b0 00c0        .dw USART_A
0000b1 f0a5        .dw XT_CFETCH
0000b2 f040        .dw XT_DOLITERAL
0000b3 0020        .dw bm_USART_TXRD
0000b4 f22e        .dw XT_AND
0000b5 f020        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000b6 ff04        .dw $ff04
0000b7 6275
0000b8 7272        .db "ubrr"
0000b9 00a7        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000ba f07b        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000bb 0054        .dw EE_UBRRVAL
0000bc 0ab9        .dw XT_EVALUEFETCH
0000bd 0abd        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000be ff06        .dw $ff06
0000bf 752b
0000c0 6173
0000c1 7472        .db "+usart"
0000c2 00b6        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000c3 f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000c4 f040        .dw XT_DOLITERAL
0000c5 0098        .dw USART_B_VALUE
0000c6 f040        .dw XT_DOLITERAL
0000c7 00c1        .dw USART_B
0000c8 f09a        .dw XT_CSTORE
                 
0000c9 f040        .dw XT_DOLITERAL
0000ca 0006        .dw USART_C_VALUE
0000cb f040        .dw XT_DOLITERAL
0000cc 00c2        .dw USART_C | bm_USARTC_en
0000cd f09a        .dw XT_CSTORE
                 
0000ce 00ba        .dw XT_UBRR
0000cf f0be        .dw XT_DUP
0000d0 f326        .dw XT_BYTESWAP
0000d1 f040        .dw XT_DOLITERAL
0000d2 00c5        .dw BAUDRATE_HIGH
0000d3 f09a        .dw XT_CSTORE
0000d4 f040        .dw XT_DOLITERAL
0000d5 00c4        .dw BAUDRATE_LOW
0000d6 f09a        .dw XT_CSTORE
                 
0000d7 006a        .dw XT_USART_INIT_RX
0000d8 077e        .dw XT_USART_INIT_TX
0000d9 f020        .dw XT_EXIT
                 
                 .set rstackstart = RAMEND
                 .set stackstart  = RAMEND - 80
                 
                 .set NUMWORDLISTS = 8
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 068d   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000da 920a          st -Y, r0
0000db b60f          in r0, SREG
0000dc 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000dd 900f          pop r0
0000de 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000df 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000e0 9200 0114     sts intcur, r0
0000e2 9009          ld r0, Y+
0000e3 be0f          out SREG, r0
0000e4 9009          ld r0, Y+
0000e5 9468          set ; set the interrupt flag for the inner interpreter
0000e6 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
0000e7 ff05          .dw $ff05
0000e8 5f66
0000e9 7063
0000ea 0075          .db "f_cpu",0
0000eb 00be          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0000ec f07b          .dw PFA_DOVALUE1
                 PFA_F_CPU:
0000ed 0056          .dw EE_FCPU
0000ee 00f0          .dw XT_FETCH2E
0000ef 00f9          .dw XT_STORE2E
                 
                 XT_FETCH2E:
0000f0 f000          .dw DO_COLON
                 PFA_FETCH2E:
0000f1 f387          .dw XT_FETCHI
0000f2 f0be          .dw XT_DUP
0000f3 0117          .dw XT_CELLPLUS
0000f4 f373          .dw XT_FETCHE
0000f5 f0d1          .dw XT_SWAP
0000f6 f373          .dw XT_FETCHE
0000f7 f0d1          .dw XT_SWAP
0000f8 f020          .dw XT_EXIT
                 
                 XT_STORE2E:
0000f9 f000          .dw DO_COLON
                 PFA_STORE2E:
0000fa f040          .dw XT_DOLITERAL
0000fb ffeb          .dw -21
0000fc 046e          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0000fd ff05          .dw $ff05
0000fe 7473
0000ff 7461
000100 0065          .db "state",0
000101 00e7          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
000102 f04e          .dw PFA_DOVARIABLE
                 PFA_STATE:
000103 015b          .dw ram_state
                 
                 .dseg
00015b           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
000104 ff04          .dw $ff04
000105 6162
000106 6573          .db "base"
000107 00fd          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000108 f061          .dw PFA_DOUSER
                 PFA_BASE:
000109 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00010a ff05          .dw $ff05
00010b 6563
00010c 6c6c
00010d 0073          .db "cells",0
00010e 0104          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00010f f000          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
000110 f226          .dw XT_2STAR
                 .else
                 .endif
000111 f020          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
000112 ff05          .dw $ff05
000113 6563
000114 6c6c
000115 002b          .db "cell+",0
000116 010a          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000117 0118          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000118 9602          adiw tosl, CELLSIZE
000119 940c f004     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
00011b ff04          .dw $ff04
00011c 6432
00011d 7075          .db "2dup"
00011e 0112          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00011f f000          .dw DO_COLON
                 PFA_2DUP:
000120 f0dc          .dw XT_OVER
000121 f0dc          .dw XT_OVER
000122 f020          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
000123 ff05          .dw $ff05
000124 6432
000125 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
000126 0070          .db "2drop"
000127 011b          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000128 f000          .dw DO_COLON
                 PFA_2DROP:
000129 f0e6          .dw XT_DROP
00012a f0e6          .dw XT_DROP
00012b f020          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
00012c ff03          .dw $ff03
00012d 693e
00012e 006e          .db ">in",0
00012f 0123          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
000130 f061          .dw PFA_DOUSER
                 PFA_G_IN:
000131 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
000132 ff04          .dw $ff04
000133 7423
000134 6269          .db "#tib"
000135 012c          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000136 f04e          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000137 015d          .dw ram_sharptib
                 
                 .dseg
00015d           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000138 ff03          .dw $ff03
000139 6170
00013a 0064          .db "pad",0
00013b 0132          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00013c f000          .dw DO_COLON
                 PFA_PAD:
00013d 0176          .dw XT_HERE
00013e f040          .dw XT_DOLITERAL
00013f 0064          .dw 100
000140 f1b8          .dw XT_PLUS
000141 f020          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
000142 ff04          .dw $ff04
000143 6d65
000144 7469          .db "emit"
000145 0138          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000146 07e1          .dw PFA_DODEFER
                 PFA_EMIT:
000147 000e          .dw USER_EMIT
000148 07b9          .dw XT_UDEFERFETCH
000149 07c0          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00014a ff05          .dw $ff05
00014b 6d65
00014c 7469
00014d 003f          .db "emit?",0
00014e 0142          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00014f 07e1          .dw PFA_DODEFER
                 PFA_EMITQ:
000150 0010          .dw USER_EMITQ
000151 07b9          .dw XT_UDEFERFETCH
000152 07c0          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
000153 ff03          .dw $ff03
000154 656b
000155 0079          .db "key",0
000156 014a          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000157 07e1          .dw PFA_DODEFER
                 PFA_KEY:
000158 0012          .dw USER_KEY
000159 07b9          .dw XT_UDEFERFETCH
00015a 07c0          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
00015b ff04          .dw $ff04
00015c 656b
00015d 3f79          .db "key?"
00015e 0153          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00015f 07e1          .dw PFA_DODEFER
                 PFA_KEYQ:
000160 0014          .dw USER_KEYQ
000161 07b9          .dw XT_UDEFERFETCH
000162 07c0          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000163 ff02          .dw $ff02
000164 7064          .db "dp"
000165 015b          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000166 f07b          .dw PFA_DOVALUE1
                 PFA_DP:
000167 0002          .dw EE_DP
000168 0ab9          .dw XT_EVALUEFETCH
000169 0abd          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
00016a ff03          .dw $ff03
00016b 6465
00016c 0070          .db "edp",0
00016d 0163          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
00016e f07b          .dw PFA_DOVALUE1
                 PFA_EDP:
00016f 0006          .dw EE_EDP
000170 0ab9          .dw XT_EVALUEFETCH
000171 0abd          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000172 ff04          .dw $ff04
000173 6568
000174 6572          .db "here"
000175 016a          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000176 f07b          .dw PFA_DOVALUE1
                 PFA_HERE:
000177 0004          .dw EE_HERE
000178 0ab9          .dw XT_EVALUEFETCH
000179 0abd          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00017a ff05          .dw $ff05
00017b 6c61
00017c 6f6c
00017d 0074          .db "allot",0
00017e 0172          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00017f f000          .dw DO_COLON
                 PFA_ALLOT:
000180 0176          .dw XT_HERE
000181 f1b8          .dw XT_PLUS
000182 0799          .dw XT_DOTO
000183 0177          .dw PFA_HERE
000184 f020          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000185 ff08          .dw $ff08
000186 6328
000187 6572
000188 7461
000189 2965          .db "(create)"
00018a 017a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00018b f000          .dw DO_COLON
                 PFA_DOCREATE:
00018c 05fe          .dw XT_PARSENAME
00018d 0a08          .dw XT_WLSCOPE
00018e f0be          .dw XT_DUP
00018f f105          .dw XT_TO_R
000190 09ed          .dw XT_HEADER
000191 f0fc          .dw XT_R_FROM
                 .dseg
00015f           COLON_SMUDGE: .byte 4
                 .cseg
000192 f040          .dw XT_DOLITERAL
000193 0161          .dw COLON_SMUDGE+2
000194 f08e          .dw XT_STORE		; save wid
000195 f040          .dw XT_DOLITERAL
000196 015f          .dw COLON_SMUDGE+0
000197 f08e          .dw XT_STORE		; save NFA
                 
000198 f020          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
000199 0001          .dw $0001
00019a 005c          .db "\",0
00019b 0185          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00019c f000          .dw DO_COLON
                 PFA_BACKSLASH:
00019d 05e3          .dw XT_SOURCE
00019e f0d1          .dw XT_SWAP
00019f f0e6          .dw XT_DROP
0001a0 0130          .dw XT_G_IN
0001a1 f08e          .dw XT_STORE
0001a2 f020          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
0001a3 0001          .dw $0001
0001a4 0028          .db "(" ,0
0001a5 0199          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
0001a6 f000          .dw DO_COLON
                 PFA_LPARENTHESIS:
0001a7 f040          .dw XT_DOLITERAL
0001a8 0029          .dw $29
0001a9 05af          .dw XT_PARSE
0001aa 0128          .dw XT_2DROP
0001ab f020          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
0001ac ff07          .dw $ff07
0001ad 6f63
0001ae 706d
0001af 6c69
0001b0 0065          .db "compile",0
0001b1 01a3          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001b2 f000          .dw DO_COLON
                 PFA_COMPILE:
0001b3 f0fc          .dw XT_R_FROM
0001b4 f0be          .dw XT_DUP
0001b5 f24a          .dw XT_1PLUS
0001b6 f105          .dw XT_TO_R
0001b7 f387          .dw XT_FETCHI
0001b8 01bd          .dw XT_COMMA
0001b9 f020          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001ba ff01          .dw $ff01
0001bb 002c          .db ',',0 ; ,
0001bc 01ac          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001bd f000          .dw DO_COLON
                 PFA_COMMA:
0001be 0166          .dw XT_DP
0001bf f394          .dw XT_STOREI
0001c0 0166          .dw XT_DP
0001c1 f24a          .dw XT_1PLUS
0001c2 0799          .dw XT_DOTO
0001c3 0167          .dw PFA_DP
0001c4 f020          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
0001c5 0003          .dw $0003
0001c6 275b
0001c7 005d          .db "[']",0
0001c8 01ba          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001c9 f000          .dw DO_COLON
                 PFA_BRACKETTICK:
0001ca 01b2          .dw XT_COMPILE
0001cb f040          .dw XT_DOLITERAL
0001cc 0441          .dw XT_TICK
0001cd 01bd          .dw XT_COMMA
0001ce f020          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
0001cf ff03          .dw $ff03
0001d0 6962
0001d1 006e          .db "bin",0
0001d2 01c5          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0001d3 f000          .dw DO_COLON
                 PFA_BIN:
0001d4 f040          .dw XT_DOLITERAL
0001d5 0002          .dw 2
0001d6 0108          .dw XT_BASE
0001d7 f08e          .dw XT_STORE
0001d8 f020          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
0001d9 ff07          .dw $ff07
0001da 6564
0001db 6963
0001dc 616d
0001dd 006c          .db "decimal",0
0001de 01cf          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0001df f000          .dw DO_COLON
                 PFA_DECIMAL:
0001e0 f040          .dw XT_DOLITERAL
0001e1 000a          .dw 10
0001e2 0108          .dw XT_BASE
0001e3 f08e          .dw XT_STORE
0001e4 f020          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
0001e5 ff03          .dw $ff03
0001e6 6568
0001e7 0078          .db "hex",0
0001e8 01d9          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0001e9 f000          .dw DO_COLON
                 PFA_HEX:
0001ea f040          .dw XT_DOLITERAL
0001eb 0010          .dw 16
0001ec 0108          .dw XT_BASE
0001ed f08e          .dw XT_STORE
0001ee f020          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
0001ef ff02          .dw $ff02
0001f0 6c62          .db "bl"
0001f1 01e5          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0001f2 f04e          .dw PFA_DOVARIABLE
                 PFA_BL:
0001f3 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0001f4 ff07          .dw $ff07
0001f5 7574
0001f6 6e72
0001f7 656b
0001f8 0079          .db "turnkey",0
0001f9 01ef          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0001fa 07e1          .dw PFA_DODEFER
                 PFA_TURNKEY:
0001fb 0008          .dw EE_TURNKEY
0001fc 07a5          .dw XT_EDEFERFETCH
0001fd 07aa          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
0001fe ff05          .dw $ff05
0001ff 2f2a
000200 6f6d
000201 0064          .db "*/mod",0
000202 01f4          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
000203 f000          .dw DO_COLON
                 PFA_STARSLASHMOD:
000204 f105          .dw XT_TO_R
000205 f1c1          .dw XT_MSTAR
000206 f0fc          .dw XT_R_FROM
000207 f1dd          .dw XT_UMSLASHMOD
000208 f020          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000209 ff04          .dw $ff04
00020a 6d2f
00020b 646f          .db "/mod"
00020c 01fe          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00020d 020e          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00020e 019c          movw temp2, tosl
                     
00020f 9109          ld temp0, Y+
000210 9119          ld temp1, Y+
                 
000211 2f41          mov	temp6,temp1	;move dividend High to sign register
000212 2743          eor	temp6,temp3	;xor divisor High with sign register
000213 ff17          sbrs	temp1,7	;if MSB in dividend set
000214 c004          rjmp	PFA_SLASHMOD_1
000215 9510          com	temp1		;    change sign of dividend
000216 9500          com	temp0		
000217 5f0f          subi	temp0,low(-1)
000218 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000219 ff37          sbrs	temp3,7	;if MSB in divisor set
00021a c004          rjmp	PFA_SLASHMOD_2
00021b 9530          com	temp3		;    change sign of divisor
00021c 9520          com	temp2		
00021d 5f2f          subi	temp2,low(-1)
00021e 4f3f          sbci	temp3,high(-1)
00021f 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000220 18ff          sub	temp5,temp5;clear remainder High byte and carry
000221 e151          ldi	temp7,17	;init loop counter
                 
000222 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000223 1f11          rol	temp1
000224 955a          dec	temp7		;decrement counter
000225 f439          brne	PFA_SLASHMOD_5		;if done
000226 ff47          sbrs	temp6,7		;    if MSB in sign register set
000227 c004          rjmp	PFA_SLASHMOD_4
000228 9510          com	temp1	;        change sign of result
000229 9500          com	temp0
00022a 5f0f          subi	temp0,low(-1)
00022b 4f1f          sbci	temp1,high(-1)
00022c c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00022d 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00022e 1cff          rol	temp5
00022f 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000230 0af3          sbc	temp5,temp3	;
000231 f420          brcc	PFA_SLASHMOD_6		;if result negative
000232 0ee2          add	temp4,temp2	;    restore remainder
000233 1ef3          adc	temp5,temp3
000234 9488          clc			;    clear carry to be shifted into result
000235 cfec          rjmp	PFA_SLASHMOD_3		;else
000236 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000237 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000238 92fa          st -Y,temp5
000239 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00023a 01c8          movw tosl, temp0
00023b 940c f004     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
00023d ff02          .dw $ff02
00023e 2f2a          .db "*/"
00023f 0209          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
000240 f000          .dw DO_COLON
                 PFA_STARSLASH:
000241 0203          .dw XT_STARSLASHMOD
000242 f0d1          .dw XT_SWAP
000243 f0e6          .dw XT_DROP
000244 f020          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000245 ff05          .dw $ff05
000246 2f75
000247 6f6d
000248 0064          .db "u/mod",0
000249 023d          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00024a f000          .dw DO_COLON
                 PFA_USLASHMOD:
00024b f105          .dw XT_TO_R
00024c f146          .dw XT_ZERO
00024d f0fc          .dw XT_R_FROM
00024e f1dd          .dw XT_UMSLASHMOD
00024f f020          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000250 ff06          .dw $ff06
000251 656e
000252 6167
000253 6574          .db "negate"
000254 0245          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000255 f000          .dw DO_COLON
                 PFA_NEGATE:
000256 f218          .dw XT_INVERT
000257 f24a          .dw XT_1PLUS
000258 f020          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
000259 ff01          .dw $ff01
00025a 002f          .db "/",0
00025b 0250          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00025c f000          .dw DO_COLON
                 PFA_SLASH:
00025d 020d          .dw XT_SLASHMOD
00025e f0d1          .dw XT_SWAP
00025f f0e6          .dw XT_DROP
000260 f020          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
000261 ff03          .dw $ff03
000262 6f6d
000263 0064          .db "mod",0
000264 0259          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000265 f000          .dw DO_COLON
                 PFA_MOD:
000266 020d          .dw XT_SLASHMOD
000267 f0e6          .dw XT_DROP
000268 f020          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000269 ff03          .dw $ff03
00026a 6261
00026b 0073          .db "abs",0
00026c 0261          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00026d 026e          .dw PFA_ABS
                 PFA_ABS:
00026e 2399          tst tosh
00026f f41a          brpl PFA_ABS1
000270 9580          com tosl
000271 9590          com tosh
000272 9601          adiw tosl, 1
                 PFA_ABS1:
000273 940c f004     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
000275 ff03          .dw $ff03
000276 696d
000277 006e          .db "min",0
000278 0269          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000279 f000          .dw DO_COLON
                 PFA_MIN:
00027a 011f          .dw XT_2DUP
00027b f138          .dw XT_GREATER
00027c f039          .dw XT_DOCONDBRANCH
00027d 027f          .dw PFA_MIN1
00027e f0d1          .dw XT_SWAP
                 PFA_MIN1:
00027f f0e6          .dw XT_DROP
000280 f020          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
000281 ff03          .dw $ff03
000282 616d
000283 0078          .db "max",0
000284 0275          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000285 f000          .dw DO_COLON
                 PFA_MAX:
000286 011f          .dw XT_2DUP
000287 f131          .dw XT_LESS
000288 f039          .dw XT_DOCONDBRANCH
000289 028b          .dw PFA_MAX1
00028a f0d1          .dw XT_SWAP
                 PFA_MAX1:
00028b f0e6          .dw XT_DROP
00028c f020          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
00028d ff06          .dw $ff06
00028e 6977
00028f 6874
000290 6e69          .db "within"
000291 0281          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000292 f000          .dw DO_COLON
                 PFA_WITHIN:
000293 f0dc          .dw XT_OVER
000294 f1ae          .dw XT_MINUS
000295 f105          .dw XT_TO_R
000296 f1ae          .dw XT_MINUS
000297 f0fc          .dw XT_R_FROM
000298 f158          .dw XT_ULESS
000299 f020          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
00029a ff07          .dw $ff07 
00029b 6f74
00029c 7075
00029d 6570
00029e 0072          .db "toupper",0
00029f 028d          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0002a0 f000          .dw DO_COLON 
                 PFA_TOUPPER:
0002a1 f0be          .dw XT_DUP 
0002a2 f040          .dw XT_DOLITERAL 
0002a3 0061          .dw 'a' 
0002a4 f040          .dw XT_DOLITERAL 
0002a5 007b          .dw 'z'+1
0002a6 0292          .dw XT_WITHIN 
0002a7 f039          .dw XT_DOCONDBRANCH
0002a8 02ac          .dw PFA_TOUPPER0 
0002a9 f040          .dw XT_DOLITERAL
0002aa 00df          .dw $df ; inverse of 0x20
0002ab f22e          .dw XT_AND 
                 PFA_TOUPPER0:
0002ac f020          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
0002ad ff07          .dw $ff07
0002ae 6f74
0002af 6f6c
0002b0 6577
0002b1 0072          .db "tolower",0
0002b2 029a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0002b3 f000          .dw DO_COLON
                 PFA_TOLOWER:
0002b4 f0be          .dw XT_DUP
0002b5 f040          .dw XT_DOLITERAL
0002b6 0041          .dw 'A'
0002b7 f040          .dw XT_DOLITERAL
0002b8 005b          .dw 'Z'+1
0002b9 0292          .dw XT_WITHIN
0002ba f039          .dw XT_DOCONDBRANCH
0002bb 02bf          .dw PFA_TOLOWER0 
0002bc f040          .dw XT_DOLITERAL
0002bd 0020          .dw $20 
0002be f237          .dw XT_OR 
                 PFA_TOLOWER0:
0002bf f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002c0 ff03          .dw $ff03
0002c1 6c68
0002c2 0064          .db "hld",0
0002c3 02ad          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002c4 f04e          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002c5 0163          .dw ram_hld
                 
                 .dseg
000163           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
0002c6 ff04          .dw $ff04
0002c7 6f68
0002c8 646c          .db "hold"
0002c9 02c0          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0002ca f000          .dw DO_COLON
                 PFA_HOLD:
0002cb 02c4          .dw XT_HLD
0002cc f0be          .dw XT_DUP
0002cd f086          .dw XT_FETCH
0002ce f250          .dw XT_1MINUS
0002cf f0be          .dw XT_DUP
0002d0 f105          .dw XT_TO_R
0002d1 f0d1          .dw XT_SWAP
0002d2 f08e          .dw XT_STORE
0002d3 f0fc          .dw XT_R_FROM
0002d4 f09a          .dw XT_CSTORE
0002d5 f020          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
0002d6 ff02          .dw $ff02
0002d7 233c          .db "<#"
0002d8 02c6          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0002d9 f000          .dw DO_COLON
                 PFA_L_SHARP:
0002da 013c          .dw XT_PAD
0002db 02c4          .dw XT_HLD
0002dc f08e          .dw XT_STORE
0002dd f020          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
0002de ff01          .dw $ff01
0002df 0023          .db "#",0
0002e0 02d6          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0002e1 f000          .dw DO_COLON
                 PFA_SHARP:
0002e2 0108          .dw XT_BASE
0002e3 f086          .dw XT_FETCH
0002e4 0360          .dw XT_UDSLASHMOD
0002e5 f0ee          .dw XT_ROT
0002e6 f040          .dw XT_DOLITERAL
0002e7 0009          .dw 9
0002e8 f0dc          .dw XT_OVER
0002e9 f131          .dw XT_LESS
0002ea f039          .dw XT_DOCONDBRANCH
0002eb 02ef          .dw PFA_SHARP1
0002ec f040          .dw XT_DOLITERAL
0002ed 0007          .dw 7
0002ee f1b8          .dw XT_PLUS
                 PFA_SHARP1:
0002ef f040          .dw XT_DOLITERAL
0002f0 0030          .dw $30
0002f1 f1b8          .dw XT_PLUS
0002f2 02ca          .dw XT_HOLD
0002f3 f020          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
0002f4 ff02          .dw $ff02
0002f5 7323          .db "#s"
0002f6 02de          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0002f7 f000          .dw DO_COLON
                 PFA_SHARP_S:
0002f8 02e1          .dw XT_SHARP
0002f9 011f          .dw XT_2DUP
0002fa f237          .dw XT_OR
0002fb f12a          .dw XT_EQUALZERO
0002fc f039          .dw XT_DOCONDBRANCH
0002fd 02f8          .dw PFA_SHARP_S
0002fe f020          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
0002ff ff02          .dw $ff02
000300 3e23          .db "#>"
000301 02f4          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000302 f000          .dw DO_COLON
                 PFA_SHARP_G:
000303 0128          .dw XT_2DROP
000304 02c4          .dw XT_HLD
000305 f086          .dw XT_FETCH
000306 f0be          .dw XT_DUP
000307 013c          .dw XT_PAD
000308 f0d1          .dw XT_SWAP
000309 f1ae          .dw XT_MINUS
00030a f020          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
00030b ff04          .dw $ff04
00030c 6973
00030d 6e67          .db "sign"
00030e 02ff          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00030f f000          .dw DO_COLON
                 PFA_SIGN:
000310 f13f          .dw XT_LESSZERO
000311 f039          .dw XT_DOCONDBRANCH
000312 0316          .dw PFA_SIGN1
000313 f040          .dw XT_DOLITERAL
000314 002d          .dw $2d
000315 02ca          .dw XT_HOLD
                 PFA_SIGN1:
000316 f020          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
000317 ff03          .dw $ff03
000318 2e64
000319 0072          .db "d.r",0
00031a 030b          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00031b f000          .dw DO_COLON
                 PFA_DDOTR:
00031c f105          .dw XT_TO_R
00031d f0d1          .dw XT_SWAP
00031e f0dc          .dw XT_OVER
00031f 08a1          .dw XT_DABS
000320 02d9          .dw XT_L_SHARP
000321 02f7          .dw XT_SHARP_S
000322 f0ee          .dw XT_ROT
000323 030f          .dw XT_SIGN
000324 0302          .dw XT_SHARP_G
000325 f0fc          .dw XT_R_FROM
000326 f0dc          .dw XT_OVER
000327 f1ae          .dw XT_MINUS
000328 0423          .dw XT_SPACES
000329 0432          .dw XT_TYPE
00032a f020          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
00032b ff02          .dw $ff02
00032c 722e          .db ".r"
00032d 0317          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00032e f000          .dw DO_COLON
                 PFA_DOTR:
00032f f105          .dw XT_TO_R
000330 f341          .dw XT_S2D
000331 f0fc          .dw XT_R_FROM
000332 031b          .dw XT_DDOTR
000333 f020          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
000334 ff02          .dw $ff02
000335 2e64          .db "d."
000336 032b          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000337 f000          .dw DO_COLON
                 PFA_DDOT:
000338 f146          .dw XT_ZERO
000339 031b          .dw XT_DDOTR
00033a 041a          .dw XT_SPACE
00033b f020          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
00033c ff01          .dw $ff01
00033d 002e          .db ".",0
00033e 0334          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00033f f000          .dw DO_COLON
                 PFA_DOT:
000340 f341          .dw XT_S2D
000341 0337          .dw XT_DDOT
000342 f020          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
000343 ff03          .dw $ff03
000344 6475
000345 002e          .db "ud.",0
000346 033c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000347 f000          .dw DO_COLON
                 PFA_UDDOT:
000348 f146          .dw XT_ZERO
000349 0350          .dw XT_UDDOTR
00034a 041a          .dw XT_SPACE
00034b f020          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
00034c ff04          .dw $ff04
00034d 6475
00034e 722e          .db "ud.r"
00034f 0343          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000350 f000          .dw DO_COLON
                 PFA_UDDOTR:
000351 f105          .dw XT_TO_R
000352 02d9          .dw XT_L_SHARP
000353 02f7          .dw XT_SHARP_S
000354 0302          .dw XT_SHARP_G
000355 f0fc          .dw XT_R_FROM
000356 f0dc          .dw XT_OVER
000357 f1ae          .dw XT_MINUS
000358 0423          .dw XT_SPACES
000359 0432          .dw XT_TYPE
00035a f020          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
00035b ff06          .dw $ff06
00035c 6475
00035d 6d2f
00035e 646f          .db "ud/mod"
00035f 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000360 f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
000361 f105          .dw XT_TO_R
000362 f146          .dw XT_ZERO
000363 f10e          .dw XT_R_FETCH
000364 f1dd          .dw XT_UMSLASHMOD
000365 f0fc          .dw XT_R_FROM
000366 f0d1          .dw XT_SWAP
000367 f105          .dw XT_TO_R
000368 f1dd          .dw XT_UMSLASHMOD
000369 f0fc          .dw XT_R_FROM
00036a f020          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
00036b ff06          .dw $ff06 
00036c 6964
00036d 6967
00036e 3f74          .db "digit?"
00036f 035b          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000370 f000          .dw DO_COLON 
                 PFA_DIGITQ:
000371 02a0          .dw XT_TOUPPER
000372 f040          .dw XT_DOLITERAL 
000373 0030          .dw $30 
000374 f1ae          .dw XT_MINUS 
000375 f0be          .dw XT_DUP 
000376 f040          .dw XT_DOLITERAL
000377 0009          .dw $09 
000378 f163          .dw XT_UGREATER 
000379 f039          .dw XT_DOCONDBRANCH
00037a 0387          .dw PFA_DIGITQ0 
00037b f040          .dw XT_DOLITERAL
00037c 0007          .dw $07 
00037d f1ae          .dw XT_MINUS 
00037e f0be          .dw XT_DUP 
00037f f040          .dw XT_DOLITERAL
000380 0009          .dw $09 
000381 0396          .dw XT_ULESSEQUAL
000382 f039          .dw XT_DOCONDBRANCH
000383 0387          .dw PFA_DIGITQ1 
000384 f0e6          .dw XT_DROP 
000385 f146          .dw XT_ZERO
000386 f020          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
000387 f0be          .dw XT_DUP 
000388 0108          .dw XT_BASE 
000389 f086          .dw XT_FETCH 
00038a 039e          .dw XT_UGREATEREQUAL
00038b f039          .dw XT_DOCONDBRANCH
00038c 0390          .dw PFA_DIGITQ2 
00038d f0e6          .dw XT_DROP 
00038e f146          .dw XT_ZERO
00038f f020          .dw XT_EXIT 
                 PFA_DIGITQ2:
000390 f14f          .dw XT_TRUE
000391 f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
000392 ff03          .dw $ff03 
000393 3c75
000394 003d          .db "u<=",0
000395 036b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
000396 f000          .dw DO_COLON 
                 PFA_ULESSEQUAL:
000397 f163          .dw XT_UGREATER 
000398 f218          .dw XT_INVERT 
000399 f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
00039a ff03          .dw $ff03 
00039b 3e75
00039c 003d          .db "u>=",0
00039d 0392          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
00039e f000          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
00039f f158          .dw XT_ULESS 
0003a0 f218          .dw XT_INVERT 
0003a1 f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003a2 f000        .dw DO_COLON
                 PFA_DOSLITERAL:
0003a3 f0fc        .dw XT_R_FROM   ; ( -- addr )
0003a4 f0be        .dw XT_DUP      ; ( -- addr addr )
0003a5 f0be        .dw XT_DUP
0003a6 f387        .dw XT_FETCHI   ; ( -- addr addr n )
0003a7 f0d1        .dw XT_SWAP
0003a8 f24a        .dw XT_1PLUS
0003a9 f0d1        .dw XT_SWAP
0003aa f0ee        .dw XT_ROT      ; ( -- addr' n addr )
0003ab f0dc        .dw XT_OVER     ; ( -- addr' n addr n)
0003ac f24a        .dw XT_1PLUS
0003ad f21f        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003ae f1b8        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003af f24a        .dw XT_1PLUS
0003b0 f105        .dw XT_TO_R     ; ( -- )
0003b1 f020        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003b2 ff02        .dw $ff02
0003b3 2c73        .db "s",$2c
0003b4 039a        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003b5 f000          .dw DO_COLON
                 PFA_SCOMMA:
0003b6 f0be          .dw XT_DUP
0003b7 03b9          .dw XT_DOSCOMMA
0003b8 f020          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003b9 f000          .dw DO_COLON
                 PFA_DOSCOMMA:
0003ba 01bd          .dw XT_COMMA
0003bb f0be          .dw XT_DUP   ; ( --addr len len)
0003bc f21f          .dw XT_2SLASH ; ( -- addr len len/2
0003bd f0d1          .dw XT_SWAP   ; ( -- addr len/2 len
0003be f0dc          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003bf f226          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003c0 f1ae          .dw XT_MINUS  ; ( -- addr len/2 rem
0003c1 f105          .dw XT_TO_R
0003c2 f146          .dw XT_ZERO
0003c3 f2bf          .dw XT_DOQDO
0003c4 03cb          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
0003c5 f0be          .dw XT_DUP         ; ( -- addr addr )
0003c6 f086          .dw XT_FETCH       ; ( -- addr c1c2 )
0003c7 01bd          .dw XT_COMMA       ; ( -- addr )
0003c8 0117          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003c9 f2f0          .dw XT_DOLOOP
0003ca 03c5          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003cb f0fc          .dw XT_R_FROM
0003cc f16e          .dw XT_GREATERZERO
0003cd f039          .dw XT_DOCONDBRANCH
0003ce 03d2          .dw PFA_SCOMMA3
0003cf f0be            .dw XT_DUP     ; well, tricky
0003d0 f0a5            .dw XT_CFETCH
0003d1 01bd            .dw XT_COMMA
                 PFA_SCOMMA3:
0003d2 f0e6          .dw XT_DROP        ; ( -- )
0003d3 f020          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003d4 ff05          .dw $ff05
0003d5 7469
0003d6 7079
0003d7 0065          .db "itype",0
0003d8 03b2          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003d9 f000          .dw DO_COLON
                 PFA_ITYPE:
0003da f0be          .dw XT_DUP    ; ( --addr len len)
0003db f21f          .dw XT_2SLASH ; ( -- addr len len/2
0003dc f0d1          .dw XT_SWAP   ; ( -- addr len/2 len
0003dd f0dc          .dw XT_OVER   ; ( -- addr len/2 len len/2
0003de f226          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003df f1ae          .dw XT_MINUS  ; ( -- addr len/2 rem
0003e0 f105          .dw XT_TO_R
0003e1 f146          .dw XT_ZERO
0003e2 f2bf          .dw XT_DOQDO
0003e3 03ec          .dw PFA_ITYPE2
                 PFA_ITYPE1:
0003e4 f0be          .dw XT_DUP         ; ( -- addr addr )
0003e5 f387          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003e6 f0be          .dw XT_DUP
0003e7 03f9          .dw XT_LOWEMIT
0003e8 03f5          .dw XT_HIEMIT
0003e9 f24a          .dw XT_1PLUS    ; ( -- addr+cell )
0003ea f2f0          .dw XT_DOLOOP
0003eb 03e4          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0003ec f0fc          .dw XT_R_FROM
0003ed f16e          .dw XT_GREATERZERO
0003ee f039          .dw XT_DOCONDBRANCH
0003ef 03f3          .dw PFA_ITYPE3
0003f0 f0be            .dw XT_DUP     ; make sure the drop below has always something to do
0003f1 f387            .dw XT_FETCHI
0003f2 03f9            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0003f3 f0e6          .dw XT_DROP
0003f4 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0003f5 f000          .dw DO_COLON
                 PFA_HIEMIT:
0003f6 f326          .dw XT_BYTESWAP
0003f7 03f9          .dw XT_LOWEMIT
0003f8 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0003f9 f000          .dw DO_COLON
                 PFA_LOWEMIT:
0003fa f040          .dw XT_DOLITERAL
0003fb 00ff          .dw $00ff
0003fc f22e          .dw XT_AND
0003fd 0146          .dw XT_EMIT
0003fe f020          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0003ff ff06          .dw $ff06
000400 6369
000401 756f
000402 746e          .db "icount"
000403 03d4          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000404 f000          .dw DO_COLON
                 PFA_ICOUNT:
000405 f0be          .dw XT_DUP
000406 f24a          .dw XT_1PLUS
000407 f0d1          .dw XT_SWAP
000408 f387          .dw XT_FETCHI
000409 f020          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
00040a ff02          .dw $ff02
00040b 7263          .db "cr"
00040c 03ff          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00040d f000          .dw DO_COLON
                 PFA_CR:
00040e f040          .dw XT_DOLITERAL
00040f 000d          .dw 13
000410 0146          .dw XT_EMIT
000411 f040          .dw XT_DOLITERAL
000412 000a          .dw 10
000413 0146          .dw XT_EMIT
000414 f020          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
000415 ff05          .dw $ff05
000416 7073
000417 6361
000418 0065          .db "space",0
000419 040a          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00041a f000          .dw DO_COLON
                 PFA_SPACE:
00041b 01f2          .dw XT_BL
00041c 0146          .dw XT_EMIT
00041d f020          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
00041e ff06          .dw $ff06
00041f 7073
000420 6361
000421 7365          .db "spaces"
000422 0415          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000423 f000          .dw DO_COLON
                 PFA_SPACES:
000424 f0be          .dw XT_DUP
000425 f16e          .dw XT_GREATERZERO
000426 f22e          .dw XT_AND
000427 f146          .dw XT_ZERO
000428 f2bf          .dw XT_DOQDO
000429 042d          .dw PFA_SPACES2
                 PFA_SPACES1:
00042a 041a          .dw XT_SPACE
00042b f2f0          .dw XT_DOLOOP
00042c 042a          .dw PFA_SPACES1
                 PFA_SPACES2:
00042d f020          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
00042e ff04          .dw $ff04
00042f 7974
000430 6570          .db "type"
000431 041e          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000432 f000          .dw DO_COLON
                 PFA_TYPE:
000433 f0dc          .dw XT_OVER
000434 f1b8          .dw XT_PLUS
000435 f0d1          .dW XT_SWAP
000436 f2bf          .dw XT_DOQDO
000437 043d          .dw PFA_TYPE2
                 PFA_TYPE1:
000438 f2d5          .dw XT_I
000439 f0a5          .dw XT_CFETCH
00043a 0146          .dw XT_EMIT
00043b f2f0          .dw XT_DOLOOP
00043c 0438          .dw PFA_TYPE1
                 PFA_TYPE2:
00043d f020          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
00043e ff01          .dw $ff01
00043f 0027          .db "'",0
000440 042e          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000441 f000          .dw DO_COLON
                 PFA_TICK:
000442 05fe          .dw XT_PARSENAME
000443 061b          .dw XT_FINDNAME
000444 f12a          .dw XT_EQUALZERO
000445 f039          .dw XT_DOCONDBRANCH
000446 044a          .dw PFA_TICK1
000447 f040          .dw XT_DOLITERAL
000448 fff3          .dw -13
000449 046e          .dw XT_THROW
                 PFA_TICK1:
00044a f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
00044b ff07          .dw $ff07
00044c 6168
00044d 646e
00044e 656c
00044f 0072          .db "handler",0
000450 043e          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000451 f061          .dw PFA_DOUSER
                 PFA_HANDLER:
000452 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
000453 ff05          .dw $ff05
000454 6163
000455 6374
000456 0068          .db "catch",0
000457 044b          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000458 f000          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
000459 f29c          .dw XT_SP_FETCH
00045a f105          .dw XT_TO_R
                     ; handler @ >r
00045b 0451          .dw XT_HANDLER
00045c f086          .dw XT_FETCH
00045d f105          .dw XT_TO_R
                     ; rp@ handler !
00045e f285          .dw XT_RP_FETCH
00045f 0451          .dw XT_HANDLER
000460 f08e          .dw XT_STORE
000461 f02a          .dw XT_EXECUTE
                     ; r> handler !
000462 f0fc          .dw XT_R_FROM
000463 0451          .dw XT_HANDLER
000464 f08e          .dw XT_STORE
000465 f0fc          .dw XT_R_FROM
000466 f0e6          .dw XT_DROP
000467 f146          .dw XT_ZERO
000468 f020          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
000469 ff05          .dw $ff05
00046a 6874
00046b 6f72
00046c 0077          .db "throw",0
00046d 0453          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00046e f000          .dw DO_COLON
                 PFA_THROW:
00046f f0be          .dw XT_DUP
000470 f12a          .dw XT_EQUALZERO
000471 f039          .dw XT_DOCONDBRANCH
000472 0475          .dw PFA_THROW1
000473 f0e6      	.dw XT_DROP
000474 f020      	.dw XT_EXIT
                 PFA_THROW1:
000475 0451          .dw XT_HANDLER
000476 f086          .dw XT_FETCH
000477 f28f          .dw XT_RP_STORE
000478 f0fc          .dw XT_R_FROM
000479 0451          .dw XT_HANDLER
00047a f08e          .dw XT_STORE
00047b f0fc          .dw XT_R_FROM
00047c f0d1          .dw XT_SWAP
00047d f105          .dw XT_TO_R
00047e f2a5          .dw XT_SP_STORE
00047f f0e6          .dw XT_DROP
000480 f0fc          .dw XT_R_FROM    
000481 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
000482 ff05          .dw $ff05
000483 7363
000484 696b
000485 0070          .db "cskip",0
000486 0469          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000487 f000          .dw DO_COLON
                 PFA_CSKIP:
000488 f105          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000489 f0be          .dw XT_DUP            ; ( -- addr' n' n' )
00048a f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00048b 0497          .dw PFA_CSKIP2
00048c f0dc          .dw XT_OVER           ; ( -- addr' n' addr' )
00048d f0a5          .dw XT_CFETCH         ; ( -- addr' n' c' )
00048e f10e          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00048f f123          .dw XT_EQUAL          ; ( -- addr' n' f )
000490 f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000491 0497          .dw PFA_CSKIP2
000492 f040          .dw XT_DOLITERAL
000493 0001          .dw 1
000494 05ed          .dw XT_SLASHSTRING
000495 f02f          .dw XT_DOBRANCH
000496 0489          .dw PFA_CSKIP1
                 PFA_CSKIP2:
000497 f0fc          .dw XT_R_FROM
000498 f0e6          .dw XT_DROP           ; ( -- addr2 n2)
000499 f020          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
00049a ff06          .dw $ff06
00049b 6361
00049c 6563
00049d 7470          .db "accept"
00049e 0482          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00049f f000          .dw DO_COLON
                 PFA_ACCEPT:
0004a0 f0be          .dw XT_DUP        ; ( -- addr n1 n1)
0004a1 f105          .dw XT_TO_R
0004a2 f105          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
0004a3 0157          .dw XT_KEY        ; ( -- addr k )
0004a4 f0be          .dw XT_DUP        ; ( -- addr k k )
0004a5 f040          .dw XT_DOLITERAL
0004a6 000a          .dw 10
0004a7 f119          .dw XT_NOTEQUAL
0004a8 f039          .dw XT_DOCONDBRANCH
0004a9 04dd          .dw PFA_ACCEPT2
0004aa f0be          .dw XT_DUP
0004ab f040          .dw XT_DOLITERAL
0004ac 000d          .dw 13
0004ad f119          .dw XT_NOTEQUAL
0004ae f039          .dw XT_DOCONDBRANCH
0004af 04dd          .dw PFA_ACCEPT2
                     ; check backspace
0004b0 f0be          .dw XT_DUP
0004b1 f040          .dw XT_DOLITERAL
0004b2 0008          .dw 8
0004b3 f123          .dw XT_EQUAL
0004b4 f039          .dw XT_DOCONDBRANCH
0004b5 04c9          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
0004b6 f0fc          .dw XT_R_FROM             ; ( -- addr k n1 )
0004b7 f10e          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
0004b8 f0dc          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
0004b9 f105          .dw XT_TO_R
0004ba f123          .dw XT_EQUAL              ; ( -- addr k f )
0004bb f039          .dw XT_DOCONDBRANCH
0004bc 04c0          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
0004bd f0e6          .dw XT_DROP               ; ( -- addr )
0004be f02f          .dw XT_DOBRANCH
0004bf 04a3          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
0004c0 f0be          .dw XT_DUP                ; ( -- addr k k )
0004c1 0146          .dw XT_EMIT               ; ( -- addr k )
0004c2 041a          .dw XT_SPACE              ; ( -- addr k )
0004c3 0146          .dw XT_EMIT               ; ( -- addr )
0004c4 f250          .dw XT_1MINUS             ; ( -- addr--)
0004c5 f0fc          .dw XT_R_FROM
0004c6 f24a          .dw XT_1PLUS
0004c7 f02f          .dw XT_DOBRANCH
0004c8 04d7          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
0004c9 f0be          .dw XT_DUP            ; ( -- addr k k )
0004ca 01f2          .dw XT_BL
0004cb f131          .dw XT_LESS
0004cc f039          .dw XT_DOCONDBRANCH
0004cd 04d0          .dw PFA_ACCEPT6
0004ce f0e6          .dw XT_DROP
0004cf 01f2          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
0004d0 f0be          .dw XT_DUP            ; ( -- addr k k)
0004d1 0146          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
0004d2 f0dc          .dw XT_OVER           ; ( -- addr k addr
0004d3 f09a          .dw XT_CSTORE         ; ( -- addr)
0004d4 f24a          .dw XT_1PLUS          ; ( -- addr++)
0004d5 f0fc          .dw XT_R_FROM         ; ( -- addr n1)
0004d6 f250          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
0004d7 f0be          .dw XT_DUP
0004d8 f105          .dw XT_TO_R
0004d9 f12a          .dw XT_EQUALZERO
0004da f039          .dw XT_DOCONDBRANCH
0004db 04a3          .dw PFA_ACCEPT1
0004dc f0be          .dw XT_DUP
                 PFA_ACCEPT2:
0004dd 0128          .dw XT_2DROP
0004de f0fc          .dw XT_R_FROM
0004df f0fc          .dw XT_R_FROM
0004e0 f0d1          .dw XT_SWAP
0004e1 f1ae          .dw XT_MINUS
0004e2 040d          .dw XT_CR
0004e3 f020          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004e4 ff06          .dw $ff06
0004e5 6572
0004e6 6966
0004e7 6c6c          .db "refill"
0004e8 049a          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004e9 07e1          .dw PFA_DODEFER
                 PFA_REFILL:
0004ea 001a          .dw USER_REFILL
0004eb 07b9          .dw XT_UDEFERFETCH
0004ec 07c0          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
0004ed ff04          .dw $ff04
0004ee 6863
0004ef 7261          .db "char"
0004f0 04e4          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004f1 f000          .dw DO_COLON
                 PFA_CHAR:
0004f2 05fe          .dw XT_PARSENAME
0004f3 f0e6          .dw XT_DROP
0004f4 f0a5          .dw XT_CFETCH
0004f5 f020          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
0004f6 ff06          .dw $ff06
0004f7 756e
0004f8 626d
0004f9 7265          .db "number"
0004fa 04ed          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004fb f000          .dw DO_COLON
                 PFA_NUMBER:
0004fc 0108          .dw XT_BASE
0004fd f086          .dw XT_FETCH
0004fe f105          .dw XT_TO_R
0004ff 056c          .dw XT_NUMBERSIGN
000500 f105          .dw XT_TO_R
000501 0538          .dw XT_PRAEFIX
000502 056c          .dw XT_NUMBERSIGN
000503 f0fc          .dw XT_R_FROM
000504 f237          .dw XT_OR
000505 f105          .dw XT_TO_R
000506 f105          .dw XT_TO_R
000507 f105          .dw XT_TO_R
000508 f146          .dw XT_ZERO       ; starting value
000509 f146          .dw XT_ZERO
00050a f0fc          .dw XT_R_FROM
00050b f0fc          .dw XT_R_FROM
00050c 058b          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00050d f0c6          .dw XT_QDUP
00050e f039              .dw XT_DOCONDBRANCH
00050f 052c      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
000510 f040          .dw XT_DOLITERAL
000511 0001          .dw 1
000512 f123          .dw XT_EQUAL
000513 f039          .dw XT_DOCONDBRANCH
000514 0523          .dw PFA_NUMBER2
                 	; excatly one character is left
000515 f0a5      	.dw XT_CFETCH
000516 f040      	.dw XT_DOLITERAL
000517 002e      	.dw $2e ; .
000518 f123      	.dw XT_EQUAL
000519 f039      	.dw XT_DOCONDBRANCH
00051a 0523      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
00051b f0fc      	.dw XT_R_FROM
00051c f039              .dw XT_DOCONDBRANCH
00051d 051f      	.dw PFA_NUMBER3
00051e 08ae              .dw XT_DNEGATE
                 PFA_NUMBER3:
00051f f040      	.dw XT_DOLITERAL
000520 0002      	.dw 2
000521 f02f      	.dw XT_DOBRANCH
000522 0533      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
000523 0128      	.dw XT_2DROP
000524 f0e6      	.dw XT_DROP
000525 f0fc      	.dw XT_R_FROM
000526 f0e6      	.dw XT_DROP
000527 f0fc              .dw XT_R_FROM
000528 0108              .dw XT_BASE
000529 f08e              .dw XT_STORE
00052a f146      	.dw XT_ZERO
00052b f020      	.dw XT_EXIT
                 PFA_NUMBER1:
00052c 0128          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00052d f0fc          .dw XT_R_FROM
00052e f039          .dw XT_DOCONDBRANCH
00052f 0531          .dw PFA_NUMBER4
000530 0255          .dw XT_NEGATE
                 PFA_NUMBER4:
000531 f040          .dw XT_DOLITERAL
000532 0001          .dw 1
                 PFA_NUMBER5:
000533 f0fc          .dw XT_R_FROM
000534 0108          .dw XT_BASE
000535 f08e          .dw XT_STORE
000536 f14f          .dw XT_TRUE
000537 f020          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
000538 f000          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
000539 f0dc          .dw XT_OVER 
00053a f0a5          .dw XT_CFETCH 
00053b f040          .dw XT_DOLITERAL
00053c 0029          .dw $29 
00053d f138          .dw XT_GREATER 
00053e f039          .dw XT_DOCONDBRANCH
00053f 0541          .dw PFA_PRAEFIX0 
000540 f020          .dw XT_EXIT 
                 PFA_PRAEFIX0:
000541 f0dc          .dw XT_OVER 
000542 f0a5          .dw XT_CFETCH 
000543 0548          .dw XT_SETBASE
000544 f040          .dw XT_DOLITERAL
000545 0001          .dw $1 
000546 05ed          .dw XT_SLASHSTRING 
000547 f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000548 f000          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000549 f0be          .dw XT_DUP 
00054a f040          .dw XT_DOLITERAL
00054b 0024          .dw '$' 
00054c f123          .dw XT_EQUAL 
00054d f039          .dw XT_DOCONDBRANCH
00054e 0552          .dw PFA_SETBASE0 
00054f f0e6          .dw XT_DROP 
000550 01e9          .dw XT_HEX 
000551 f020          .dw XT_EXIT 
                 PFA_SETBASE0:
000552 f0be          .dw XT_DUP 
000553 f040          .dw XT_DOLITERAL
000554 0025          .dw '%' 
000555 f123          .dw XT_EQUAL 
000556 f039          .dw XT_DOCONDBRANCH
000557 055b          .dw PFA_SETBASE1 
000558 f0e6          .dw XT_DROP 
000559 01d3          .dw XT_BIN
00055a f020          .dw XT_EXIT 
                 PFA_SETBASE1:
00055b f0be          .dw XT_DUP 
00055c f040          .dw XT_DOLITERAL
00055d 0026          .dw '&'
00055e f123          .dw XT_EQUAL 
00055f f039          .dw XT_DOCONDBRANCH
000560 0564          .dw PFA_SETBASE2 
000561 f0e6          .dw XT_DROP
000562 01df          .dw XT_DECIMAL 
000563 f020          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
000564 f040          .dw XT_DOLITERAL
000565 0023          .dw '#'
000566 f123          .dw XT_EQUAL 
000567 f039          .dw XT_DOCONDBRANCH
000568 056b          .dw PFA_SETBASE3 
000569 01df          .dw XT_DECIMAL 
00056a f020          .dw XT_EXIT 
                 PFA_SETBASE3:
00056b f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
00056c f000          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
00056d f0dc          .dw XT_OVER
00056e f0a5          .dw XT_CFETCH
00056f f040          .dw XT_DOLITERAL
000570 002b          .dw '+'
000571 f123          .dw XT_EQUAL
000572 f039          .dw XT_DOCONDBRANCH
000573 0577          .dw PFA_NUMBERSIGN_MINUS
000574 f040            .dw XT_DOLITERAL
000575 0001            .dw 1
000576 05ed            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
000577 f0dc          .dw XT_OVER    ; ( -- addr len addr )
000578 f0a5          .dw XT_CFETCH
000579 f040          .dw XT_DOLITERAL
00057a 002d          .dw '-'
00057b f123          .dw XT_EQUAL  ; ( -- addr len flag )
00057c f0be          .dw XT_DUP
00057d f105          .dw XT_TO_R
00057e f039          .dw XT_DOCONDBRANCH
00057f 0583          .dw PFA_NUMBERSIGN_PLUS
000580 f040          .dw XT_DOLITERAL      ; skip sign character
000581 0001          .dw 1
000582 05ed          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
000583 f0fc          .dw XT_R_FROM
000584 f020          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
000585 ff07          .dw $ff07
000586 6e3e
000587 6d75
000588 6562
000589 0072          .db ">number",0
00058a 04f6          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00058b f000          .dw DO_COLON
                 PFA_TO_NUMBER:
00058c f0be          .dw XT_DUP
00058d f039          .dw XT_DOCONDBRANCH
00058e 05a9          .dw PFA_TO_NUMBER1
00058f f0dc              .dw XT_OVER
000590 f0a5              .dw XT_CFETCH
000591 0370              .dw XT_DIGITQ
000592 f12a              .dw XT_EQUALZERO
000593 f039              .dw XT_DOCONDBRANCH
000594 0596              .dw PFA_TO_NUMBER2
000595 f020                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
000596 f105              .dw XT_TO_R
000597 08d3              .dw XT_2SWAP
000598 f0fc              .dw XT_R_FROM
000599 f0d1              .dw XT_SWAP
00059a 0108              .dw XT_BASE
00059b f086              .dw XT_FETCH
00059c f1fb              .dw XT_UMSTAR
00059d f0e6              .dw XT_DROP
00059e f0ee              .dw XT_ROT
00059f 0108              .dw XT_BASE
0005a0 f086              .dw XT_FETCH
0005a1 f1fb              .dw XT_UMSTAR
0005a2 0ce1              .dw XT_DPLUS
0005a3 08d3              .dw XT_2SWAP
0005a4 f040              .dw XT_DOLITERAL
0005a5 0001              .dw 1
0005a6 05ed              .dw XT_SLASHSTRING
0005a7 f02f          .dw XT_DOBRANCH
0005a8 058c          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
0005a9 f020          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
0005aa ff05          .dw $ff05
0005ab 6170
0005ac 7372
0005ad 0065          .db "parse",0
0005ae 0585          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0005af f000          .dw DO_COLON
                 PFA_PARSE:
0005b0 f105          .dw XT_TO_R     ; ( -- )
0005b1 05e3          .dw XT_SOURCE   ; ( -- addr len)
0005b2 0130          .dw XT_G_IN     ; ( -- addr len >in)
0005b3 f086          .dw XT_FETCH
0005b4 05ed          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0005b5 f0fc          .dw XT_R_FROM      ; ( -- addr' len' c)
0005b6 05c4          .dw XT_CSCAN       ; ( -- addr' len'')
0005b7 f0be          .dw XT_DUP         ; ( -- addr' len'' len'')
0005b8 f24a          .dw XT_1PLUS
0005b9 0130          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
0005ba f274          .dw XT_PLUSSTORE   ; ( -- addr' len')
0005bb f040          .dw XT_DOLITERAL
0005bc 0001          .dw 1
0005bd 05ed          .dw XT_SLASHSTRING
0005be f020          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
0005bf ff05          .dw $ff05
0005c0 7363
0005c1 6163
0005c2 006e          .db "cscan",0
0005c3 05aa          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0005c4 f000          .dw DO_COLON
                 PFA_CSCAN:
0005c5 f0d1          .dw XT_SWAP         ; ( -- addr1 c n1 )
0005c6 f0be          .dw XT_DUP          ; ( -- addr1 c n1 n1)
0005c7 f105          .dw XT_TO_R         ; ( -- addr1 c n1)
0005c8 f146          .dw XT_ZERO         ; ( -- addr1 c n1 0)
0005c9 f2bf          .dw XT_DOQDO        ; ( -- addr1 c)
0005ca 05db          .dw PFA_CSCAN3
                 PFA_CSCAN1:
0005cb f0dc          .dw XT_OVER         ; ( -- addr1 c addr1 )
0005cc f2d5          .dw XT_I            ; ( -- addr1 c addr1 i)
0005cd f1b8          .dw XT_PLUS         ; ( -- addr1 c addr')
0005ce f0a5          .dw XT_CFETCH       ; ( -- addr1 c c')
0005cf f0dc          .dw XT_OVER         ; ( -- addr1 c c' c)
0005d0 f123          .dw XT_EQUAL        ; ( -- addr1 c f)
0005d1 f039          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
0005d2 05d9          .dw PFA_CSCAN2
0005d3 f0e6          .dw XT_DROP         ; ( -- addr1 )
0005d4 f2d5          .dw XT_I            ; ( -- addr1 n2)
0005d5 f2ff          .dw XT_UNLOOP       ; ( -- addr1 n2)
0005d6 f0fc          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
0005d7 f0e6          .dw XT_DROP         ; ( -- addr1 n2)
0005d8 f020          .dw XT_EXIT
                 PFA_CSCAN2:
0005d9 f2f0          .dw XT_DOLOOP
0005da 05cb          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
0005db f0e6          .dw XT_DROP         ; ( -- addr1)
0005dc f0fc          .dw XT_R_FROM       ; ( -- addr1 n1)
0005dd f020          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0005de ff06          .dw $FF06
0005df 6f73
0005e0 7275
0005e1 6563          .db "source"
0005e2 05bf          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0005e3 07e1          .dw PFA_DODEFER
                 PFA_SOURCE:
0005e4 0016          .dw USER_SOURCE
0005e5 07b9          .dw XT_UDEFERFETCH
0005e6 07c0          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
0005e7 ff07          .dw $ff07
0005e8 732f
0005e9 7274
0005ea 6e69
0005eb 0067          .db "/string",0
0005ec 05de          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005ed f000          .dw DO_COLON
                 PFA_SLASHSTRING:
0005ee f0dc          .dw XT_OVER    ; ( -- addr1 u1 n u1)
0005ef 0279          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
0005f0 f0ee          .dw XT_ROT     ; ( -- u1 n addr1 )
0005f1 f0dc          .dw XT_OVER    ; ( -- u1 n addr1 n)
0005f2 f1b8          .dw XT_PLUS    ; ( -- u1 n addr2 )
0005f3 f0ee          .dw XT_ROT     ; ( -- n addr2 u1)
0005f4 f0ee          .dw XT_ROT     ; ( -- addr2 u1 n)
0005f5 f1ae          .dw XT_MINUS   ; ( -- addr2 u2)
0005f6 f020          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
0005f7 ff0a          .dw $FF0A 
0005f8 6170
0005f9 7372
0005fa 2d65
0005fb 616e
0005fc 656d          .db "parse-name"
0005fd 05e7          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005fe f000          .dw DO_COLON 
                 PFA_PARSENAME:
0005ff 01f2          .dw XT_BL
000600 0602          .dw XT_SKIPSCANCHAR
000601 f020          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000602 f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
000603 f105          .dw XT_TO_R
000604 05e3          .dw XT_SOURCE 
000605 0130          .dw XT_G_IN 
000606 f086          .dw XT_FETCH 
000607 05ed          .dw XT_SLASHSTRING 
                 
000608 f10e          .dw XT_R_FETCH
000609 0487          .dw XT_CSKIP
00060a f0fc          .dw XT_R_FROM
00060b 05c4          .dw XT_CSCAN
                 
                     ; adjust >IN
00060c 011f          .dw XT_2DUP
00060d f1b8          .dw XT_PLUS
00060e 05e3          .dw XT_SOURCE 
00060f f0e6          .dw XT_DROP
000610 f1ae          .dw XT_MINUS
000611 0130          .dw XT_G_IN
000612 f08e          .dw XT_STORE
000613 f020          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
000614 ff09          .dw $ff09
000615 6966
000616 646e
000617 6e2d
000618 6d61
000619 0065          .db "find-name",0
00061a 05f7          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
00061b f000          .dw DO_COLON
                 PFA_FINDNAME:
00061c f040          .dw XT_DOLITERAL
00061d 0014          .dw EE_ORDERLISTLEN
00061e f373          .dw XT_FETCHE
00061f f146          .dw XT_ZERO
000620 f2bf          .dw XT_DOQDO
000621 0636          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
000622 011f          .dw XT_2DUP
000623 f040          .dw XT_DOLITERAL
000624 0016          .dw EE_ORDERLIST
000625 f2d5          .dw XT_I
000626 010f          .dw XT_CELLS
000627 f1b8          .dw XT_PLUS  
000628 f373          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
000629 07f5          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
00062a f0c6          .dw XT_QDUP
00062b f039          .dw XT_DOCONDBRANCH
00062c 0634          .dw PFA_FINDNAME4
00062d f105      	.dw XT_TO_R
00062e f105      	.dw XT_TO_R
00062f 0128      	.dw XT_2DROP
000630 f0fc      	.dw XT_R_FROM
000631 f0fc      	.dw XT_R_FROM
000632 f2ff      	.dw XT_UNLOOP
000633 f020      	.dw XT_EXIT
                 PFA_FINDNAME4:
000634 f2f0          .dw XT_DOLOOP
000635 0622          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000636 0128          .dw XT_2DROP
000637 f146          .dw XT_ZERO
000638 f020          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
000639 ff04          .dw $ff04
00063a 7571
00063b 7469          .db "quit"
00063c 0614          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00063d f000          .dw DO_COLON
                 PFA_QUIT:
00063e 06b5          .dw XT_SP0
00063f f2a5          .dw XT_SP_STORE
000640 06ca          .dw XT_RP0
000641 f28f          .dw XT_RP_STORE
000642 0a7a          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000643 0102          .dw XT_STATE
000644 f086          .dw XT_FETCH
000645 f12a          .dw XT_EQUALZERO
000646 f039          .dw XT_DOCONDBRANCH
000647 0649          .dw PFA_QUIT4
000648 065f          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000649 04e9          .dw XT_REFILL
00064a f039          .dw XT_DOCONDBRANCH
00064b 0643          .dw PFA_QUIT2
00064c f040          .dw XT_DOLITERAL
00064d 06e3          .dw XT_INTERPRET
00064e 0458          .dw XT_CATCH
00064f f0c6          .dw XT_QDUP
000650 f039          .dw XT_DOCONDBRANCH
000651 065b          .dw PFA_QUIT3
000652 f0be      	.dw XT_DUP
000653 f040      	.dw XT_DOLITERAL
000654 fffe      	.dw -2
000655 f131      	.dw XT_LESS
000656 f039      	.dw XT_DOCONDBRANCH
000657 0659      	.dw PFA_QUIT5
000658 066d      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000659 f02f      	.dw XT_DOBRANCH
00065a 063e      	.dw PFA_QUIT
                 PFA_QUIT3:
00065b 0666          .dw XT_PROMPTOK
00065c f02f          .dw XT_DOBRANCH
00065d 0643          .dw PFA_QUIT2
00065e f020          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
00065f f000          .dw DO_COLON
                 PFA_PROMPTRDY:
000660 040d          .dw XT_CR
000661 03a2          .dw XT_DOSLITERAL
000662 0002          .dw 2
000663 203e          .db "> "
000664 03d9          .dw XT_ITYPE
000665 f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000666 f000          .dw DO_COLON
                 PFA_PROMPTOK:
000667 03a2          .dw XT_DOSLITERAL
000668 0003          .dw 3
000669 6f20
00066a 006b          .db " ok",0
00066b 03d9          .dw XT_ITYPE
00066c f020          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00066d f000          .dw DO_COLON
                 PFA_PROMPTERROR:
00066e 03a2      	.dw XT_DOSLITERAL
00066f 0004      	.dw 4
000670 3f20
000671 203f      	.db  " ?? "
000672 03d9          .dw XT_ITYPE
000673 0108      	.dw XT_BASE
000674 f086      	.dw XT_FETCH
000675 f105      	.dw XT_TO_R
000676 01df      	.dw XT_DECIMAL
000677 033f      	.dw XT_DOT
000678 0130      	.dw XT_G_IN
000679 f086      	.dw XT_FETCH
00067a 033f      	.dw XT_DOT
00067b f0fc      	.dw XT_R_FROM
00067c 0108      	.dw XT_BASE
00067d f08e      	.dw XT_STORE
00067e f020          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00067f ff05          .dw $ff05
000680 6170
000681 7375
000682 0065          .db "pause",0
000683 0639          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000684 07e1          .dw PFA_DODEFER
                 PFA_PAUSE:
000685 0165          .dw ram_pause
000686 07af          .dw XT_RDEFERFETCH
000687 07b4          .dw XT_RDEFERSTORE
                 
                 .dseg
000165           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000688 ff04          .dw $ff04
000689 6f63
00068a 646c          .db "cold"
00068b 067f          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00068c 068d          .dw PFA_COLD
                 PFA_COLD:
00068d b6a4          in_ r10, MCUSR
00068e 24bb          clr r11
00068f 2422          clr zerol
000690 2433          clr zeroh
000691 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000167           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000692 e6e7          ldi zl, low(ram_user1)
000693 e0f1          ldi zh, high(ram_user1)
000694 012f          movw upl, zl
                     ; init return stack pointer
000695 ef0f          ldi temp0,low(rstackstart)
000696 bf0d          out_ SPL,temp0
000697 8304          std Z+4, temp0
000698 e410          ldi temp1,high(rstackstart)
000699 bf1e          out_ SPH,temp1
00069a 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00069b eacf          ldi yl,low(stackstart)
00069c 83c6          std Z+6, yl
00069d e4d0          ldi yh,high(stackstart)
00069e 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00069f eaa8          ldi XL, low(PFA_WARM)
0006a0 e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
0006a1 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
0006a3 ff04          .dw $ff04
0006a4 6177
0006a5 6d72          .db "warm"
0006a6 0688          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
0006a7 f000          .dw DO_COLON
                 PFA_WARM:
0006a8 0923          .dw XT_INITUSER
0006a9 f040          .dw XT_DOLITERAL
0006aa 077e          .dw XT_NOOP
0006ab f040          .dw XT_DOLITERAL
0006ac 0684          .dw XT_PAUSE
0006ad 07cc          .dw XT_DEFERSTORE
0006ae 01fa          .dw XT_TURNKEY
0006af 063d          .dw XT_QUIT
0006b0 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0006b1 ff03          .dw $ff03
0006b2 7073
0006b3 0030          .db "sp0",0
0006b4 06a3          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0006b5 f07b          .dw PFA_DOVALUE1
                 PFA_SP0:
0006b6 0006          .dw USER_SP0
0006b7 06be          .dw XT_UVALUEFETCH
0006b8 06c2          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0006b9 ff02          .dw $ff02
0006ba 7073          .db "sp"
0006bb 06b1          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0006bc f061          .dw PFA_DOUSER
                 PFA_SP:
0006bd 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
0006be f000          .dw DO_COLON
                 PFA_UVALUEFETCH:
0006bf f387          .dw XT_FETCHI
0006c0 f0ad          .dw XT_FETCHU
0006c1 f020          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
0006c2 f000          .dw DO_COLON
                 PFA_UVALUESTORE:
0006c3 f387          .dw XT_FETCHI
0006c4 f0b5          .dw XT_STOREU
0006c5 f020          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0006c6 ff03          .dw $ff03
0006c7 7072
0006c8 0030          .db "rp0",0
0006c9 06b9          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0006ca f000          .dw DO_COLON
                 PFA_RP0:
0006cb 06ce          .dw XT_DORP0
0006cc f086          .dw XT_FETCH
0006cd f020          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0006ce f061          .dw PFA_DOUSER
                 PFA_DORP0:
0006cf 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
0006d0 ff05          .dw $ff05
0006d1 6564
0006d2 7470
0006d3 0068          .db "depth",0
0006d4 06c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0006d5 f000          .dw DO_COLON
                 PFA_DEPTH:
0006d6 06b5          .dw XT_SP0
0006d7 f29c          .dw XT_SP_FETCH
0006d8 f1ae          .dw XT_MINUS
0006d9 f21f          .dw XT_2SLASH
0006da f250          .dw XT_1MINUS
0006db f020          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
0006dc ff09          .dw $ff09
0006dd 6e69
0006de 6574
0006df 7072
0006e0 6572
0006e1 0074          .db "interpret",0
0006e2 06d0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
0006e3 f000          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
0006e4 05fe          .dw XT_PARSENAME ; ( -- addr len )
0006e5 f0c6          .dw XT_QDUP   ; ( -- addr len len )
0006e6 f16e          .dw XT_GREATERZERO
0006e7 f039          .dw XT_DOCONDBRANCH
0006e8 0707          .dw PFA_INTERPRET5
0006e9 f040          .dw XT_DOLITERAL
0006ea 0026          .dw EE_RECOGNIZERLISTLEN
0006eb f373          .dw XT_FETCHE       ; ( addr len rec # -- )
0006ec f146          .dw XT_ZERO
                 
0006ed f2bf          .dw XT_DOQDO
0006ee 0703          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
0006ef 011f          .dw XT_2DUP ; ( -- addr len addr len  )
0006f0 f2d5          .dw XT_I    ; ( -- addr len addr len i )
0006f1 f0ee          .dw XT_ROT  ; ( -- addr len len i addr )
0006f2 f0ee          .dw XT_ROT  ; ( -- addr len i addr len )
0006f3 f105          .dw XT_TO_R
0006f4 f105          .dw XT_TO_R
                 
0006f5 010f          .dw XT_CELLS
0006f6 f040          .dw XT_DOLITERAL
0006f7 0028          .dw EE_RECOGNIZERLIST
0006f8 f1b8          .dw XT_PLUS
0006f9 f373          .dw XT_FETCHE
                 
0006fa f02a          .dw XT_EXECUTE
0006fb f0fc          .dw XT_R_FROM
0006fc f0fc          .dw XT_R_FROM
0006fd f0ee          .dw XT_ROT
0006fe f039          .dw XT_DOCONDBRANCH
0006ff 0701          .dw PFA_INTERPRET3
000700 09ca            .dw XT_LEAVE
                 PFA_INTERPRET3:
000701 f2f0          .dw XT_DOLOOP
000702 06ef          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
000703 0128          .dw XT_2DROP
000704 0754          .dw XT_QSTACK
000705 f02f          .dw XT_DOBRANCH
000706 06e4          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
000707 f0e6          .dw xT_DROP
000708 f020          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
000709 ff0a          .dw $ff0a
00070a 6572
00070b 2d63
00070c 6e69
00070d 6e74
00070e 6d75          .db "rec-intnum"
00070f 06dc          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
000710 f000          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
000711 04fb          .dw XT_NUMBER 
000712 f039          .dw XT_DOCONDBRANCH 
000713 0725          .dw PFA_REC_NONUMBER
                 
000714 0102          .dw XT_STATE
000715 f086          .dw XT_FETCH
000716 f039          .dw XT_DOCONDBRANCH
000717 0722          .dw PFA_REC_NUMBER_DONE
000718 f040      	.dw XT_DOLITERAL
000719 0002      	.dw 2
00071a f123      	.dw XT_EQUAL
00071b f039      	.dw XT_DOCONDBRANCH
00071c 071f      	.dw PFA_REC_NUMBER_SINGLE
00071d f0d1      	.dw XT_SWAP
00071e 0931              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
00071f 0931              .dw XT_LITERAL
000720 f02f              .dw XT_DOBRANCH
000721 0723              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
000722 f0e6          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000723 f14f          .dw XT_TRUE
000724 f020          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000725 f146          .dw XT_ZERO
000726 f020          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000727 ff08          .dw $ff08
000728 6572
000729 2d63
00072a 6966
00072b 646e          .db "rec-find"
00072c 0709          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00072d f000          .dw DO_COLON
                 PFA_REC_FIND:
00072e 061b          .dw XT_FINDNAME
00072f f0be          .dw XT_DUP
000730 f039          .dw XT_DOCONDBRANCH 
000731 0740          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
000732 f16e      	.dw XT_GREATERZERO
000733 f039      	.dw XT_DOCONDBRANCH
000734 0737      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000735 f02f      	    .dw XT_DOBRANCH
000736 073e      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000737 0102      	    .dw XT_STATE
000738 f086      	    .dw XT_FETCH
000739 f039      	    .dw XT_DOCONDBRANCH
00073a 073e      	    .dw PFA_REC_FIND_EXECUTE
00073b 01bd      	    .dw XT_COMMA
00073c f02f      	    .dw XT_DOBRANCH
00073d 073f      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
00073e f02a          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
00073f f14f          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
000740 f020          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
000741 ff0c          .dw $ff0c
000742 6572
000743 2d63
000744 6f6e
000745 6674
000746 756f
000747 646e          .db "rec-notfound"
000748 0727          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000749 f000          .dw DO_COLON
                 PFA_REC_NOTFOUND:
00074a 0432          .dw XT_TYPE
00074b f040          .dw XT_DOLITERAL
00074c fff3          .dw -13
00074d 046e          .dw XT_THROW
00074e f020          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
00074f ff06          .dw $ff06
000750 733f
000751 6174
000752 6b63          .db "?stack"
000753 0741          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000754 f000          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
000755 06d5          .dw XT_DEPTH
000756 f13f          .dw XT_LESSZERO
000757 f039          .dw XT_DOCONDBRANCH
000758 075c          .dw PFA_QSTACK1
000759 f040            .dw XT_DOLITERAL
00075a fffc            .dw -4
00075b 046e            .dw XT_THROW
                 PFA_QSTACK1:
00075c f020          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
00075d ff03          .dw $ff03
00075e 6576
00075f 0072          .db "ver",0
000760 074f          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
000761 f000          .dw DO_COLON
                 PFA_VER:
000762 0b4e          .dw XT_ENV_FORTHNAME
000763 03d9          .dw XT_ITYPE
000764 041a          .dw XT_SPACE
000765 0108          .dw XT_BASE
000766 f086          .dw XT_FETCH
000767 f105          .dw XT_TO_R
000768 01df          .dw XT_DECIMAL
                 
000769 0b5c          .dw XT_ENV_FORTHVERSION
00076a f341          .dw XT_S2D
00076b 02d9          .dw XT_L_SHARP
00076c 02e1          .dw XT_SHARP
00076d f040          .dw XT_DOLITERAL
00076e 002e          .dw '.'
00076f 02ca          .dw XT_HOLD
000770 02f7          .dw XT_SHARP_S
000771 0302          .dw XT_SHARP_G
000772 f0fc          .dw XT_R_FROM
000773 0108          .dw XT_BASE
000774 f08e          .dw XT_STORE
                 
000775 0432          .dw XT_TYPE
000776 041a          .dw XT_SPACE
000777 0b64          .dw XT_ENV_CPU
000778 03d9          .dw XT_ITYPE
000779 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
00077a ff04          .dw $ff04
00077b 6f6e
00077c 706f          .db "noop"
00077d 075d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00077e 077f          .dw PFA_NOOP
                 PFA_NOOP:
00077f 940c f004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000781 ff06          .dw $ff06
000782 6e75
000783 7375
000784 6465          .db "unused"
000785 077a          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000786 f000          .dw DO_COLON
                 PFA_UNUSED:
000787 06b5          .dw XT_SP0
000788 0176          .dw XT_HERE
000789 f1ae          .dw XT_MINUS
00078a f020          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
00078b 0002          .dw $0002
00078c 6f74          .db "to"
00078d 0781          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00078e f000          .dw DO_COLON
                 PFA_TO:
00078f 0441          .dw XT_TICK
000790 f24a          .dw XT_1PLUS  		; to body
000791 0102          .dw XT_STATE
000792 f086          .dw XT_FETCH
000793 f039          .dw XT_DOCONDBRANCH
000794 079f          .dw PFA_TO1
000795 01b2          .dw XT_COMPILE
000796 0799          .dw XT_DOTO
000797 01bd          .dw XT_COMMA
000798 f020          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
000799 f000          .dw DO_COLON
                 PFA_DOTO:
00079a f0fc          .dw XT_R_FROM
00079b f0be          .dw XT_DUP
00079c f24a          .dw XT_1PLUS
00079d f105          .dw XT_TO_R
00079e f387          .dw XT_FETCHI
                 PFA_TO1:
00079f f0be          .dw XT_DUP
0007a0 f24a          .dw XT_1PLUS
0007a1 f24a          .dw XT_1PLUS
0007a2 f387          .dw XT_FETCHI
0007a3 f02a          .dw XT_EXECUTE
0007a4 f020          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
0007a5 f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
0007a6 f24a          .dw XT_1PLUS ; >body
0007a7 f387          .dw XT_FETCHI
0007a8 f373          .dw XT_FETCHE
0007a9 f020          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
0007aa f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
0007ab f24a          .dw XT_1PLUS
0007ac f387          .dw XT_FETCHI
0007ad f34f          .dw XT_STOREE
0007ae f020          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
0007af f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
0007b0 f24a          .dw XT_1PLUS ; >body
0007b1 f387          .dw XT_FETCHI
0007b2 f086          .dw XT_FETCH
0007b3 f020          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
0007b4 f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
0007b5 f24a          .dw XT_1PLUS
0007b6 f387          .dw XT_FETCHI
0007b7 f08e          .dw XT_STORE
0007b8 f020          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
0007b9 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
0007ba f24a          .dw XT_1PLUS ; >body
0007bb f387          .dw XT_FETCHI
0007bc f32f          .dw XT_UP_FETCH
0007bd f1b8          .dw XT_PLUS
0007be f086          .dw XT_FETCH
0007bf f020          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
0007c0 f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
0007c1 f24a          .dw XT_1PLUS
0007c2 f387          .dw XT_FETCHI
0007c3 f32f          .dw XT_UP_FETCH
0007c4 f1b8          .dw XT_PLUS
0007c5 f08e          .dw XT_STORE
0007c6 f020          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
0007c7 ff06          .dw $ff06
0007c8 6564
0007c9 6566
0007ca 2172          .db "defer!"
0007cb 078b          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
0007cc f000          .dw DO_COLON
                 PFA_DEFERSTORE:
0007cd f0be          .dw XT_DUP
0007ce f040          .dw XT_DOLITERAL
0007cf 0003          .dw 3
0007d0 f1b8          .dw XT_PLUS   ; >body 2 +
0007d1 f387          .dw XT_FETCHI
0007d2 f02a          .dw XT_EXECUTE
0007d3 f020          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
0007d4 ff06          .dw $ff06
0007d5 6564
0007d6 6566
0007d7 4072          .db "defer@"
0007d8 07c7          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
0007d9 f000          .dw DO_COLON
                 PFA_DEFERFETCH:
0007da f0be          .dw XT_DUP
0007db f24a          .dw XT_1PLUS ; >body
0007dc f24a          .dw XT_1PLUS 
0007dd f387          .dw XT_FETCHI
0007de f02a          .dw XT_EXECUTE
0007df f020          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
0007e0 07e1          .dw PFA_DODEFER
                 PFA_DODEFER:
0007e1 940e 0a35     call_ DO_DODOES
0007e3 f0be          .dw XT_DUP
0007e4 f250          .dw XT_1MINUS
0007e5 f0d1          .dw XT_SWAP
0007e6 f24a          .dw XT_1PLUS
0007e7 f387          .dw XT_FETCHI
0007e8 f02a          .dw XT_EXECUTE 
0007e9 f02a          .dw XT_EXECUTE
0007ea f020          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0007eb ff0f          .dw $ff0f
0007ec 6573
0007ed 7261
0007ee 6863
0007ef 772d
0007f0 726f
0007f1 6c64
0007f2 7369
0007f3 0074          .db "search-wordlist",0
0007f4 07d4          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0007f5 f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0007f6 f146          .dw XT_ZERO
0007f7 f0d1          .dw XT_SWAP
0007f8 f040          .dw XT_DOLITERAL
0007f9 0804          .dw XT_ISWORD
0007fa f0d1          .dw XT_SWAP
0007fb 083b          .dw XT_TRAVERSEWORDLIST
0007fc f0be          .dw XT_DUP
0007fd f12a          .dw XT_EQUALZERO
0007fe f039          .dw XT_DOCONDBRANCH
0007ff 0803          .dw PFA_SEARCH_WORDLIST1
000800 0128             .dw XT_2DROP
000801 f0e6             .dw XT_DROP
000802 f146             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
000803 f020          .dw XT_EXIT
                 
                 XT_ISWORD:
000804 f000          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
000805 f105          .dw XT_TO_R
000806 f105          .dw XT_TO_R
000807 011f          .dw XT_2DUP
000808 f0fc          .dw XT_R_FROM
000809 f0ee          .dw XT_ROT
00080a f0ee          .dw XT_ROT
00080b f10e          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
00080c 082a          .dw XT_NAME2STRING
00080d 0856          .dw XT_ICOMPARE      ; (-- addr len 0 f )
00080e f039          .dw XT_DOCONDBRANCH
00080f 081e          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
000810 0128            .dw XT_2DROP
000811 f0e6            .dw XT_DROP
                       ; ... get the XT ...
000812 f10e            .dw XT_R_FETCH
000813 0bef            .dw XT_NFA2LFA
000814 f24a            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
000815 f14f            .dw XT_TRUE
000816 f0fc            .dw XT_R_FROM
000817 f387            .dw XT_FETCHI
000818 f16e            .dw XT_GREATERZERO
000819 f039            .dw XT_DOCONDBRANCH
00081a 081c            .dw PFA_ISWORD1
00081b 0255               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
00081c f146            .dw XT_ZERO       ; finish traverse-wordlist
00081d f020            .dw XT_EXIT
                 PFA_ISWORD3:
00081e f0fc          .dw XT_R_FROM
00081f f0e6          .dw XT_DROP
000820 f14f          .dw XT_TRUE         ; maybe next word
000821 f020          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
000822 ff0b          .dw $ff0b
000823 616e
000824 656d
000825 733e
000826 7274
000827 6e69
000828 0067          .db "name>string",0
000829 07eb          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00082a f000          .dw DO_COLON
                 PFA_NAME2STRING:
00082b 0404          .dw XT_ICOUNT   ; ( -- addr n )
00082c f040          .dw XT_DOLITERAL
00082d 00ff          .dw $00FF
00082e f22e          .dw XT_AND      ; mask immediate bit
00082f f020          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
000830 ff11          .dw $ff11
000831 7274
000832 7661
000833 7265
000834 6573
000835 772d
000836 726f
000837 6c64
000838 7369
000839 0074          .db "traverse-wordlist",0
00083a 0822          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00083b f000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
00083c f373          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00083d f0be          .dw XT_DUP           ; ( -- xt nt nt )
00083e f039          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00083f 084e          .dw PFA_TRAVERSEWORDLIST2       ;
000840 011f          .dw XT_2DUP
000841 f105          .dw XT_TO_R
000842 f105          .dw XT_TO_R
000843 f0d1          .dw XT_SWAP
000844 f02a          .dw XT_EXECUTE
000845 f0fc          .dw XT_R_FROM
000846 f0fc          .dw XT_R_FROM
000847 f0ee          .dw XT_ROT
000848 f039          .dw XT_DOCONDBRANCH
000849 084e          .dw PFA_TRAVERSEWORDLIST2
00084a 0bef          .dw XT_NFA2LFA
00084b f387          .dw XT_FETCHI        ; ( -- addr )
00084c f02f          .dw XT_DOBRANCH      ; ( -- addr )
00084d 083d          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00084e 0128          .dw XT_2DROP
00084f f020          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
000850 ff08          .dw $ff08
000851 6369
000852 6d6f
000853 6170
000854 6572          .db "icompare"
000855 0830          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000856 f000          .dw DO_COLON
                 PFA_ICOMPARE:
000857 f105          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000858 f0dc          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000859 f0fc          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00085a f119          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00085b f039          .dw XT_DOCONDBRANCH
00085c 0861          .dw PFA_ICOMPARE_SAMELEN
00085d 0128            .dw XT_2DROP
00085e f0e6            .dw XT_DROP
00085f f146            .dw XT_ZERO
000860 f020            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000861 f0d1          .dw XT_SWAP ; ( -- r-addr f-addr len )
000862 f146          .dw XT_ZERO
000863 f2bf          .dw XT_DOQDO
000864 0882          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000865 f0dc          .dw XT_OVER
000866 f086          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000867 f0dc          .dw XT_OVER
000868 f387          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000869 f0be          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00086a f040          .dw XT_DOLITERAL
00086b 0100          .dw $100
00086c f158          .dw XT_ULESS
00086d f039          .dw XT_DOCONDBRANCH
00086e 0873          .dw PFA_ICOMPARE_LASTCELL
00086f f0d1          .dw XT_SWAP
000870 f040          .dw XT_DOLITERAL
000871 00ff          .dw $00FF
000872 f22e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000873 f119          .dw XT_NOTEQUAL
000874 f039          .dw XT_DOCONDBRANCH
000875 087a          .dw PFA_ICOMPARE_NEXTLOOP
000876 0128          .dw XT_2DROP
000877 f146          .dw XT_ZERO
000878 f2ff          .dw XT_UNLOOP
000879 f020          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00087a f24a          .dw XT_1PLUS
00087b f0d1          .dw XT_SWAP
00087c 0117          .dw XT_CELLPLUS
00087d f0d1          .dw XT_SWAP
00087e f040          .dw XT_DOLITERAL
00087f 0002          .dw 2
000880 f2d6          .dw XT_DOPLUSLOOP
000881 0865          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000882 0128          .dw XT_2DROP
000883 f14f          .dw XT_TRUE
000884 f020          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000885 ff01          .dw $ff01
000886 002a          .db "*",0
000887 0850          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000888 f000          .dw DO_COLON
                 PFA_STAR:
000889 f1c1          .dw XT_MSTAR
00088a 089a          .dw XT_D2S
00088b f020          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00088c ff01          .dw $FF01
00088d 006a          .db "j",0
00088e 0885          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00088f f000          .dw DO_COLON
                 PFA_J:
000890 f285          .dw XT_RP_FETCH
000891 f040          .dw XT_DOLITERAL
000892 0009          .dw 9
000893 f1b8          .dw XT_PLUS
000894 f086          .dw XT_FETCH
000895 f020          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000896 ff03          .dw $ff03
000897 3e64
000898 0073          .db "d>s",0
000899 088c          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
00089a f000          .dw DO_COLON
                 PFA_D2S:
00089b f0e6          .dw XT_DROP
00089c f020          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00089d ff04          .dw $ff04
00089e 6164
00089f 7362          .db "dabs"
0008a0 0896          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
0008a1 f000          .dw DO_COLON
                 PFA_DABS:
0008a2 f0be          .dw XT_DUP
0008a3 f13f          .dw XT_LESSZERO
0008a4 f039          .dw XT_DOCONDBRANCH
0008a5 08a7          .dw PFA_DABS1
0008a6 08ae          .dw XT_DNEGATE
                 PFA_DABS1:
0008a7 f020          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
0008a8 ff07          .dw $ff07
0008a9 6e64
0008aa 6765
0008ab 7461
0008ac 0065          .db "dnegate",0
0008ad 089d          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
0008ae f000          .dw DO_COLON
                 PFA_DNEGATE:
0008af 0d09          .dw XT_DINVERT
0008b0 f040          .dw XT_DOLITERAL
0008b1 0001          .dw 1
0008b2 f146          .dw XT_ZERO
0008b3 0ce1          .dw XT_DPLUS
0008b4 f020          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
0008b5 ff05          .dw $ff05
0008b6 6d63
0008b7 766f
0008b8 0065          .db "cmove",0
0008b9 08a8          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
0008ba 08bb          .dw PFA_CMOVE
                 PFA_CMOVE:
0008bb 93bf          push xh
0008bc 93af          push xl
0008bd 91e9          ld zl, Y+
0008be 91f9          ld zh, Y+ ; addr-to
0008bf 91a9          ld xl, Y+
0008c0 91b9          ld xh, Y+ ; addr-from
0008c1 2f09          mov temp0, tosh
0008c2 2b08          or temp0, tosl
0008c3 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
0008c4 911d          ld temp1, X+
0008c5 9311          st Z+, temp1
0008c6 9701          sbiw tosl, 1
0008c7 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
0008c8 91af          pop xl
0008c9 91bf          pop xh
0008ca 9189
0008cb 9199          loadtos
0008cc 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
0008ce ff05          .dw $ff05
0008cf 7332
0008d0 6177
0008d1 0070          .db "2swap",0
0008d2 08b5          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
0008d3 f000          .dw DO_COLON
                 PFA_2SWAP:
0008d4 f0ee          .dw XT_ROT
0008d5 f105          .dw XT_TO_R
0008d6 f0ee          .dw XT_ROT
0008d7 f0fc          .dw XT_R_FROM
0008d8 f020          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
0008d9 ff03          .dw $ff03
0008da 6974
0008db 0062          .db "tib",0
0008dc 08ce          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0008dd f04e          .dw PFA_DOVARIABLE
                 PFA_TIB:
0008de 018d          .dw ram_tib
                     
                 .dseg
00018d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
0008df ff0a          .dw $ff0a
0008e0 6572
0008e1 6966
0008e2 6c6c
0008e3 742d
0008e4 6269          .db "refill-tib"
0008e5 08d9          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
0008e6 f000          .dw DO_COLON
                 PFA_REFILLTIB:
0008e7 08dd          .dw XT_TIB
0008e8 f040          .dw XT_DOLITERAL
0008e9 0064          .dw TIBSIZE
0008ea 049f          .dw XT_ACCEPT
0008eb 0136          .dw XT_NUMBERTIB
0008ec f08e          .dw XT_STORE
0008ed f146          .dw XT_ZERO
0008ee 0130          .dw XT_G_IN
0008ef f08e          .dw XT_STORE
0008f0 f040          .dw XT_DOLITERAL
0008f1 ffff          .dw -1
0008f2 f020          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0008f3 ff0a          .dw $FF0A
0008f4 6f73
0008f5 7275
0008f6 6563
0008f7 742d
0008f8 6269          .db "source-tib"
0008f9 08df          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0008fa f000          .dw DO_COLON
                 PFA_SOURCETIB:
0008fb 08dd          .dw XT_TIB
0008fc 0136          .dw XT_NUMBERTIB
0008fd f086          .dw XT_FETCH
0008fe f020          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0008ff ff07        .dw $ff07
000900 6565
000901 752d
000902 6573
000903 0072        .db "ee-user",0
000904 08f3        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
000905 f04e        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
000906 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000907 ff06        .dw $ff06
000908 6565
000909 723e
00090a 6d61        .db "ee>ram"
00090b 08ff        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00090c f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00090d f146          .dw XT_ZERO
00090e f2bf          .dw XT_DOQDO
00090f 091a          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000910 f0dc          .dw XT_OVER
000911 f373          .dw XT_FETCHE
000912 f0dc          .dw XT_OVER
000913 f08e          .dw XT_STORE
000914 0117          .dw XT_CELLPLUS
000915 f0d1          .dw XT_SWAP
000916 0117          .dw XT_CELLPLUS
000917 f0d1          .dw XT_SWAP
000918 f2f0          .dw XT_DOLOOP
000919 0910          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00091a 0128          .dw XT_2DROP
00091b f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00091c ff09        .dw $ff09
00091d 6e69
00091e 7469
00091f 752d
000920 6573
000921 0072        .db "init-user",0
000922 0907        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000923 f000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000924 0905          .dw XT_EEUSER
000925 f32f          .dw XT_UP_FETCH
000926 f040          .dw XT_DOLITERAL
000927 001c          .dw SYSUSERSIZE
000928 f21f          .dw XT_2SLASH
000929 090c          .dw XT_EE2RAM
00092a f020          .dw XT_EXIT
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
00092b 0007          .dw $0007
00092c 696c
00092d 6574
00092e 6172
00092f 006c          .db "literal",0
000930 091c          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000931 f000          .dw DO_COLON
                 PFA_LITERAL:
000932 01b2          .dw XT_COMPILE
000933 f040          .dw XT_DOLITERAL
000934 01bd          .dw XT_COMMA
000935 f020          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000936 0008        .dw $0008
000937 6c73
000938 7469
000939 7265
00093a 6c61        .db "sliteral"
00093b 092b        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00093c f000          .dw DO_COLON
                 PFA_SLITERAL:
00093d 01b2          .dw XT_COMPILE
00093e 03a2          .dw XT_DOSLITERAL    ; ( -- addr n)
00093f 03b5          .dw XT_SCOMMA
000940 f020          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000941 f000          .dw DO_COLON
                 PFA_GMARK:
000942 0166          .dw XT_DP
000943 01b2          .dw XT_COMPILE
000944 ffff          .dw -1           ; ffff does not erase flash
000945 f020          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000946 f000          .dw DO_COLON
                 PFA_GRESOLVE:
000947 0754          .dw XT_QSTACK
000948 0166          .dw XT_DP
000949 f0d1          .dw XT_SWAP
00094a f394          .dw XT_STOREI
00094b f020          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00094c f000          .dw DO_COLON
                 PFA_LMARK:
00094d 0166          .dw XT_DP
00094e f020          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00094f f000          .dw DO_COLON
                 PFA_LRESOLVE:
000950 0754          .dw XT_QSTACK
000951 01bd          .dw XT_COMMA
000952 f020          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000953 0005          .dw $0005
000954 6861
000955 6165
000956 0064          .db "ahead",0
000957 0936          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000958 f000          .dw DO_COLON
                 PFA_AHEAD:
000959 01b2          .dw XT_COMPILE
00095a f02f          .dw XT_DOBRANCH
00095b 0941          .dw XT_GMARK
00095c f020          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
00095d 0002          .dw $0002
00095e 6669          .db "if"
00095f 0953          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000960 f000          .dw DO_COLON
                 PFA_IF:
000961 01b2          .dw XT_COMPILE
000962 f039          .dw XT_DOCONDBRANCH
000963 0941          .dw XT_GMARK
000964 f020          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000965 0004          .dw $0004
000966 6c65
000967 6573          .db "else"
000968 095d          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000969 f000          .dw DO_COLON
                 PFA_ELSE:
00096a 01b2          .dw XT_COMPILE
00096b f02f          .dw XT_DOBRANCH
00096c 0941          .dw XT_GMARK
00096d f0d1          .dw XT_SWAP
00096e 0946          .dw XT_GRESOLVE
00096f f020          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000970 0004          .dw $0004
000971 6874
000972 6e65          .db "then"
000973 0965          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000974 f000          .dw DO_COLON
                 PFA_THEN:
000975 0946          .dw XT_GRESOLVE
000976 f020          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000977 0005          .dw $0005
000978 6562
000979 6967
00097a 006e          .db "begin",0
00097b 0970          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00097c f000          .dw DO_COLON
                 PFA_BEGIN:
00097d 094c          .dw XT_LMARK
00097e f020          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
00097f 0005          .dw $0005
000980 6877
000981 6c69
000982 0065          .db "while",0
000983 0977          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000984 f000          .dw DO_COLON
                 PFA_WHILE:
000985 01b2          .dw XT_COMPILE
000986 f039          .dw XT_DOCONDBRANCH
000987 0941          .dw XT_GMARK
000988 f0d1          .dw XT_SWAP
000989 f020          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
00098a 0006          .dw $0006
00098b 6572
00098c 6570
00098d 7461          .db "repeat"
00098e 097f          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
00098f f000          .dw DO_COLON
                 PFA_REPEAT:
000990 09a2          .dw XT_AGAIN
000991 0946          .dw XT_GRESOLVE
000992 f020          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000993 0005          .dw $0005
000994 6e75
000995 6974
000996 006c          .db "until",0
000997 098a          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000998 f000          .dw DO_COLON
                 PFA_UNTIL:
000999 01b2          .dw XT_COMPILE
00099a f039          .dw XT_DOCONDBRANCH
00099b 094f          .dw XT_LRESOLVE
00099c f020          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
00099d 0005          .dw $0005
00099e 6761
00099f 6961
0009a0 006e          .db "again",0
0009a1 0993          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0009a2 f000          .dw DO_COLON
                 PFA_AGAIN:
0009a3 01b2          .dw XT_COMPILE
0009a4 f02f          .dw XT_DOBRANCH
0009a5 094f          .dw XT_LRESOLVE
0009a6 f020          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
0009a7 0002          .dw $0002
0009a8 6f64          .db "do"
0009a9 099d          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0009aa f000          .dw DO_COLON
                 PFA_DO:
0009ab 01b2          .dw XT_COMPILE
0009ac f2aa          .dw XT_DODO
0009ad 0941          .dw XT_GMARK
0009ae 094c          .dw XT_LMARK
0009af f020          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
0009b0 0004          .dw $0004
0009b1 6f6c
0009b2 706f          .db "loop"
0009b3 09a7          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0009b4 f000          .dw DO_COLON
                 PFA_LOOP:
0009b5 01b2          .dw XT_COMPILE
0009b6 f2f0          .dw XT_DOLOOP
0009b7 094f          .dw XT_LRESOLVE
0009b8 0946          .dw XT_GRESOLVE
0009b9 f020          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
0009ba 0005          .dw $0005
0009bb 6c2b
0009bc 6f6f
0009bd 0070          .db "+loop",0
0009be 09b0          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0009bf f000          .dw DO_COLON
                 PFA_PLUSLOOP:
0009c0 01b2          .dw XT_COMPILE
0009c1 f2d6          .dw XT_DOPLUSLOOP
0009c2 094f          .dw XT_LRESOLVE
0009c3 0946          .dw XT_GRESOLVE
0009c4 f020          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
0009c5 ff05         .dw $FF05
0009c6 656c
0009c7 7661
0009c8 0065         .db "leave",0
0009c9 09ba         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0009ca 09cb          .dw PFA_LEAVE
                 PFA_LEAVE:
0009cb 910f          pop temp0  ; drop limit and counter from returnstack
0009cc 911f          pop temp1
0009cd 910f          pop temp0
0009ce 911f          pop temp1
0009cf 91af          pop xl
0009d0 91bf          pop xh
0009d1 940c f004     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
0009d3 0003          .dw $0003
0009d4 643f
0009d5 006f          .db "?do",0
0009d6 09c5          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0009d7 f000          .dw DO_COLON
                 PFA_QDO:
0009d8 01b2          .dw XT_COMPILE
0009d9 f2bf          .dw XT_DOQDO
0009da 0941          .dw XT_GMARK
0009db 094c          .dw XT_LMARK
0009dc f020          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0009dd ff06          .dw $ff06
0009de 7263
0009df 6165
0009e0 6574          .db "create"
0009e1 09d3          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0009e2 f000          .dw DO_COLON
                 PFA_CREATE:
0009e3 018b          .dw XT_DOCREATE
0009e4 0a11          .dw XT_REVEAL
0009e5 01b2          .dw XT_COMPILE
0009e6 f05b          .dw PFA_DOCONSTANT
0009e7 f020          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0009e8 ff06          .dw $ff06
0009e9 6568
0009ea 6461
0009eb 7265          .db "header"
0009ec 09dd          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0009ed f000          .dw DO_COLON
                 PFA_HEADER:
0009ee 0166          .dw XT_DP           ; the new Name Field
0009ef f105          .dw XT_TO_R
0009f0 f105          .dw XT_TO_R		; ( R: NFA WID )
0009f1 f0be          .dw XT_DUP    
0009f2 f16e          .dw XT_GREATERZERO 
0009f3 f039          .dw XT_DOCONDBRANCH
0009f4 09ff          .dw PFA_HEADER1
0009f5 f0be          .dw XT_DUP
0009f6 f040          .dw XT_DOLITERAL
0009f7 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0009f8 f237          .dw XT_OR
0009f9 03b9          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0009fa f0fc          .dw XT_R_FROM
0009fb f373          .dw XT_FETCHE
0009fc 01bd          .dw XT_COMMA
0009fd f0fc          .dw XT_R_FROM
0009fe f020          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0009ff f040          .dw XT_DOLITERAL
000a00 fff0          .dw -16
000a01 046e          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000a02 ff07          .dw $ff07
000a03 6c77
000a04 6373
000a05 706f
000a06 0065          .db "wlscope",0
000a07 09e8          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000a08 07e1          .dw PFA_DODEFER
                 PFA_WLSCOPE:
000a09 0034          .dw EE_WLSCOPE
000a0a 07a5          .dw XT_EDEFERFETCH
000a0b 07aa          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000a0c ff06          .dw $ff06
000a0d 6572
000a0e 6576
000a0f 6c61          .db "reveal"
000a10 0a02          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000a11 f000          .dw DO_COLON
                 PFA_REVEAL:
000a12 f040          .dw XT_DOLITERAL
000a13 015f          .dw COLON_SMUDGE+0
000a14 f086          .dw XT_FETCH
000a15 f0c6          .dw XT_QDUP
000a16 f039          .dw XT_DOCONDBRANCH
000a17 0a20          .dw PFA_REVEAL1
                 ;
000a18 f040          .dw XT_DOLITERAL
000a19 0161          .dw COLON_SMUDGE+2
000a1a f086          .dw XT_FETCH		; ( NFA WID )
000a1b f34f          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000a1c f146          .dw XT_ZERO
000a1d f040          .dw XT_DOLITERAL
000a1e 015f          .dw COLON_SMUDGE+0
000a1f f08e          .dw XT_STORE
                 PFA_REVEAL1:
000a20 f020          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000a21 ff06          .dw $ff06
000a22 616c
000a23 6574
000a24 7473          .db "latest"
000a25 0a0c          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000a26 f04e          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000a27 01f1          .dw ram_LATEST
                 
                 .dseg
0001f1           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000a28 0005          .dw $0005
000a29 6f64
000a2a 7365
000a2b 003e          .db "does>",0
000a2c 0a21          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000a2d f000          .dw DO_COLON
                 PFA_DOES:
000a2e 01b2          .dw XT_COMPILE
000a2f 0a40          .dw XT_DODOES
000a30 01b2          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000a31 940e          .dw $940e       ; the address of this compiled
000a32 01b2          .dw XT_COMPILE  ; code will replace the XT of the 
000a33 0a35          .dw DO_DODOES   ; word that CREATE created
000a34 f020          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000a35 939a
000a36 938a          savetos
000a37 01cb          movw tosl, wl
000a38 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000a39 917f          pop wh
000a3a 916f          pop wl
                 
000a3b 93bf          push XH
000a3c 93af          push XL
000a3d 01db          movw XL, wl
000a3e 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000a40 f000          .dw DO_COLON
                 PFA_DODOES:
000a41 f0fc          .dw XT_R_FROM
000a42 f040          .dw XT_DOLITERAL
000a43 0161          .dw COLON_SMUDGE+2
000a44 f086          .dw XT_FETCH
000a45 f373          .dw XT_FETCHE
000a46 0bef          .dw XT_NFA2LFA
000a47 f24a          .dw XT_1PLUS   ; lfa>xt
                 
000a48 f394          .dw XT_STOREI
000a49 f020          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000a4a ff01          .dw $ff01
000a4b 003a          .db ":",0
000a4c 0a28          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000a4d f000          .dw DO_COLON
                 PFA_COLON:
000a4e 018b          .dw XT_DOCREATE
000a4f 0166          .dw XT_DP
000a50 0a26          .dw XT_LATEST
000a51 f08e          .dw XT_STORE
000a52 01b2          .dw XT_COMPILE
000a53 f000          .dw DO_COLON
000a54 0a71          .dw XT_RBRACKET
000a55 f020          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000a56 ff07          .dw $ff07
000a57 6e3a
000a58 6e6f
000a59 6d61
000a5a 0065          .db ":noname",0
000a5b 0a4a          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000a5c f000          .dw DO_COLON
                 PFA_COLONNONAME:
000a5d 0166          .dw XT_DP
000a5e f0be          .dw XT_DUP
000a5f 0a26          .dw XT_LATEST
000a60 f08e          .dw XT_STORE
                 
000a61 01b2          .dw XT_COMPILE
000a62 f000          .dw DO_COLON
                 
000a63 0a71          .dw XT_RBRACKET
000a64 f020          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000a65 0001          .dw $0001
000a66 003b          .db $3b,0
000a67 0a56          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000a68 f000          .dw DO_COLON
                 PFA_SEMICOLON:
000a69 01b2          .dw XT_COMPILE
000a6a f020          .dw XT_EXIT
000a6b 0a7a          .dw XT_LBRACKET
000a6c 0a11          .dw XT_REVEAL
000a6d f020          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000a6e ff01          .dw $ff01
000a6f 005d          .db "]",0
000a70 0a65          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000a71 f000          .dw DO_COLON
                 PFA_RBRACKET:
000a72 f040          .dw XT_DOLITERAL
000a73 0001          .dw 1
000a74 0102          .dw XT_STATE
000a75 f08e          .dw XT_STORE
000a76 f020          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000a77 0001          .dw $0001
000a78 005b          .db "[",0
000a79 0a6e          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000a7a f000          .dw DO_COLON
                 PFA_LBRACKET:
000a7b f146          .dw XT_ZERO
000a7c 0102          .dw XT_STATE
000a7d f08e          .dw XT_STORE
000a7e f020          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000a7f ff08          .dw $ff08
000a80 6176
000a81 6972
000a82 6261
000a83 656c          .db "variable"
000a84 0a77          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000a85 f000          .dw DO_COLON
                 PFA_VARIABLE:
000a86 0176          .dw XT_HERE
000a87 0a92          .dw XT_CONSTANT
000a88 f040          .dw XT_DOLITERAL
000a89 0002          .dw 2
000a8a 017f          .dw XT_ALLOT
000a8b f020          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000a8c ff08          .dw $ff08
000a8d 6f63
000a8e 736e
000a8f 6174
000a90 746e          .db "constant"
000a91 0a7f          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000a92 f000          .dw DO_COLON
                 PFA_CONSTANT:
000a93 018b          .dw XT_DOCREATE
000a94 0a11          .dw XT_REVEAL
000a95 01b2          .dw XT_COMPILE
000a96 f04e          .dw PFA_DOVARIABLE
000a97 01bd          .dw XT_COMMA
000a98 f020          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000a99 ff04          .dw $ff04
000a9a 7375
000a9b 7265          .db "user"
000a9c 0a8c          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000a9d f000          .dw DO_COLON
                 PFA_USER:
000a9e 018b          .dw XT_DOCREATE
000a9f 0a11          .dw XT_REVEAL
                 
000aa0 01b2          .dw XT_COMPILE
000aa1 f061          .dw PFA_DOUSER
000aa2 01bd          .dw XT_COMMA
000aa3 f020          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000aa4 ff05          .dw $ff05
000aa5 6176
000aa6 756c
000aa7 0065          .db "value",0
000aa8 0a99          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000aa9 f000          .dw DO_COLON
                 PFA_VALUE:
000aaa f075          .dw XT_DOVALUE
000aab 016e          .dw XT_EDP
000aac 01bd          .dw XT_COMMA
000aad 01b2          .dw XT_COMPILE
000aae 0ab9          .dw XT_EVALUEFETCH
000aaf 01b2          .dw XT_COMPILE
000ab0 0abd          .dw XT_EVALUESTORE
000ab1 016e          .dw XT_EDP
000ab2 f0be          .dw XT_DUP
000ab3 f24a          .dw XT_1PLUS
000ab4 f24a          .dw XT_1PLUS
000ab5 0799          .dw XT_DOTO
000ab6 016f          .dw PFA_EDP
000ab7 f34f          .dw XT_STOREE
000ab8 f020          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000ab9 f000          .dw DO_COLON
                 PFA_EVALUEFETCH:
000aba f387          .dw XT_FETCHI
000abb f373          .dw XT_FETCHE
000abc f020          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000abd f000          .dw DO_COLON
                 PFA_EVALUESTORE:
000abe f387          .dw XT_FETCHI
000abf f34f          .dw XT_STOREE
000ac0 f020          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000ac1 0007          .dw $0007
000ac2 6572
000ac3 7563
000ac4 7372
000ac5 0065          .db "recurse",0
000ac6 0aa4          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000ac7 f000          .dw DO_COLON
                 PFA_RECURSE:
000ac8 0a26          .dw XT_LATEST
000ac9 f086          .dw XT_FETCH
000aca 01bd          .dw XT_COMMA
000acb f020          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000acc ff09          .dw $ff09
000acd 6d69
000ace 656d
000acf 6964
000ad0 7461
000ad1 0065          .db "immediate",0
000ad2 0ac1          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000ad3 f000          .dw DO_COLON
                 PFA_IMMEDIATE:
000ad4 0bb0          .dw XT_GET_CURRENT
000ad5 f373          .dw XT_FETCHE
000ad6 f0be          .dw XT_DUP
000ad7 f387          .dw XT_FETCHI
000ad8 f040          .dw XT_DOLITERAL
000ad9 7fff          .dw $7fff
000ada f22e          .dw XT_AND
000adb f0d1          .dw XT_SWAP
000adc f394          .dw XT_STOREI
000add f020          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000ade 0006          .dw $0006
000adf 635b
000ae0 6168
000ae1 5d72          .db "[char]"
000ae2 0acc          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000ae3 f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
000ae4 01b2          .dw XT_COMPILE
000ae5 f040          .dw XT_DOLITERAL
000ae6 04f1          .dw XT_CHAR
000ae7 01bd          .dw XT_COMMA
000ae8 f020          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000ae9 0006          .dw $0006
000aea 6261
000aeb 726f
000aec 2274          .db "abort", $22
000aed 0ade          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000aee f000          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000aef 01b2          .dw XT_COMPILE
000af0 f039          .dw XT_DOCONDBRANCH
000af1 0166          .dw XT_DP
000af2 01b2          .dw XT_COMPILE
000af3 ffff          .dw -1
                     
000af4 0d40          .dw XT_DOTSTRING
                     
000af5 01b2          .dw XT_COMPILE
000af6 f040          .dw XT_DOLITERAL
                     
000af7 01b2          .dw XT_COMPILE
000af8 fffe          .dw -2
000af9 01b2          .dw XT_COMPILE
000afa 046e          .dw XT_THROW
                     ; then
000afb 0166          .dw XT_DP
000afc f0d1          .dw XT_SWAP
000afd f394          .dw XT_STOREI
000afe f020          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000aff ff05          .dw $ff05
000b00 6261
000b01 726f
000b02 0074          .db "abort",0
000b03 0ae9          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000b04 f000          .dw DO_COLON
                 PFA_ABORT:
000b05 f040          .dw XT_DOLITERAL
000b06 ffff          .dw -1
000b07 046e          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000b08 ff04          .dw $ff04
000b09 6f63
000b0a 6564          .db "code"
000b0b 0aff          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000b0c f000          .dw DO_COLON
                 PFA_CODE:
000b0d 018b          .dw XT_DOCREATE
000b0e 0a11          .dw XT_REVEAL
000b0f 0166          .dw XT_DP
000b10 f24a          .dw XT_1PLUS
000b11 01bd          .dw XT_COMMA
000b12 f020          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000b13 ff08          .dw $ff08
000b14 6e65
000b15 2d64
000b16 6f63
000b17 6564          .db "end-code"
000b18 0b08          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000b19 f000          .dw DO_COLON
                 PFA_ENDCODE:
000b1a 01b2          .dw XT_COMPILE
000b1b 940c          .dw $940c
000b1c 01b2          .dw XT_COMPILE
000b1d f004          .dw DO_NEXT
000b1e f020          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000b1f ff0b          .dw $ff0b
000b20 6e65
000b21 6976
000b22 6f72
000b23 6d6e
000b24 6e65
000b25 0074          .db "environment",0
000b26 0b13          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000b27 f04e          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000b28 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000b29 ff09          .dw $ff09
000b2a 6f77
000b2b 6472
000b2c 696c
000b2d 7473
000b2e 0073          .db "wordlists",0
000b2f 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000b30 f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000b31 f040          .dw XT_DOLITERAL
000b32 0008          .dw NUMWORDLISTS
000b33 f020          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000b34 ff04          .dw $ff04
000b35 702f
000b36 6461          .db "/pad"
000b37 0b29          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000b38 f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000b39 f29c          .dw XT_SP_FETCH
000b3a 013c          .dw XT_PAD
000b3b f1ae          .dw XT_MINUS
000b3c f020          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000b3d ff05          .dw $ff05
000b3e 682f
000b3f 6c6f
000b40 0064          .db "/hold",0
000b41 0b34          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000b42 f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000b43 013c          .dw XT_PAD
000b44 0176          .dw XT_HERE
000b45 f1ae          .dw XT_MINUS
000b46 f020          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000b47 ff0a          .dw $ff0a
000b48 6f66
000b49 7472
000b4a 2d68
000b4b 616e
000b4c 656d          .db "forth-name"
000b4d 0b3d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000b4e f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000b4f 03a2          .dw XT_DOSLITERAL
000b50 0007          .dw 7
000b51 6d61
000b52 6f66
000b53 7472
000b54 0068          .db "amforth",0
000b55 f020          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000b56 ff07          .dw $ff07
000b57 6576
000b58 7372
000b59 6f69
000b5a 006e          .db "version",0
000b5b 0b47          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000b5c f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000b5d f040          .dw XT_DOLITERAL
000b5e 0034          .dw 52
000b5f f020          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000b60 ff03          .dw $ff03
000b61 7063
000b62 0075          .db "cpu",0
000b63 0b56          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000b64 f000          .dw DO_COLON
                 PFA_EN_CPU:
000b65 f040          .dw XT_DOLITERAL
000b66 0049          .dw mcu_name
000b67 0404          .dw XT_ICOUNT
000b68 f020          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000b69 ff08          .dw $ff08
000b6a 636d
000b6b 2d75
000b6c 6e69
000b6d 6f66          .db "mcu-info"
000b6e 0b60          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000b6f f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
000b70 f040          .dw XT_DOLITERAL
000b71 0045          .dw mcu_info
000b72 f020          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000b73 ff05          .dw $ff05
000b74 752f
000b75 6573
000b76 0072          .db "/user",0
000b77 0b69          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000b78 f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000b79 f040          .dw XT_DOLITERAL
000b7a 0026          .dw SYSUSERSIZE + APPUSERSIZE
000b7b f020          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000b7c ff04          .dw $ff04
000b7d 6540
000b7e 5d5b          .db "@e[]"
000b7f 0b1f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000b80 f000          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000b81 f0be          .dw XT_DUP
000b82 f373          .dw XT_FETCHE
000b83 f105          .dw XT_TO_R    ; save the counter to r-stack
000b84 f10e          .dw XT_R_FETCH
000b85 f146          .dw XT_ZERO
000b86 f0d1          .dw XT_SWAP    ; go from bigger to smaller addresses
000b87 f2bf          .dw XT_DOQDO
000b88 0b92          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000b89 f2d5          .dw XT_I
000b8a 010f          .dw XT_CELLS ; ( -- ee-addr i*2 )
000b8b f0dc          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000b8c f1b8          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000b8d f373          .dw XT_FETCHE ;( -- ee-addr item_i )
000b8e f0d1          .dw XT_SWAP   ;( -- item_i ee-addr )
000b8f f14f          .dw XT_TRUE  ; shortcut for -1
000b90 f2d6          .dw XT_DOPLUSLOOP
000b91 0b89          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000b92 0128          .dw XT_2DROP
000b93 f0fc          .dw XT_R_FROM ; get the counter from r-stack
000b94 f020          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000b95 ff04          .dw $ff04
000b96 6521
000b97 5d5b          .db "!e[]"
000b98 0b7c          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000b99 f000          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000b9a 011f          .dw XT_2DUP
000b9b f34f          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000b9c f0d1          .dw XT_SWAP    
000b9d f146          .dw XT_ZERO
000b9e f2bf          .dw XT_DOQDO
000b9f 0ba6          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000ba0 0117          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000ba1 f0d1          .dw XT_SWAP
000ba2 f0dc          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000ba3 f34f          .dw XT_STOREE
000ba4 f2f0          .dw XT_DOLOOP
000ba5 0ba0          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000ba6 f0e6          .dw XT_DROP
000ba7 f020          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000ba8 ff0b          .dw $ff0b
000ba9 6567
000baa 2d74
000bab 7563
000bac 7272
000bad 6e65
000bae 0074          .db "get-current",0
000baf 0b95          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000bb0 f000          .dw DO_COLON
                 PFA_GET_CURRENT:
000bb1 f040          .dw XT_DOLITERAL
000bb2 0010          .dw EE_CURRENT
000bb3 f373          .dw XT_FETCHE
000bb4 f020          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000bb5 ff09          .dw $ff09
000bb6 6567
000bb7 2d74
000bb8 726f
000bb9 6564
000bba 0072          .db "get-order",0
000bbb 0ba8          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000bbc f000          .dw DO_COLON
                 PFA_GET_ORDER:
000bbd f040          .dw XT_DOLITERAL
000bbe 0014          .dw EE_ORDERLISTLEN
000bbf 0b80          .dw XT_FETCH_EE_ARRAY
000bc0 f020          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000bc1 ff07          .dw $ff07
000bc2 6f63
000bc3 706d
000bc4 7261
000bc5 0065          .db "compare",0
000bc6 0bb5          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000bc7 0bc8          .dw PFA_COMPARE
                 PFA_COMPARE:
000bc8 93bf          push xh
000bc9 93af          push xl
000bca 018c          movw temp0, tosl
000bcb 9189
000bcc 9199          loadtos
000bcd 01dc          movw xl, tosl
000bce 9189
000bcf 9199          loadtos
000bd0 019c          movw temp2, tosl
000bd1 9189
000bd2 9199          loadtos
000bd3 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000bd4 90ed          ld temp4, X+
000bd5 90f1          ld temp5, Z+
000bd6 14ef          cp temp4, temp5
000bd7 f451          brne PFA_COMPARE_NOTEQUAL
000bd8 950a          dec temp0
000bd9 f019          breq PFA_COMPARE_ENDREACHED2
000bda 952a          dec temp2
000bdb f7c1          brne PFA_COMPARE_LOOP
000bdc c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000bdd 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000bde 2b02          or temp0, temp2
000bdf f411          brne PFA_COMPARE_CHECKLASTCHAR
000be0 2788          clr tosl
000be1 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000be2 ef8f          ser tosl
000be3 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000be4 2f98          mov tosh, tosl
000be5 91af          pop xl
000be6 91bf          pop xh
000be7 940c f004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000be9 ff07         .dw $ff07
000bea 666e
000beb 3e61
000bec 666c
000bed 0061         .db "nfa>lfa",0
000bee 0bc1         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000bef f000          .dw DO_COLON
                 PFA_NFA2LFA:
000bf0 0404          .dw XT_ICOUNT 
000bf1 f040          .dw XT_DOLITERAL
000bf2 00ff          .dw $00ff
000bf3 f22e          .dw XT_AND
000bf4 f24a          .dw XT_1PLUS
000bf5 f21f          .dw XT_2SLASH
000bf6 f1b8          .dw XT_PLUS
000bf7 f020          .dw XT_EXIT
                 .include "dict_wl.inc"
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000bf8 ff0b          .dw $ff0b
000bf9 6573
000bfa 2d74
000bfb 7563
000bfc 7272
000bfd 6e65
000bfe 0074          .db "set-current",0
000bff 0be9          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000c00 f000          .dw DO_COLON
                 PFA_SET_CURRENT:
000c01 f040          .dw XT_DOLITERAL
000c02 0010          .dw EE_CURRENT
000c03 f34f          .dw XT_STOREE
000c04 f020          .dw XT_EXIT
                 .include "words/previous.asm"
                 
                 ; Search Order
                 ; remove the first entry in the search order list
                 VE_PREVIOUS:
000c05 ff08          .dw $ff08
000c06 7270
000c07 7665
000c08 6f69
000c09 7375          .db "previous"
000c0a 0bf8          .dw VE_HEAD
                     .set VE_HEAD = VE_PREVIOUS
                 XT_PREVIOUS:
000c0b f000          .dw DO_COLON	
                 PFA_PREVIOUS:
000c0c 0bbc          .dw XT_GET_ORDER
000c0d f0d1          .dw XT_SWAP
000c0e f0e6          .dw XT_DROP
000c0f f250          .dw XT_1MINUS
000c10 f0be          .dw XT_DUP
000c11 f12a          .dw XT_EQUALZERO
000c12 f039          .dw XT_DOCONDBRANCH
000c13 0c17          .dw PFA_PREVIOUS1
000c14 f040          .dw XT_DOLITERAL
000c15 ffce          .dw -50
000c16 046e          .dw XT_THROW
                 PFA_PREVIOUS1:
000c17 0c74          .dw XT_SET_ORDER
000c18 f020          .dw XT_EXIT
                 .include "words/definitions.asm"
                 
                 ; Search Order
                 ; Make the compilation word list the same as the current first word list in the search order.
                 VE_DEFINITIONS:
000c19 ff0b          .dw $ff0b
000c1a 6564
000c1b 6966
000c1c 696e
000c1d 6974
000c1e 6e6f
000c1f 0073          .db "definitions",0
000c20 0c05          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFINITIONS
                 XT_DEFINITIONS:
000c21 f000          .dw DO_COLON
                 PFA_DEFINITIONS:
000c22 0bbc          .dw XT_GET_ORDER
000c23 f0dc          .dw XT_OVER
000c24 0c00          .dw XT_SET_CURRENT
                     ; now empty the order list on stack
000c25 f146          .dw XT_ZERO
000c26 f2bf          .dw XT_DOQDO
000c27 0c2b          .dw PFA_DEFINITIONS2
                 PFA_DEFINITIONS1:
000c28 f0e6          .dw XT_DROP
000c29 f2f0          .dw XT_DOLOOP
000c2a 0c28          .dw PFA_DEFINITIONS1
                 PFA_DEFINITIONS2:
000c2b f020          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000c2c ff08          .dw $ff08
000c2d 6f77
000c2e 6472
000c2f 696c
000c30 7473          .db "wordlist"
000c31 0c19          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000c32 f000          .dw DO_COLON
                 PFA_WORDLIST:
000c33 016e          .dw XT_EDP
000c34 f146          .dw XT_ZERO
000c35 f0dc          .dw XT_OVER
000c36 f34f          .dw XT_STOREE
000c37 f0be          .dw XT_DUP
000c38 f24a          .dw XT_1PLUS
000c39 f24a          .dw XT_1PLUS
000c3a 0799          .dw XT_DOTO
000c3b 016f          .dw PFA_EDP
000c3c f020          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000c3d ff04          .dw $ff04
000c3e 6e6f
000c3f 796c          .db "only"
000c40 0c2c          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000c41 f000          .dw DO_COLON
                 PFA_ONLY:
000c42 f040          .dw XT_DOLITERAL
000c43 0012          .dw EE_FORTHWORDLIST
000c44 f040          .dw XT_DOLITERAL
000c45 0001          .dw 1
000c46 0c74          .dw XT_SET_ORDER
000c47 f020          .dw XT_EXIT
                 .include "words/forth.asm"
                 
                 ; Search Order
                 ; replace the search order list with the system default list
                 VE_FORTH:
000c48 ff05          .dw $ff05
000c49 6f66
000c4a 7472
000c4b 0068          .db "forth",0
000c4c 0c3d          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH
                 XT_FORTH:
000c4d f000          .dw DO_COLON
                 PFA_FORTH:
000c4e 0bbc          .dw XT_GET_ORDER
000c4f f0d1          .dw XT_SWAP
000c50 f0e6          .dw XT_DROP
000c51 0c5e          .dw XT_FORTH_WORDLIST
000c52 f0d1          .dw XT_SWAP
000c53 0c74          .dw XT_SET_ORDER
000c54 f020          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000c55 ff0e          .dw $ff0e
000c56 6f66
000c57 7472
000c58 2d68
000c59 6f77
000c5a 6472
000c5b 696c
000c5c 7473          .db "forth-wordlist"
000c5d 0c48          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000c5e f07b          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000c5f 000e          .dw EE_WL_FORTH
000c60 0ab9          .dw XT_EVALUEFETCH
000c61 0abd          .dw XT_EVALUESTORE
                 .include "words/also.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_ALSO:
000c62 ff04          .dw $ff04
000c63 6c61
000c64 6f73          .db "also"
000c65 0c55          .dw VE_HEAD
                     .set VE_HEAD = VE_ALSO
                 XT_ALSO:
000c66 f000          .dw DO_COLON
                 PFA_ALSO:
000c67 0bbc          .dw XT_GET_ORDER
000c68 f0dc          .dw XT_OVER
000c69 f0d1          .dw XT_SWAP
000c6a f24a          .dw XT_1PLUS
000c6b 0c74          .dw XT_SET_ORDER
000c6c f020          .dw XT_EXIT
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 VE_SET_ORDER:
000c6d ff09          .dw $ff09
000c6e 6573
000c6f 2d74
000c70 726f
000c71 6564
000c72 0072          .db "set-order",0
000c73 0c62          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000c74 f000          .dw DO_COLON
                 PFA_SET_ORDER:
000c75 f040          .dw XT_DOLITERAL
000c76 0014          .dw EE_ORDERLISTLEN
000c77 0b99          .dw XT_STORE_EE_ARRAY
000c78 f020          .dw XT_EXIT
                 
                 .include "words/order.asm"
                 
                 ; Search Order
                 ; print the wids of the current word list and the search order
                 VE_ORDER:
000c79 ff05          .dw $ff05
000c7a 726f
000c7b 6564
000c7c 0072          .db "order",0
000c7d 0c6d          .dw VE_HEAD
                     .set VE_HEAD = VE_ORDER
                 XT_ORDER:
000c7e f000          .dw DO_COLON
                 PFA_ORDER:
000c7f 0bb0          .dw XT_GET_CURRENT
000c80 0d1f          .dw XT_UDOT
000c81 040d          .dw XT_CR
000c82 0bbc          .dw XT_GET_ORDER
000c83 f0be          .dw XT_DUP
000c84 0d1f          .dw XT_UDOT
000c85 f146          .dw XT_ZERO
000c86 f2bf          .dw XT_DOQDO
000c87 0c8c          .dw PFA_ORDER2
                 PFA_ORDER1:
000c88 0d1f          .dw XT_UDOT
000c89 041a          .dw XT_SPACE         ; ( -- addr n)
000c8a f2f0          .dw XT_DOLOOP
000c8b 0c88          .dw PFA_ORDER1
                 PFA_ORDER2:
000c8c f020          .dw XT_EXIT
                 
                 ;.include "dict_mcu.inc"
                 ;.include "dict_vm.inc"
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000c8d ff04          .dw $ff04
000c8e 692b
000c8f 746e          .db "+int"
000c90 0c79          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000c91 0c92          .dw PFA_INTON
                 PFA_INTON:
000c92 9478          sei
000c93 940c f004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000c95 ff04          .dw $ff04
000c96 692d
000c97 746e          .db "-int"
000c98 0c8d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000c99 0c9a          .dw PFA_INTOFF
                 PFA_INTOFF:
000c9a 94f8          cli
000c9b 940c f004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000c9d ff04          .dw $ff04
000c9e 6e69
000c9f 2174          .db "int!"
000ca0 0c95          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000ca1 f000          .dw DO_COLON
                 PFA_INTSTORE:
000ca2 f040          .dw XT_DOLITERAL
000ca3 0115          .dw intvec
000ca4 f1b8          .dw XT_PLUS
000ca5 f08e          .dw XT_STORE
000ca6 f020          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000ca7 ff04          .dw $ff04
000ca8 6e69
000ca9 4074          .db "int@"
000caa 0c9d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000cab f000          .dw DO_COLON
                 PFA_INTFETCH:
000cac f040          .dw XT_DOLITERAL
000cad 0115          .dw intvec
000cae f1b8          .dw XT_PLUS
000caf f086          .dw XT_FETCH
000cb0 f020          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000cb1 ff08          .dw $ff08
000cb2 6e69
000cb3 2d74
000cb4 7274
000cb5 7061          .db "int-trap"
000cb6 0ca7          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000cb7 0cb8          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000cb8 9380 0114     sts intcur, tosl
000cba 9189
000cbb 9199          loadtos
000cbc 9468          set ; set the interrupt flag for the inner interpreter
000cbd 940c f004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000cbf f000          .dw DO_COLON
                 PFA_ISREXEC:
000cc0 f040          .dw XT_DOLITERAL
000cc1 0114          .dw intcur
000cc2 f0a5          .dw XT_CFETCH
000cc3 f040          .dw XT_DOLITERAL
000cc4 0115          .dw intvec
000cc5 f1b8          .dw XT_PLUS
000cc6 f086          .dw XT_FETCH
000cc7 f02a          .dw XT_EXECUTE
000cc8 0cca          .dw XT_ISREND
000cc9 f020          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000cca 0ccb          .dw PFA_ISREND
                 PFA_ISREND:
000ccb d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000ccc 940c f004     jmp_ DO_NEXT
                 PFA_ISREND1:
000cce 9518          reti
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000ccf ff03          .dw $ff03
000cd0 3264
000cd1 002a          .db "d2*",0
000cd2 0cb1          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000cd3 0cd4          .dw PFA_D2STAR
                 PFA_D2STAR:
000cd4 9109          ld temp0, Y+
000cd5 9119          ld temp1, Y+
000cd6 0f00          lsl temp0
000cd7 1f11          rol temp1
000cd8 1f88          rol tosl
000cd9 1f99          rol tosh
000cda 931a          st -Y, temp1
000cdb 930a          st -Y, temp0
000cdc 940c f004     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000cde ff02          .dw $ff02
000cdf 2b64          .db "d+"
000ce0 0ccf          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000ce1 0ce2          .dw PFA_DPLUS
                 PFA_DPLUS:
000ce2 9129          ld temp2, Y+
000ce3 9139          ld temp3, Y+
                 
000ce4 90e9          ld temp4, Y+
000ce5 90f9          ld temp5, Y+
000ce6 9149          ld temp6, Y+
000ce7 9159          ld temp7, Y+
                 
000ce8 0f24          add temp2, temp6
000ce9 1f35          adc temp3, temp7
000cea 1d8e          adc tosl, temp4
000ceb 1d9f          adc tosh, temp5
                     
000cec 933a          st -Y, temp3
000ced 932a          st -Y, temp2
000cee 940c f004     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000cf0 ff02          .dw $ff02
000cf1 2d64          .db "d-"
000cf2 0cde          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000cf3 0cf4          .dw PFA_DMINUS
                 PFA_DMINUS:
000cf4 9129          ld temp2, Y+
000cf5 9139          ld temp3, Y+
                 
000cf6 90e9          ld temp4, Y+
000cf7 90f9          ld temp5, Y+
000cf8 9149          ld temp6, Y+
000cf9 9159          ld temp7, Y+
                 
000cfa 1b42          sub temp6, temp2
000cfb 0b53          sbc temp7, temp3
000cfc 0ae8          sbc temp4, tosl
000cfd 0af9          sbc temp5, tosh
                 
000cfe 935a          st -Y, temp7
000cff 934a          st -Y, temp6
000d00 01c7          movw tosl, temp4
000d01 940c f004     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000d03 ff07          .dw $ff07
000d04 6964
000d05 766e
000d06 7265
000d07 0074          .db "dinvert",0
000d08 0cf0          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000d09 0d0a          .dw PFA_DINVERT
                 PFA_DINVERT:
000d0a 9109          ld temp0, Y+
000d0b 9119          ld temp1, Y+
000d0c 9580          com tosl
000d0d 9590          com tosh
000d0e 9500          com temp0
000d0f 9510          com temp1
000d10 931a          st -Y, temp1
000d11 930a          st -Y, temp0
000d12 940c f004     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
000d14 ff02          .dw $ff02
000d15 3d64          .db "d="
000d16 0d03          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000d17 f000          .dw DO_COLON
                 PFA_DEQUAL:
000d18 0cf3          .dw XT_DMINUS
000d19 f237          .dw XT_OR
000d1a f12a          .dw XT_EQUALZERO
000d1b f020          .dw XT_EXIT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
000d1c ff02          .dw $ff02
000d1d 2e75          .db "u."
000d1e 0d14          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000d1f f000          .dw DO_COLON
                 PFA_UDOT:
000d20 f146          .dw XT_ZERO
000d21 0347          .dw XT_UDDOT
000d22 f020          .dw XT_EXIT
                 .include "words/udotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 VE_UDOTR:
000d23 ff03          .dw $ff03
000d24 2e75
000d25 0072          .db "u.r",0
000d26 0d1c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
000d27 f000          .dw DO_COLON
                 PFA_UDOTR:
000d28 f146          .dw XT_ZERO
000d29 f0d1          .dw XT_SWAP
000d2a 0350          .dw XT_UDDOTR
000d2b f020          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
000d2c ff02          .dw $ff02
000d2d 732e          .db ".s"
000d2e 0d23          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000d2f f000          .dw DO_COLON
                 PFA_DOTS:
000d30 06b5          .dw XT_SP0
000d31 f29c          .dw XT_SP_FETCH
000d32 0117          .dw XT_CELLPLUS
000d33 f2bf          .dw XT_DOQDO
000d34 0d3c          .dw PFA_DOTS2
                 PFA_DOTS1:
000d35 f2d5          .dw XT_I
000d36 f086          .dw XT_FETCH 
000d37 0d1f          .dw XT_UDOT
000d38 f040          .dw XT_DOLITERAL
000d39 0002          .dw 2
000d3a f2d6          .dw XT_DOPLUSLOOP
000d3b 0d35          .dw PFA_DOTS1
                 PFA_DOTS2:
000d3c f020          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
000d3d 0002          .dw $0002
000d3e 222e          .db ".",$22
000d3f 0d2c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000d40 f000          .dw DO_COLON
                 PFA_DOTSTRING:
000d41 0d48          .dw XT_SQUOTE
000d42 01b2          .dw XT_COMPILE
000d43 03d9          .dw XT_ITYPE
000d44 f020          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
000d45 0002        .dw $0002
000d46 2273        .db "s",$22
000d47 0d3d        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000d48 f000          .dw DO_COLON
                 PFA_SQUOTE:
000d49 f040          .dw XT_DOLITERAL
000d4a 0022          .dw $22
000d4b 05af          .dw XT_PARSE       ; ( -- addr n)
000d4c 0102          .dw XT_STATE
000d4d f086          .dw XT_FETCH
000d4e f039          .dw XT_DOCONDBRANCH
000d4f 0d53          .dw PFA_SQUOTE1
000d50 01b2            .dw XT_COMPILE
000d51 03a2            .dw XT_DOSLITERAL    ; ( -- addr n)
000d52 03b5            .dw XT_SCOMMA
                 PFA_SQUOTE1:
000d53 f020          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000d54 ff06          .dw $ff06
000d55 6445
000d56 6665
000d57 7265          .db "Edefer"
000d58 0d45          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000d59 f000          .dw DO_COLON
                 PFA_EDEFER:
000d5a 018b          .dw XT_DOCREATE
000d5b 0a11          .dw XT_REVEAL
000d5c 01b2          .dw XT_COMPILE
000d5d 07e1          .dw PFA_DODEFER
                 
000d5e 016e          .dw XT_EDP
000d5f f0be          .dw XT_DUP
000d60 01bd          .dw XT_COMMA
000d61 01b2          .dw XT_COMPILE
000d62 07a5          .dw XT_EDEFERFETCH
000d63 01b2          .dw XT_COMPILE
000d64 07aa          .dw XT_EDEFERSTORE
000d65 0117          .dw XT_CELLPLUS
000d66 0799          .dw XT_DOTO
000d67 016f          .dw PFA_EDP
000d68 f020          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000d69 ff06          .dw $ff06
000d6a 6452
000d6b 6665
000d6c 7265          .db "Rdefer"
000d6d 0d54          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000d6e f000          .dw DO_COLON
                 PFA_RDEFER:
000d6f 018b          .dw XT_DOCREATE
000d70 0a11          .dw XT_REVEAL
                 
000d71 01b2          .dw XT_COMPILE
000d72 07e1          .dw PFA_DODEFER
                 
000d73 0176          .dw XT_HERE
000d74 01bd          .dw XT_COMMA
000d75 f040          .dw XT_DOLITERAL
000d76 0002          .dw 2
000d77 017f          .dw XT_ALLOT
                 
000d78 01b2          .dw XT_COMPILE
000d79 07af          .dw XT_RDEFERFETCH
000d7a 01b2          .dw XT_COMPILE
000d7b 07b4          .dw XT_RDEFERSTORE
000d7c f020          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000d7d 0002          .dw $0002
000d7e 7369          .db "is"
000d7f 0d69          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000d80 f000          .dw DO_COLON
                 PFA_IS:
000d81 0102          .dw XT_STATE
000d82 f086          .dw XT_FETCH
000d83 f039          .dw XT_DOCONDBRANCH
000d84 0d89          .dw PFA_IS1
000d85 01c9          .dw XT_BRACKETTICK
000d86 01b2          .dw XT_COMPILE
000d87 07cc          .dw XT_DEFERSTORE
000d88 f020          .dw XT_EXIT
                 PFA_IS1:
000d89 0441          .dw XT_TICK
000d8a 07cc          .dw XT_DEFERSTORE
000d8b f020          .dw XT_EXIT
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000d8c ff0b          .dw $ff0b
000d8d 7061
000d8e 6c70
000d8f 7574
000d90 6e72
000d91 656b
000d92 0079          .db "applturnkey",0
000d93 0d7d          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000d94 f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
000d95 00c3          .dw XT_USART
000d96 0c91          .dw XT_INTON
000d97 0761          .dw XT_VER
000d98 041a          .dw XT_SPACE
000d99 00ec          .dw XT_F_CPU
000d9a f040          .dw XT_DOLITERAL
000d9b 03e8          .dw 1000
000d9c f1dd          .dw XT_UMSLASHMOD
000d9d f0d1          .dw XT_SWAP
000d9e f0e6          .dw XT_DROP
000d9f 01df          .dw XT_DECIMAL
000da0 033f          .dw XT_DOT
000da1 03a2          .dw XT_DOSLITERAL
000da2 0004          .dw 4
000da3 486b
000da4 207a          .db "kHz "
000da5 03d9          .dw XT_ITYPE
000da6 f020          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000da7 ff04          .dw $ff04
000da8 6966
000da9 6c6c          .db "fill"
000daa 0d8c          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000dab f000          .dw DO_COLON
                 PFA_FILL:
000dac f0ee          .dw XT_ROT
000dad f0ee          .dw XT_ROT
000dae f146          .dw XT_ZERO
000daf f2bf          .dw XT_DOQDO
000db0 0db6          .dw PFA_FILL2
                 PFA_FILL1:
000db1 011f          .dw XT_2DUP
000db2 f09a          .dw XT_CSTORE  ; ( -- c c-addr)
000db3 f24a          .dw XT_1PLUS
000db4 f2f0          .dw XT_DOLOOP
000db5 0db1          .dw PFA_FILL1
                 PFA_FILL2:
000db6 f0e6          .dw XT_DROP
000db7 f0e6          .dw XT_DROP
000db8 f020          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
000db9 ff0d          .dw $ff0d
000dba 6873
000dbb 776f
000dbc 772d
000dbd 726f
000dbe 6c64
000dbf 7369
000dc0 0074          .db "show-wordlist",0
000dc1 0da7          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
000dc2 f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
000dc3 f040          .dw XT_DOLITERAL
000dc4 0dc8          .dw XT_SHOWWORD
000dc5 f0d1          .dw XT_SWAP
000dc6 083b          .dw XT_TRAVERSEWORDLIST
000dc7 f020          .dw XT_EXIT
                 
                 XT_SHOWWORD:
000dc8 f000          .dw DO_COLON
                 PFA_SHOWWORD:
000dc9 082a          .dw XT_NAME2STRING
000dca 03d9          .dw XT_ITYPE
000dcb 041a          .dw XT_SPACE         ; ( -- addr n)
000dcc f14f          .dw XT_TRUE
000dcd f020          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000dce ff05          .dw $ff05
000dcf 6f77
000dd0 6472
000dd1 0073          .db "words",0
000dd2 0db9          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000dd3 f000          .dw DO_COLON
                 PFA_WORDS:
000dd4 f040          .dw XT_DOLITERAL
000dd5 0016          .dw EE_ORDERLIST
000dd6 f373          .dw XT_FETCHE
000dd7 0dc2          .dw XT_SHOWWORDLIST
000dd8 f020          .dw XT_EXIT
                 
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
000dd9 ff03          .dw $ff03
000dda 6d31
000ddb 0073          .db "1ms",0
000ddc 0dce          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000ddd 0dde          .dw PFA_1MS
                 PFA_1MS:
000dde eae0
000ddf e0ff
000de0 9731
000de1 f7f1          delay 1000
000de2 940c f004     jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
000de4 0008          .dw $0008
000de5 6c32
000de6 7469
000de7 7265
000de8 6c61          .db "2literal"
000de9 0dd9          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
000dea f000          .dw DO_COLON
                 PFA_2LITERAL:
000deb f0d1          .dw XT_SWAP
000dec 01b2          .dw XT_COMPILE
000ded f040          .dw XT_DOLITERAL
000dee 01bd          .dw XT_COMMA
000def 01b2          .dw XT_COMPILE
000df0 f040          .dw XT_DOLITERAL
000df1 01bd          .dw XT_COMMA
                     
000df2 f020          .dw XT_EXIT
                 .include "device.inc"
                 
                 ; generated automatically, no not edit
                 
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 .if WANT_USART0 == 1
                 .endif
                 .if WANT_PORTA == 1
                 .endif
                 .if WANT_PORTB == 1
                 .endif
                 .if WANT_PORTC == 1
                 .endif
                 .if WANT_PORTD == 1
                 .endif
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_3 == 1
                 .endif
                 .if WANT_BOOT_LOAD == 1
                 .endif
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 .if WANT_JTAG == 1
                 .endif
                 .if WANT_EEPROM == 1
                 .endif
                 .if WANT_TWI == 1
                 .endif
                 .if WANT_USART1 == 1
                 .endif
                 .if WANT_SPI == 1
                 .endif
                 .if WANT_WATCHDOG == 1
                 .endif
                 .if WANT_CPU == 1
                 .endif
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
00f004 f09e          brts DO_INTERRUPT
00f005 01fd          movw zl, XL        ; READ IP
00f006 2755
00f007 0fee
00f008 1fff
00f009 1f55
00f00a bf5b
00f00b 9167
00f00c 9177          readflashcell wl, wh
00f00d 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00e 01fb          movw zl, wl
00f00f 2755
00f010 0fee
00f011 1fff
00f012 1f55
00f013 bf5b
00f014 9107
00f015 9117          readflashcell temp0,temp1
00f016 01f8          movw zl, temp0
00f017 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f018 94e8          clt
00f019 eb6f          ldi wl, LOW(XT_ISREXEC)
00f01a e07c          ldi wh, HIGH(XT_ISREXEC)
00f01b cff2          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f01c ff04          .dw $ff04
00f01d 7865
00f01e 7469          .db "exit"
00f01f 0de4          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f020 f021          .dw PFA_EXIT
                 PFA_EXIT:
00f021 91af          pop XL
00f022 91bf          pop XH
00f023 cfe0          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f024 ff07          .dw $ff07
00f025 7865
00f026 6365
00f027 7475
00f028 0065          .db "execute",0
00f029 f01c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02a f02b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f02b 01bc          movw wl, tosl
00f02c 9189
00f02d 9199          loadtos
00f02e cfdf          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f02f f030          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f030 01fd          movw zl, XL
00f031 2755
00f032 0fee
00f033 1fff
00f034 1f55
00f035 bf5b
00f036 91a7
00f037 91b7          readflashcell XL,XH
00f038 cfcb          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f039 f03a          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03a 2b98          or tosh, tosl
00f03b 9189
00f03c 9199          loadtos
00f03d f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f03e 9611          adiw XL, 1
00f03f cfc4          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f040 f041          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f041 939a
00f042 938a          savetos
00f043 01fd          movw zl, xl
00f044 2755
00f045 0fee
00f046 1fff
00f047 1f55
00f048 bf5b
00f049 9187
00f04a 9197          readflashcell tosl,tosh
00f04b 9611          adiw xl, 1
00f04c cfb7          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f04d f04e          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f04e 939a
00f04f 938a          savetos
00f050 01fb          movw zl, wl
00f051 9631          adiw zl,1
00f052 2755
00f053 0fee
00f054 1fff
00f055 1f55
00f056 bf5b
00f057 9187
00f058 9197          readflashcell tosl,tosh
00f059 cfaa          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05a f05b          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f05b 939a
00f05c 938a          savetos
00f05d 01cb          movw tosl, wl
00f05e 9601          adiw tosl, 1
00f05f cfa4          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f060 f061          .dw PFA_DOUSER
                 PFA_DOUSER:
00f061 939a
00f062 938a          savetos
00f063 01fb          movw zl, wl
00f064 9631          adiw zl, 1
00f065 2755
00f066 0fee
00f067 1fff
00f068 1f55
00f069 bf5b
00f06a 9187
00f06b 9197          readflashcell tosl,tosh
00f06c 0d84          add tosl, upl
00f06d 1d95          adc tosh, uph
00f06e cf95          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f06f ff07          .dw $ff07
00f070 7628
00f071 6c61
00f072 6575
00f073 0029          .db "(value)", 0
00f074 f024          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f075 f000          .dw DO_COLON
                 PFA_DOVALUE:
00f076 018b          .dw XT_DOCREATE
00f077 0a11          .dw XT_REVEAL
00f078 01b2          .dw XT_COMPILE
00f079 f07b          .dw PFA_DOVALUE1
00f07a f020          .dw XT_EXIT
                 PFA_DOVALUE1:
00f07b 940e 0a35     call_ DO_DODOES
00f07d f0be          .dw XT_DUP
00f07e f0d1          .dw XT_SWAP
00f07f f24a          .dw XT_1PLUS
00f080 f387          .dw XT_FETCHI
00f081 f02a          .dw XT_EXECUTE
00f082 f020          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f083 ff01          .dw $ff01
00f084 0040          .db "@",0
00f085 f06f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f086 f087          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f087 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f088 9181          ld tosl, z+
00f089 9191          ld tosh, z+
00f08a cf79          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08b ff01          .dw $ff01
00f08c 0021          .db "!",0
00f08d f083          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f08e f08f          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f08f 01fc          movw zl, tosl
00f090 9189
00f091 9199          loadtos
                     ; the high byte is written before the low byte
00f092 8391          std Z+1, tosh
00f093 8380          std Z+0, tosl
00f094 9189
00f095 9199          loadtos
00f096 cf6d          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f097 ff02          .dw $ff02
00f098 2163          .db "c!"
00f099 f08b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09a f09b          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09b 01fc          movw zl, tosl
00f09c 9189
00f09d 9199          loadtos
00f09e 8380          st Z, tosl
00f09f 9189
00f0a0 9199          loadtos
00f0a1 cf62          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a2 ff02          .dw $ff02
00f0a3 4063          .db "c@"
00f0a4 f097          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a5 f0a6          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0a6 01fc          movw zl, tosl
00f0a7 2799          clr tosh
00f0a8 8180          ld tosl, Z
00f0a9 cf5a          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
00f0aa ff02          .dw $ff02
00f0ab 7540          .db "@u"
00f0ac f0a2          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0ad f000          .dw DO_COLON
                 PFA_FETCHU:
00f0ae f32f          .dw XT_UP_FETCH
00f0af f1b8          .dw XT_PLUS
00f0b0 f086          .dw XT_FETCH
00f0b1 f020          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
00f0b2 ff02          .dw $ff02
00f0b3 7521          .db "!u"
00f0b4 f0aa          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b5 f000          .dw DO_COLON
                 PFA_STOREU:
00f0b6 f32f          .dw XT_UP_FETCH
00f0b7 f1b8          .dw XT_PLUS
00f0b8 f08e          .dw XT_STORE
00f0b9 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0ba ff03          .dw $ff03
00f0bb 7564
00f0bc 0070          .db "dup",0
00f0bd f0b2          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0be f0bf          .dw PFA_DUP
                 PFA_DUP:
00f0bf 939a
00f0c0 938a          savetos
00f0c1 cf42          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c2 ff04          .dw $ff04
00f0c3 643f
00f0c4 7075          .db "?dup"
00f0c5 f0ba          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0c6 f0c7          .dw PFA_QDUP
                 PFA_QDUP:
00f0c7 2f08          mov temp0, tosl
00f0c8 2b09          or temp0, tosh
00f0c9 f011          breq PFA_QDUP1
00f0ca 939a
00f0cb 938a          savetos
                 PFA_QDUP1:
00f0cc cf37          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0cd ff04          .dw $ff04
00f0ce 7773
00f0cf 7061          .db "swap"
00f0d0 f0c2          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d1 f0d2          .dw PFA_SWAP
                 PFA_SWAP:
00f0d2 018c          movw temp0, tosl
00f0d3 9189
00f0d4 9199          loadtos
00f0d5 931a          st -Y, temp1
00f0d6 930a          st -Y, temp0
00f0d7 cf2c          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0d8 ff04          .dw $ff04
00f0d9 766f
00f0da 7265          .db "over"
00f0db f0cd          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0dc f0dd          .dw PFA_OVER
                 PFA_OVER:
00f0dd 939a
00f0de 938a          savetos
00f0df 818a          ldd tosl, Y+2
00f0e0 819b          ldd tosh, Y+3
                 
00f0e1 cf22          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e2 ff04          .dw $ff04
00f0e3 7264
00f0e4 706f          .db "drop"
00f0e5 f0d8          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0e6 f0e7          .dw PFA_DROP
                 PFA_DROP:
00f0e7 9189
00f0e8 9199          loadtos
00f0e9 cf1a          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ea ff03          .dw $ff03
00f0eb 6f72
00f0ec 0074          .db "rot",0
00f0ed f0e2          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0ee f0ef          .dw PFA_ROT
                 PFA_ROT:
00f0ef 018c          movw temp0, tosl
00f0f0 9129          ld temp2, Y+
00f0f1 9139          ld temp3, Y+ 
00f0f2 9189
00f0f3 9199          loadtos
                         
00f0f4 933a          st -Y, temp3
00f0f5 932a          st -Y, temp2
00f0f6 931a          st -Y, temp1
00f0f7 930a          st -Y, temp0
                 
00f0f8 cf0b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f0f9 ff02          .dw $ff02
00f0fa 3e72          .db "r>"
00f0fb f0ea          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f0fc f0fd          .dw PFA_R_FROM
                 PFA_R_FROM:
00f0fd 939a
00f0fe 938a          savetos
00f0ff 918f          pop tosl
00f100 919f          pop tosh
00f101 cf02          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f102 ff02          .dw $ff02
00f103 723e          .db ">r"
00f104 f0f9          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f105 f106          .dw PFA_TO_R
                 PFA_TO_R:
00f106 939f          push tosh
00f107 938f          push tosl
00f108 9189
00f109 9199          loadtos
00f10a cef9          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f10b ff02          .dw $ff02
00f10c 4072          .db "r@"
00f10d f102          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f10e f10f          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f10f 939a
00f110 938a          savetos
00f111 918f          pop tosl
00f112 919f          pop tosh
00f113 939f          push tosh
00f114 938f          push tosl
00f115 ceee          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
00f116 ff02          .dw $ff02
00f117 3e3c          .db "<>"
00f118 f10b          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f119 f11a          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
00f11a 9129          ld temp2, Y+
00f11b 9139          ld temp3, Y+
00f11c 1782          cp tosl, temp2
00f11d 0793          cpc tosh, temp3
00f11e f151          breq PFA_ZERO1
00f11f c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f120 ff01          .dw $ff01
00f121 003d          .db "=",0
00f122 f116          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f123 f000          .dw DO_COLON
                 PFA_EQUAL:
00f124 f1ae          .dw XT_MINUS
00f125 f12a          .dw XT_EQUALZERO
00f126 f020          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
00f127 ff02          .dw $ff02
00f128 3d30          .db "0="
00f129 f120          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
00f12a f12b          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
00f12b 2b98          or tosh, tosl
00f12c f4e1          brne PFA_ZERO1
00f12d c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f12e ff01          .dw $ff01
00f12f 003c          .db "<",0
00f130 f127          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f131 f000          .dw DO_COLON
                 PFA_LESS:
00f132 f1ae          .dw XT_MINUS
00f133 f13f          .dw XT_LESSZERO
00f134 f020          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f135 ff01          .dw $ff01
00f136 003e          .db ">",0
00f137 f12e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f138 f000          .dw DO_COLON
                 PFA_GREATER:
00f139 f1ae          .dw XT_MINUS
00f13a f16e          .dw XT_GREATERZERO
00f13b f020          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00f13c ff02          .dw $ff02
00f13d 3c30          .db "0<"
00f13e f135          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00f13f f140          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00f140 fd97          sbrc tosh,7
00f141 c010          rjmp PFA_TRUE1
00f142 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f143 ff01          .dw $ff01
00f144 0030          .db "0",0
00f145 f13c          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f146 f147          .dw PFA_ZERO
                 PFA_ZERO:
00f147 939a
00f148 938a          savetos
                 PFA_ZERO1:
00f149 01c1          movw tosl, zerol
00f14a ceb9          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f14b ff04          .dw $ff04
00f14c 7274
00f14d 6575          .db "true"
00f14e f143          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f14f f150          .dw PFA_TRUE
                 PFA_TRUE:
00f150 939a
00f151 938a          savetos
                 PFA_TRUE1:
00f152 ef8f          ser tosl
00f153 ef9f          ser tosh
00f154 ceaf          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f155 ff02          .dw $ff02
00f156 3c75          .db "u<"
00f157 f14b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f158 f159          .dw PFA_ULESS
                 PFA_ULESS:
00f159 9129          ld temp2, Y+
00f15a 9139          ld temp3, Y+
00f15b 1782          cp tosl, temp2
00f15c 0793          cpc tosh, temp3
00f15d f358          brlo PFA_ZERO1
00f15e f351          brbs 1, PFA_ZERO1
00f15f cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00f160 ff02          .dw $ff02
00f161 3e75          .db "u>"
00f162 f155          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f163 f164          .dw PFA_UGREATER
                 PFA_UGREATER:
00f164 9129          ld temp2, Y+
00f165 9139          ld temp3, Y+
00f166 1728          cp temp2, tosl
00f167 0739          cpc temp3, tosh
00f168 f300          brlo PFA_ZERO1
00f169 f2f9          brbs 1, PFA_ZERO1
00f16a cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f16b ff02          .dw $ff02
00f16c 3e30          .db "0>"
00f16d f160          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f16e f16f          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f16f 1582          cp tosl, zerol
00f170 0593          cpc tosh, zeroh
00f171 f2bc          brlt PFA_ZERO1
00f172 f2b1          brbs 1, PFA_ZERO1
00f173 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
00f174 ff02          .dw $ff02
00f175 3e64          .db "d>"
00f176 f16b          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
00f177 f000          .dw DO_COLON
                 PFA_DGREATER:
00f178 0cf3          .dw XT_DMINUS
00f179 f17f          .dw XT_DGREATERZERO
00f17a f020          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f17b ff03          .dw $ff03
00f17c 3064
00f17d 003e          .db "d0>",0
00f17e f174          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f17f f180          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f180 1582          cp tosl, zerol
00f181 0593          cpc tosh, zeroh
00f182 9189
00f183 9199          loadtos
00f184 0582          cpc tosl, zerol
00f185 0593          cpc tosh, zeroh
00f186 f214          brlt PFA_ZERO1
00f187 f209          brbs 1, PFA_ZERO1
00f188 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
00f189 ff02          .dw $ff02
00f18a 3c64          .db "d<"
00f18b f17b          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00f18c f000          .dw DO_COLON
                 PFA_DLESS:
00f18d 0cf3          .dw XT_DMINUS
00f18e f194          .dw XT_DLESSZERO
00f18f f020          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00f190 ff03          .dw $ff03
00f191 3064
00f192 003c          .db "d0<",0
00f193 f189          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
00f194 f195          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
00f195 9622          adiw Y,2
00f196 fd97          sbrc tosh,7
00f197 940c f152     jmp PFA_TRUE1
00f199 940c f149     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f19b ff04          .dw $ff04
00f19c 6f6c
00f19d 3267          .db "log2"
00f19e f190          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f19f f1a0          .dw PFA_LOG2
                 PFA_LOG2:
00f1a0 01fc          movw zl, tosl
00f1a1 2799          clr tosh
00f1a2 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f1a3 958a          dec tosl
00f1a4 f022          brmi PFA_LOG2_2 ; wrong data
00f1a5 0fee          lsl  zl
00f1a6 1fff          rol  zh
00f1a7 f7d8          brcc PFA_LOG2_1
00f1a8 ce5b          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f1a9 959a          dec tosh
00f1aa ce59          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1ab ff01          .dw $ff01
00f1ac 002d          .db "-",0
00f1ad f19b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1ae f1af          .dw PFA_MINUS
                 PFA_MINUS:
00f1af 9109          ld temp0, Y+
00f1b0 9119          ld temp1, Y+
00f1b1 1b08          sub temp0, tosl
00f1b2 0b19          sbc temp1, tosh
00f1b3 01c8          movw tosl, temp0
00f1b4 ce4f          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1b5 ff01          .dw $ff01
00f1b6 002b          .db "+",0
00f1b7 f1ab          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1b8 f1b9          .dw PFA_PLUS
                 PFA_PLUS:
00f1b9 9109          ld temp0, Y+
00f1ba 9119          ld temp1, Y+
00f1bb 0f80          add tosl, temp0
00f1bc 1f91          adc tosh, temp1
00f1bd ce46          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1be ff02          .dw $ff02
00f1bf 2a6d          .db "m*"
00f1c0 f1b5          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1c1 f1c2          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1c2 018c          movw temp0, tosl
00f1c3 9189
00f1c4 9199          loadtos
00f1c5 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1c6 0231          muls temp3, temp1
00f1c7 0170          movw temp4, r0
                     ; low cell  al*bl
00f1c8 9f20          mul  temp2, temp0
00f1c9 01c0          movw tosl, r0
                     ; signed ah*bl
00f1ca 0330          mulsu temp3, temp0
00f1cb 08f3          sbc   temp5, zeroh
00f1cc 0d90          add   tosh,  r0
00f1cd 1ce1          adc   temp4, r1
00f1ce 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1cf 0312          mulsu temp1, temp2
00f1d0 08f3          sbc   temp5, zeroh
00f1d1 0d90          add   tosh,  r0
00f1d2 1ce1          adc   temp4, r1
00f1d3 1cf3          adc   temp5, zeroh
                 
00f1d4 939a
00f1d5 938a          savetos
00f1d6 01c7          movw tosl, temp4
00f1d7 ce2c          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1d8 ff06          .dw $ff06
00f1d9 6d75
00f1da 6d2f
00f1db 646f          .db "um/mod"
00f1dc f1be          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1dd f1de          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1de 017c          movw temp4, tosl
                 
00f1df 9129          ld temp2, Y+
00f1e0 9139          ld temp3, Y+
                   
00f1e1 9109          ld temp0, Y+
00f1e2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1e3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1e4 2755          clr temp7
00f1e5 0f00          lsl temp0
00f1e6 1f11          rol temp1
00f1e7 1f22          rol temp2
00f1e8 1f33          rol temp3
00f1e9 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1ea 152e          cp temp2, temp4
00f1eb 053f          cpc temp3, temp5
00f1ec 0552          cpc temp7,zerol
                 
00f1ed f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1ee 9503          inc temp0
00f1ef 192e          sub temp2, temp4
00f1f0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1f1 954a          dec  temp6
00f1f2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1f3 933a          st -Y,temp3
00f1f4 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1f5 01c8          movw tosl, temp0
00f1f6 ce0d          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1f7 ff03          .dw $ff03
00f1f8 6d75
00f1f9 002a          .db "um*",0
00f1fa f1d8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1fb f1fc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1fc 018c          movw temp0, tosl
00f1fd 9189
00f1fe 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1ff 9f80          mul tosl,temp0
00f200 01f0          movw zl, r0
00f201 2722          clr temp2
00f202 2733          clr temp3
                     ; middle bytes
00f203 9f90          mul tosh, temp0
00f204 0df0          add zh, r0
00f205 1d21          adc temp2, r1
00f206 1d33          adc temp3, zeroh
                         
00f207 9f81          mul tosl, temp1
00f208 0df0          add zh, r0
00f209 1d21          adc temp2, r1
00f20a 1d33          adc temp3, zeroh
                     
00f20b 9f91          mul tosh, temp1
00f20c 0d20          add temp2, r0
00f20d 1d31          adc temp3, r1
00f20e 01cf          movw tosl, zl
00f20f 939a
00f210 938a          savetos
00f211 01c9          movw tosl, temp2
00f212 cdf1          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f213 ff06          .dw $ff06
00f214 6e69
00f215 6576
00f216 7472          .db "invert"
00f217 f1f7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f218 f219          .dw PFA_INVERT
                 PFA_INVERT:
00f219 9580          com tosl
00f21a 9590          com tosh
00f21b cde8          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f21c ff02          .dw $ff02
00f21d 2f32          .db "2/"
00f21e f213          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f21f f220          .dw PFA_2SLASH
                 PFA_2SLASH:
00f220 9595          asr tosh
00f221 9587          ror tosl
00f222 cde1          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f223 ff02          .dw $ff02
00f224 2a32          .db "2*"
00f225 f21c          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f226 f227          .dw PFA_2STAR
                 PFA_2STAR:
00f227 0f88          lsl tosl
00f228 1f99          rol tosh
00f229 cdda          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f22a ff03          .dw $ff03
00f22b 6e61
00f22c 0064          .db "and",0
00f22d f223          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f22e f22f          .dw PFA_AND
                 PFA_AND:
00f22f 9109          ld temp0, Y+
00f230 9119          ld temp1, Y+
00f231 2380          and tosl, temp0
00f232 2391          and tosh, temp1
00f233 cdd0          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f234 ff02          .dw $ff02
00f235 726f          .db "or"
00f236 f22a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f237 f238          .dw PFA_OR
                 PFA_OR:
00f238 9109          ld temp0, Y+
00f239 9119          ld temp1, Y+
00f23a 2b80          or tosl, temp0
00f23b 2b91          or tosh, temp1
00f23c cdc7          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f23d ff03          .dw $ff03
00f23e 6f78
00f23f 0072          .db "xor",0
00f240 f234          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f241 f242          .dw PFA_XOR
                 PFA_XOR:
00f242 9109          ld temp0, Y+
00f243 9119          ld temp1, Y+
00f244 2780          eor tosl, temp0
00f245 2791          eor tosh, temp1
00f246 cdbd          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f247 ff02          .dw $ff02
00f248 2b31          .db "1+"
00f249 f23d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f24a f24b          .dw PFA_1PLUS
                 PFA_1PLUS:
00f24b 9601          adiw tosl,1
00f24c cdb7          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f24d ff02          .dw $ff02 
00f24e 2d31          .db "1-"
00f24f f247          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f250 f251          .dw PFA_1MINUS
                 PFA_1MINUS:
00f251 9701          sbiw tosl, 1
00f252 cdb1          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f253 ff06          .dw $ff06
00f254 736c
00f255 6968
00f256 7466          .db "lshift"
00f257 f24d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f258 f259          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f259 01fc          movw zl, tosl
00f25a 9189
00f25b 9199          loadtos
                 PFA_LSHIFT1:
00f25c 9731          sbiw zl, 1
00f25d f01a          brmi PFA_LSHIFT2
00f25e 0f88          lsl tosl
00f25f 1f99          rol tosh
00f260 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f261 cda2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f262 ff06          .dw $ff06
00f263 7372
00f264 6968
00f265 7466          .db "rshift"
00f266 f253          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f267 f268          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f268 01fc          movw zl, tosl
00f269 9189
00f26a 9199          loadtos
                 PFA_RSHIFT1:
00f26b 9731          sbiw zl, 1
00f26c f01a          brmi PFA_RSHIFT2
00f26d 9596          lsr tosh
00f26e 9587          ror tosl
00f26f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f270 cd93          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f271 ff02          .dw $ff02
00f272 212b          .db "+!"
00f273 f262          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f274 f275          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f275 01fc          movw zl, tosl
00f276 9189
00f277 9199          loadtos
00f278 8120          ldd temp2, Z+0
00f279 8131          ldd temp3, Z+1
00f27a 0f82          add tosl, temp2
00f27b 1f93          adc tosh, temp3
00f27c 8380          std Z+0, tosl
00f27d 8391          std Z+1, tosh
00f27e 9189
00f27f 9199          loadtos
00f280 cd83          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f281 ff03          .dw $ff03
00f282 7072
00f283 0040          .db "rp@",0
00f284 f271          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f285 f286          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f286 939a
00f287 938a          savetos
00f288 b78d          in tosl, SPL
00f289 b79e          in tosh, SPH
00f28a cd79          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f28b ff03          .dw $ff03
00f28c 7072
00f28d 0021          .db "rp!",0
00f28e f281          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f28f f290          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f290 b72f          in temp2, SREG
00f291 94f8          cli
00f292 bf8d          out SPL, tosl
00f293 bf9e          out SPH, tosh
00f294 bf2f          out SREG, temp2
00f295 9189
00f296 9199          loadtos
00f297 cd6c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f298 ff03          .dw $ff03
00f299 7073
00f29a 0040          .db "sp@",0
00f29b f28b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f29c f29d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f29d 939a
00f29e 938a          savetos
00f29f 01ce          movw tosl, yl
00f2a0 cd63          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f2a1 ff03          .dw $ff03
00f2a2 7073
00f2a3 0021          .db "sp!",0
00f2a4 f298          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f2a5 f2a6          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a6 01ec          movw yl, tosl
00f2a7 9189
00f2a8 9199          loadtos
00f2a9 cd5a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2aa f2ab          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2ab 01fd          movw zl, xl
00f2ac 2755
00f2ad 0fee
00f2ae 1fff
00f2af 1f55
00f2b0 bf5b
00f2b1 9107
00f2b2 9117          readflashcell temp0,temp1
00f2b3 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2b4 9129          ld temp2, Y+
00f2b5 9139          ld temp3, Y+
                 PFA_DODO1:
00f2b6 931f          push temp1
00f2b7 930f          push temp0
00f2b8 933f          push temp3
00f2b9 932f          push temp2
00f2ba 939f          push tosh
00f2bb 938f          push tosl
00f2bc 9189
00f2bd 9199          loadtos
00f2be cd45          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
00f2bf f2c0          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2c0 01fd          movw zl, xl
00f2c1 2755
00f2c2 0fee
00f2c3 1fff
00f2c4 1f55
00f2c5 bf5b
00f2c6 9107
00f2c7 9117          readflashcell temp0,temp1
00f2c8 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2c9 9129          ld temp2, Y+
00f2ca 9139          ld temp3, Y+
                     ; now check for equality
00f2cb 1782          cp tosl, temp2
00f2cc 0793          cpc tosh, temp3
00f2cd f741          brne PFA_DODO1
                     ; both values are the same -> skip loop
00f2ce 01d8          movw xl, temp0
00f2cf 9189
00f2d0 9199          loadtos
00f2d1 cd32          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2d2 ff01          .dw $FF01
00f2d3 0069          .db "i",0
00f2d4 f2a1          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2d5 f10f          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2d6 f2d7          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2d7 91ef          pop zl
00f2d8 91ff          pop zh
00f2d9 0fe8          add zl, tosl
00f2da 1ff9          adc zh, tosh
00f2db 2f19          mov temp1, tosh
00f2dc 9189
00f2dd 9199          loadtos
                 PFA_DOPLUSLOOP4: 
00f2de 912f          pop temp2
00f2df 913f          pop temp3
00f2e0 17e2          cp zl, temp2
00f2e1 07f3          cpc zh, temp3
00f2e2 ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
00f2e3 c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
00f2e4 f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
00f2e5 c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
00f2e6 f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
00f2e7 933f          push temp3
00f2e8 932f          push temp2
00f2e9 93ff          push zh
00f2ea 93ef          push zl
00f2eb cd44          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
00f2ec 910f          pop  temp0
00f2ed 911f          pop  temp1  ; remove leave destination
00f2ee 9611          adiw xl, 1 ; skip branch-back address
00f2ef cd14          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2f0 f2f1          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2f1 91ef          pop zl
00f2f2 91ff          pop zh
00f2f3 9631          adiw zl,1
00f2f4 912f          pop temp2
00f2f5 913f          pop temp3
00f2f6 17e2          cp zl, temp2
00f2f7 07f3          cpc zh, temp3
00f2f8 f399          breq PFA_DOPLUSLOOP1
00f2f9 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2fa ff06          .dw $ff06
00f2fb 6e75
00f2fc 6f6c
00f2fd 706f          .db "unloop"
00f2fe f2d2          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2ff f300          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f300 911f          pop temp1
00f301 910f          pop temp0
00f302 911f          pop temp1
00f303 910f          pop temp0
00f304 911f          pop temp1
00f305 910f          pop temp0
00f306 ccfd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f307 ff06          .dw $ff06
00f308 6d63
00f309 766f
00f30a 3e65          .db "cmove>"
00f30b f2fa          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f30c f30d          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f30d 93bf          push xh
00f30e 93af          push xl
00f30f 91e9          ld zl, Y+
00f310 91f9          ld zh, Y+ ; addr-to
00f311 91a9          ld xl, Y+
00f312 91b9          ld xh, Y+ ; addr-from
00f313 2f09          mov temp0, tosh
00f314 2b08          or temp0, tosl
00f315 f041          brbs 1, PFA_CMOVE_G1
00f316 0fe8          add zl, tosl
00f317 1ff9          adc zh, tosh
00f318 0fa8          add xl, tosl
00f319 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f31a 911e          ld temp1, -X
00f31b 9312          st -Z, temp1
00f31c 9701          sbiw tosl, 1
00f31d f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f31e 91af          pop xl
00f31f 91bf          pop xh
00f320 9189
00f321 9199          loadtos
00f322 cce1          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f323 ff02          .dw $ff02
00f324 3c3e          .db "><"
00f325 f307          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f326 f327          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f327 2f09          mov temp0, tosh
00f328 2f98          mov tosh, tosl
00f329 2f80          mov tosl, temp0
00f32a ccd9          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f32b ff03          .dw $ff03
00f32c 7075
00f32d 0040          .db "up@",0
00f32e f323          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f32f f330          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f330 939a
00f331 938a          savetos
00f332 01c2          movw tosl, upl
00f333 ccd0          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f334 ff03          .dw $ff03
00f335 7075
00f336 0021          .db "up!",0
00f337 f32b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f338 f339          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f339 012c          movw upl, tosl
00f33a 9189
00f33b 9199          loadtos
00f33c ccc7          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
00f33d ff03          .dw $ff03
00f33e 3e73
00f33f 0064          .db "s>d",0
00f340 f334          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00f341 f000          .dw DO_COLON
                 PFA_S2D:
00f342 f0be          .dw XT_DUP
00f343 f13f          .dw XT_LESSZERO
                 .include "words/not.asm"
00f344 f020      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
00f345 ff03          .dw $ff03
00f346 6f6e
00f347 0074          .db "not",0
00f348 f33d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
00f349 f000          .dw DO_COLON
                 PFA_NOT:
00f34a f12a          .dw XT_EQUALZERO
00f34b f020          .dw XT_EXIT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f34c ff02          .dw $ff02
00f34d 6521          .db "!e"
00f34e f345          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f34f f350          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f350 01fc          movw zl, tosl
00f351 9189
00f352 9199          loadtos
00f353 b72f          in_ temp2, SREG
00f354 94f8          cli
00f355 d028          rcall PFA_FETCHE2
00f356 b500          in_  temp0, EEDR
00f357 1708          cp temp0,tosl
00f358 f009          breq PFA_STOREE3
00f359 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f35a 9631          adiw zl,1
00f35b d022          rcall PFA_FETCHE2
00f35c b500          in_  temp0, EEDR
00f35d 1709          cp temp0,tosh
00f35e f011          breq PFA_STOREE4
00f35f 2f89          mov tosl, tosh
00f360 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f361 bf2f          out_ SREG, temp2
00f362 9189
00f363 9199          loadtos
00f364 cc9f          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f365 99f9          sbic EECR, EEPE
00f366 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f367 b707          in_ temp0, SPMCSR
00f368 fd00          sbrc temp0,SPMEN
00f369 cffd          rjmp PFA_STOREE2
                 
00f36a bdf2          out_ EEARH,zh
00f36b bde1          out_ EEARL,zl
00f36c bd80          out_ EEDR, tosl
00f36d 9afa          sbi EECR,EEMPE
00f36e 9af9          sbi EECR,EEPE
                 
00f36f 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f370 ff02          .dw $ff02
00f371 6540          .db "@e"
00f372 f34c          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f373 f374          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f374 b72f          in_ temp2, SREG
00f375 94f8          cli
00f376 01fc          movw zl, tosl
00f377 d006          rcall PFA_FETCHE2
00f378 b580          in_ tosl, EEDR
                 
00f379 9631          adiw zl,1
                 
00f37a d003          rcall PFA_FETCHE2
00f37b b590          in_  tosh, EEDR
00f37c bf2f          out_ SREG, temp2
00f37d cc86          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f37e 99f9          sbic EECR, EEPE
00f37f cffe          rjmp PFA_FETCHE2
                 
00f380 bdf2          out_ EEARH,zh
00f381 bde1          out_ EEARL,zl
                 
00f382 9af8          sbi EECR,EERE
00f383 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f384 ff02          .dw $ff02
00f385 6940          .db "@i"
00f386 f370          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f387 f388          .dw PFA_FETCHI
                 PFA_FETCHI:
00f388 01fc          movw zl, tosl
00f389 2755
00f38a 0fee
00f38b 1fff
00f38c 1f55
00f38d bf5b
00f38e 9187
00f38f 9197          readflashcell tosl,tosh
00f390 cc73          jmp_ DO_NEXT
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f391 ff02          .dw $ff02
00f392 6921          .db "!i"
00f393 f384          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f394 07e1          .dw PFA_DODEFER
                 PFA_STOREI:
00f395 000a          .dw EE_STOREI
00f396 07a5          .dw XT_EDEFERFETCH
00f397 07aa          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f398 ff09          .dw $ff09
00f399 2128
00f39a 2d69
00f39b 726e
00f39c 7777
00f39d 0029          .db "(!i-nrww)",0
00f39e f391          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f39f f3a0          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f3a0 b71f        in temp1,SREG
00f3a1 931f        push temp1
00f3a2 94f8        cli
                 
00f3a3 019c        movw temp2, tosl ; save the (word) address
00f3a4 9189
00f3a5 9199        loadtos          ; get the new value for the flash cell
00f3a6 93af        push xl
00f3a7 93bf        push xh
00f3a8 93cf        push yl
00f3a9 93df        push yh
00f3aa d009        rcall DO_STOREI_atmega
00f3ab 91df        pop yh
00f3ac 91cf        pop yl
00f3ad 91bf        pop xh
00f3ae 91af        pop xl
                   ; finally clear the stack
00f3af 9189
00f3b0 9199        loadtos
00f3b1 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f3b2 bf1f        out SREG,temp1
                 
00f3b3 cc50        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f3b4 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f3b5 94e0        com temp4
00f3b6 94f0        com temp5
00f3b7 218e        and tosl, temp4
00f3b8 219f        and tosh, temp5
00f3b9 2b98        or tosh, tosl
00f3ba f019        breq DO_STOREI_writepage 
                 
00f3bb 01f9          movw zl, temp2
00f3bc e002          ldi temp0,(1<<PGERS)
00f3bd d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3be 01f9        movw zl, temp2
00f3bf e004        ldi temp0,(1<<PGWRT)
00f3c0 d020        rcall dospm
                 
                   ; reenable RWW section
00f3c1 01f9        movw zl, temp2
00f3c2 e100        ldi temp0,(1<<RWWSRE)
00f3c3 d01d        rcall dospm
00f3c4 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3c5 01f9        movw zl, temp2
                   ; get the beginning of page
00f3c6 78e0        andi zl,low(pagemask)
00f3c7 7fff        andi zh,high(pagemask)
00f3c8 01ef        movw y, z
                   ; loop counter (in words)
00f3c9 e8a0        ldi xl,low(pagesize)
00f3ca e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3cb 01fe        movw z, y
00f3cc 2755
00f3cd 0fee
00f3ce 1fff
00f3cf 1f55
00f3d0 bf5b
00f3d1 9147
00f3d2 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3d3 01fe        movw z, y
00f3d4 17e2        cp zl, temp2
00f3d5 07f3        cpc zh, temp3
00f3d6 f011        breq pageload_newdata
00f3d7 010a          movw r0, temp6
00f3d8 c002          rjmp pageload_cont
                 pageload_newdata:
00f3d9 017a          movw temp4, temp6
00f3da 010c          movw r0, tosl
                 pageload_cont:
00f3db 2700        clr temp0
00f3dc d004        rcall dospm
00f3dd 9621        adiw y, 1
00f3de 9711        sbiw x, 1
00f3df f759        brne pageload_loop
                 
                 pageload_done:
00f3e0 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3e1 99f9        sbic EECR, EEPE
00f3e2 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3e3 b717        in_  temp1, SPMCSR
00f3e4 fd10        sbrc temp1, SPMEN
00f3e5 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3e6 2755
00f3e7 0fee
00f3e8 1fff
00f3e9 1f55
00f3ea bf5b        writeflashcell
                   ; execute spm
00f3eb 6001        ori temp0, (1<<SPMEN)
00f3ec bf07        out_ SPMCSR,temp0
00f3ed 95e8        spm
00f3ee 9508        ret
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
00f3ef ff03          .dw $ff03
00f3f0 3e6e
00f3f1 0072          .db "n>r",0
00f3f2 f398          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
00f3f3 f3f4          .dw PFA_N_TO_R
                 PFA_N_TO_R:
00f3f4 01fc          movw zl, tosl
00f3f5 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
00f3f6 9189
00f3f7 9199          loadtos
00f3f8 939f          push tosh
00f3f9 938f          push tosl
00f3fa 950a          dec temp0
00f3fb f7d1          brne PFA_N_TO_R1
00f3fc 93ef          push zl
00f3fd 93ff          push zh
00f3fe 9189
00f3ff 9199          loadtos
00f400 cc03          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00f401 ff03          .dw $ff03
00f402 726e
00f403 003e          .db "nr>",0
00f404 f3ef          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00f405 f406          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
00f406 939a
00f407 938a          savetos
00f408 91ff          pop zh
00f409 91ef          pop zl
00f40a 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00f40b 918f          pop tosl
00f40c 919f          pop tosh
00f40d 939a
00f40e 938a          savetos
00f40f 950a          dec temp0
00f410 f7d1          brne PFA_N_R_FROM1
00f411 01cf          movw tosl, zl
00f412 cbf1          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 f3 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 f3 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 94 0d         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 9f f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 73 0b         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 01 f4         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 2d 07         .dw XT_REC_FIND
00002a 10 07         .dw XT_REC_INTNUMBER
00002c 49 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 b0 0b         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 40         .dw rstackstart  ; USER_RP
00003e af 40         .dw stackstart   ; USER_SP0
000040 af 40         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 9f 00         .dw XT_TX  ; USER_EMIT
000048 ad 00         .dw XT_TXQ ; USER_EMITQ
00004a 75 00         .dw XT_RX  ; USER_KEY
00004c 8f 00         .dw XT_RXQ ; USER_KEYQ
00004e fa 08         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 e6 08         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 67 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 24
000058 f4 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1284P" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  80 r17:  57 r18:  58 r19:  42 r20:  13 r21:  44 r22:  11 r23:   3 
r24: 173 r25: 123 r26:  45 r27:  22 r28:   6 r29:   4 r30:  71 r31:  35 
x  :   4 y  : 189 z  :  42 
Registers used: 29 out of 35 (82.9%)

"ATmega1284P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :  11 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  22 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :  10 elpm  :  20 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   2 
jmp   :  22 ld    : 131 ldd   :   4 ldi   :  22 lds   :   2 lpm   :   0 
lsl   :  16 lsr   :   1 mov   :  12 movw  :  66 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  28 
pop   :  52 push  :  38 rcall :  47 ret   :   6 reti  :   2 rjmp  :  89 
rol   :  36 ror   :   2 sbc   :   8 sbci  :   3 sbi   :   3 sbic  :   3 
sbis  :   0 sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   4 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  62 std   :   8 
sts   :   3 sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 73 out of 114 (64.0%)

"ATmega1284P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01e826   1944   9308  11252  131072   8.6%
[.dseg] 0x000100 0x0001f3      0    243    243   16384   1.5%
[.eseg] 0x000000 0x00005a      0     90     90    4096   2.2%

Assembly complete, 0 errors, 2 warnings
