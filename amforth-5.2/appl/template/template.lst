
AVRASM ver. 2.1.51  template.asm Mon Dec 23 20:35:23 2013

template.asm(12): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
template.asm(16): Including file '../../core/devices/atmega1284p\device.asm'
../../core/devices/atmega1284p\device.asm(5): Including file '../../Atmel/Appnotes2\m1284Pdef.inc'
template.asm(68): Including file '../../core\drivers/1wire.asm'
template.asm(78): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
template.asm(81): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/2dup.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/2drop.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(16): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(21): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(25): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(29): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(34): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(36): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(48): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(67): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(77): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(81): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(94): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(100): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(108): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(127): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(130): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/traverse-wordlist.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(140): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(145): Including file '../../core\words/init-user.asm'
dict_appl.inc(4): Including file '../../core\words/d-2star.asm'
dict_appl.inc(5): Including file '../../core\words/d-plus.asm'
dict_appl.inc(6): Including file '../../core\words/d-minus.asm'
dict_appl.inc(7): Including file '../../core\words/d-invert.asm'
dict_appl.inc(8): Including file '../../core\words/udot.asm'
dict_appl.inc(9): Including file '../../core\words/dot-s.asm'
dict_appl.inc(11): Including file '../../core\words/dotstring.asm'
dict_appl.inc(12): Including file '../../core\words/squote.asm'
dict_appl.inc(14): Including file '../../core\words/words.asm'
dict_appl.inc(16): Including file '../../core\words/edefer.asm'
dict_appl.inc(17): Including file '../../core\words/rdefer.asm'
dict_appl.inc(18): Including file '../../core\words/is.asm'
dict_appl.inc(20): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/wlscope.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(38): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/value.asm'
../../core\dict_compiler.inc(41): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(45): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(48): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(58): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(63): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(64): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(68): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(69): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(21): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(22): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(25): Including file '../../core/devices/atmega1284p\device.inc'
dict_appl.inc(27): Including file 'words/applturnkey.asm'
dict_appl.inc(28): Including file 'words/qmark.asm'
dict_appl.inc(29): Including file '../../core\words/marker.asm'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-greaterzero.asm'
../../core\dict_core.inc(49): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(50): Including file '../../core\words/d-lesszero.asm'
../../core\dict_core.inc(51): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(52): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(53): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(54): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(55): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(56): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(58): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(59): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(60): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(61): Including file '../../core\words/and.asm'
../../core\dict_core.inc(62): Including file '../../core\words/or.asm'
../../core\dict_core.inc(63): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(65): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(66): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(67): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(68): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(69): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(73): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(74): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(76): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(78): Including file '../../core\words/i.asm'
../../core\dict_core.inc(79): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(80): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(81): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(85): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(86): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(87): Including file '../../core\words/up.asm'
../../core\dict_core.inc(88): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(89): Including file '../../core\words/not.asm'
dict_appl_core.inc(2): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(3): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(7): Including file '../../core\words/fetch-i.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 ;
                 ; The order of the entries (esp the include order) must not be
                 ; changed since it is very important that the settings are in the
                 ; right order
                 ;
                 ; note: .set is like a variable, .equ is like a constant
                 ;
                 ; first is to include the macros from the amforth
                 ; directory
                 
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; include the amforth device definition file. These
                 ; files include the *def.inc from atmel internally.
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_USART1 = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d124      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d122      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d120      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d11e      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d11c      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d11a      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d118      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d116      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d114      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d112      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d110      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d10e      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d10c      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d10a      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d108      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d106      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d104      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d102      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d100      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0fe      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0fc      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0fa      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0f8      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0f6      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0f4      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0f2      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0f0      	 rcall isr ; Store Program Memory Read
                 .org 56
000038 d0ee      	 rcall isr ; USART1 RX complete
                 .org 58
00003a d0ec      	 rcall isr ; USART1 Data Register Empty
                 .org 60
00003c d0ea      	 rcall isr ; USART1 TX complete
                 .org 62
00003e d0e8      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0e6      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0e4      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0e2      	 rcall isr ; Timer/Counter3 Overflow
                 .equ INTVECTORS = 35
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000045 4000      	.dw 16384
                 mcu_eepromsize:
000046 1000      	.dw 4096
                 mcu_maxdp:
000047 ffff      	.dw 65535 
                 mcu_numints:
000048 0023      	.dw 35
                 mcu_name:
000049 000b      	.dw 11
00004a 5441
00004b 656d
00004c 6167
00004d 3231
00004e 3438
00004f 0050      	.db "ATmega1284P",0
                 .set codestart=pc
                 
                 ;.equ MCUSR = MCUCSR
                 
                 ; The amforth code is split into two segments, one starting
                 ; at address 0 (the RWW area) and one starting in
                 ; the NRWW region. The latter part cannot be changed
                 ; at runtime so it contains most of the core system
                 ; that would never be changed. If unsure what it
                 ; means, leave it as it is. This address may be
                 ; adjusted to give room for other code fragments (e.g.
                 ; bootloaders). The amforth code will start here and may
                 ; occupy all space until flash-end.
                 
                 .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; now define your own WANT options, if the settings from
                 ; the files included above are not ok. Use the .set
                 ; instruction, not the .equ. e.g.:
                 ;
                 ; .set WANT_XY = 1
                 ;
                 ; there are many WANT options available. There are two
                 ; places where they are defined initially: core/macros.asm 
                 ; and core/devices/<mcutype>/device.asm. Setting the value
                 ; to 1 enables the feature, setting to 0 disables it.
                 ; Most options are disabled by default. You should never
                 ; change the files mentioned above, setting the options here
                 ; is absolutly sufficient.
                 
                 ; the dictionary search treats lowercase and uppercase
                 ; letters the same. Set to 0 if you do not want it
                 .set WANT_IGNORECASE = 1
                 
                 ; amforth needs two essential parameters
                 ; cpu clock in hertz, 1MHz is factory default
                 .equ F_CPU = 8000000
                 .equ TIBSIZE  = $64    ; ANS94 needs at least 80 characters per line
                 .equ APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .equ NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 
                 ;
                 ; DRIVER SECTION
                 ; 
                 ; settings for 1wire interface, if desired
                 .equ OW_PORT=PORTA
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
000050 ff08          .dw $ff08
000051 7731
000052 722e
000053 7365
000054 7465          .db "1w.reset"
000055 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
000056 0057          .dw PFA_OW_RESET
                 PFA_OW_RESET:
000057 939a
000058 938a          savetos
000059 2799          clr tosh
                     ; setup to output
00005a 9a0c          sbi OW_DDR, OW_BIT
                     ; Pull output low
00005b 9814          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
00005c ece0
00005d e0f3
00005e 9731
00005f f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
000060 b71f          in temp1, SREG
000061 94f8          cli
                     ; Pull output high
000062 9a14          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
000063 980c          cbi OW_DDR, OW_BIT 
000064 e8e0
000065 e0f0
000066 9731
000067 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
000068 b180          in tosl, OW_PIN
000069 ff84          sbrs tosl, OW_BIT
00006a ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
00006b bf1f          out SREG, temp1
                     ; release bus
00006c 980c          cbi OW_DDR, OW_BIT
00006d 9814          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
00006e e4e0
00006f e0f3
000070 9731
000071 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
000072 2f89          mov tosl, tosh
000073 940c f004     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
000075 ff07          .dw $ff07
000076 7731
000077 732e
000078 6f6c
000079 0074          .db "1w.slot",0
00007a 0050          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
00007b 007c          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
00007c 9a0c          sbi OW_DDR, OW_BIT
00007d 9814          cbi OW_PORT, OW_BIT
                     ; disable interrupts
00007e b71f          in temp1, SREG
00007f 94f8          cli
000080 e0ec
000081 e0f0
000082 9731
000083 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000084 9488          clc
000085 9587          ror tosl
000086 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000087 980c            cbi OW_DDR, OW_BIT
000088 9a14            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000089 e1e2
00008a e0f0
00008b 9731
00008c f7f1          DELAY 9   ; wait DELAY E to sample
00008d b100          in temp0, OW_PIN
00008e fd04          sbrc temp0, OW_BIT
00008f 6880          ori tosl, $80
                 
000090 e6e6
000091 e0f0
000092 9731
000093 f7f1          DELAY   51 ; DELAY B
000094 980c          cbi OW_DDR, OW_BIT
000095 9a14          sbi OW_PORT, OW_BIT ; release bus
000096 e0e4
000097 e0f0
000098 9731
000099 f7f1          delay 2
                     ; re-enable interrupts
00009a bf1f          out SREG, temp1
00009b 940c f004     jmp_ DO_NEXT
                 
                 ; terminal settings
                 ; check http://amforth.sourceforge.net/recipes/usart-settings.html
                 ; for further information
                 .set WANT_ISR_RX = 1 ; interrupt driven receive
                 .set WANT_ISR_TX = 0 ; send slowly but with less code space
                 ; 9600 @ 8N1 is commonly used.
                 .equ BAUD = 9600
                 ; define which usart to use.
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000028 940c 009d   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_in: .byte 1
000101           usart_rx_out: .byte 1
000102           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00009d 93af        push xl
00009e b7af        in xl, SREG
00009f 93af        push xl
0000a0 93bf        push xh
0000a1 93ef        push zl
0000a2 93ff        push zh
                 
0000a3 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
0000a5 91a0 0100   lds xl,usart_rx_in
0000a7 e0e2        ldi zl, low(usart_rx_data)
0000a8 e0f1        ldi zh, high(usart_rx_data)
0000a9 0fea        add zl, xl
0000aa 1df3        adc zh, zeroh
0000ab 83b0        st Z, xh
                 
0000ac 95a3        inc xl
0000ad 70af        andi xl,usart_rx_mask
                 
0000ae 93a0 0100   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
0000b0 91ff        pop zh
0000b1 91ef        pop zl
0000b2 91bf        pop xh
0000b3 91af        pop xl
0000b4 bfaf        out SREG, xl
0000b5 91af        pop xl
0000b6 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
0000b7 f000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
0000b8 f146        .dw XT_ZERO
0000b9 f040        .dw XT_DOLITERAL
0000ba 0100        .dw usart_rx_in
0000bb f08e        .dw XT_STORE
                 
0000bc f020        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
0000bd ff06          .dw $ff06
0000be 7872
0000bf 692d
0000c0 7273          .db "rx-isr"
0000c1 0075          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000c2 f000          .dw DO_COLON
                 PFA_RX_ISR:
0000c3 00dc        .dw XT_RXQ_ISR
0000c4 f039        .dw XT_DOCONDBRANCH
0000c5 00c3        .dw PFA_RX_ISR
0000c6 f040        .dw XT_DOLITERAL
0000c7 0101        .dw usart_rx_out
0000c8 f0a5        .dw XT_CFETCH
0000c9 f0be        .dw XT_DUP
0000ca f24a        .dw XT_1PLUS
0000cb f040        .dw XT_DOLITERAL
0000cc 000f        .dw usart_rx_mask
0000cd f22e        .dw XT_AND
0000ce f040        .dw XT_DOLITERAL
0000cf 0101        .dw usart_rx_out
0000d0 f09a        .dw XT_CSTORE
0000d1 f040        .dw XT_DOLITERAL
0000d2 0102        .dw usart_rx_data
0000d3 f1b8        .dw XT_PLUS
0000d4 f0a5        .dw XT_CFETCH
0000d5 f020        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
0000d6 ff07          .dw $ff07
0000d7 7872
0000d8 2d3f
0000d9 7369
0000da 0072          .db "rx?-isr",0
0000db 00bd          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
0000dc f000          .dw DO_COLON
                 PFA_RXQ_ISR:
0000dd 06d1        .dw XT_PAUSE
0000de f040        .dw XT_DOLITERAL
0000df 0101        .dw usart_rx_out
0000e0 f0a5        .dw XT_CFETCH
0000e1 f040        .dw XT_DOLITERAL
0000e2 0100        .dw usart_rx_in
0000e3 f0a5        .dw XT_CFETCH
0000e4 f119        .dw XT_NOTEQUAL
0000e5 f020        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000e6 ff07          .dw $ff07
0000e7 7874
0000e8 702d
0000e9 6c6f
0000ea 006c          .db "tx-poll",0
0000eb 00d6          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ec f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000ed 00fa        .dw XT_TXQ_POLL
0000ee f039        .dw XT_DOCONDBRANCH
0000ef 00ed        .dw PFA_TX_POLL
                   ; send to usart
0000f0 f040        .dw XT_DOLITERAL
0000f1 00c6        .dw USART_DATA
0000f2 f09a        .dw XT_CSTORE
0000f3 f020        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000f4 ff08          .dw $ff08
0000f5 7874
0000f6 2d3f
0000f7 6f70
0000f8 6c6c          .db "tx?-poll"
0000f9 00e6          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000fa f000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000fb 06d1        .dw XT_PAUSE
0000fc f040        .dw XT_DOLITERAL
0000fd 00c0        .dw USART_A
0000fe f0a5        .dw XT_CFETCH
0000ff f040        .dw XT_DOLITERAL
000100 0020        .dw bm_USART_TXRD
000101 f22e        .dw XT_AND
000102 f020        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
000103 ff04        .dw $ff04
000104 6275
000105 7272        .db "ubrr"
000106 00f4        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
000107 f07b        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
000108 0054        .dw EE_UBRRVAL
000109 0bce        .dw XT_EVALUEFETCH
00010a 0bd2        .dw XT_EVALUESTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
00010b ff06        .dw $ff06
00010c 752b
00010d 6173
00010e 7472        .db "+usart"
00010f 0103        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
000110 f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
000111 f040        .dw XT_DOLITERAL
000112 0098        .dw USART_B_VALUE
000113 f040        .dw XT_DOLITERAL
000114 00c1        .dw USART_B
000115 f09a        .dw XT_CSTORE
                 
000116 f040        .dw XT_DOLITERAL
000117 0006        .dw USART_C_VALUE
000118 f040        .dw XT_DOLITERAL
000119 00c2        .dw USART_C | bm_USARTC_en
00011a f09a        .dw XT_CSTORE
                 
00011b 0107        .dw XT_UBRR
00011c f0be        .dw XT_DUP
00011d f326        .dw XT_BYTESWAP
00011e f040        .dw XT_DOLITERAL
00011f 00c5        .dw BAUDRATE_HIGH
000120 f09a        .dw XT_CSTORE
000121 f040        .dw XT_DOLITERAL
000122 00c4        .dw BAUDRATE_LOW
000123 f09a        .dw XT_CSTORE
                 
000124 00b7        .dw XT_USART_INIT_RX
000125 07cb        .dw XT_USART_INIT_TX
000126 f020        .dw XT_EXIT
                 
                 ; include the whole source tree.
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 06da   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000114           intcur: .byte 1
000115           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000127 920a          st -Y, r0
000128 b60f          in r0, SREG
000129 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00012a 900f          pop r0
00012b 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00012c 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
00012d 9200 0114     sts intcur, r0
00012f 9009          ld r0, Y+
000130 be0f          out SREG, r0
000131 9009          ld r0, Y+
000132 9468          set ; set the interrupt flag for the inner interpreter
000133 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
000134 ff05          .dw $ff05
000135 5f66
000136 7063
000137 0075          .db "f_cpu",0
000138 010b          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000139 f07b          .dw PFA_DOVALUE1
                 PFA_F_CPU:
00013a 0056          .dw EE_FCPU
00013b 013d          .dw XT_FETCH2E
00013c 0146          .dw XT_STORE2E
                 
                 XT_FETCH2E:
00013d f000          .dw DO_COLON
                 PFA_FETCH2E:
00013e f3e5          .dw XT_FETCHI
00013f f0be          .dw XT_DUP
000140 0164          .dw XT_CELLPLUS
000141 f373          .dw XT_FETCHE
000142 f0d1          .dw XT_SWAP
000143 f373          .dw XT_FETCHE
000144 f0d1          .dw XT_SWAP
000145 f020          .dw XT_EXIT
                 
                 XT_STORE2E:
000146 f000          .dw DO_COLON
                 PFA_STORE2E:
000147 f040          .dw XT_DOLITERAL
000148 ffeb          .dw -21
000149 04bb          .dw XT_THROW
                 
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00014a ff05          .dw $ff05
00014b 7473
00014c 7461
00014d 0065          .db "state",0
00014e 0134          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00014f f04e          .dw PFA_DOVARIABLE
                 PFA_STATE:
000150 015b          .dw ram_state
                 
                 .dseg
00015b           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
000151 ff04          .dw $ff04
000152 6162
000153 6573          .db "base"
000154 014a          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000155 f061          .dw PFA_DOUSER
                 PFA_BASE:
000156 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
000157 ff05          .dw $ff05
000158 6563
000159 6c6c
00015a 0073          .db "cells",0
00015b 0151          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00015c f000          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
00015d f226          .dw XT_2STAR
                 .else
                 .endif
00015e f020          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00015f ff05          .dw $ff05
000160 6563
000161 6c6c
000162 002b          .db "cell+",0
000163 0157          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000164 0165          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000165 9602          adiw tosl, CELLSIZE
000166 940c f004     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 VE_2DUP:
000168 ff04          .dw $ff04
000169 6432
00016a 7075          .db "2dup"
00016b 015f          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00016c f000          .dw DO_COLON
                 PFA_2DUP:
00016d f0dc          .dw XT_OVER
00016e f0dc          .dw XT_OVER
00016f f020          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 VE_2DROP:
000170 ff05          .dw $ff05
000171 6432
000172 6f72
../../core\words/2drop.asm(6): warning: .cseg .db misalignment - padding zero byte
000173 0070          .db "2drop"
000174 0168          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000175 f000          .dw DO_COLON
                 PFA_2DROP:
000176 f0e6          .dw XT_DROP
000177 f0e6          .dw XT_DROP
000178 f020          .dw XT_EXIT
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
000179 ff03          .dw $ff03
00017a 693e
00017b 006e          .db ">in",0
00017c 0170          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
00017d f061          .dw PFA_DOUSER
                 PFA_G_IN:
00017e 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
00017f ff04          .dw $ff04
000180 7423
000181 6269          .db "#tib"
000182 0179          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000183 f04e          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000184 015d          .dw ram_sharptib
                 
                 .dseg
00015d           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000185 ff03          .dw $ff03
000186 6170
000187 0064          .db "pad",0
000188 017f          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
000189 f000          .dw DO_COLON
                 PFA_PAD:
00018a 01c3          .dw XT_HERE
00018b f040          .dw XT_DOLITERAL
00018c 0064          .dw 100
00018d f1b8          .dw XT_PLUS
00018e f020          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
00018f ff04          .dw $ff04
000190 6d65
000191 7469          .db "emit"
000192 0185          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000193 082e          .dw PFA_DODEFER
                 PFA_EMIT:
000194 000e          .dw USER_EMIT
000195 0806          .dw XT_UDEFERFETCH
000196 080d          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
000197 ff05          .dw $ff05
000198 6d65
000199 7469
00019a 003f          .db "emit?",0
00019b 018f          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00019c 082e          .dw PFA_DODEFER
                 PFA_EMITQ:
00019d 0010          .dw USER_EMITQ
00019e 0806          .dw XT_UDEFERFETCH
00019f 080d          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
0001a0 ff03          .dw $ff03
0001a1 656b
0001a2 0079          .db "key",0
0001a3 0197          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0001a4 082e          .dw PFA_DODEFER
                 PFA_KEY:
0001a5 0012          .dw USER_KEY
0001a6 0806          .dw XT_UDEFERFETCH
0001a7 080d          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
0001a8 ff04          .dw $ff04
0001a9 656b
0001aa 3f79          .db "key?"
0001ab 01a0          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0001ac 082e          .dw PFA_DODEFER
                 PFA_KEYQ:
0001ad 0014          .dw USER_KEYQ
0001ae 0806          .dw XT_UDEFERFETCH
0001af 080d          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0001b0 ff02          .dw $ff02
0001b1 7064          .db "dp"
0001b2 01a8          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0001b3 f07b          .dw PFA_DOVALUE1
                 PFA_DP:
0001b4 0002          .dw EE_DP
0001b5 0bce          .dw XT_EVALUEFETCH
0001b6 0bd2          .dw XT_EVALUESTORE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
0001b7 ff03          .dw $ff03
0001b8 6465
0001b9 0070          .db "edp",0
0001ba 01b0          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
0001bb f07b          .dw PFA_DOVALUE1
                 PFA_EDP:
0001bc 0006          .dw EE_EDP
0001bd 0bce          .dw XT_EVALUEFETCH
0001be 0bd2          .dw XT_EVALUESTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0001bf ff04          .dw $ff04
0001c0 6568
0001c1 6572          .db "here"
0001c2 01b7          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0001c3 f07b          .dw PFA_DOVALUE1
                 PFA_HERE:
0001c4 0004          .dw EE_HERE
0001c5 0bce          .dw XT_EVALUEFETCH
0001c6 0bd2          .dw XT_EVALUESTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0001c7 ff05          .dw $ff05
0001c8 6c61
0001c9 6f6c
0001ca 0074          .db "allot",0
0001cb 01bf          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0001cc f000          .dw DO_COLON
                 PFA_ALLOT:
0001cd 01c3          .dw XT_HERE
0001ce f1b8          .dw XT_PLUS
0001cf 07e6          .dw XT_DOTO
0001d0 01c4          .dw PFA_HERE
0001d1 f020          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
0001d2 ff08          .dw $ff08
0001d3 6328
0001d4 6572
0001d5 7461
0001d6 2965          .db "(create)"
0001d7 01c7          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001d8 f000          .dw DO_COLON
                 PFA_DOCREATE:
0001d9 064b          .dw XT_PARSENAME
0001da 0b1d          .dw XT_WLSCOPE
0001db f0be          .dw XT_DUP
0001dc f105          .dw XT_TO_R
0001dd 0b02          .dw XT_HEADER
0001de f0fc          .dw XT_R_FROM
                 .dseg
00015f           COLON_SMUDGE: .byte 4
                 .cseg
0001df f040          .dw XT_DOLITERAL
0001e0 0161          .dw COLON_SMUDGE+2
0001e1 f08e          .dw XT_STORE		; save wid
0001e2 f040          .dw XT_DOLITERAL
0001e3 015f          .dw COLON_SMUDGE+0
0001e4 f08e          .dw XT_STORE		; save NFA
                 
0001e5 f020          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
0001e6 0001          .dw $0001
0001e7 005c          .db "\",0
0001e8 01d2          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001e9 f000          .dw DO_COLON
                 PFA_BACKSLASH:
0001ea 0630          .dw XT_SOURCE
0001eb f0d1          .dw XT_SWAP
0001ec f0e6          .dw XT_DROP
0001ed 017d          .dw XT_G_IN
0001ee f08e          .dw XT_STORE
0001ef f020          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
0001f0 0001          .dw $0001
0001f1 0028          .db "(" ,0
0001f2 01e6          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
0001f3 f000          .dw DO_COLON
                 PFA_LPARENTHESIS:
0001f4 f040          .dw XT_DOLITERAL
0001f5 0029          .dw $29
0001f6 05fc          .dw XT_PARSE
0001f7 0175          .dw XT_2DROP
0001f8 f020          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
0001f9 ff07          .dw $ff07
0001fa 6f63
0001fb 706d
0001fc 6c69
0001fd 0065          .db "compile",0
0001fe 01f0          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001ff f000          .dw DO_COLON
                 PFA_COMPILE:
000200 f0fc          .dw XT_R_FROM
000201 f0be          .dw XT_DUP
000202 f24a          .dw XT_1PLUS
000203 f105          .dw XT_TO_R
000204 f3e5          .dw XT_FETCHI
000205 020a          .dw XT_COMMA
000206 f020          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
000207 ff01          .dw $ff01
000208 002c          .db ',',0 ; ,
000209 01f9          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
00020a f000          .dw DO_COLON
                 PFA_COMMA:
00020b 01b3          .dw XT_DP
00020c f387          .dw XT_STOREI
00020d 01b3          .dw XT_DP
00020e f24a          .dw XT_1PLUS
00020f 07e6          .dw XT_DOTO
000210 01b4          .dw PFA_DP
000211 f020          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
000212 0003          .dw $0003
000213 275b
000214 005d          .db "[']",0
000215 0207          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000216 f000          .dw DO_COLON
                 PFA_BRACKETTICK:
000217 01ff          .dw XT_COMPILE
000218 f040          .dw XT_DOLITERAL
000219 048e          .dw XT_TICK
00021a 020a          .dw XT_COMMA
00021b f020          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
00021c ff03          .dw $ff03
00021d 6962
00021e 006e          .db "bin",0
00021f 0212          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
000220 f000          .dw DO_COLON
                 PFA_BIN:
000221 f040          .dw XT_DOLITERAL
000222 0002          .dw 2
000223 0155          .dw XT_BASE
000224 f08e          .dw XT_STORE
000225 f020          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
000226 ff07          .dw $ff07
000227 6564
000228 6963
000229 616d
00022a 006c          .db "decimal",0
00022b 021c          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00022c f000          .dw DO_COLON
                 PFA_DECIMAL:
00022d f040          .dw XT_DOLITERAL
00022e 000a          .dw 10
00022f 0155          .dw XT_BASE
000230 f08e          .dw XT_STORE
000231 f020          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
000232 ff03          .dw $ff03
000233 6568
000234 0078          .db "hex",0
000235 0226          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000236 f000          .dw DO_COLON
                 PFA_HEX:
000237 f040          .dw XT_DOLITERAL
000238 0010          .dw 16
000239 0155          .dw XT_BASE
00023a f08e          .dw XT_STORE
00023b f020          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
00023c ff02          .dw $ff02
00023d 6c62          .db "bl"
00023e 0232          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00023f f04e          .dw PFA_DOVARIABLE
                 PFA_BL:
000240 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000241 ff07          .dw $ff07
000242 7574
000243 6e72
000244 656b
000245 0079          .db "turnkey",0
000246 023c          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000247 082e          .dw PFA_DODEFER
                 PFA_TURNKEY:
000248 0008          .dw EE_TURNKEY
000249 07f2          .dw XT_EDEFERFETCH
00024a 07f7          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
00024b ff05          .dw $ff05
00024c 2f2a
00024d 6f6d
00024e 0064          .db "*/mod",0
00024f 0241          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
000250 f000          .dw DO_COLON
                 PFA_STARSLASHMOD:
000251 f105          .dw XT_TO_R
000252 f1c1          .dw XT_MSTAR
000253 f0fc          .dw XT_R_FROM
000254 f1dd          .dw XT_UMSLASHMOD
000255 f020          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000256 ff04          .dw $ff04
000257 6d2f
000258 646f          .db "/mod"
000259 024b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00025a 025b          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00025b 019c          movw temp2, tosl
                     
00025c 9109          ld temp0, Y+
00025d 9119          ld temp1, Y+
                 
00025e 2f41          mov	temp6,temp1	;move dividend High to sign register
00025f 2743          eor	temp6,temp3	;xor divisor High with sign register
000260 ff17          sbrs	temp1,7	;if MSB in dividend set
000261 c004          rjmp	PFA_SLASHMOD_1
000262 9510          com	temp1		;    change sign of dividend
000263 9500          com	temp0		
000264 5f0f          subi	temp0,low(-1)
000265 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000266 ff37          sbrs	temp3,7	;if MSB in divisor set
000267 c004          rjmp	PFA_SLASHMOD_2
000268 9530          com	temp3		;    change sign of divisor
000269 9520          com	temp2		
00026a 5f2f          subi	temp2,low(-1)
00026b 4f3f          sbci	temp3,high(-1)
00026c 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00026d 18ff          sub	temp5,temp5;clear remainder High byte and carry
00026e e151          ldi	temp7,17	;init loop counter
                 
00026f 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000270 1f11          rol	temp1
000271 955a          dec	temp7		;decrement counter
000272 f439          brne	PFA_SLASHMOD_5		;if done
000273 ff47          sbrs	temp6,7		;    if MSB in sign register set
000274 c004          rjmp	PFA_SLASHMOD_4
000275 9510          com	temp1	;        change sign of result
000276 9500          com	temp0
000277 5f0f          subi	temp0,low(-1)
000278 4f1f          sbci	temp1,high(-1)
000279 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00027a 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00027b 1cff          rol	temp5
00027c 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00027d 0af3          sbc	temp5,temp3	;
00027e f420          brcc	PFA_SLASHMOD_6		;if result negative
00027f 0ee2          add	temp4,temp2	;    restore remainder
000280 1ef3          adc	temp5,temp3
000281 9488          clc			;    clear carry to be shifted into result
000282 cfec          rjmp	PFA_SLASHMOD_3		;else
000283 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000284 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000285 92fa          st -Y,temp5
000286 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000287 01c8          movw tosl, temp0
000288 940c f004     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
00028a ff02          .dw $ff02
00028b 2f2a          .db "*/"
00028c 0256          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
00028d f000          .dw DO_COLON
                 PFA_STARSLASH:
00028e 0250          .dw XT_STARSLASHMOD
00028f f0d1          .dw XT_SWAP
000290 f0e6          .dw XT_DROP
000291 f020          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000292 ff05          .dw $ff05
000293 2f75
000294 6f6d
000295 0064          .db "u/mod",0
000296 028a          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000297 f000          .dw DO_COLON
                 PFA_USLASHMOD:
000298 f105          .dw XT_TO_R
000299 f146          .dw XT_ZERO
00029a f0fc          .dw XT_R_FROM
00029b f1dd          .dw XT_UMSLASHMOD
00029c f020          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00029d ff06          .dw $ff06
00029e 656e
00029f 6167
0002a0 6574          .db "negate"
0002a1 0292          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
0002a2 f000          .dw DO_COLON
                 PFA_NEGATE:
0002a3 f218          .dw XT_INVERT
0002a4 f24a          .dw XT_1PLUS
0002a5 f020          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
0002a6 ff01          .dw $ff01
0002a7 002f          .db "/",0
0002a8 029d          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
0002a9 f000          .dw DO_COLON
                 PFA_SLASH:
0002aa 025a          .dw XT_SLASHMOD
0002ab f0d1          .dw XT_SWAP
0002ac f0e6          .dw XT_DROP
0002ad f020          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
0002ae ff03          .dw $ff03
0002af 6f6d
0002b0 0064          .db "mod",0
0002b1 02a6          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0002b2 f000          .dw DO_COLON
                 PFA_MOD:
0002b3 025a          .dw XT_SLASHMOD
0002b4 f0e6          .dw XT_DROP
0002b5 f020          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
0002b6 ff03          .dw $ff03
0002b7 6261
0002b8 0073          .db "abs",0
0002b9 02ae          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
0002ba 02bb          .dw PFA_ABS
                 PFA_ABS:
0002bb 2399          tst tosh
0002bc f41a          brpl PFA_ABS1
0002bd 9580          com tosl
0002be 9590          com tosh
0002bf 9601          adiw tosl, 1
                 PFA_ABS1:
0002c0 940c f004     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
0002c2 ff03          .dw $ff03
0002c3 696d
0002c4 006e          .db "min",0
0002c5 02b6          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
0002c6 f000          .dw DO_COLON
                 PFA_MIN:
0002c7 016c          .dw XT_2DUP
0002c8 f138          .dw XT_GREATER
0002c9 f039          .dw XT_DOCONDBRANCH
0002ca 02cc          .dw PFA_MIN1
0002cb f0d1          .dw XT_SWAP
                 PFA_MIN1:
0002cc f0e6          .dw XT_DROP
0002cd f020          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
0002ce ff03          .dw $ff03
0002cf 616d
0002d0 0078          .db "max",0
0002d1 02c2          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
0002d2 f000          .dw DO_COLON
                 PFA_MAX:
0002d3 016c          .dw XT_2DUP
0002d4 f131          .dw XT_LESS
0002d5 f039          .dw XT_DOCONDBRANCH
0002d6 02d8          .dw PFA_MAX1
0002d7 f0d1          .dw XT_SWAP
                 PFA_MAX1:
0002d8 f0e6          .dw XT_DROP
0002d9 f020          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
0002da ff06          .dw $ff06
0002db 6977
0002dc 6874
0002dd 6e69          .db "within"
0002de 02ce          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
0002df f000          .dw DO_COLON
                 PFA_WITHIN:
0002e0 f0dc          .dw XT_OVER
0002e1 f1ae          .dw XT_MINUS
0002e2 f105          .dw XT_TO_R
0002e3 f1ae          .dw XT_MINUS
0002e4 f0fc          .dw XT_R_FROM
0002e5 f158          .dw XT_ULESS
0002e6 f020          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
0002e7 ff07          .dw $ff07 
0002e8 6f74
0002e9 7075
0002ea 6570
0002eb 0072          .db "toupper",0
0002ec 02da          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0002ed f000          .dw DO_COLON 
                 PFA_TOUPPER:
0002ee f0be          .dw XT_DUP 
0002ef f040          .dw XT_DOLITERAL 
0002f0 0061          .dw 'a' 
0002f1 f040          .dw XT_DOLITERAL 
0002f2 007b          .dw 'z'+1
0002f3 02df          .dw XT_WITHIN 
0002f4 f039          .dw XT_DOCONDBRANCH
0002f5 02f9          .dw PFA_TOUPPER0 
0002f6 f040          .dw XT_DOLITERAL
0002f7 00df          .dw $df ; inverse of 0x20
0002f8 f22e          .dw XT_AND 
                 PFA_TOUPPER0:
0002f9 f020          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
0002fa ff07          .dw $ff07
0002fb 6f74
0002fc 6f6c
0002fd 6577
0002fe 0072          .db "tolower",0
0002ff 02e7          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000300 f000          .dw DO_COLON
                 PFA_TOLOWER:
000301 f0be          .dw XT_DUP
000302 f040          .dw XT_DOLITERAL
000303 0041          .dw 'A'
000304 f040          .dw XT_DOLITERAL
000305 005b          .dw 'Z'+1
000306 02df          .dw XT_WITHIN
000307 f039          .dw XT_DOCONDBRANCH
000308 030c          .dw PFA_TOLOWER0 
000309 f040          .dw XT_DOLITERAL
00030a 0020          .dw $20 
00030b f237          .dw XT_OR 
                 PFA_TOLOWER0:
00030c f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00030d ff03          .dw $ff03
00030e 6c68
00030f 0064          .db "hld",0
000310 02fa          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000311 f04e          .dw PFA_DOVARIABLE
                 PFA_HLD:
000312 0163          .dw ram_hld
                 
                 .dseg
000163           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
000313 ff04          .dw $ff04
000314 6f68
000315 646c          .db "hold"
000316 030d          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000317 f000          .dw DO_COLON
                 PFA_HOLD:
000318 0311          .dw XT_HLD
000319 f0be          .dw XT_DUP
00031a f086          .dw XT_FETCH
00031b f250          .dw XT_1MINUS
00031c f0be          .dw XT_DUP
00031d f105          .dw XT_TO_R
00031e f0d1          .dw XT_SWAP
00031f f08e          .dw XT_STORE
000320 f0fc          .dw XT_R_FROM
000321 f09a          .dw XT_CSTORE
000322 f020          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
000323 ff02          .dw $ff02
000324 233c          .db "<#"
000325 0313          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000326 f000          .dw DO_COLON
                 PFA_L_SHARP:
000327 0189          .dw XT_PAD
000328 0311          .dw XT_HLD
000329 f08e          .dw XT_STORE
00032a f020          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
00032b ff01          .dw $ff01
00032c 0023          .db "#",0
00032d 0323          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00032e f000          .dw DO_COLON
                 PFA_SHARP:
00032f 0155          .dw XT_BASE
000330 f086          .dw XT_FETCH
000331 03ad          .dw XT_UDSLASHMOD
000332 f0ee          .dw XT_ROT
000333 f040          .dw XT_DOLITERAL
000334 0009          .dw 9
000335 f0dc          .dw XT_OVER
000336 f131          .dw XT_LESS
000337 f039          .dw XT_DOCONDBRANCH
000338 033c          .dw PFA_SHARP1
000339 f040          .dw XT_DOLITERAL
00033a 0007          .dw 7
00033b f1b8          .dw XT_PLUS
                 PFA_SHARP1:
00033c f040          .dw XT_DOLITERAL
00033d 0030          .dw $30
00033e f1b8          .dw XT_PLUS
00033f 0317          .dw XT_HOLD
000340 f020          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
000341 ff02          .dw $ff02
000342 7323          .db "#s"
000343 032b          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000344 f000          .dw DO_COLON
                 PFA_SHARP_S:
000345 032e          .dw XT_SHARP
000346 016c          .dw XT_2DUP
000347 f237          .dw XT_OR
000348 f12a          .dw XT_EQUALZERO
000349 f039          .dw XT_DOCONDBRANCH
00034a 0345          .dw PFA_SHARP_S
00034b f020          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
00034c ff02          .dw $ff02
00034d 3e23          .db "#>"
00034e 0341          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00034f f000          .dw DO_COLON
                 PFA_SHARP_G:
000350 0175          .dw XT_2DROP
000351 0311          .dw XT_HLD
000352 f086          .dw XT_FETCH
000353 f0be          .dw XT_DUP
000354 0189          .dw XT_PAD
000355 f0d1          .dw XT_SWAP
000356 f1ae          .dw XT_MINUS
000357 f020          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
000358 ff04          .dw $ff04
000359 6973
00035a 6e67          .db "sign"
00035b 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00035c f000          .dw DO_COLON
                 PFA_SIGN:
00035d f13f          .dw XT_LESSZERO
00035e f039          .dw XT_DOCONDBRANCH
00035f 0363          .dw PFA_SIGN1
000360 f040          .dw XT_DOLITERAL
000361 002d          .dw $2d
000362 0317          .dw XT_HOLD
                 PFA_SIGN1:
000363 f020          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
000364 ff03          .dw $ff03
000365 2e64
000366 0072          .db "d.r",0
000367 0358          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000368 f000          .dw DO_COLON
                 PFA_DDOTR:
000369 f105          .dw XT_TO_R
00036a f0d1          .dw XT_SWAP
00036b f0dc          .dw XT_OVER
00036c 08ff          .dw XT_DABS
00036d 0326          .dw XT_L_SHARP
00036e 0344          .dw XT_SHARP_S
00036f f0ee          .dw XT_ROT
000370 035c          .dw XT_SIGN
000371 034f          .dw XT_SHARP_G
000372 f0fc          .dw XT_R_FROM
000373 f0dc          .dw XT_OVER
000374 f1ae          .dw XT_MINUS
000375 0470          .dw XT_SPACES
000376 047f          .dw XT_TYPE
000377 f020          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
000378 ff02          .dw $ff02
000379 722e          .db ".r"
00037a 0364          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00037b f000          .dw DO_COLON
                 PFA_DOTR:
00037c f105          .dw XT_TO_R
00037d f341          .dw XT_S2D
00037e f0fc          .dw XT_R_FROM
00037f 0368          .dw XT_DDOTR
000380 f020          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
000381 ff02          .dw $ff02
000382 2e64          .db "d."
000383 0378          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000384 f000          .dw DO_COLON
                 PFA_DDOT:
000385 f146          .dw XT_ZERO
000386 0368          .dw XT_DDOTR
000387 0467          .dw XT_SPACE
000388 f020          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
000389 ff01          .dw $ff01
00038a 002e          .db ".",0
00038b 0381          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00038c f000          .dw DO_COLON
                 PFA_DOT:
00038d f341          .dw XT_S2D
00038e 0384          .dw XT_DDOT
00038f f020          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
000390 ff03          .dw $ff03
000391 6475
000392 002e          .db "ud.",0
000393 0389          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000394 f000          .dw DO_COLON
                 PFA_UDDOT:
000395 f146          .dw XT_ZERO
000396 039d          .dw XT_UDDOTR
000397 0467          .dw XT_SPACE
000398 f020          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
000399 ff04          .dw $ff04
00039a 6475
00039b 722e          .db "ud.r"
00039c 0390          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00039d f000          .dw DO_COLON
                 PFA_UDDOTR:
00039e f105          .dw XT_TO_R
00039f 0326          .dw XT_L_SHARP
0003a0 0344          .dw XT_SHARP_S
0003a1 034f          .dw XT_SHARP_G
0003a2 f0fc          .dw XT_R_FROM
0003a3 f0dc          .dw XT_OVER
0003a4 f1ae          .dw XT_MINUS
0003a5 0470          .dw XT_SPACES
0003a6 047f          .dw XT_TYPE
0003a7 f020          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
0003a8 ff06          .dw $ff06
0003a9 6475
0003aa 6d2f
0003ab 646f          .db "ud/mod"
0003ac 0399          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0003ad f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
0003ae f105          .dw XT_TO_R
0003af f146          .dw XT_ZERO
0003b0 f10e          .dw XT_R_FETCH
0003b1 f1dd          .dw XT_UMSLASHMOD
0003b2 f0fc          .dw XT_R_FROM
0003b3 f0d1          .dw XT_SWAP
0003b4 f105          .dw XT_TO_R
0003b5 f1dd          .dw XT_UMSLASHMOD
0003b6 f0fc          .dw XT_R_FROM
0003b7 f020          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
0003b8 ff06          .dw $ff06 
0003b9 6964
0003ba 6967
0003bb 3f74          .db "digit?"
0003bc 03a8          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0003bd f000          .dw DO_COLON 
                 PFA_DIGITQ:
0003be 02ed          .dw XT_TOUPPER
0003bf f040          .dw XT_DOLITERAL 
0003c0 0030          .dw $30 
0003c1 f1ae          .dw XT_MINUS 
0003c2 f0be          .dw XT_DUP 
0003c3 f040          .dw XT_DOLITERAL
0003c4 0009          .dw $09 
0003c5 f163          .dw XT_UGREATER 
0003c6 f039          .dw XT_DOCONDBRANCH
0003c7 03d4          .dw PFA_DIGITQ0 
0003c8 f040          .dw XT_DOLITERAL
0003c9 0007          .dw $07 
0003ca f1ae          .dw XT_MINUS 
0003cb f0be          .dw XT_DUP 
0003cc f040          .dw XT_DOLITERAL
0003cd 0009          .dw $09 
0003ce 03e3          .dw XT_ULESSEQUAL
0003cf f039          .dw XT_DOCONDBRANCH
0003d0 03d4          .dw PFA_DIGITQ1 
0003d1 f0e6          .dw XT_DROP 
0003d2 f146          .dw XT_ZERO
0003d3 f020          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
0003d4 f0be          .dw XT_DUP 
0003d5 0155          .dw XT_BASE 
0003d6 f086          .dw XT_FETCH 
0003d7 03eb          .dw XT_UGREATEREQUAL
0003d8 f039          .dw XT_DOCONDBRANCH
0003d9 03dd          .dw PFA_DIGITQ2 
0003da f0e6          .dw XT_DROP 
0003db f146          .dw XT_ZERO
0003dc f020          .dw XT_EXIT 
                 PFA_DIGITQ2:
0003dd f14f          .dw XT_TRUE
0003de f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
0003df ff03          .dw $ff03 
0003e0 3c75
0003e1 003d          .db "u<=",0
0003e2 03b8          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
0003e3 f000          .dw DO_COLON 
                 PFA_ULESSEQUAL:
0003e4 f163          .dw XT_UGREATER 
0003e5 f218          .dw XT_INVERT 
0003e6 f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
0003e7 ff03          .dw $ff03 
0003e8 3e75
0003e9 003d          .db "u>=",0
0003ea 03df          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
0003eb f000          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
0003ec f158          .dw XT_ULESS 
0003ed f218          .dw XT_INVERT 
0003ee f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003ef f000        .dw DO_COLON
                 PFA_DOSLITERAL:
0003f0 f0fc        .dw XT_R_FROM   ; ( -- addr )
0003f1 f0be        .dw XT_DUP      ; ( -- addr addr )
0003f2 f0be        .dw XT_DUP
0003f3 f3e5        .dw XT_FETCHI   ; ( -- addr addr n )
0003f4 f0d1        .dw XT_SWAP
0003f5 f24a        .dw XT_1PLUS
0003f6 f0d1        .dw XT_SWAP
0003f7 f0ee        .dw XT_ROT      ; ( -- addr' n addr )
0003f8 f0dc        .dw XT_OVER     ; ( -- addr' n addr n)
0003f9 f24a        .dw XT_1PLUS
0003fa f21f        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003fb f1b8        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003fc f24a        .dw XT_1PLUS
0003fd f105        .dw XT_TO_R     ; ( -- )
0003fe f020        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003ff ff02        .dw $ff02
000400 2c73        .db "s",$2c
000401 03e7        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000402 f000          .dw DO_COLON
                 PFA_SCOMMA:
000403 f0be          .dw XT_DUP
000404 0406          .dw XT_DOSCOMMA
000405 f020          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
000406 f000          .dw DO_COLON
                 PFA_DOSCOMMA:
000407 020a          .dw XT_COMMA
000408 f0be          .dw XT_DUP   ; ( --addr len len)
000409 f21f          .dw XT_2SLASH ; ( -- addr len len/2
00040a f0d1          .dw XT_SWAP   ; ( -- addr len/2 len
00040b f0dc          .dw XT_OVER   ; ( -- addr len/2 len len/2
00040c f226          .dw XT_2STAR  ; ( -- addr len/2 len len'
00040d f1ae          .dw XT_MINUS  ; ( -- addr len/2 rem
00040e f105          .dw XT_TO_R
00040f f146          .dw XT_ZERO
000410 f2bf          .dw XT_DOQDO
000411 0418          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
000412 f0be          .dw XT_DUP         ; ( -- addr addr )
000413 f086          .dw XT_FETCH       ; ( -- addr c1c2 )
000414 020a          .dw XT_COMMA       ; ( -- addr )
000415 0164          .dw XT_CELLPLUS    ; ( -- addr+cell )
000416 f2f0          .dw XT_DOLOOP
000417 0412          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000418 f0fc          .dw XT_R_FROM
000419 f16e          .dw XT_GREATERZERO
00041a f039          .dw XT_DOCONDBRANCH
00041b 041f          .dw PFA_SCOMMA3
00041c f0be            .dw XT_DUP     ; well, tricky
00041d f0a5            .dw XT_CFETCH
00041e 020a            .dw XT_COMMA
                 PFA_SCOMMA3:
00041f f0e6          .dw XT_DROP        ; ( -- )
000420 f020          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000421 ff05          .dw $ff05
000422 7469
000423 7079
000424 0065          .db "itype",0
000425 03ff          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000426 f000          .dw DO_COLON
                 PFA_ITYPE:
000427 f0be          .dw XT_DUP    ; ( --addr len len)
000428 f21f          .dw XT_2SLASH ; ( -- addr len len/2
000429 f0d1          .dw XT_SWAP   ; ( -- addr len/2 len
00042a f0dc          .dw XT_OVER   ; ( -- addr len/2 len len/2
00042b f226          .dw XT_2STAR  ; ( -- addr len/2 len len'
00042c f1ae          .dw XT_MINUS  ; ( -- addr len/2 rem
00042d f105          .dw XT_TO_R
00042e f146          .dw XT_ZERO
00042f f2bf          .dw XT_DOQDO
000430 0439          .dw PFA_ITYPE2
                 PFA_ITYPE1:
000431 f0be          .dw XT_DUP         ; ( -- addr addr )
000432 f3e5          .dw XT_FETCHI      ; ( -- addr c1c2 )
000433 f0be          .dw XT_DUP
000434 0446          .dw XT_LOWEMIT
000435 0442          .dw XT_HIEMIT
000436 f24a          .dw XT_1PLUS    ; ( -- addr+cell )
000437 f2f0          .dw XT_DOLOOP
000438 0431          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000439 f0fc          .dw XT_R_FROM
00043a f16e          .dw XT_GREATERZERO
00043b f039          .dw XT_DOCONDBRANCH
00043c 0440          .dw PFA_ITYPE3
00043d f0be            .dw XT_DUP     ; make sure the drop below has always something to do
00043e f3e5            .dw XT_FETCHI
00043f 0446            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000440 f0e6          .dw XT_DROP
000441 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000442 f000          .dw DO_COLON
                 PFA_HIEMIT:
000443 f326          .dw XT_BYTESWAP
000444 0446          .dw XT_LOWEMIT
000445 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000446 f000          .dw DO_COLON
                 PFA_LOWEMIT:
000447 f040          .dw XT_DOLITERAL
000448 00ff          .dw $00ff
000449 f22e          .dw XT_AND
00044a 0193          .dw XT_EMIT
00044b f020          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00044c ff06          .dw $ff06
00044d 6369
00044e 756f
00044f 746e          .db "icount"
000450 0421          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000451 f000          .dw DO_COLON
                 PFA_ICOUNT:
000452 f0be          .dw XT_DUP
000453 f24a          .dw XT_1PLUS
000454 f0d1          .dw XT_SWAP
000455 f3e5          .dw XT_FETCHI
000456 f020          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
000457 ff02          .dw $ff02
000458 7263          .db "cr"
000459 044c          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00045a f000          .dw DO_COLON
                 PFA_CR:
00045b f040          .dw XT_DOLITERAL
00045c 000d          .dw 13
00045d 0193          .dw XT_EMIT
00045e f040          .dw XT_DOLITERAL
00045f 000a          .dw 10
000460 0193          .dw XT_EMIT
000461 f020          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
000462 ff05          .dw $ff05
000463 7073
000464 6361
000465 0065          .db "space",0
000466 0457          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000467 f000          .dw DO_COLON
                 PFA_SPACE:
000468 023f          .dw XT_BL
000469 0193          .dw XT_EMIT
00046a f020          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
00046b ff06          .dw $ff06
00046c 7073
00046d 6361
00046e 7365          .db "spaces"
00046f 0462          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000470 f000          .dw DO_COLON
                 PFA_SPACES:
000471 f0be          .dw XT_DUP
000472 f16e          .dw XT_GREATERZERO
000473 f22e          .dw XT_AND
000474 f146          .dw XT_ZERO
000475 f2bf          .dw XT_DOQDO
000476 047a          .dw PFA_SPACES2
                 PFA_SPACES1:
000477 0467          .dw XT_SPACE
000478 f2f0          .dw XT_DOLOOP
000479 0477          .dw PFA_SPACES1
                 PFA_SPACES2:
00047a f020          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
00047b ff04          .dw $ff04
00047c 7974
00047d 6570          .db "type"
00047e 046b          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00047f f000          .dw DO_COLON
                 PFA_TYPE:
000480 f0dc          .dw XT_OVER
000481 f1b8          .dw XT_PLUS
000482 f0d1          .dW XT_SWAP
000483 f2bf          .dw XT_DOQDO
000484 048a          .dw PFA_TYPE2
                 PFA_TYPE1:
000485 f2d5          .dw XT_I
000486 f0a5          .dw XT_CFETCH
000487 0193          .dw XT_EMIT
000488 f2f0          .dw XT_DOLOOP
000489 0485          .dw PFA_TYPE1
                 PFA_TYPE2:
00048a f020          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 VE_TICK:
00048b ff01          .dw $ff01
00048c 0027          .db "'",0
00048d 047b          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00048e f000          .dw DO_COLON
                 PFA_TICK:
00048f 064b          .dw XT_PARSENAME
000490 0668          .dw XT_FINDNAME
000491 f12a          .dw XT_EQUALZERO
000492 f039          .dw XT_DOCONDBRANCH
000493 0497          .dw PFA_TICK1
000494 f040          .dw XT_DOLITERAL
000495 fff3          .dw -13
000496 04bb          .dw XT_THROW
                 PFA_TICK1:
000497 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
000498 ff07          .dw $ff07
000499 6168
00049a 646e
00049b 656c
00049c 0072          .db "handler",0
00049d 048b          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00049e f061          .dw PFA_DOUSER
                 PFA_HANDLER:
00049f 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
0004a0 ff05          .dw $ff05
0004a1 6163
0004a2 6374
0004a3 0068          .db "catch",0
0004a4 0498          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
0004a5 f000          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
0004a6 f29c          .dw XT_SP_FETCH
0004a7 f105          .dw XT_TO_R
                     ; handler @ >r
0004a8 049e          .dw XT_HANDLER
0004a9 f086          .dw XT_FETCH
0004aa f105          .dw XT_TO_R
                     ; rp@ handler !
0004ab f285          .dw XT_RP_FETCH
0004ac 049e          .dw XT_HANDLER
0004ad f08e          .dw XT_STORE
0004ae f02a          .dw XT_EXECUTE
                     ; r> handler !
0004af f0fc          .dw XT_R_FROM
0004b0 049e          .dw XT_HANDLER
0004b1 f08e          .dw XT_STORE
0004b2 f0fc          .dw XT_R_FROM
0004b3 f0e6          .dw XT_DROP
0004b4 f146          .dw XT_ZERO
0004b5 f020          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
0004b6 ff05          .dw $ff05
0004b7 6874
0004b8 6f72
0004b9 0077          .db "throw",0
0004ba 04a0          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
0004bb f000          .dw DO_COLON
                 PFA_THROW:
0004bc f0be          .dw XT_DUP
0004bd f12a          .dw XT_EQUALZERO
0004be f039          .dw XT_DOCONDBRANCH
0004bf 04c2          .dw PFA_THROW1
0004c0 f0e6      	.dw XT_DROP
0004c1 f020      	.dw XT_EXIT
                 PFA_THROW1:
0004c2 049e          .dw XT_HANDLER
0004c3 f086          .dw XT_FETCH
0004c4 f28f          .dw XT_RP_STORE
0004c5 f0fc          .dw XT_R_FROM
0004c6 049e          .dw XT_HANDLER
0004c7 f08e          .dw XT_STORE
0004c8 f0fc          .dw XT_R_FROM
0004c9 f0d1          .dw XT_SWAP
0004ca f105          .dw XT_TO_R
0004cb f2a5          .dw XT_SP_STORE
0004cc f0e6          .dw XT_DROP
0004cd f0fc          .dw XT_R_FROM    
0004ce f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
0004cf ff05          .dw $ff05
0004d0 7363
0004d1 696b
0004d2 0070          .db "cskip",0
0004d3 04b6          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
0004d4 f000          .dw DO_COLON
                 PFA_CSKIP:
0004d5 f105          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0004d6 f0be          .dw XT_DUP            ; ( -- addr' n' n' )
0004d7 f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0004d8 04e4          .dw PFA_CSKIP2
0004d9 f0dc          .dw XT_OVER           ; ( -- addr' n' addr' )
0004da f0a5          .dw XT_CFETCH         ; ( -- addr' n' c' )
0004db f10e          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0004dc f123          .dw XT_EQUAL          ; ( -- addr' n' f )
0004dd f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0004de 04e4          .dw PFA_CSKIP2
0004df f040          .dw XT_DOLITERAL
0004e0 0001          .dw 1
0004e1 063a          .dw XT_SLASHSTRING
0004e2 f02f          .dw XT_DOBRANCH
0004e3 04d6          .dw PFA_CSKIP1
                 PFA_CSKIP2:
0004e4 f0fc          .dw XT_R_FROM
0004e5 f0e6          .dw XT_DROP           ; ( -- addr2 n2)
0004e6 f020          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
0004e7 ff06          .dw $ff06
0004e8 6361
0004e9 6563
0004ea 7470          .db "accept"
0004eb 04cf          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0004ec f000          .dw DO_COLON
                 PFA_ACCEPT:
0004ed f0be          .dw XT_DUP        ; ( -- addr n1 n1)
0004ee f105          .dw XT_TO_R
0004ef f105          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
0004f0 01a4          .dw XT_KEY        ; ( -- addr k )
0004f1 f0be          .dw XT_DUP        ; ( -- addr k k )
0004f2 f040          .dw XT_DOLITERAL
0004f3 000a          .dw 10
0004f4 f119          .dw XT_NOTEQUAL
0004f5 f039          .dw XT_DOCONDBRANCH
0004f6 052a          .dw PFA_ACCEPT2
0004f7 f0be          .dw XT_DUP
0004f8 f040          .dw XT_DOLITERAL
0004f9 000d          .dw 13
0004fa f119          .dw XT_NOTEQUAL
0004fb f039          .dw XT_DOCONDBRANCH
0004fc 052a          .dw PFA_ACCEPT2
                     ; check backspace
0004fd f0be          .dw XT_DUP
0004fe f040          .dw XT_DOLITERAL
0004ff 0008          .dw 8
000500 f123          .dw XT_EQUAL
000501 f039          .dw XT_DOCONDBRANCH
000502 0516          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
000503 f0fc          .dw XT_R_FROM             ; ( -- addr k n1 )
000504 f10e          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
000505 f0dc          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
000506 f105          .dw XT_TO_R
000507 f123          .dw XT_EQUAL              ; ( -- addr k f )
000508 f039          .dw XT_DOCONDBRANCH
000509 050d          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
00050a f0e6          .dw XT_DROP               ; ( -- addr )
00050b f02f          .dw XT_DOBRANCH
00050c 04f0          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
00050d f0be          .dw XT_DUP                ; ( -- addr k k )
00050e 0193          .dw XT_EMIT               ; ( -- addr k )
00050f 0467          .dw XT_SPACE              ; ( -- addr k )
000510 0193          .dw XT_EMIT               ; ( -- addr )
000511 f250          .dw XT_1MINUS             ; ( -- addr--)
000512 f0fc          .dw XT_R_FROM
000513 f24a          .dw XT_1PLUS
000514 f02f          .dw XT_DOBRANCH
000515 0524          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
000516 f0be          .dw XT_DUP            ; ( -- addr k k )
000517 023f          .dw XT_BL
000518 f131          .dw XT_LESS
000519 f039          .dw XT_DOCONDBRANCH
00051a 051d          .dw PFA_ACCEPT6
00051b f0e6          .dw XT_DROP
00051c 023f          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
00051d f0be          .dw XT_DUP            ; ( -- addr k k)
00051e 0193          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
00051f f0dc          .dw XT_OVER           ; ( -- addr k addr
000520 f09a          .dw XT_CSTORE         ; ( -- addr)
000521 f24a          .dw XT_1PLUS          ; ( -- addr++)
000522 f0fc          .dw XT_R_FROM         ; ( -- addr n1)
000523 f250          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
000524 f0be          .dw XT_DUP
000525 f105          .dw XT_TO_R
000526 f12a          .dw XT_EQUALZERO
000527 f039          .dw XT_DOCONDBRANCH
000528 04f0          .dw PFA_ACCEPT1
000529 f0be          .dw XT_DUP
                 PFA_ACCEPT2:
00052a 0175          .dw XT_2DROP
00052b f0fc          .dw XT_R_FROM
00052c f0fc          .dw XT_R_FROM
00052d f0d1          .dw XT_SWAP
00052e f1ae          .dw XT_MINUS
00052f 045a          .dw XT_CR
000530 f020          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
000531 ff06          .dw $ff06
000532 6572
000533 6966
000534 6c6c          .db "refill"
000535 04e7          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000536 082e          .dw PFA_DODEFER
                 PFA_REFILL:
000537 001a          .dw USER_REFILL
000538 0806          .dw XT_UDEFERFETCH
000539 080d          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
00053a ff04          .dw $ff04
00053b 6863
00053c 7261          .db "char"
00053d 0531          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00053e f000          .dw DO_COLON
                 PFA_CHAR:
00053f 064b          .dw XT_PARSENAME
000540 f0e6          .dw XT_DROP
000541 f0a5          .dw XT_CFETCH
000542 f020          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
000543 ff06          .dw $ff06
000544 756e
000545 626d
000546 7265          .db "number"
000547 053a          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000548 f000          .dw DO_COLON
                 PFA_NUMBER:
000549 0155          .dw XT_BASE
00054a f086          .dw XT_FETCH
00054b f105          .dw XT_TO_R
00054c 05b9          .dw XT_NUMBERSIGN
00054d f105          .dw XT_TO_R
00054e 0585          .dw XT_PRAEFIX
00054f 05b9          .dw XT_NUMBERSIGN
000550 f0fc          .dw XT_R_FROM
000551 f237          .dw XT_OR
000552 f105          .dw XT_TO_R
000553 f105          .dw XT_TO_R
000554 f105          .dw XT_TO_R
000555 f146          .dw XT_ZERO       ; starting value
000556 f146          .dw XT_ZERO
000557 f0fc          .dw XT_R_FROM
000558 f0fc          .dw XT_R_FROM
000559 05d8          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00055a f0c6          .dw XT_QDUP
00055b f039              .dw XT_DOCONDBRANCH
00055c 0579      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
00055d f040          .dw XT_DOLITERAL
00055e 0001          .dw 1
00055f f123          .dw XT_EQUAL
000560 f039          .dw XT_DOCONDBRANCH
000561 0570          .dw PFA_NUMBER2
                 	; excatly one character is left
000562 f0a5      	.dw XT_CFETCH
000563 f040      	.dw XT_DOLITERAL
000564 002e      	.dw $2e ; .
000565 f123      	.dw XT_EQUAL
000566 f039      	.dw XT_DOCONDBRANCH
000567 0570      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
000568 f0fc      	.dw XT_R_FROM
000569 f039              .dw XT_DOCONDBRANCH
00056a 056c      	.dw PFA_NUMBER3
00056b 090c              .dw XT_DNEGATE
                 PFA_NUMBER3:
00056c f040      	.dw XT_DOLITERAL
00056d 0002      	.dw 2
00056e f02f      	.dw XT_DOBRANCH
00056f 0580      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
000570 0175      	.dw XT_2DROP
000571 f0e6      	.dw XT_DROP
000572 f0fc      	.dw XT_R_FROM
000573 f0e6      	.dw XT_DROP
000574 f0fc              .dw XT_R_FROM
000575 0155              .dw XT_BASE
000576 f08e              .dw XT_STORE
000577 f146      	.dw XT_ZERO
000578 f020      	.dw XT_EXIT
                 PFA_NUMBER1:
000579 0175          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00057a f0fc          .dw XT_R_FROM
00057b f039          .dw XT_DOCONDBRANCH
00057c 057e          .dw PFA_NUMBER4
00057d 02a2          .dw XT_NEGATE
                 PFA_NUMBER4:
00057e f040          .dw XT_DOLITERAL
00057f 0001          .dw 1
                 PFA_NUMBER5:
000580 f0fc          .dw XT_R_FROM
000581 0155          .dw XT_BASE
000582 f08e          .dw XT_STORE
000583 f14f          .dw XT_TRUE
000584 f020          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
000585 f000          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
000586 f0dc          .dw XT_OVER 
000587 f0a5          .dw XT_CFETCH 
000588 f040          .dw XT_DOLITERAL
000589 0029          .dw $29 
00058a f138          .dw XT_GREATER 
00058b f039          .dw XT_DOCONDBRANCH
00058c 058e          .dw PFA_PRAEFIX0 
00058d f020          .dw XT_EXIT 
                 PFA_PRAEFIX0:
00058e f0dc          .dw XT_OVER 
00058f f0a5          .dw XT_CFETCH 
000590 0595          .dw XT_SETBASE
000591 f040          .dw XT_DOLITERAL
000592 0001          .dw $1 
000593 063a          .dw XT_SLASHSTRING 
000594 f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
000595 f000          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
000596 f0be          .dw XT_DUP 
000597 f040          .dw XT_DOLITERAL
000598 0024          .dw '$' 
000599 f123          .dw XT_EQUAL 
00059a f039          .dw XT_DOCONDBRANCH
00059b 059f          .dw PFA_SETBASE0 
00059c f0e6          .dw XT_DROP 
00059d 0236          .dw XT_HEX 
00059e f020          .dw XT_EXIT 
                 PFA_SETBASE0:
00059f f0be          .dw XT_DUP 
0005a0 f040          .dw XT_DOLITERAL
0005a1 0025          .dw '%' 
0005a2 f123          .dw XT_EQUAL 
0005a3 f039          .dw XT_DOCONDBRANCH
0005a4 05a8          .dw PFA_SETBASE1 
0005a5 f0e6          .dw XT_DROP 
0005a6 0220          .dw XT_BIN
0005a7 f020          .dw XT_EXIT 
                 PFA_SETBASE1:
0005a8 f0be          .dw XT_DUP 
0005a9 f040          .dw XT_DOLITERAL
0005aa 0026          .dw '&'
0005ab f123          .dw XT_EQUAL 
0005ac f039          .dw XT_DOCONDBRANCH
0005ad 05b1          .dw PFA_SETBASE2 
0005ae f0e6          .dw XT_DROP
0005af 022c          .dw XT_DECIMAL 
0005b0 f020          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
0005b1 f040          .dw XT_DOLITERAL
0005b2 0023          .dw '#'
0005b3 f123          .dw XT_EQUAL 
0005b4 f039          .dw XT_DOCONDBRANCH
0005b5 05b8          .dw PFA_SETBASE3 
0005b6 022c          .dw XT_DECIMAL 
0005b7 f020          .dw XT_EXIT 
                 PFA_SETBASE3:
0005b8 f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
0005b9 f000          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
0005ba f0dc          .dw XT_OVER
0005bb f0a5          .dw XT_CFETCH
0005bc f040          .dw XT_DOLITERAL
0005bd 002b          .dw '+'
0005be f123          .dw XT_EQUAL
0005bf f039          .dw XT_DOCONDBRANCH
0005c0 05c4          .dw PFA_NUMBERSIGN_MINUS
0005c1 f040            .dw XT_DOLITERAL
0005c2 0001            .dw 1
0005c3 063a            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
0005c4 f0dc          .dw XT_OVER    ; ( -- addr len addr )
0005c5 f0a5          .dw XT_CFETCH
0005c6 f040          .dw XT_DOLITERAL
0005c7 002d          .dw '-'
0005c8 f123          .dw XT_EQUAL  ; ( -- addr len flag )
0005c9 f0be          .dw XT_DUP
0005ca f105          .dw XT_TO_R
0005cb f039          .dw XT_DOCONDBRANCH
0005cc 05d0          .dw PFA_NUMBERSIGN_PLUS
0005cd f040          .dw XT_DOLITERAL      ; skip sign character
0005ce 0001          .dw 1
0005cf 063a          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
0005d0 f0fc          .dw XT_R_FROM
0005d1 f020          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
0005d2 ff07          .dw $ff07
0005d3 6e3e
0005d4 6d75
0005d5 6562
0005d6 0072          .db ">number",0
0005d7 0543          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0005d8 f000          .dw DO_COLON
                 PFA_TO_NUMBER:
0005d9 f0be          .dw XT_DUP
0005da f039          .dw XT_DOCONDBRANCH
0005db 05f6          .dw PFA_TO_NUMBER1
0005dc f0dc              .dw XT_OVER
0005dd f0a5              .dw XT_CFETCH
0005de 03bd              .dw XT_DIGITQ
0005df f12a              .dw XT_EQUALZERO
0005e0 f039              .dw XT_DOCONDBRANCH
0005e1 05e3              .dw PFA_TO_NUMBER2
0005e2 f020                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
0005e3 f105              .dw XT_TO_R
0005e4 0931              .dw XT_2SWAP
0005e5 f0fc              .dw XT_R_FROM
0005e6 f0d1              .dw XT_SWAP
0005e7 0155              .dw XT_BASE
0005e8 f086              .dw XT_FETCH
0005e9 f1fb              .dw XT_UMSTAR
0005ea f0e6              .dw XT_DROP
0005eb f0ee              .dw XT_ROT
0005ec 0155              .dw XT_BASE
0005ed f086              .dw XT_FETCH
0005ee f1fb              .dw XT_UMSTAR
0005ef 099b              .dw XT_DPLUS
0005f0 0931              .dw XT_2SWAP
0005f1 f040              .dw XT_DOLITERAL
0005f2 0001              .dw 1
0005f3 063a              .dw XT_SLASHSTRING
0005f4 f02f          .dw XT_DOBRANCH
0005f5 05d9          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
0005f6 f020          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
0005f7 ff05          .dw $ff05
0005f8 6170
0005f9 7372
0005fa 0065          .db "parse",0
0005fb 05d2          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0005fc f000          .dw DO_COLON
                 PFA_PARSE:
0005fd f105          .dw XT_TO_R     ; ( -- )
0005fe 0630          .dw XT_SOURCE   ; ( -- addr len)
0005ff 017d          .dw XT_G_IN     ; ( -- addr len >in)
000600 f086          .dw XT_FETCH
000601 063a          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000602 f0fc          .dw XT_R_FROM      ; ( -- addr' len' c)
000603 0611          .dw XT_CSCAN       ; ( -- addr' len'')
000604 f0be          .dw XT_DUP         ; ( -- addr' len'' len'')
000605 f24a          .dw XT_1PLUS
000606 017d          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
000607 f274          .dw XT_PLUSSTORE   ; ( -- addr' len')
000608 f040          .dw XT_DOLITERAL
000609 0001          .dw 1
00060a 063a          .dw XT_SLASHSTRING
00060b f020          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
00060c ff05          .dw $ff05
00060d 7363
00060e 6163
00060f 006e          .db "cscan",0
000610 05f7          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000611 f000          .dw DO_COLON
                 PFA_CSCAN:
000612 f0d1          .dw XT_SWAP         ; ( -- addr1 c n1 )
000613 f0be          .dw XT_DUP          ; ( -- addr1 c n1 n1)
000614 f105          .dw XT_TO_R         ; ( -- addr1 c n1)
000615 f146          .dw XT_ZERO         ; ( -- addr1 c n1 0)
000616 f2bf          .dw XT_DOQDO        ; ( -- addr1 c)
000617 0628          .dw PFA_CSCAN3
                 PFA_CSCAN1:
000618 f0dc          .dw XT_OVER         ; ( -- addr1 c addr1 )
000619 f2d5          .dw XT_I            ; ( -- addr1 c addr1 i)
00061a f1b8          .dw XT_PLUS         ; ( -- addr1 c addr')
00061b f0a5          .dw XT_CFETCH       ; ( -- addr1 c c')
00061c f0dc          .dw XT_OVER         ; ( -- addr1 c c' c)
00061d f123          .dw XT_EQUAL        ; ( -- addr1 c f)
00061e f039          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
00061f 0626          .dw PFA_CSCAN2
000620 f0e6          .dw XT_DROP         ; ( -- addr1 )
000621 f2d5          .dw XT_I            ; ( -- addr1 n2)
000622 f2ff          .dw XT_UNLOOP       ; ( -- addr1 n2)
000623 f0fc          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
000624 f0e6          .dw XT_DROP         ; ( -- addr1 n2)
000625 f020          .dw XT_EXIT
                 PFA_CSCAN2:
000626 f2f0          .dw XT_DOLOOP
000627 0618          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
000628 f0e6          .dw XT_DROP         ; ( -- addr1)
000629 f0fc          .dw XT_R_FROM       ; ( -- addr1 n1)
00062a f020          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
00062b ff06          .dw $FF06
00062c 6f73
00062d 7275
00062e 6563          .db "source"
00062f 060c          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000630 082e          .dw PFA_DODEFER
                 PFA_SOURCE:
000631 0016          .dw USER_SOURCE
000632 0806          .dw XT_UDEFERFETCH
000633 080d          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
000634 ff07          .dw $ff07
000635 732f
000636 7274
000637 6e69
000638 0067          .db "/string",0
000639 062b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00063a f000          .dw DO_COLON
                 PFA_SLASHSTRING:
00063b f0dc          .dw XT_OVER    ; ( -- addr1 u1 n u1)
00063c 02c6          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
00063d f0ee          .dw XT_ROT     ; ( -- u1 n addr1 )
00063e f0dc          .dw XT_OVER    ; ( -- u1 n addr1 n)
00063f f1b8          .dw XT_PLUS    ; ( -- u1 n addr2 )
000640 f0ee          .dw XT_ROT     ; ( -- n addr2 u1)
000641 f0ee          .dw XT_ROT     ; ( -- addr2 u1 n)
000642 f1ae          .dw XT_MINUS   ; ( -- addr2 u2)
000643 f020          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
000644 ff0a          .dw $FF0A 
000645 6170
000646 7372
000647 2d65
000648 616e
000649 656d          .db "parse-name"
00064a 0634          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00064b f000          .dw DO_COLON 
                 PFA_PARSENAME:
00064c 023f          .dw XT_BL
00064d 064f          .dw XT_SKIPSCANCHAR
00064e f020          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00064f f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
000650 f105          .dw XT_TO_R
000651 0630          .dw XT_SOURCE 
000652 017d          .dw XT_G_IN 
000653 f086          .dw XT_FETCH 
000654 063a          .dw XT_SLASHSTRING 
                 
000655 f10e          .dw XT_R_FETCH
000656 04d4          .dw XT_CSKIP
000657 f0fc          .dw XT_R_FROM
000658 0611          .dw XT_CSCAN
                 
                     ; adjust >IN
000659 016c          .dw XT_2DUP
00065a f1b8          .dw XT_PLUS
00065b 0630          .dw XT_SOURCE 
00065c f0e6          .dw XT_DROP
00065d f1ae          .dw XT_MINUS
00065e 017d          .dw XT_G_IN
00065f f08e          .dw XT_STORE
000660 f020          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
000661 ff09          .dw $ff09
000662 6966
000663 646e
000664 6e2d
000665 6d61
000666 0065          .db "find-name",0
000667 0644          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000668 f000          .dw DO_COLON
                 PFA_FINDNAME:
000669 f040          .dw XT_DOLITERAL
00066a 0014          .dw EE_ORDERLISTLEN
00066b f373          .dw XT_FETCHE
00066c f146          .dw XT_ZERO
00066d f2bf          .dw XT_DOQDO
00066e 0683          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
00066f 016c          .dw XT_2DUP
000670 f040          .dw XT_DOLITERAL
000671 0016          .dw EE_ORDERLIST
000672 f2d5          .dw XT_I
000673 015c          .dw XT_CELLS
000674 f1b8          .dw XT_PLUS  
000675 f373          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
000676 0842          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
000677 f0c6          .dw XT_QDUP
000678 f039          .dw XT_DOCONDBRANCH
000679 0681          .dw PFA_FINDNAME4
00067a f105      	.dw XT_TO_R
00067b f105      	.dw XT_TO_R
00067c 0175      	.dw XT_2DROP
00067d f0fc      	.dw XT_R_FROM
00067e f0fc      	.dw XT_R_FROM
00067f f2ff      	.dw XT_UNLOOP
000680 f020      	.dw XT_EXIT
                 PFA_FINDNAME4:
000681 f2f0          .dw XT_DOLOOP
000682 066f          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
000683 0175          .dw XT_2DROP
000684 f146          .dw XT_ZERO
000685 f020          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
000686 ff04          .dw $ff04
000687 7571
000688 7469          .db "quit"
000689 0661          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00068a f000          .dw DO_COLON
                 PFA_QUIT:
00068b 0702          .dw XT_SP0
00068c f2a5          .dw XT_SP_STORE
00068d 0717          .dw XT_RP0
00068e f28f          .dw XT_RP_STORE
00068f 0b8f          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000690 014f          .dw XT_STATE
000691 f086          .dw XT_FETCH
000692 f12a          .dw XT_EQUALZERO
000693 f039          .dw XT_DOCONDBRANCH
000694 0696          .dw PFA_QUIT4
000695 06ac          .dw XT_PROMPTRDY
                 PFA_QUIT4:
000696 0536          .dw XT_REFILL
000697 f039          .dw XT_DOCONDBRANCH
000698 0690          .dw PFA_QUIT2
000699 f040          .dw XT_DOLITERAL
00069a 0730          .dw XT_INTERPRET
00069b 04a5          .dw XT_CATCH
00069c f0c6          .dw XT_QDUP
00069d f039          .dw XT_DOCONDBRANCH
00069e 06a8          .dw PFA_QUIT3
00069f f0be      	.dw XT_DUP
0006a0 f040      	.dw XT_DOLITERAL
0006a1 fffe      	.dw -2
0006a2 f131      	.dw XT_LESS
0006a3 f039      	.dw XT_DOCONDBRANCH
0006a4 06a6      	.dw PFA_QUIT5
0006a5 06ba      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
0006a6 f02f      	.dw XT_DOBRANCH
0006a7 068b      	.dw PFA_QUIT
                 PFA_QUIT3:
0006a8 06b3          .dw XT_PROMPTOK
0006a9 f02f          .dw XT_DOBRANCH
0006aa 0690          .dw PFA_QUIT2
0006ab f020          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
0006ac f000          .dw DO_COLON
                 PFA_PROMPTRDY:
0006ad 045a          .dw XT_CR
0006ae 03ef          .dw XT_DOSLITERAL
0006af 0002          .dw 2
0006b0 203e          .db "> "
0006b1 0426          .dw XT_ITYPE
0006b2 f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
0006b3 f000          .dw DO_COLON
                 PFA_PROMPTOK:
0006b4 03ef          .dw XT_DOSLITERAL
0006b5 0003          .dw 3
0006b6 6f20
0006b7 006b          .db " ok",0
0006b8 0426          .dw XT_ITYPE
0006b9 f020          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
0006ba f000          .dw DO_COLON
                 PFA_PROMPTERROR:
0006bb 03ef      	.dw XT_DOSLITERAL
0006bc 0004      	.dw 4
0006bd 3f20
0006be 203f      	.db  " ?? "
0006bf 0426          .dw XT_ITYPE
0006c0 0155      	.dw XT_BASE
0006c1 f086      	.dw XT_FETCH
0006c2 f105      	.dw XT_TO_R
0006c3 022c      	.dw XT_DECIMAL
0006c4 038c      	.dw XT_DOT
0006c5 017d      	.dw XT_G_IN
0006c6 f086      	.dw XT_FETCH
0006c7 038c      	.dw XT_DOT
0006c8 f0fc      	.dw XT_R_FROM
0006c9 0155      	.dw XT_BASE
0006ca f08e      	.dw XT_STORE
0006cb f020          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
0006cc ff05          .dw $ff05
0006cd 6170
0006ce 7375
0006cf 0065          .db "pause",0
0006d0 0686          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
0006d1 082e          .dw PFA_DODEFER
                 PFA_PAUSE:
0006d2 0165          .dw ram_pause
0006d3 07fc          .dw XT_RDEFERFETCH
0006d4 0801          .dw XT_RDEFERSTORE
                 
                 .dseg
000165           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
0006d5 ff04          .dw $ff04
0006d6 6f63
0006d7 646c          .db "cold"
0006d8 06cc          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
0006d9 06da          .dw PFA_COLD
                 PFA_COLD:
0006da b6a4          in_ r10, MCUSR
0006db 24bb          clr r11
0006dc 2422          clr zerol
0006dd 2433          clr zeroh
0006de be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000167           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
0006df e6e7          ldi zl, low(ram_user1)
0006e0 e0f1          ldi zh, high(ram_user1)
0006e1 012f          movw upl, zl
                     ; init return stack pointer
0006e2 ef0f          ldi temp0,low(rstackstart)
0006e3 bf0d          out_ SPL,temp0
0006e4 8304          std Z+4, temp0
0006e5 e410          ldi temp1,high(rstackstart)
0006e6 bf1e          out_ SPH,temp1
0006e7 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
0006e8 eacf          ldi yl,low(stackstart)
0006e9 83c6          std Z+6, yl
0006ea e4d0          ldi yh,high(stackstart)
0006eb 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
0006ec efa5          ldi XL, low(PFA_WARM)
0006ed e0b6          ldi XH, high(PFA_WARM)
                     ; its a far jump...
0006ee 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
0006f0 ff04          .dw $ff04
0006f1 6177
0006f2 6d72          .db "warm"
0006f3 06d5          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
0006f4 f000          .dw DO_COLON
                 PFA_WARM:
0006f5 0981          .dw XT_INITUSER
0006f6 f040          .dw XT_DOLITERAL
0006f7 07cb          .dw XT_NOOP
0006f8 f040          .dw XT_DOLITERAL
0006f9 06d1          .dw XT_PAUSE
0006fa 0819          .dw XT_DEFERSTORE
0006fb 0247          .dw XT_TURNKEY
0006fc 068a          .dw XT_QUIT
0006fd f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0006fe ff03          .dw $ff03
0006ff 7073
000700 0030          .db "sp0",0
000701 06f0          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000702 f07b          .dw PFA_DOVALUE1
                 PFA_SP0:
000703 0006          .dw USER_SP0
000704 070b          .dw XT_UVALUEFETCH
000705 070f          .dw XT_UVALUESTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000706 ff02          .dw $ff02
000707 7073          .db "sp"
000708 06fe          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000709 f061          .dw PFA_DOUSER
                 PFA_SP:
00070a 0008          .dw USER_SP
                 
                 XT_UVALUEFETCH:
00070b f000          .dw DO_COLON
                 PFA_UVALUEFETCH:
00070c f3e5          .dw XT_FETCHI
00070d f0ad          .dw XT_FETCHU
00070e f020          .dw XT_EXIT
                 
                 XT_UVALUESTORE:
00070f f000          .dw DO_COLON
                 PFA_UVALUESTORE:
000710 f3e5          .dw XT_FETCHI
000711 f0b5          .dw XT_STOREU
000712 f020          .dw XT_EXIT
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000713 ff03          .dw $ff03
000714 7072
000715 0030          .db "rp0",0
000716 0706          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000717 f000          .dw DO_COLON
                 PFA_RP0:
000718 071b          .dw XT_DORP0
000719 f086          .dw XT_FETCH
00071a f020          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00071b f061          .dw PFA_DOUSER
                 PFA_DORP0:
00071c 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
00071d ff05          .dw $ff05
00071e 6564
00071f 7470
000720 0068          .db "depth",0
000721 0713          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000722 f000          .dw DO_COLON
                 PFA_DEPTH:
000723 0702          .dw XT_SP0
000724 f29c          .dw XT_SP_FETCH
000725 f1ae          .dw XT_MINUS
000726 f21f          .dw XT_2SLASH
000727 f250          .dw XT_1MINUS
000728 f020          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
000729 ff09          .dw $ff09
00072a 6e69
00072b 6574
00072c 7072
00072d 6572
00072e 0074          .db "interpret",0
00072f 071d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000730 f000          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
000731 064b          .dw XT_PARSENAME ; ( -- addr len )
000732 f0c6          .dw XT_QDUP   ; ( -- addr len len )
000733 f16e          .dw XT_GREATERZERO
000734 f039          .dw XT_DOCONDBRANCH
000735 0754          .dw PFA_INTERPRET5
000736 f040          .dw XT_DOLITERAL
000737 0026          .dw EE_RECOGNIZERLISTLEN
000738 f373          .dw XT_FETCHE       ; ( addr len rec # -- )
000739 f146          .dw XT_ZERO
                 
00073a f2bf          .dw XT_DOQDO
00073b 0750          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
00073c 016c          .dw XT_2DUP ; ( -- addr len addr len  )
00073d f2d5          .dw XT_I    ; ( -- addr len addr len i )
00073e f0ee          .dw XT_ROT  ; ( -- addr len len i addr )
00073f f0ee          .dw XT_ROT  ; ( -- addr len i addr len )
000740 f105          .dw XT_TO_R
000741 f105          .dw XT_TO_R
                 
000742 015c          .dw XT_CELLS
000743 f040          .dw XT_DOLITERAL
000744 0028          .dw EE_RECOGNIZERLIST
000745 f1b8          .dw XT_PLUS
000746 f373          .dw XT_FETCHE
                 
000747 f02a          .dw XT_EXECUTE
000748 f0fc          .dw XT_R_FROM
000749 f0fc          .dw XT_R_FROM
00074a f0ee          .dw XT_ROT
00074b f039          .dw XT_DOCONDBRANCH
00074c 074e          .dw PFA_INTERPRET3
00074d 0adf            .dw XT_LEAVE
                 PFA_INTERPRET3:
00074e f2f0          .dw XT_DOLOOP
00074f 073c          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
000750 0175          .dw XT_2DROP
000751 07a1          .dw XT_QSTACK
000752 f02f          .dw XT_DOBRANCH
000753 0731          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
000754 f0e6          .dw xT_DROP
000755 f020          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
000756 ff0a          .dw $ff0a
000757 6572
000758 2d63
000759 6e69
00075a 6e74
00075b 6d75          .db "rec-intnum"
00075c 0729          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
00075d f000          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
00075e 0548          .dw XT_NUMBER 
00075f f039          .dw XT_DOCONDBRANCH 
000760 0772          .dw PFA_REC_NONUMBER
                 
000761 014f          .dw XT_STATE
000762 f086          .dw XT_FETCH
000763 f039          .dw XT_DOCONDBRANCH
000764 076f          .dw PFA_REC_NUMBER_DONE
000765 f040      	.dw XT_DOLITERAL
000766 0002      	.dw 2
000767 f123      	.dw XT_EQUAL
000768 f039      	.dw XT_DOCONDBRANCH
000769 076c      	.dw PFA_REC_NUMBER_SINGLE
00076a f0d1      	.dw XT_SWAP
00076b 0a46              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
00076c 0a46              .dw XT_LITERAL
00076d f02f              .dw XT_DOBRANCH
00076e 0770              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
00076f f0e6          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
000770 f14f          .dw XT_TRUE
000771 f020          .dw XT_EXIT
                 PFA_REC_NONUMBER:
000772 f146          .dw XT_ZERO
000773 f020          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
000774 ff08          .dw $ff08
000775 6572
000776 2d63
000777 6966
000778 646e          .db "rec-find"
000779 0756          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00077a f000          .dw DO_COLON
                 PFA_REC_FIND:
00077b 0668          .dw XT_FINDNAME
00077c f0be          .dw XT_DUP
00077d f039          .dw XT_DOCONDBRANCH 
00077e 078d          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
00077f f16e      	.dw XT_GREATERZERO
000780 f039      	.dw XT_DOCONDBRANCH
000781 0784      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
000782 f02f      	    .dw XT_DOBRANCH
000783 078b      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
000784 014f      	    .dw XT_STATE
000785 f086      	    .dw XT_FETCH
000786 f039      	    .dw XT_DOCONDBRANCH
000787 078b      	    .dw PFA_REC_FIND_EXECUTE
000788 020a      	    .dw XT_COMMA
000789 f02f      	    .dw XT_DOBRANCH
00078a 078c      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
00078b f02a          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
00078c f14f          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
00078d f020          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
00078e ff0c          .dw $ff0c
00078f 6572
000790 2d63
000791 6f6e
000792 6674
000793 756f
000794 646e          .db "rec-notfound"
000795 0774          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
000796 f000          .dw DO_COLON
                 PFA_REC_NOTFOUND:
000797 047f          .dw XT_TYPE
000798 f040          .dw XT_DOLITERAL
000799 fff3          .dw -13
00079a 04bb          .dw XT_THROW
00079b f020          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
00079c ff06          .dw $ff06
00079d 733f
00079e 6174
00079f 6b63          .db "?stack"
0007a0 078e          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
0007a1 f000          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
0007a2 0722          .dw XT_DEPTH
0007a3 f13f          .dw XT_LESSZERO
0007a4 f039          .dw XT_DOCONDBRANCH
0007a5 07a9          .dw PFA_QSTACK1
0007a6 f040            .dw XT_DOLITERAL
0007a7 fffc            .dw -4
0007a8 04bb            .dw XT_THROW
                 PFA_QSTACK1:
0007a9 f020          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
0007aa ff03          .dw $ff03
0007ab 6576
0007ac 0072          .db "ver",0
0007ad 079c          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
0007ae f000          .dw DO_COLON
                 PFA_VER:
0007af 0c63          .dw XT_ENV_FORTHNAME
0007b0 0426          .dw XT_ITYPE
0007b1 0467          .dw XT_SPACE
0007b2 0155          .dw XT_BASE
0007b3 f086          .dw XT_FETCH
0007b4 f105          .dw XT_TO_R
0007b5 022c          .dw XT_DECIMAL
                 
0007b6 0c71          .dw XT_ENV_FORTHVERSION
0007b7 f341          .dw XT_S2D
0007b8 0326          .dw XT_L_SHARP
0007b9 032e          .dw XT_SHARP
0007ba f040          .dw XT_DOLITERAL
0007bb 002e          .dw '.'
0007bc 0317          .dw XT_HOLD
0007bd 0344          .dw XT_SHARP_S
0007be 034f          .dw XT_SHARP_G
0007bf f0fc          .dw XT_R_FROM
0007c0 0155          .dw XT_BASE
0007c1 f08e          .dw XT_STORE
                 
0007c2 047f          .dw XT_TYPE
0007c3 0467          .dw XT_SPACE
0007c4 0c79          .dw XT_ENV_CPU
0007c5 0426          .dw XT_ITYPE
0007c6 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
0007c7 ff04          .dw $ff04
0007c8 6f6e
0007c9 706f          .db "noop"
0007ca 07aa          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
0007cb 07cc          .dw PFA_NOOP
                 PFA_NOOP:
0007cc 940c f004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
0007ce ff06          .dw $ff06
0007cf 6e75
0007d0 7375
0007d1 6465          .db "unused"
0007d2 07c7          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
0007d3 f000          .dw DO_COLON
                 PFA_UNUSED:
0007d4 0702          .dw XT_SP0
0007d5 01c3          .dw XT_HERE
0007d6 f1ae          .dw XT_MINUS
0007d7 f020          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
0007d8 0002          .dw $0002
0007d9 6f74          .db "to"
0007da 07ce          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
0007db f000          .dw DO_COLON
                 PFA_TO:
0007dc 048e          .dw XT_TICK
0007dd f24a          .dw XT_1PLUS  		; to body
0007de 014f          .dw XT_STATE
0007df f086          .dw XT_FETCH
0007e0 f039          .dw XT_DOCONDBRANCH
0007e1 07ec          .dw PFA_TO1
0007e2 01ff          .dw XT_COMPILE
0007e3 07e6          .dw XT_DOTO
0007e4 020a          .dw XT_COMMA
0007e5 f020          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
0007e6 f000          .dw DO_COLON
                 PFA_DOTO:
0007e7 f0fc          .dw XT_R_FROM
0007e8 f0be          .dw XT_DUP
0007e9 f24a          .dw XT_1PLUS
0007ea f105          .dw XT_TO_R
0007eb f3e5          .dw XT_FETCHI
                 PFA_TO1:
0007ec f0be          .dw XT_DUP
0007ed f24a          .dw XT_1PLUS
0007ee f24a          .dw XT_1PLUS
0007ef f3e5          .dw XT_FETCHI
0007f0 f02a          .dw XT_EXECUTE
0007f1 f020          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
0007f2 f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
0007f3 f24a          .dw XT_1PLUS ; >body
0007f4 f3e5          .dw XT_FETCHI
0007f5 f373          .dw XT_FETCHE
0007f6 f020          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
0007f7 f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
0007f8 f24a          .dw XT_1PLUS
0007f9 f3e5          .dw XT_FETCHI
0007fa f34f          .dw XT_STOREE
0007fb f020          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
0007fc f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
0007fd f24a          .dw XT_1PLUS ; >body
0007fe f3e5          .dw XT_FETCHI
0007ff f086          .dw XT_FETCH
000800 f020          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000801 f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
000802 f24a          .dw XT_1PLUS
000803 f3e5          .dw XT_FETCHI
000804 f08e          .dw XT_STORE
000805 f020          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000806 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
000807 f24a          .dw XT_1PLUS ; >body
000808 f3e5          .dw XT_FETCHI
000809 f32f          .dw XT_UP_FETCH
00080a f1b8          .dw XT_PLUS
00080b f086          .dw XT_FETCH
00080c f020          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00080d f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
00080e f24a          .dw XT_1PLUS
00080f f3e5          .dw XT_FETCHI
000810 f32f          .dw XT_UP_FETCH
000811 f1b8          .dw XT_PLUS
000812 f08e          .dw XT_STORE
000813 f020          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
000814 ff06          .dw $ff06
000815 6564
000816 6566
000817 2172          .db "defer!"
000818 07d8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000819 f000          .dw DO_COLON
                 PFA_DEFERSTORE:
00081a f0be          .dw XT_DUP
00081b f040          .dw XT_DOLITERAL
00081c 0003          .dw 3
00081d f1b8          .dw XT_PLUS   ; >body 2 +
00081e f3e5          .dw XT_FETCHI
00081f f02a          .dw XT_EXECUTE
000820 f020          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
000821 ff06          .dw $ff06
000822 6564
000823 6566
000824 4072          .db "defer@"
000825 0814          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000826 f000          .dw DO_COLON
                 PFA_DEFERFETCH:
000827 f0be          .dw XT_DUP
000828 f24a          .dw XT_1PLUS ; >body
000829 f24a          .dw XT_1PLUS 
00082a f3e5          .dw XT_FETCHI
00082b f02a          .dw XT_EXECUTE
00082c f020          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
00082d 082e          .dw PFA_DODEFER
                 PFA_DODEFER:
00082e 940e 0b4a     call_ DO_DODOES
000830 f0be          .dw XT_DUP
000831 f250          .dw XT_1MINUS
000832 f0d1          .dw XT_SWAP
000833 f24a          .dw XT_1PLUS
000834 f3e5          .dw XT_FETCHI
000835 f02a          .dw XT_EXECUTE 
000836 f02a          .dw XT_EXECUTE
000837 f020          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
000838 ff0f          .dw $ff0f
000839 6573
00083a 7261
00083b 6863
00083c 772d
00083d 726f
00083e 6c64
00083f 7369
000840 0074          .db "search-wordlist",0
000841 0821          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000842 f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
000843 f146          .dw XT_ZERO
000844 f0d1          .dw XT_SWAP
000845 f040          .dw XT_DOLITERAL
000846 0851          .dw XT_ISWORD
000847 f0d1          .dw XT_SWAP
000848 0888          .dw XT_TRAVERSEWORDLIST
000849 f0be          .dw XT_DUP
00084a f12a          .dw XT_EQUALZERO
00084b f039          .dw XT_DOCONDBRANCH
00084c 0850          .dw PFA_SEARCH_WORDLIST1
00084d 0175             .dw XT_2DROP
00084e f0e6             .dw XT_DROP
00084f f146             .dw XT_ZERO
                 PFA_SEARCH_WORDLIST1:
000850 f020          .dw XT_EXIT
                 
                 XT_ISWORD:
000851 f000          .dw DO_COLON
                 PFA_ISWORD:
                     ; ( c-addr len 0 nt -- c-addr len 0 true| xt +/-1 false )
000852 f105          .dw XT_TO_R
000853 f105          .dw XT_TO_R
000854 016c          .dw XT_2DUP
000855 f0fc          .dw XT_R_FROM
000856 f0ee          .dw XT_ROT
000857 f0ee          .dw XT_ROT
000858 f10e          .dw XT_R_FETCH  ; -- addr len 0 addr len nt
000859 0877          .dw XT_NAME2STRING
00085a 08a3          .dw XT_ICOMPARE      ; (-- addr len 0 f )
00085b f039          .dw XT_DOCONDBRANCH
00085c 086b          .dw PFA_ISWORD3
                       ; we found the word, now clean up iteration data ...
00085d 0175            .dw XT_2DROP
00085e f0e6            .dw XT_DROP
                       ; ... get the XT ...
00085f f10e            .dw XT_R_FETCH
000860 0d04            .dw XT_NFA2LFA
000861 f24a            .dw XT_1PLUS  ; lfa2xt
                       ; .. and get the header flag
000862 f14f            .dw XT_TRUE
000863 f0fc            .dw XT_R_FROM
000864 f3e5            .dw XT_FETCHI
000865 f16e            .dw XT_GREATERZERO
000866 f039            .dw XT_DOCONDBRANCH
000867 0869            .dw PFA_ISWORD1
000868 02a2               .dw XT_NEGATE  ; it's immediate
                 PFA_ISWORD1:
000869 f146            .dw XT_ZERO       ; finish traverse-wordlist
00086a f020            .dw XT_EXIT
                 PFA_ISWORD3:
00086b f0fc          .dw XT_R_FROM
00086c f0e6          .dw XT_DROP
00086d f14f          .dw XT_TRUE         ; maybe next word
00086e f020          .dw XT_EXIT
                 
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 VE_NAME2STRING:
00086f ff0b          .dw $ff0b
000870 616e
000871 656d
000872 733e
000873 7274
000874 6e69
000875 0067          .db "name>string",0
000876 0838          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000877 f000          .dw DO_COLON
                 PFA_NAME2STRING:
000878 0451          .dw XT_ICOUNT   ; ( -- addr n )
000879 f040          .dw XT_DOLITERAL
00087a 00ff          .dw $00FF
00087b f22e          .dw XT_AND      ; mask immediate bit
00087c f020          .dw XT_EXIT
                 
                 ; ( i*x xt wid -- j*x ) 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 VE_TRAVERSEWORDLIST:
00087d ff11          .dw $ff11
00087e 7274
00087f 7661
000880 7265
000881 6573
000882 772d
000883 726f
000884 6c64
000885 7369
000886 0074          .db "traverse-wordlist",0
000887 086f          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000888 f000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
000889 f373          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00088a f0be          .dw XT_DUP           ; ( -- xt nt nt )
00088b f039          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00088c 089b          .dw PFA_TRAVERSEWORDLIST2       ;
00088d 016c          .dw XT_2DUP
00088e f105          .dw XT_TO_R
00088f f105          .dw XT_TO_R
000890 f0d1          .dw XT_SWAP
000891 f02a          .dw XT_EXECUTE
000892 f0fc          .dw XT_R_FROM
000893 f0fc          .dw XT_R_FROM
000894 f0ee          .dw XT_ROT
000895 f039          .dw XT_DOCONDBRANCH
000896 089b          .dw PFA_TRAVERSEWORDLIST2
000897 0d04          .dw XT_NFA2LFA
000898 f3e5          .dw XT_FETCHI        ; ( -- addr )
000899 f02f          .dw XT_DOBRANCH      ; ( -- addr )
00089a 088a          .dw PFA_TRAVERSEWORDLIST1       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00089b 0175          .dw XT_2DROP
00089c f020          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
00089d ff08          .dw $ff08
00089e 6369
00089f 6d6f
0008a0 6170
0008a1 6572          .db "icompare"
0008a2 087d          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0008a3 f000          .dw DO_COLON
                 PFA_ICOMPARE:
0008a4 f105          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0008a5 f0dc          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0008a6 f0fc          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0008a7 f119          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0008a8 f039          .dw XT_DOCONDBRANCH
0008a9 08ae          .dw PFA_ICOMPARE_SAMELEN
0008aa 0175            .dw XT_2DROP
0008ab f0e6            .dw XT_DROP
0008ac f146            .dw XT_ZERO
0008ad f020            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0008ae f0d1          .dw XT_SWAP ; ( -- r-addr f-addr len )
0008af f146          .dw XT_ZERO
0008b0 f2bf          .dw XT_DOQDO
0008b1 08d1          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0008b2 f0dc          .dw XT_OVER
0008b3 f086          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
0008b4 08d4          .dw XT_ICOMPARE_LC
                 .endif
0008b5 f0dc          .dw XT_OVER
0008b6 f3e5          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
0008b7 08d4          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0008b8 f0be          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0008b9 f040          .dw XT_DOLITERAL
0008ba 0100          .dw $100
0008bb f158          .dw XT_ULESS
0008bc f039          .dw XT_DOCONDBRANCH
0008bd 08c2          .dw PFA_ICOMPARE_LASTCELL
0008be f0d1          .dw XT_SWAP
0008bf f040          .dw XT_DOLITERAL
0008c0 00ff          .dw $00FF
0008c1 f22e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0008c2 f119          .dw XT_NOTEQUAL
0008c3 f039          .dw XT_DOCONDBRANCH
0008c4 08c9          .dw PFA_ICOMPARE_NEXTLOOP
0008c5 0175          .dw XT_2DROP
0008c6 f146          .dw XT_ZERO
0008c7 f2ff          .dw XT_UNLOOP
0008c8 f020          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
0008c9 f24a          .dw XT_1PLUS
0008ca f0d1          .dw XT_SWAP
0008cb 0164          .dw XT_CELLPLUS
0008cc f0d1          .dw XT_SWAP
0008cd f040          .dw XT_DOLITERAL
0008ce 0002          .dw 2
0008cf f2d6          .dw XT_DOPLUSLOOP
0008d0 08b2          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
0008d1 0175          .dw XT_2DROP
0008d2 f14f          .dw XT_TRUE
0008d3 f020          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
0008d4 f000          .dw DO_COLON
                 PFA_ICOMPARE_LC:
0008d5 f0be          .dw XT_DUP
0008d6 f040          .dw XT_DOLITERAL
0008d7 00ff          .dw $00ff
0008d8 f22e          .dw XT_AND
0008d9 0300          .dw XT_TOLOWER
0008da f0d1          .dw XT_SWAP
0008db f326          .dw XT_BYTESWAP
0008dc f040          .dw XT_DOLITERAL
0008dd 00ff          .dw $00ff
0008de f22e          .dw XT_AND
0008df 0300          .dw XT_TOLOWER
0008e0 f326          .dw XT_BYTESWAP
0008e1 f237          .dw XT_OR
0008e2 f020          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
0008e3 ff01          .dw $ff01
0008e4 002a          .db "*",0
0008e5 089d          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
0008e6 f000          .dw DO_COLON
                 PFA_STAR:
0008e7 f1c1          .dw XT_MSTAR
0008e8 08f8          .dw XT_D2S
0008e9 f020          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
0008ea ff01          .dw $FF01
0008eb 006a          .db "j",0
0008ec 08e3          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
0008ed f000          .dw DO_COLON
                 PFA_J:
0008ee f285          .dw XT_RP_FETCH
0008ef f040          .dw XT_DOLITERAL
0008f0 0009          .dw 9
0008f1 f1b8          .dw XT_PLUS
0008f2 f086          .dw XT_FETCH
0008f3 f020          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
0008f4 ff03          .dw $ff03
0008f5 3e64
0008f6 0073          .db "d>s",0
0008f7 08ea          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
0008f8 f000          .dw DO_COLON
                 PFA_D2S:
0008f9 f0e6          .dw XT_DROP
0008fa f020          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
0008fb ff04          .dw $ff04
0008fc 6164
0008fd 7362          .db "dabs"
0008fe 08f4          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
0008ff f000          .dw DO_COLON
                 PFA_DABS:
000900 f0be          .dw XT_DUP
000901 f13f          .dw XT_LESSZERO
000902 f039          .dw XT_DOCONDBRANCH
000903 0905          .dw PFA_DABS1
000904 090c          .dw XT_DNEGATE
                 PFA_DABS1:
000905 f020          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000906 ff07          .dw $ff07
000907 6e64
000908 6765
000909 7461
00090a 0065          .db "dnegate",0
00090b 08fb          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00090c f000          .dw DO_COLON
                 PFA_DNEGATE:
00090d 09c3          .dw XT_DINVERT
00090e f040          .dw XT_DOLITERAL
00090f 0001          .dw 1
000910 f146          .dw XT_ZERO
000911 099b          .dw XT_DPLUS
000912 f020          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000913 ff05          .dw $ff05
000914 6d63
000915 766f
000916 0065          .db "cmove",0
000917 0906          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000918 0919          .dw PFA_CMOVE
                 PFA_CMOVE:
000919 93bf          push xh
00091a 93af          push xl
00091b 91e9          ld zl, Y+
00091c 91f9          ld zh, Y+ ; addr-to
00091d 91a9          ld xl, Y+
00091e 91b9          ld xh, Y+ ; addr-from
00091f 2f09          mov temp0, tosh
000920 2b08          or temp0, tosl
000921 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000922 911d          ld temp1, X+
000923 9311          st Z+, temp1
000924 9701          sbiw tosl, 1
000925 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000926 91af          pop xl
000927 91bf          pop xh
000928 9189
000929 9199          loadtos
00092a 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
00092c ff05          .dw $ff05
00092d 7332
00092e 6177
00092f 0070          .db "2swap",0
000930 0913          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000931 f000          .dw DO_COLON
                 PFA_2SWAP:
000932 f0ee          .dw XT_ROT
000933 f105          .dw XT_TO_R
000934 f0ee          .dw XT_ROT
000935 f0fc          .dw XT_R_FROM
000936 f020          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000937 ff03          .dw $ff03
000938 6974
000939 0062          .db "tib",0
00093a 092c          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00093b f04e          .dw PFA_DOVARIABLE
                 PFA_TIB:
00093c 018d          .dw ram_tib
                     
                 .dseg
00018d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
00093d ff0a          .dw $ff0a
00093e 6572
00093f 6966
000940 6c6c
000941 742d
000942 6269          .db "refill-tib"
000943 0937          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000944 f000          .dw DO_COLON
                 PFA_REFILLTIB:
000945 093b          .dw XT_TIB
000946 f040          .dw XT_DOLITERAL
000947 0064          .dw TIBSIZE
000948 04ec          .dw XT_ACCEPT
000949 0183          .dw XT_NUMBERTIB
00094a f08e          .dw XT_STORE
00094b f146          .dw XT_ZERO
00094c 017d          .dw XT_G_IN
00094d f08e          .dw XT_STORE
00094e f040          .dw XT_DOLITERAL
00094f ffff          .dw -1
000950 f020          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
000951 ff0a          .dw $FF0A
000952 6f73
000953 7275
000954 6563
000955 742d
000956 6269          .db "source-tib"
000957 093d          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000958 f000          .dw DO_COLON
                 PFA_SOURCETIB:
000959 093b          .dw XT_TIB
00095a 0183          .dw XT_NUMBERTIB
00095b f086          .dw XT_FETCH
00095c f020          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
00095d ff07        .dw $ff07
00095e 6565
00095f 752d
000960 6573
000961 0072        .db "ee-user",0
000962 0951        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
000963 f04e        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
000964 0038        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000965 ff06        .dw $ff06
000966 6565
000967 723e
000968 6d61        .db "ee>ram"
000969 095d        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00096a f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00096b f146          .dw XT_ZERO
00096c f2bf          .dw XT_DOQDO
00096d 0978          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00096e f0dc          .dw XT_OVER
00096f f373          .dw XT_FETCHE
000970 f0dc          .dw XT_OVER
000971 f08e          .dw XT_STORE
000972 0164          .dw XT_CELLPLUS
000973 f0d1          .dw XT_SWAP
000974 0164          .dw XT_CELLPLUS
000975 f0d1          .dw XT_SWAP
000976 f2f0          .dw XT_DOLOOP
000977 096e          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000978 0175          .dw XT_2DROP
000979 f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00097a ff09        .dw $ff09
00097b 6e69
00097c 7469
00097d 752d
00097e 6573
00097f 0072        .db "init-user",0
000980 0965        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000981 f000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000982 0963          .dw XT_EEUSER
000983 f32f          .dw XT_UP_FETCH
000984 f040          .dw XT_DOLITERAL
000985 001c          .dw SYSUSERSIZE
000986 f21f          .dw XT_2SLASH
000987 096a          .dw XT_EE2RAM
000988 f020          .dw XT_EXIT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000989 ff03          .dw $ff03
00098a 3264
00098b 002a          .db "d2*",0
00098c 097a          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00098d 098e          .dw PFA_D2STAR
                 PFA_D2STAR:
00098e 9109          ld temp0, Y+
00098f 9119          ld temp1, Y+
000990 0f00          lsl temp0
000991 1f11          rol temp1
000992 1f88          rol tosl
000993 1f99          rol tosh
000994 931a          st -Y, temp1
000995 930a          st -Y, temp0
000996 940c f004     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000998 ff02          .dw $ff02
000999 2b64          .db "d+"
00099a 0989          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00099b 099c          .dw PFA_DPLUS
                 PFA_DPLUS:
00099c 9129          ld temp2, Y+
00099d 9139          ld temp3, Y+
                 
00099e 90e9          ld temp4, Y+
00099f 90f9          ld temp5, Y+
0009a0 9149          ld temp6, Y+
0009a1 9159          ld temp7, Y+
                 
0009a2 0f24          add temp2, temp6
0009a3 1f35          adc temp3, temp7
0009a4 1d8e          adc tosl, temp4
0009a5 1d9f          adc tosh, temp5
                     
0009a6 933a          st -Y, temp3
0009a7 932a          st -Y, temp2
0009a8 940c f004     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
0009aa ff02          .dw $ff02
0009ab 2d64          .db "d-"
0009ac 0998          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
0009ad 09ae          .dw PFA_DMINUS
                 PFA_DMINUS:
0009ae 9129          ld temp2, Y+
0009af 9139          ld temp3, Y+
                 
0009b0 90e9          ld temp4, Y+
0009b1 90f9          ld temp5, Y+
0009b2 9149          ld temp6, Y+
0009b3 9159          ld temp7, Y+
                 
0009b4 1b42          sub temp6, temp2
0009b5 0b53          sbc temp7, temp3
0009b6 0ae8          sbc temp4, tosl
0009b7 0af9          sbc temp5, tosh
                 
0009b8 935a          st -Y, temp7
0009b9 934a          st -Y, temp6
0009ba 01c7          movw tosl, temp4
0009bb 940c f004     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0009bd ff07          .dw $ff07
0009be 6964
0009bf 766e
0009c0 7265
0009c1 0074          .db "dinvert",0
0009c2 09aa          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0009c3 09c4          .dw PFA_DINVERT
                 PFA_DINVERT:
0009c4 9109          ld temp0, Y+
0009c5 9119          ld temp1, Y+
0009c6 9580          com tosl
0009c7 9590          com tosh
0009c8 9500          com temp0
0009c9 9510          com temp1
0009ca 931a          st -Y, temp1
0009cb 930a          st -Y, temp0
0009cc 940c f004     jmp_ DO_NEXT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
0009ce ff02          .dw $ff02
0009cf 2e75          .db "u."
0009d0 09bd          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0009d1 f000          .dw DO_COLON
                 PFA_UDOT:
0009d2 f146          .dw XT_ZERO
0009d3 0394          .dw XT_UDDOT
0009d4 f020          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
0009d5 ff02          .dw $ff02
0009d6 732e          .db ".s"
0009d7 09ce          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
0009d8 f000          .dw DO_COLON
                 PFA_DOTS:
0009d9 0702          .dw XT_SP0
0009da f29c          .dw XT_SP_FETCH
0009db 0164          .dw XT_CELLPLUS
0009dc f2bf          .dw XT_DOQDO
0009dd 09e5          .dw PFA_DOTS2
                 PFA_DOTS1:
0009de f2d5          .dw XT_I
0009df f086          .dw XT_FETCH 
0009e0 09d1          .dw XT_UDOT
0009e1 f040          .dw XT_DOLITERAL
0009e2 0002          .dw 2
0009e3 f2d6          .dw XT_DOPLUSLOOP
0009e4 09de          .dw PFA_DOTS1
                 PFA_DOTS2:
0009e5 f020          .dw XT_EXIT
                 
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
0009e6 0002          .dw $0002
0009e7 222e          .db ".",$22
0009e8 09d5          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
0009e9 f000          .dw DO_COLON
                 PFA_DOTSTRING:
0009ea 09f1          .dw XT_SQUOTE
0009eb 01ff          .dw XT_COMPILE
0009ec 0426          .dw XT_ITYPE
0009ed f020          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
0009ee 0002        .dw $0002
0009ef 2273        .db "s",$22
0009f0 09e6        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
0009f1 f000          .dw DO_COLON
                 PFA_SQUOTE:
0009f2 f040          .dw XT_DOLITERAL
0009f3 0022          .dw $22
0009f4 05fc          .dw XT_PARSE       ; ( -- addr n)
0009f5 014f          .dw XT_STATE
0009f6 f086          .dw XT_FETCH
0009f7 f039          .dw XT_DOCONDBRANCH
0009f8 09fc          .dw PFA_SQUOTE1
0009f9 01ff            .dw XT_COMPILE
0009fa 03ef            .dw XT_DOSLITERAL    ; ( -- addr n)
0009fb 0402            .dw XT_SCOMMA
                 PFA_SQUOTE1:
0009fc f020          .dw XT_EXIT
                 
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
0009fd ff05          .dw $ff05
0009fe 6f77
0009ff 6472
000a00 0073          .db "words",0
000a01 09ee          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000a02 f000          .dw DO_COLON
                 PFA_WORDS:
000a03 f040          .dw XT_DOLITERAL
000a04 0016          .dw EE_ORDERLIST
000a05 f373          .dw XT_FETCHE
000a06 0d16          .dw XT_SHOWWORDLIST
000a07 f020          .dw XT_EXIT
                 
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000a08 ff06          .dw $ff06
000a09 6445
000a0a 6665
000a0b 7265          .db "Edefer"
000a0c 09fd          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000a0d f000          .dw DO_COLON
                 PFA_EDEFER:
000a0e 01d8          .dw XT_DOCREATE
000a0f 0b26          .dw XT_REVEAL
000a10 01ff          .dw XT_COMPILE
000a11 082e          .dw PFA_DODEFER
                 
000a12 01bb          .dw XT_EDP
000a13 f0be          .dw XT_DUP
000a14 020a          .dw XT_COMMA
000a15 01ff          .dw XT_COMPILE
000a16 07f2          .dw XT_EDEFERFETCH
000a17 01ff          .dw XT_COMPILE
000a18 07f7          .dw XT_EDEFERSTORE
000a19 0164          .dw XT_CELLPLUS
000a1a 07e6          .dw XT_DOTO
000a1b 01bc          .dw PFA_EDP
000a1c f020          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000a1d ff06          .dw $ff06
000a1e 6452
000a1f 6665
000a20 7265          .db "Rdefer"
000a21 0a08          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000a22 f000          .dw DO_COLON
                 PFA_RDEFER:
000a23 01d8          .dw XT_DOCREATE
000a24 0b26          .dw XT_REVEAL
                 
000a25 01ff          .dw XT_COMPILE
000a26 082e          .dw PFA_DODEFER
                 
000a27 01c3          .dw XT_HERE
000a28 020a          .dw XT_COMMA
000a29 f040          .dw XT_DOLITERAL
000a2a 0002          .dw 2
000a2b 01cc          .dw XT_ALLOT
                 
000a2c 01ff          .dw XT_COMPILE
000a2d 07fc          .dw XT_RDEFERFETCH
000a2e 01ff          .dw XT_COMPILE
000a2f 0801          .dw XT_RDEFERSTORE
000a30 f020          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000a31 0002          .dw $0002
000a32 7369          .db "is"
000a33 0a1d          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000a34 f000          .dw DO_COLON
                 PFA_IS:
000a35 014f          .dw XT_STATE
000a36 f086          .dw XT_FETCH
000a37 f039          .dw XT_DOCONDBRANCH
000a38 0a3d          .dw PFA_IS1
000a39 0216          .dw XT_BRACKETTICK
000a3a 01ff          .dw XT_COMPILE
000a3b 0819          .dw XT_DEFERSTORE
000a3c f020          .dw XT_EXIT
                 PFA_IS1:
000a3d 048e          .dw XT_TICK
000a3e 0819          .dw XT_DEFERSTORE
000a3f f020          .dw XT_EXIT
                 
                 
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
000a40 0007          .dw $0007
000a41 696c
000a42 6574
000a43 6172
000a44 006c          .db "literal",0
000a45 0a31          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000a46 f000          .dw DO_COLON
                 PFA_LITERAL:
000a47 01ff          .dw XT_COMPILE
000a48 f040          .dw XT_DOLITERAL
000a49 020a          .dw XT_COMMA
000a4a f020          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000a4b 0008        .dw $0008
000a4c 6c73
000a4d 7469
000a4e 7265
000a4f 6c61        .db "sliteral"
000a50 0a40        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000a51 f000          .dw DO_COLON
                 PFA_SLITERAL:
000a52 01ff          .dw XT_COMPILE
000a53 03ef          .dw XT_DOSLITERAL    ; ( -- addr n)
000a54 0402          .dw XT_SCOMMA
000a55 f020          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000a56 f000          .dw DO_COLON
                 PFA_GMARK:
000a57 01b3          .dw XT_DP
000a58 01ff          .dw XT_COMPILE
000a59 ffff          .dw -1           ; ffff does not erase flash
000a5a f020          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000a5b f000          .dw DO_COLON
                 PFA_GRESOLVE:
000a5c 07a1          .dw XT_QSTACK
000a5d 01b3          .dw XT_DP
000a5e f0d1          .dw XT_SWAP
000a5f f387          .dw XT_STOREI
000a60 f020          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000a61 f000          .dw DO_COLON
                 PFA_LMARK:
000a62 01b3          .dw XT_DP
000a63 f020          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000a64 f000          .dw DO_COLON
                 PFA_LRESOLVE:
000a65 07a1          .dw XT_QSTACK
000a66 020a          .dw XT_COMMA
000a67 f020          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000a68 0005          .dw $0005
000a69 6861
000a6a 6165
000a6b 0064          .db "ahead",0
000a6c 0a4b          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000a6d f000          .dw DO_COLON
                 PFA_AHEAD:
000a6e 01ff          .dw XT_COMPILE
000a6f f02f          .dw XT_DOBRANCH
000a70 0a56          .dw XT_GMARK
000a71 f020          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
000a72 0002          .dw $0002
000a73 6669          .db "if"
000a74 0a68          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000a75 f000          .dw DO_COLON
                 PFA_IF:
000a76 01ff          .dw XT_COMPILE
000a77 f039          .dw XT_DOCONDBRANCH
000a78 0a56          .dw XT_GMARK
000a79 f020          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000a7a 0004          .dw $0004
000a7b 6c65
000a7c 6573          .db "else"
000a7d 0a72          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000a7e f000          .dw DO_COLON
                 PFA_ELSE:
000a7f 01ff          .dw XT_COMPILE
000a80 f02f          .dw XT_DOBRANCH
000a81 0a56          .dw XT_GMARK
000a82 f0d1          .dw XT_SWAP
000a83 0a5b          .dw XT_GRESOLVE
000a84 f020          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000a85 0004          .dw $0004
000a86 6874
000a87 6e65          .db "then"
000a88 0a7a          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000a89 f000          .dw DO_COLON
                 PFA_THEN:
000a8a 0a5b          .dw XT_GRESOLVE
000a8b f020          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000a8c 0005          .dw $0005
000a8d 6562
000a8e 6967
000a8f 006e          .db "begin",0
000a90 0a85          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000a91 f000          .dw DO_COLON
                 PFA_BEGIN:
000a92 0a61          .dw XT_LMARK
000a93 f020          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
000a94 0005          .dw $0005
000a95 6877
000a96 6c69
000a97 0065          .db "while",0
000a98 0a8c          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000a99 f000          .dw DO_COLON
                 PFA_WHILE:
000a9a 01ff          .dw XT_COMPILE
000a9b f039          .dw XT_DOCONDBRANCH
000a9c 0a56          .dw XT_GMARK
000a9d f0d1          .dw XT_SWAP
000a9e f020          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
000a9f 0006          .dw $0006
000aa0 6572
000aa1 6570
000aa2 7461          .db "repeat"
000aa3 0a94          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000aa4 f000          .dw DO_COLON
                 PFA_REPEAT:
000aa5 0ab7          .dw XT_AGAIN
000aa6 0a5b          .dw XT_GRESOLVE
000aa7 f020          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000aa8 0005          .dw $0005
000aa9 6e75
000aaa 6974
000aab 006c          .db "until",0
000aac 0a9f          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000aad f000          .dw DO_COLON
                 PFA_UNTIL:
000aae 01ff          .dw XT_COMPILE
000aaf f039          .dw XT_DOCONDBRANCH
000ab0 0a64          .dw XT_LRESOLVE
000ab1 f020          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
000ab2 0005          .dw $0005
000ab3 6761
000ab4 6961
000ab5 006e          .db "again",0
000ab6 0aa8          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000ab7 f000          .dw DO_COLON
                 PFA_AGAIN:
000ab8 01ff          .dw XT_COMPILE
000ab9 f02f          .dw XT_DOBRANCH
000aba 0a64          .dw XT_LRESOLVE
000abb f020          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
000abc 0002          .dw $0002
000abd 6f64          .db "do"
000abe 0ab2          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000abf f000          .dw DO_COLON
                 PFA_DO:
000ac0 01ff          .dw XT_COMPILE
000ac1 f2aa          .dw XT_DODO
000ac2 0a56          .dw XT_GMARK
000ac3 0a61          .dw XT_LMARK
000ac4 f020          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
000ac5 0004          .dw $0004
000ac6 6f6c
000ac7 706f          .db "loop"
000ac8 0abc          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000ac9 f000          .dw DO_COLON
                 PFA_LOOP:
000aca 01ff          .dw XT_COMPILE
000acb f2f0          .dw XT_DOLOOP
000acc 0a64          .dw XT_LRESOLVE
000acd 0a5b          .dw XT_GRESOLVE
000ace f020          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
000acf 0005          .dw $0005
000ad0 6c2b
000ad1 6f6f
000ad2 0070          .db "+loop",0
000ad3 0ac5          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000ad4 f000          .dw DO_COLON
                 PFA_PLUSLOOP:
000ad5 01ff          .dw XT_COMPILE
000ad6 f2d6          .dw XT_DOPLUSLOOP
000ad7 0a64          .dw XT_LRESOLVE
000ad8 0a5b          .dw XT_GRESOLVE
000ad9 f020          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
000ada ff05         .dw $FF05
000adb 656c
000adc 7661
000add 0065         .db "leave",0
000ade 0acf         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000adf 0ae0          .dw PFA_LEAVE
                 PFA_LEAVE:
000ae0 910f          pop temp0  ; drop limit and counter from returnstack
000ae1 911f          pop temp1
000ae2 910f          pop temp0
000ae3 911f          pop temp1
000ae4 91af          pop xl
000ae5 91bf          pop xh
000ae6 940c f004     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
000ae8 0003          .dw $0003
000ae9 643f
000aea 006f          .db "?do",0
000aeb 0ada          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000aec f000          .dw DO_COLON
                 PFA_QDO:
000aed 01ff          .dw XT_COMPILE
000aee f2bf          .dw XT_DOQDO
000aef 0a56          .dw XT_GMARK
000af0 0a61          .dw XT_LMARK
000af1 f020          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000af2 ff06          .dw $ff06
000af3 7263
000af4 6165
000af5 6574          .db "create"
000af6 0ae8          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000af7 f000          .dw DO_COLON
                 PFA_CREATE:
000af8 01d8          .dw XT_DOCREATE
000af9 0b26          .dw XT_REVEAL
000afa 01ff          .dw XT_COMPILE
000afb f05b          .dw PFA_DOCONSTANT
000afc f020          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000afd ff06          .dw $ff06
000afe 6568
000aff 6461
000b00 7265          .db "header"
000b01 0af2          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000b02 f000          .dw DO_COLON
                 PFA_HEADER:
000b03 01b3          .dw XT_DP           ; the new Name Field
000b04 f105          .dw XT_TO_R
000b05 f105          .dw XT_TO_R		; ( R: NFA WID )
000b06 f0be          .dw XT_DUP    
000b07 f16e          .dw XT_GREATERZERO 
000b08 f039          .dw XT_DOCONDBRANCH
000b09 0b14          .dw PFA_HEADER1
000b0a f0be          .dw XT_DUP
000b0b f040          .dw XT_DOLITERAL
000b0c ff00          .dw $ff00           ; all flags are off (e.g. immediate)
000b0d f237          .dw XT_OR
000b0e 0406          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
000b0f f0fc          .dw XT_R_FROM
000b10 f373          .dw XT_FETCHE
000b11 020a          .dw XT_COMMA
000b12 f0fc          .dw XT_R_FROM
000b13 f020          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000b14 f040          .dw XT_DOLITERAL
000b15 fff0          .dw -16
000b16 04bb          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000b17 ff07          .dw $ff07
000b18 6c77
000b19 6373
000b1a 706f
000b1b 0065          .db "wlscope",0
000b1c 0afd          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000b1d 082e          .dw PFA_DODEFER
                 PFA_WLSCOPE:
000b1e 0034          .dw EE_WLSCOPE
000b1f 07f2          .dw XT_EDEFERFETCH
000b20 07f7          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000b21 ff06          .dw $ff06
000b22 6572
000b23 6576
000b24 6c61          .db "reveal"
000b25 0b17          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000b26 f000          .dw DO_COLON
                 PFA_REVEAL:
000b27 f040          .dw XT_DOLITERAL
000b28 015f          .dw COLON_SMUDGE+0
000b29 f086          .dw XT_FETCH
000b2a f0c6          .dw XT_QDUP
000b2b f039          .dw XT_DOCONDBRANCH
000b2c 0b35          .dw PFA_REVEAL1
                 ;
000b2d f040          .dw XT_DOLITERAL
000b2e 0161          .dw COLON_SMUDGE+2
000b2f f086          .dw XT_FETCH		; ( NFA WID )
000b30 f34f          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000b31 f146          .dw XT_ZERO
000b32 f040          .dw XT_DOLITERAL
000b33 015f          .dw COLON_SMUDGE+0
000b34 f08e          .dw XT_STORE
                 PFA_REVEAL1:
000b35 f020          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000b36 ff06          .dw $ff06
000b37 616c
000b38 6574
000b39 7473          .db "latest"
000b3a 0b21          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000b3b f04e          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000b3c 01f1          .dw ram_LATEST
                 
                 .dseg
0001f1           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000b3d 0005          .dw $0005
000b3e 6f64
000b3f 7365
000b40 003e          .db "does>",0
000b41 0b36          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000b42 f000          .dw DO_COLON
                 PFA_DOES:
000b43 01ff          .dw XT_COMPILE
000b44 0b55          .dw XT_DODOES
000b45 01ff          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000b46 940e          .dw $940e       ; the address of this compiled
000b47 01ff          .dw XT_COMPILE  ; code will replace the XT of the 
000b48 0b4a          .dw DO_DODOES   ; word that CREATE created
000b49 f020          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000b4a 939a
000b4b 938a          savetos
000b4c 01cb          movw tosl, wl
000b4d 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000b4e 917f          pop wh
000b4f 916f          pop wl
                 
000b50 93bf          push XH
000b51 93af          push XL
000b52 01db          movw XL, wl
000b53 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000b55 f000          .dw DO_COLON
                 PFA_DODOES:
000b56 f0fc          .dw XT_R_FROM
000b57 f040          .dw XT_DOLITERAL
000b58 0161          .dw COLON_SMUDGE+2
000b59 f086          .dw XT_FETCH
000b5a f373          .dw XT_FETCHE
000b5b 0d04          .dw XT_NFA2LFA
000b5c f24a          .dw XT_1PLUS   ; lfa>xt
                 
000b5d f387          .dw XT_STOREI
000b5e f020          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000b5f ff01          .dw $ff01
000b60 003a          .db ":",0
000b61 0b3d          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000b62 f000          .dw DO_COLON
                 PFA_COLON:
000b63 01d8          .dw XT_DOCREATE
000b64 01b3          .dw XT_DP
000b65 0b3b          .dw XT_LATEST
000b66 f08e          .dw XT_STORE
000b67 01ff          .dw XT_COMPILE
000b68 f000          .dw DO_COLON
000b69 0b86          .dw XT_RBRACKET
000b6a f020          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000b6b ff07          .dw $ff07
000b6c 6e3a
000b6d 6e6f
000b6e 6d61
000b6f 0065          .db ":noname",0
000b70 0b5f          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000b71 f000          .dw DO_COLON
                 PFA_COLONNONAME:
000b72 01b3          .dw XT_DP
000b73 f0be          .dw XT_DUP
000b74 0b3b          .dw XT_LATEST
000b75 f08e          .dw XT_STORE
                 
000b76 01ff          .dw XT_COMPILE
000b77 f000          .dw DO_COLON
                 
000b78 0b86          .dw XT_RBRACKET
000b79 f020          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000b7a 0001          .dw $0001
000b7b 003b          .db $3b,0
000b7c 0b6b          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000b7d f000          .dw DO_COLON
                 PFA_SEMICOLON:
000b7e 01ff          .dw XT_COMPILE
000b7f f020          .dw XT_EXIT
000b80 0b8f          .dw XT_LBRACKET
000b81 0b26          .dw XT_REVEAL
000b82 f020          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000b83 ff01          .dw $ff01
000b84 005d          .db "]",0
000b85 0b7a          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000b86 f000          .dw DO_COLON
                 PFA_RBRACKET:
000b87 f040          .dw XT_DOLITERAL
000b88 0001          .dw 1
000b89 014f          .dw XT_STATE
000b8a f08e          .dw XT_STORE
000b8b f020          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000b8c 0001          .dw $0001
000b8d 005b          .db "[",0
000b8e 0b83          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000b8f f000          .dw DO_COLON
                 PFA_LBRACKET:
000b90 f146          .dw XT_ZERO
000b91 014f          .dw XT_STATE
000b92 f08e          .dw XT_STORE
000b93 f020          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000b94 ff08          .dw $ff08
000b95 6176
000b96 6972
000b97 6261
000b98 656c          .db "variable"
000b99 0b8c          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000b9a f000          .dw DO_COLON
                 PFA_VARIABLE:
000b9b 01c3          .dw XT_HERE
000b9c 0ba7          .dw XT_CONSTANT
000b9d f040          .dw XT_DOLITERAL
000b9e 0002          .dw 2
000b9f 01cc          .dw XT_ALLOT
000ba0 f020          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000ba1 ff08          .dw $ff08
000ba2 6f63
000ba3 736e
000ba4 6174
000ba5 746e          .db "constant"
000ba6 0b94          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000ba7 f000          .dw DO_COLON
                 PFA_CONSTANT:
000ba8 01d8          .dw XT_DOCREATE
000ba9 0b26          .dw XT_REVEAL
000baa 01ff          .dw XT_COMPILE
000bab f04e          .dw PFA_DOVARIABLE
000bac 020a          .dw XT_COMMA
000bad f020          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000bae ff04          .dw $ff04
000baf 7375
000bb0 7265          .db "user"
000bb1 0ba1          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000bb2 f000          .dw DO_COLON
                 PFA_USER:
000bb3 01d8          .dw XT_DOCREATE
000bb4 0b26          .dw XT_REVEAL
                 
000bb5 01ff          .dw XT_COMPILE
000bb6 f061          .dw PFA_DOUSER
000bb7 020a          .dw XT_COMMA
000bb8 f020          .dw XT_EXIT
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
000bb9 ff05          .dw $ff05
000bba 6176
000bbb 756c
000bbc 0065          .db "value",0
000bbd 0bae          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000bbe f000          .dw DO_COLON
                 PFA_VALUE:
000bbf f075          .dw XT_DOVALUE
000bc0 01bb          .dw XT_EDP
000bc1 020a          .dw XT_COMMA
000bc2 01ff          .dw XT_COMPILE
000bc3 0bce          .dw XT_EVALUEFETCH
000bc4 01ff          .dw XT_COMPILE
000bc5 0bd2          .dw XT_EVALUESTORE
000bc6 01bb          .dw XT_EDP
000bc7 f0be          .dw XT_DUP
000bc8 f24a          .dw XT_1PLUS
000bc9 f24a          .dw XT_1PLUS
000bca 07e6          .dw XT_DOTO
000bcb 01bc          .dw PFA_EDP
000bcc f34f          .dw XT_STOREE
000bcd f020          .dw XT_EXIT
                 
                 XT_EVALUEFETCH:
000bce f000          .dw DO_COLON
                 PFA_EVALUEFETCH:
000bcf f3e5          .dw XT_FETCHI
000bd0 f373          .dw XT_FETCHE
000bd1 f020          .dw XT_EXIT
                 
                 XT_EVALUESTORE:
000bd2 f000          .dw DO_COLON
                 PFA_EVALUESTORE:
000bd3 f3e5          .dw XT_FETCHI
000bd4 f34f          .dw XT_STOREE
000bd5 f020          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000bd6 0007          .dw $0007
000bd7 6572
000bd8 7563
000bd9 7372
000bda 0065          .db "recurse",0
000bdb 0bb9          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000bdc f000          .dw DO_COLON
                 PFA_RECURSE:
000bdd 0b3b          .dw XT_LATEST
000bde f086          .dw XT_FETCH
000bdf 020a          .dw XT_COMMA
000be0 f020          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000be1 ff09          .dw $ff09
000be2 6d69
000be3 656d
000be4 6964
000be5 7461
000be6 0065          .db "immediate",0
000be7 0bd6          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000be8 f000          .dw DO_COLON
                 PFA_IMMEDIATE:
000be9 0cc5          .dw XT_GET_CURRENT
000bea f373          .dw XT_FETCHE
000beb f0be          .dw XT_DUP
000bec f3e5          .dw XT_FETCHI
000bed f040          .dw XT_DOLITERAL
000bee 7fff          .dw $7fff
000bef f22e          .dw XT_AND
000bf0 f0d1          .dw XT_SWAP
000bf1 f387          .dw XT_STOREI
000bf2 f020          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000bf3 0006          .dw $0006
000bf4 635b
000bf5 6168
000bf6 5d72          .db "[char]"
000bf7 0be1          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000bf8 f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
000bf9 01ff          .dw XT_COMPILE
000bfa f040          .dw XT_DOLITERAL
000bfb 053e          .dw XT_CHAR
000bfc 020a          .dw XT_COMMA
000bfd f020          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000bfe 0006          .dw $0006
000bff 6261
000c00 726f
000c01 2274          .db "abort", $22
000c02 0bf3          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000c03 f000          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000c04 01ff          .dw XT_COMPILE
000c05 f039          .dw XT_DOCONDBRANCH
000c06 01b3          .dw XT_DP
000c07 01ff          .dw XT_COMPILE
000c08 ffff          .dw -1
                     
000c09 09e9          .dw XT_DOTSTRING
                     
000c0a 01ff          .dw XT_COMPILE
000c0b f040          .dw XT_DOLITERAL
                     
000c0c 01ff          .dw XT_COMPILE
000c0d fffe          .dw -2
000c0e 01ff          .dw XT_COMPILE
000c0f 04bb          .dw XT_THROW
                     ; then
000c10 01b3          .dw XT_DP
000c11 f0d1          .dw XT_SWAP
000c12 f387          .dw XT_STOREI
000c13 f020          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000c14 ff05          .dw $ff05
000c15 6261
000c16 726f
000c17 0074          .db "abort",0
000c18 0bfe          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000c19 f000          .dw DO_COLON
                 PFA_ABORT:
000c1a f040          .dw XT_DOLITERAL
000c1b ffff          .dw -1
000c1c 04bb          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000c1d ff04          .dw $ff04
000c1e 6f63
000c1f 6564          .db "code"
000c20 0c14          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000c21 f000          .dw DO_COLON
                 PFA_CODE:
000c22 01d8          .dw XT_DOCREATE
000c23 0b26          .dw XT_REVEAL
000c24 01b3          .dw XT_DP
000c25 f24a          .dw XT_1PLUS
000c26 020a          .dw XT_COMMA
000c27 f020          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000c28 ff08          .dw $ff08
000c29 6e65
000c2a 2d64
000c2b 6f63
000c2c 6564          .db "end-code"
000c2d 0c1d          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000c2e f000          .dw DO_COLON
                 PFA_ENDCODE:
000c2f 01ff          .dw XT_COMPILE
000c30 940c          .dw $940c
000c31 01ff          .dw XT_COMPILE
000c32 f004          .dw DO_NEXT
000c33 f020          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000c34 ff0b          .dw $ff0b
000c35 6e65
000c36 6976
000c37 6f72
000c38 6d6e
000c39 6e65
000c3a 0074          .db "environment",0
000c3b 0c28          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000c3c f04e          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000c3d 000c          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000c3e ff09          .dw $ff09
000c3f 6f77
000c40 6472
000c41 696c
000c42 7473
000c43 0073          .db "wordlists",0
000c44 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000c45 f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000c46 f040          .dw XT_DOLITERAL
000c47 0008          .dw NUMWORDLISTS
000c48 f020          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000c49 ff04          .dw $ff04
000c4a 702f
000c4b 6461          .db "/pad"
000c4c 0c3e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000c4d f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000c4e f29c          .dw XT_SP_FETCH
000c4f 0189          .dw XT_PAD
000c50 f1ae          .dw XT_MINUS
000c51 f020          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000c52 ff05          .dw $ff05
000c53 682f
000c54 6c6f
000c55 0064          .db "/hold",0
000c56 0c49          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000c57 f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000c58 0189          .dw XT_PAD
000c59 01c3          .dw XT_HERE
000c5a f1ae          .dw XT_MINUS
000c5b f020          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000c5c ff0a          .dw $ff0a
000c5d 6f66
000c5e 7472
000c5f 2d68
000c60 616e
000c61 656d          .db "forth-name"
000c62 0c52          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000c63 f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000c64 03ef          .dw XT_DOSLITERAL
000c65 0007          .dw 7
000c66 6d61
000c67 6f66
000c68 7472
000c69 0068          .db "amforth",0
000c6a f020          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000c6b ff07          .dw $ff07
000c6c 6576
000c6d 7372
000c6e 6f69
000c6f 006e          .db "version",0
000c70 0c5c          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000c71 f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000c72 f040          .dw XT_DOLITERAL
000c73 0034          .dw 52
000c74 f020          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000c75 ff03          .dw $ff03
000c76 7063
000c77 0075          .db "cpu",0
000c78 0c6b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000c79 f000          .dw DO_COLON
                 PFA_EN_CPU:
000c7a f040          .dw XT_DOLITERAL
000c7b 0049          .dw mcu_name
000c7c 0451          .dw XT_ICOUNT
000c7d f020          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000c7e ff08          .dw $ff08
000c7f 636d
000c80 2d75
000c81 6e69
000c82 6f66          .db "mcu-info"
000c83 0c75          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000c84 f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
000c85 f040          .dw XT_DOLITERAL
000c86 0045          .dw mcu_info
000c87 f020          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000c88 ff05          .dw $ff05
000c89 752f
000c8a 6573
000c8b 0072          .db "/user",0
000c8c 0c7e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000c8d f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000c8e f040          .dw XT_DOLITERAL
000c8f 0026          .dw SYSUSERSIZE + APPUSERSIZE
000c90 f020          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000c91 ff04          .dw $ff04
000c92 6540
000c93 5d5b          .db "@e[]"
000c94 0c34          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000c95 f000          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000c96 f0be          .dw XT_DUP
000c97 f373          .dw XT_FETCHE
000c98 f105          .dw XT_TO_R    ; save the counter to r-stack
000c99 f10e          .dw XT_R_FETCH
000c9a f146          .dw XT_ZERO
000c9b f0d1          .dw XT_SWAP    ; go from bigger to smaller addresses
000c9c f2bf          .dw XT_DOQDO
000c9d 0ca7          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000c9e f2d5          .dw XT_I
000c9f 015c          .dw XT_CELLS ; ( -- ee-addr i*2 )
000ca0 f0dc          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000ca1 f1b8          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000ca2 f373          .dw XT_FETCHE ;( -- ee-addr item_i )
000ca3 f0d1          .dw XT_SWAP   ;( -- item_i ee-addr )
000ca4 f14f          .dw XT_TRUE  ; shortcut for -1
000ca5 f2d6          .dw XT_DOPLUSLOOP
000ca6 0c9e          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000ca7 0175          .dw XT_2DROP
000ca8 f0fc          .dw XT_R_FROM ; get the counter from r-stack
000ca9 f020          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000caa ff04          .dw $ff04
000cab 6521
000cac 5d5b          .db "!e[]"
000cad 0c91          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000cae f000          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000caf 016c          .dw XT_2DUP
000cb0 f34f          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000cb1 f0d1          .dw XT_SWAP    
000cb2 f146          .dw XT_ZERO
000cb3 f2bf          .dw XT_DOQDO
000cb4 0cbb          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000cb5 0164          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000cb6 f0d1          .dw XT_SWAP
000cb7 f0dc          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000cb8 f34f          .dw XT_STOREE
000cb9 f2f0          .dw XT_DOLOOP
000cba 0cb5          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000cbb f0e6          .dw XT_DROP
000cbc f020          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000cbd ff0b          .dw $ff0b
000cbe 6567
000cbf 2d74
000cc0 7563
000cc1 7272
000cc2 6e65
000cc3 0074          .db "get-current",0
000cc4 0caa          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000cc5 f000          .dw DO_COLON
                 PFA_GET_CURRENT:
000cc6 f040          .dw XT_DOLITERAL
000cc7 0010          .dw EE_CURRENT
000cc8 f373          .dw XT_FETCHE
000cc9 f020          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000cca ff09          .dw $ff09
000ccb 6567
000ccc 2d74
000ccd 726f
000cce 6564
000ccf 0072          .db "get-order",0
000cd0 0cbd          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000cd1 f000          .dw DO_COLON
                 PFA_GET_ORDER:
000cd2 f040          .dw XT_DOLITERAL
000cd3 0014          .dw EE_ORDERLISTLEN
000cd4 0c95          .dw XT_FETCH_EE_ARRAY
000cd5 f020          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000cd6 ff07          .dw $ff07
000cd7 6f63
000cd8 706d
000cd9 7261
000cda 0065          .db "compare",0
000cdb 0cca          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000cdc 0cdd          .dw PFA_COMPARE
                 PFA_COMPARE:
000cdd 93bf          push xh
000cde 93af          push xl
000cdf 018c          movw temp0, tosl
000ce0 9189
000ce1 9199          loadtos
000ce2 01dc          movw xl, tosl
000ce3 9189
000ce4 9199          loadtos
000ce5 019c          movw temp2, tosl
000ce6 9189
000ce7 9199          loadtos
000ce8 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000ce9 90ed          ld temp4, X+
000cea 90f1          ld temp5, Z+
000ceb 14ef          cp temp4, temp5
000cec f451          brne PFA_COMPARE_NOTEQUAL
000ced 950a          dec temp0
000cee f019          breq PFA_COMPARE_ENDREACHED2
000cef 952a          dec temp2
000cf0 f7c1          brne PFA_COMPARE_LOOP
000cf1 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000cf2 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000cf3 2b02          or temp0, temp2
000cf4 f411          brne PFA_COMPARE_CHECKLASTCHAR
000cf5 2788          clr tosl
000cf6 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000cf7 ef8f          ser tosl
000cf8 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000cf9 2f98          mov tosh, tosl
000cfa 91af          pop xl
000cfb 91bf          pop xh
000cfc 940c f004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000cfe ff07         .dw $ff07
000cff 666e
000d00 3e61
000d01 666c
000d02 0061         .db "nfa>lfa",0
000d03 0cd6         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000d04 f000          .dw DO_COLON
                 PFA_NFA2LFA:
000d05 0451          .dw XT_ICOUNT 
000d06 f040          .dw XT_DOLITERAL
000d07 00ff          .dw $00ff
000d08 f22e          .dw XT_AND
000d09 f24a          .dw XT_1PLUS
000d0a f21f          .dw XT_2SLASH
000d0b f1b8          .dw XT_PLUS
000d0c f020          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
000d0d ff0d          .dw $ff0d
000d0e 6873
000d0f 776f
000d10 772d
000d11 726f
000d12 6c64
000d13 7369
000d14 0074          .db "show-wordlist",0
000d15 0cfe          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
000d16 f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
000d17 f040          .dw XT_DOLITERAL
000d18 0d1c          .dw XT_SHOWWORD
000d19 f0d1          .dw XT_SWAP
000d1a 0888          .dw XT_TRAVERSEWORDLIST
000d1b f020          .dw XT_EXIT
                 
                 XT_SHOWWORD:
000d1c f000          .dw DO_COLON
                 PFA_SHOWWORD:
000d1d 0877          .dw XT_NAME2STRING
000d1e 0426          .dw XT_ITYPE
000d1f 0467          .dw XT_SPACE         ; ( -- addr n)
000d20 f14f          .dw XT_TRUE
000d21 f020          .dw XT_EXIT
                 
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000d22 ff04          .dw $ff04
000d23 692b
000d24 746e          .db "+int"
000d25 0d0d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000d26 0d27          .dw PFA_INTON
                 PFA_INTON:
000d27 9478          sei
000d28 940c f004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000d2a ff04          .dw $ff04
000d2b 692d
000d2c 746e          .db "-int"
000d2d 0d22          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000d2e 0d2f          .dw PFA_INTOFF
                 PFA_INTOFF:
000d2f 94f8          cli
000d30 940c f004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000d32 ff04          .dw $ff04
000d33 6e69
000d34 2174          .db "int!"
000d35 0d2a          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000d36 f000          .dw DO_COLON
                 PFA_INTSTORE:
000d37 f040          .dw XT_DOLITERAL
000d38 0115          .dw intvec
000d39 f1b8          .dw XT_PLUS
000d3a f08e          .dw XT_STORE
000d3b f020          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000d3c ff04          .dw $ff04
000d3d 6e69
000d3e 4074          .db "int@"
000d3f 0d32          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000d40 f000          .dw DO_COLON
                 PFA_INTFETCH:
000d41 f040          .dw XT_DOLITERAL
000d42 0115          .dw intvec
000d43 f1b8          .dw XT_PLUS
000d44 f086          .dw XT_FETCH
000d45 f020          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000d46 ff08          .dw $ff08
000d47 6e69
000d48 2d74
000d49 7274
000d4a 7061          .db "int-trap"
000d4b 0d3c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000d4c 0d4d          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000d4d 9380 0114     sts intcur, tosl
000d4f 9189
000d50 9199          loadtos
000d51 9468          set ; set the interrupt flag for the inner interpreter
000d52 940c f004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000d54 f000          .dw DO_COLON
                 PFA_ISREXEC:
000d55 f040          .dw XT_DOLITERAL
000d56 0114          .dw intcur
000d57 f0a5          .dw XT_CFETCH
000d58 f040          .dw XT_DOLITERAL
000d59 0115          .dw intvec
000d5a f1b8          .dw XT_PLUS
000d5b f086          .dw XT_FETCH
000d5c f02a          .dw XT_EXECUTE
000d5d 0d5f          .dw XT_ISREND
000d5e f020          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000d5f 0d60          .dw PFA_ISREND
                 PFA_ISREND:
000d60 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000d61 940c f004     jmp_ DO_NEXT
                 PFA_ISREND1:
000d63 9518          reti
                 
                 ; include some controller specific definitions
                 .include "device.inc"
                 
                 ; generated automatically, no not edit
                 
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 .if WANT_USART0 == 1
                 .endif
                 .if WANT_PORTA == 1
                 .endif
                 .if WANT_PORTB == 1
                 .endif
                 .if WANT_PORTC == 1
                 .endif
                 .if WANT_PORTD == 1
                 .endif
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_3 == 1
                 .endif
                 .if WANT_BOOT_LOAD == 1
                 .endif
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 .if WANT_JTAG == 1
                 .endif
                 .if WANT_EEPROM == 1
                 .endif
                 .if WANT_TWI == 1
                 .endif
                 .if WANT_USART1 == 1
                 .endif
                 .if WANT_SPI == 1
                 .endif
                 .if WANT_WATCHDOG == 1
                 .endif
                 .if WANT_CPU == 1
                 .endif
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000d64 ff0b          .dw $ff0b
000d65 7061
000d66 6c70
000d67 7574
000d68 6e72
000d69 656b
000d6a 0079          .db "applturnkey",0
000d6b 0d46          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000d6c f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
000d6d 0110          .dw XT_USART
000d6e 0d26          .dw XT_INTON
000d6f 07ae          .dw XT_VER
000d70 f020          .dw XT_EXIT
                 .include "words/qmark.asm"
                 
                 ; R( -- )
                 ; print the content of addr
                 VE_QMARK:
000d71 ff01          .dw $ff01
000d72 003f          .db "?",0 
000d73 0d64          .dw VE_HEAD
                     .set VE_HEAD = VE_QMARK
                 XT_QMARK:
000d74 f000          .dw DO_COLON 
                 PFA_QMARK:
000d75 f086          .dw XT_FETCH 
000d76 038c          .dw XT_DOT 
000d77 f020          .dw XT_EXIT 
                 
                 ;    : ?     ( adr - n ) @ . ; 
                 .include "words/marker.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_MARKER:
000d78 ff08          .dw $ff08
000d79 6d28
000d7a 7261
000d7b 656b
000d7c 2972          .db "(marker)"
000d7d 0d71          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000d7e f07b          .dw PFA_DOVALUE1
                 PFA_MARKER:
000d7f 0036          .dw EE_MARKER
000d80 0bce          .dw XT_EVALUEFETCH
000d81 0bd2          .dw XT_EVALUESTORE
                 
                 .set DPSTART = pc
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
00f004 f09e          brts DO_INTERRUPT
00f005 01fd          movw zl, XL        ; READ IP
00f006 2755
00f007 0fee
00f008 1fff
00f009 1f55
00f00a bf5b
00f00b 9167
00f00c 9177          readflashcell wl, wh
00f00d 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00e 01fb          movw zl, wl
00f00f 2755
00f010 0fee
00f011 1fff
00f012 1f55
00f013 bf5b
00f014 9107
00f015 9117          readflashcell temp0,temp1
00f016 01f8          movw zl, temp0
00f017 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f018 94e8          clt
00f019 e564          ldi wl, LOW(XT_ISREXEC)
00f01a e07d          ldi wh, HIGH(XT_ISREXEC)
00f01b cff2          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f01c ff04          .dw $ff04
00f01d 7865
00f01e 7469          .db "exit"
00f01f 0d78          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f020 f021          .dw PFA_EXIT
                 PFA_EXIT:
00f021 91af          pop XL
00f022 91bf          pop XH
00f023 cfe0          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f024 ff07          .dw $ff07
00f025 7865
00f026 6365
00f027 7475
00f028 0065          .db "execute",0
00f029 f01c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02a f02b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f02b 01bc          movw wl, tosl
00f02c 9189
00f02d 9199          loadtos
00f02e cfdf          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f02f f030          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f030 01fd          movw zl, XL
00f031 2755
00f032 0fee
00f033 1fff
00f034 1f55
00f035 bf5b
00f036 91a7
00f037 91b7          readflashcell XL,XH
00f038 cfcb          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f039 f03a          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03a 2b98          or tosh, tosl
00f03b 9189
00f03c 9199          loadtos
00f03d f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f03e 9611          adiw XL, 1
00f03f cfc4          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f040 f041          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f041 939a
00f042 938a          savetos
00f043 01fd          movw zl, xl
00f044 2755
00f045 0fee
00f046 1fff
00f047 1f55
00f048 bf5b
00f049 9187
00f04a 9197          readflashcell tosl,tosh
00f04b 9611          adiw xl, 1
00f04c cfb7          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f04d f04e          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f04e 939a
00f04f 938a          savetos
00f050 01fb          movw zl, wl
00f051 9631          adiw zl,1
00f052 2755
00f053 0fee
00f054 1fff
00f055 1f55
00f056 bf5b
00f057 9187
00f058 9197          readflashcell tosl,tosh
00f059 cfaa          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05a f05b          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f05b 939a
00f05c 938a          savetos
00f05d 01cb          movw tosl, wl
00f05e 9601          adiw tosl, 1
00f05f cfa4          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f060 f061          .dw PFA_DOUSER
                 PFA_DOUSER:
00f061 939a
00f062 938a          savetos
00f063 01fb          movw zl, wl
00f064 9631          adiw zl, 1
00f065 2755
00f066 0fee
00f067 1fff
00f068 1f55
00f069 bf5b
00f06a 9187
00f06b 9197          readflashcell tosl,tosh
00f06c 0d84          add tosl, upl
00f06d 1d95          adc tosh, uph
00f06e cf95          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f06f ff07          .dw $ff07
00f070 7628
00f071 6c61
00f072 6575
00f073 0029          .db "(value)", 0
00f074 f024          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f075 f000          .dw DO_COLON
                 PFA_DOVALUE:
00f076 01d8          .dw XT_DOCREATE
00f077 0b26          .dw XT_REVEAL
00f078 01ff          .dw XT_COMPILE
00f079 f07b          .dw PFA_DOVALUE1
00f07a f020          .dw XT_EXIT
                 PFA_DOVALUE1:
00f07b 940e 0b4a     call_ DO_DODOES
00f07d f0be          .dw XT_DUP
00f07e f0d1          .dw XT_SWAP
00f07f f24a          .dw XT_1PLUS
00f080 f3e5          .dw XT_FETCHI
00f081 f02a          .dw XT_EXECUTE
00f082 f020          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f083 ff01          .dw $ff01
00f084 0040          .db "@",0
00f085 f06f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f086 f087          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f087 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f088 9181          ld tosl, z+
00f089 9191          ld tosh, z+
00f08a cf79          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08b ff01          .dw $ff01
00f08c 0021          .db "!",0
00f08d f083          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f08e f08f          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f08f 01fc          movw zl, tosl
00f090 9189
00f091 9199          loadtos
                     ; the high byte is written before the low byte
00f092 8391          std Z+1, tosh
00f093 8380          std Z+0, tosl
00f094 9189
00f095 9199          loadtos
00f096 cf6d          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f097 ff02          .dw $ff02
00f098 2163          .db "c!"
00f099 f08b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09a f09b          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09b 01fc          movw zl, tosl
00f09c 9189
00f09d 9199          loadtos
00f09e 8380          st Z, tosl
00f09f 9189
00f0a0 9199          loadtos
00f0a1 cf62          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a2 ff02          .dw $ff02
00f0a3 4063          .db "c@"
00f0a4 f097          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a5 f0a6          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0a6 01fc          movw zl, tosl
00f0a7 2799          clr tosh
00f0a8 8180          ld tosl, Z
00f0a9 cf5a          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
00f0aa ff02          .dw $ff02
00f0ab 7540          .db "@u"
00f0ac f0a2          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0ad f000          .dw DO_COLON
                 PFA_FETCHU:
00f0ae f32f          .dw XT_UP_FETCH
00f0af f1b8          .dw XT_PLUS
00f0b0 f086          .dw XT_FETCH
00f0b1 f020          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
00f0b2 ff02          .dw $ff02
00f0b3 7521          .db "!u"
00f0b4 f0aa          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b5 f000          .dw DO_COLON
                 PFA_STOREU:
00f0b6 f32f          .dw XT_UP_FETCH
00f0b7 f1b8          .dw XT_PLUS
00f0b8 f08e          .dw XT_STORE
00f0b9 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0ba ff03          .dw $ff03
00f0bb 7564
00f0bc 0070          .db "dup",0
00f0bd f0b2          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0be f0bf          .dw PFA_DUP
                 PFA_DUP:
00f0bf 939a
00f0c0 938a          savetos
00f0c1 cf42          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c2 ff04          .dw $ff04
00f0c3 643f
00f0c4 7075          .db "?dup"
00f0c5 f0ba          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0c6 f0c7          .dw PFA_QDUP
                 PFA_QDUP:
00f0c7 2f08          mov temp0, tosl
00f0c8 2b09          or temp0, tosh
00f0c9 f011          breq PFA_QDUP1
00f0ca 939a
00f0cb 938a          savetos
                 PFA_QDUP1:
00f0cc cf37          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0cd ff04          .dw $ff04
00f0ce 7773
00f0cf 7061          .db "swap"
00f0d0 f0c2          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d1 f0d2          .dw PFA_SWAP
                 PFA_SWAP:
00f0d2 018c          movw temp0, tosl
00f0d3 9189
00f0d4 9199          loadtos
00f0d5 931a          st -Y, temp1
00f0d6 930a          st -Y, temp0
00f0d7 cf2c          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0d8 ff04          .dw $ff04
00f0d9 766f
00f0da 7265          .db "over"
00f0db f0cd          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0dc f0dd          .dw PFA_OVER
                 PFA_OVER:
00f0dd 939a
00f0de 938a          savetos
00f0df 818a          ldd tosl, Y+2
00f0e0 819b          ldd tosh, Y+3
                 
00f0e1 cf22          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e2 ff04          .dw $ff04
00f0e3 7264
00f0e4 706f          .db "drop"
00f0e5 f0d8          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0e6 f0e7          .dw PFA_DROP
                 PFA_DROP:
00f0e7 9189
00f0e8 9199          loadtos
00f0e9 cf1a          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ea ff03          .dw $ff03
00f0eb 6f72
00f0ec 0074          .db "rot",0
00f0ed f0e2          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0ee f0ef          .dw PFA_ROT
                 PFA_ROT:
00f0ef 018c          movw temp0, tosl
00f0f0 9129          ld temp2, Y+
00f0f1 9139          ld temp3, Y+ 
00f0f2 9189
00f0f3 9199          loadtos
                         
00f0f4 933a          st -Y, temp3
00f0f5 932a          st -Y, temp2
00f0f6 931a          st -Y, temp1
00f0f7 930a          st -Y, temp0
                 
00f0f8 cf0b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f0f9 ff02          .dw $ff02
00f0fa 3e72          .db "r>"
00f0fb f0ea          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f0fc f0fd          .dw PFA_R_FROM
                 PFA_R_FROM:
00f0fd 939a
00f0fe 938a          savetos
00f0ff 918f          pop tosl
00f100 919f          pop tosh
00f101 cf02          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f102 ff02          .dw $ff02
00f103 723e          .db ">r"
00f104 f0f9          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f105 f106          .dw PFA_TO_R
                 PFA_TO_R:
00f106 939f          push tosh
00f107 938f          push tosl
00f108 9189
00f109 9199          loadtos
00f10a cef9          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f10b ff02          .dw $ff02
00f10c 4072          .db "r@"
00f10d f102          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f10e f10f          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f10f 939a
00f110 938a          savetos
00f111 918f          pop tosl
00f112 919f          pop tosh
00f113 939f          push tosh
00f114 938f          push tosl
00f115 ceee          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
00f116 ff02          .dw $ff02
00f117 3e3c          .db "<>"
00f118 f10b          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f119 f11a          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
00f11a 9129          ld temp2, Y+
00f11b 9139          ld temp3, Y+
00f11c 1782          cp tosl, temp2
00f11d 0793          cpc tosh, temp3
00f11e f151          breq PFA_ZERO1
00f11f c032          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f120 ff01          .dw $ff01
00f121 003d          .db "=",0
00f122 f116          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f123 f000          .dw DO_COLON
                 PFA_EQUAL:
00f124 f1ae          .dw XT_MINUS
00f125 f12a          .dw XT_EQUALZERO
00f126 f020          .dw XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
00f127 ff02          .dw $ff02
00f128 3d30          .db "0="
00f129 f120          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
00f12a f12b          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
00f12b 2b98          or tosh, tosl
00f12c f4e1          brne PFA_ZERO1
00f12d c024          rjmp PFA_TRUE1
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f12e ff01          .dw $ff01
00f12f 003c          .db "<",0
00f130 f127          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f131 f000          .dw DO_COLON
                 PFA_LESS:
00f132 f1ae          .dw XT_MINUS
00f133 f13f          .dw XT_LESSZERO
00f134 f020          .dw XT_EXIT
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f135 ff01          .dw $ff01
00f136 003e          .db ">",0
00f137 f12e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f138 f000          .dw DO_COLON
                 PFA_GREATER:
00f139 f1ae          .dw XT_MINUS
00f13a f16e          .dw XT_GREATERZERO
00f13b f020          .dw XT_EXIT
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00f13c ff02          .dw $ff02
00f13d 3c30          .db "0<"
00f13e f135          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00f13f f140          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00f140 fd97          sbrc tosh,7
00f141 c010          rjmp PFA_TRUE1
00f142 c006          rjmp PFA_ZERO1
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f143 ff01          .dw $ff01
00f144 0030          .db "0",0
00f145 f13c          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f146 f147          .dw PFA_ZERO
                 PFA_ZERO:
00f147 939a
00f148 938a          savetos
                 PFA_ZERO1:
00f149 01c1          movw tosl, zerol
00f14a ceb9          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f14b ff04          .dw $ff04
00f14c 7274
00f14d 6575          .db "true"
00f14e f143          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f14f f150          .dw PFA_TRUE
                 PFA_TRUE:
00f150 939a
00f151 938a          savetos
                 PFA_TRUE1:
00f152 ef8f          ser tosl
00f153 ef9f          ser tosh
00f154 ceaf          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f155 ff02          .dw $ff02
00f156 3c75          .db "u<"
00f157 f14b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f158 f159          .dw PFA_ULESS
                 PFA_ULESS:
00f159 9129          ld temp2, Y+
00f15a 9139          ld temp3, Y+
00f15b 1782          cp tosl, temp2
00f15c 0793          cpc tosh, temp3
00f15d f358          brlo PFA_ZERO1
00f15e f351          brbs 1, PFA_ZERO1
00f15f cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00f160 ff02          .dw $ff02
00f161 3e75          .db "u>"
00f162 f155          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f163 f164          .dw PFA_UGREATER
                 PFA_UGREATER:
00f164 9129          ld temp2, Y+
00f165 9139          ld temp3, Y+
00f166 1728          cp temp2, tosl
00f167 0739          cpc temp3, tosh
00f168 f300          brlo PFA_ZERO1
00f169 f2f9          brbs 1, PFA_ZERO1
00f16a cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f16b ff02          .dw $ff02
00f16c 3e30          .db "0>"
00f16d f160          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f16e f16f          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f16f 1582          cp tosl, zerol
00f170 0593          cpc tosh, zeroh
00f171 f2bc          brlt PFA_ZERO1
00f172 f2b1          brbs 1, PFA_ZERO1
00f173 cfde          rjmp PFA_TRUE1
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
00f174 ff02          .dw $ff02
00f175 3e64          .db "d>"
00f176 f16b          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
00f177 f000          .dw DO_COLON
                 PFA_DGREATER:
00f178 09ad          .dw XT_DMINUS
00f179 f17f          .dw XT_DGREATERZERO
00f17a f020          .dw XT_EXIT
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f17b ff03          .dw $ff03
00f17c 3064
00f17d 003e          .db "d0>",0
00f17e f174          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f17f f180          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f180 1582          cp tosl, zerol
00f181 0593          cpc tosh, zeroh
00f182 9189
00f183 9199          loadtos
00f184 0582          cpc tosl, zerol
00f185 0593          cpc tosh, zeroh
00f186 f214          brlt PFA_ZERO1
00f187 f209          brbs 1, PFA_ZERO1
00f188 cfc9          rjmp PFA_TRUE1
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
00f189 ff02          .dw $ff02
00f18a 3c64          .db "d<"
00f18b f17b          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00f18c f000          .dw DO_COLON
                 PFA_DLESS:
00f18d 09ad          .dw XT_DMINUS
00f18e f194          .dw XT_DLESSZERO
00f18f f020          .dw XT_EXIT
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DLESSZERO:
00f190 ff03          .dw $ff03
00f191 3064
00f192 003c          .db "d0<",0
00f193 f189          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESSZERO
                 XT_DLESSZERO:
00f194 f195          .dw PFA_DLESSZERO
                 PFA_DLESSZERO:
00f195 9622          adiw Y,2
00f196 fd97          sbrc tosh,7
00f197 940c f152     jmp PFA_TRUE1
00f199 940c f149     jmp PFA_ZERO1
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f19b ff04          .dw $ff04
00f19c 6f6c
00f19d 3267          .db "log2"
00f19e f190          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f19f f1a0          .dw PFA_LOG2
                 PFA_LOG2:
00f1a0 01fc          movw zl, tosl
00f1a1 2799          clr tosh
00f1a2 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f1a3 958a          dec tosl
00f1a4 f022          brmi PFA_LOG2_2 ; wrong data
00f1a5 0fee          lsl  zl
00f1a6 1fff          rol  zh
00f1a7 f7d8          brcc PFA_LOG2_1
00f1a8 ce5b          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f1a9 959a          dec tosh
00f1aa ce59          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1ab ff01          .dw $ff01
00f1ac 002d          .db "-",0
00f1ad f19b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1ae f1af          .dw PFA_MINUS
                 PFA_MINUS:
00f1af 9109          ld temp0, Y+
00f1b0 9119          ld temp1, Y+
00f1b1 1b08          sub temp0, tosl
00f1b2 0b19          sbc temp1, tosh
00f1b3 01c8          movw tosl, temp0
00f1b4 ce4f          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1b5 ff01          .dw $ff01
00f1b6 002b          .db "+",0
00f1b7 f1ab          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1b8 f1b9          .dw PFA_PLUS
                 PFA_PLUS:
00f1b9 9109          ld temp0, Y+
00f1ba 9119          ld temp1, Y+
00f1bb 0f80          add tosl, temp0
00f1bc 1f91          adc tosh, temp1
00f1bd ce46          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1be ff02          .dw $ff02
00f1bf 2a6d          .db "m*"
00f1c0 f1b5          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1c1 f1c2          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1c2 018c          movw temp0, tosl
00f1c3 9189
00f1c4 9199          loadtos
00f1c5 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1c6 0231          muls temp3, temp1
00f1c7 0170          movw temp4, r0
                     ; low cell  al*bl
00f1c8 9f20          mul  temp2, temp0
00f1c9 01c0          movw tosl, r0
                     ; signed ah*bl
00f1ca 0330          mulsu temp3, temp0
00f1cb 08f3          sbc   temp5, zeroh
00f1cc 0d90          add   tosh,  r0
00f1cd 1ce1          adc   temp4, r1
00f1ce 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1cf 0312          mulsu temp1, temp2
00f1d0 08f3          sbc   temp5, zeroh
00f1d1 0d90          add   tosh,  r0
00f1d2 1ce1          adc   temp4, r1
00f1d3 1cf3          adc   temp5, zeroh
                 
00f1d4 939a
00f1d5 938a          savetos
00f1d6 01c7          movw tosl, temp4
00f1d7 ce2c          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1d8 ff06          .dw $ff06
00f1d9 6d75
00f1da 6d2f
00f1db 646f          .db "um/mod"
00f1dc f1be          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1dd f1de          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1de 017c          movw temp4, tosl
                 
00f1df 9129          ld temp2, Y+
00f1e0 9139          ld temp3, Y+
                   
00f1e1 9109          ld temp0, Y+
00f1e2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1e3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1e4 2755          clr temp7
00f1e5 0f00          lsl temp0
00f1e6 1f11          rol temp1
00f1e7 1f22          rol temp2
00f1e8 1f33          rol temp3
00f1e9 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1ea 152e          cp temp2, temp4
00f1eb 053f          cpc temp3, temp5
00f1ec 0552          cpc temp7,zerol
                 
00f1ed f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1ee 9503          inc temp0
00f1ef 192e          sub temp2, temp4
00f1f0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1f1 954a          dec  temp6
00f1f2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1f3 933a          st -Y,temp3
00f1f4 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1f5 01c8          movw tosl, temp0
00f1f6 ce0d          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1f7 ff03          .dw $ff03
00f1f8 6d75
00f1f9 002a          .db "um*",0
00f1fa f1d8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1fb f1fc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1fc 018c          movw temp0, tosl
00f1fd 9189
00f1fe 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1ff 9f80          mul tosl,temp0
00f200 01f0          movw zl, r0
00f201 2722          clr temp2
00f202 2733          clr temp3
                     ; middle bytes
00f203 9f90          mul tosh, temp0
00f204 0df0          add zh, r0
00f205 1d21          adc temp2, r1
00f206 1d33          adc temp3, zeroh
                         
00f207 9f81          mul tosl, temp1
00f208 0df0          add zh, r0
00f209 1d21          adc temp2, r1
00f20a 1d33          adc temp3, zeroh
                     
00f20b 9f91          mul tosh, temp1
00f20c 0d20          add temp2, r0
00f20d 1d31          adc temp3, r1
00f20e 01cf          movw tosl, zl
00f20f 939a
00f210 938a          savetos
00f211 01c9          movw tosl, temp2
00f212 cdf1          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f213 ff06          .dw $ff06
00f214 6e69
00f215 6576
00f216 7472          .db "invert"
00f217 f1f7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f218 f219          .dw PFA_INVERT
                 PFA_INVERT:
00f219 9580          com tosl
00f21a 9590          com tosh
00f21b cde8          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f21c ff02          .dw $ff02
00f21d 2f32          .db "2/"
00f21e f213          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f21f f220          .dw PFA_2SLASH
                 PFA_2SLASH:
00f220 9595          asr tosh
00f221 9587          ror tosl
00f222 cde1          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f223 ff02          .dw $ff02
00f224 2a32          .db "2*"
00f225 f21c          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f226 f227          .dw PFA_2STAR
                 PFA_2STAR:
00f227 0f88          lsl tosl
00f228 1f99          rol tosh
00f229 cdda          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f22a ff03          .dw $ff03
00f22b 6e61
00f22c 0064          .db "and",0
00f22d f223          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f22e f22f          .dw PFA_AND
                 PFA_AND:
00f22f 9109          ld temp0, Y+
00f230 9119          ld temp1, Y+
00f231 2380          and tosl, temp0
00f232 2391          and tosh, temp1
00f233 cdd0          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f234 ff02          .dw $ff02
00f235 726f          .db "or"
00f236 f22a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f237 f238          .dw PFA_OR
                 PFA_OR:
00f238 9109          ld temp0, Y+
00f239 9119          ld temp1, Y+
00f23a 2b80          or tosl, temp0
00f23b 2b91          or tosh, temp1
00f23c cdc7          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f23d ff03          .dw $ff03
00f23e 6f78
00f23f 0072          .db "xor",0
00f240 f234          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f241 f242          .dw PFA_XOR
                 PFA_XOR:
00f242 9109          ld temp0, Y+
00f243 9119          ld temp1, Y+
00f244 2780          eor tosl, temp0
00f245 2791          eor tosh, temp1
00f246 cdbd          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f247 ff02          .dw $ff02
00f248 2b31          .db "1+"
00f249 f23d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f24a f24b          .dw PFA_1PLUS
                 PFA_1PLUS:
00f24b 9601          adiw tosl,1
00f24c cdb7          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f24d ff02          .dw $ff02 
00f24e 2d31          .db "1-"
00f24f f247          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f250 f251          .dw PFA_1MINUS
                 PFA_1MINUS:
00f251 9701          sbiw tosl, 1
00f252 cdb1          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f253 ff06          .dw $ff06
00f254 736c
00f255 6968
00f256 7466          .db "lshift"
00f257 f24d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f258 f259          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f259 01fc          movw zl, tosl
00f25a 9189
00f25b 9199          loadtos
                 PFA_LSHIFT1:
00f25c 9731          sbiw zl, 1
00f25d f01a          brmi PFA_LSHIFT2
00f25e 0f88          lsl tosl
00f25f 1f99          rol tosh
00f260 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f261 cda2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f262 ff06          .dw $ff06
00f263 7372
00f264 6968
00f265 7466          .db "rshift"
00f266 f253          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f267 f268          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f268 01fc          movw zl, tosl
00f269 9189
00f26a 9199          loadtos
                 PFA_RSHIFT1:
00f26b 9731          sbiw zl, 1
00f26c f01a          brmi PFA_RSHIFT2
00f26d 9596          lsr tosh
00f26e 9587          ror tosl
00f26f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f270 cd93          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f271 ff02          .dw $ff02
00f272 212b          .db "+!"
00f273 f262          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f274 f275          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f275 01fc          movw zl, tosl
00f276 9189
00f277 9199          loadtos
00f278 8120          ldd temp2, Z+0
00f279 8131          ldd temp3, Z+1
00f27a 0f82          add tosl, temp2
00f27b 1f93          adc tosh, temp3
00f27c 8380          std Z+0, tosl
00f27d 8391          std Z+1, tosh
00f27e 9189
00f27f 9199          loadtos
00f280 cd83          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f281 ff03          .dw $ff03
00f282 7072
00f283 0040          .db "rp@",0
00f284 f271          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f285 f286          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f286 939a
00f287 938a          savetos
00f288 b78d          in tosl, SPL
00f289 b79e          in tosh, SPH
00f28a cd79          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f28b ff03          .dw $ff03
00f28c 7072
00f28d 0021          .db "rp!",0
00f28e f281          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f28f f290          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f290 b72f          in temp2, SREG
00f291 94f8          cli
00f292 bf8d          out SPL, tosl
00f293 bf9e          out SPH, tosh
00f294 bf2f          out SREG, temp2
00f295 9189
00f296 9199          loadtos
00f297 cd6c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f298 ff03          .dw $ff03
00f299 7073
00f29a 0040          .db "sp@",0
00f29b f28b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f29c f29d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f29d 939a
00f29e 938a          savetos
00f29f 01ce          movw tosl, yl
00f2a0 cd63          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f2a1 ff03          .dw $ff03
00f2a2 7073
00f2a3 0021          .db "sp!",0
00f2a4 f298          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f2a5 f2a6          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a6 01ec          movw yl, tosl
00f2a7 9189
00f2a8 9199          loadtos
00f2a9 cd5a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2aa f2ab          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2ab 01fd          movw zl, xl
00f2ac 2755
00f2ad 0fee
00f2ae 1fff
00f2af 1f55
00f2b0 bf5b
00f2b1 9107
00f2b2 9117          readflashcell temp0,temp1
00f2b3 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2b4 9129          ld temp2, Y+
00f2b5 9139          ld temp3, Y+
                 PFA_DODO1:
00f2b6 931f          push temp1
00f2b7 930f          push temp0
00f2b8 933f          push temp3
00f2b9 932f          push temp2
00f2ba 939f          push tosh
00f2bb 938f          push tosl
00f2bc 9189
00f2bd 9199          loadtos
00f2be cd45          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
00f2bf f2c0          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2c0 01fd          movw zl, xl
00f2c1 2755
00f2c2 0fee
00f2c3 1fff
00f2c4 1f55
00f2c5 bf5b
00f2c6 9107
00f2c7 9117          readflashcell temp0,temp1
00f2c8 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2c9 9129          ld temp2, Y+
00f2ca 9139          ld temp3, Y+
                     ; now check for equality
00f2cb 1782          cp tosl, temp2
00f2cc 0793          cpc tosh, temp3
00f2cd f741          brne PFA_DODO1
                     ; both values are the same -> skip loop
00f2ce 01d8          movw xl, temp0
00f2cf 9189
00f2d0 9199          loadtos
00f2d1 cd32          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2d2 ff01          .dw $FF01
00f2d3 0069          .db "i",0
00f2d4 f2a1          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2d5 f10f          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2d6 f2d7          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2d7 91ef          pop zl
00f2d8 91ff          pop zh
00f2d9 0fe8          add zl, tosl
00f2da 1ff9          adc zh, tosh
00f2db 2f19          mov temp1, tosh
00f2dc 9189
00f2dd 9199          loadtos
                 PFA_DOPLUSLOOP4: 
00f2de 912f          pop temp2
00f2df 913f          pop temp3
00f2e0 17e2          cp zl, temp2
00f2e1 07f3          cpc zh, temp3
00f2e2 ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
00f2e3 c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
00f2e4 f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
00f2e5 c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
00f2e6 f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
00f2e7 933f          push temp3
00f2e8 932f          push temp2
00f2e9 93ff          push zh
00f2ea 93ef          push zl
00f2eb cd44          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
00f2ec 910f          pop  temp0
00f2ed 911f          pop  temp1  ; remove leave destination
00f2ee 9611          adiw xl, 1 ; skip branch-back address
00f2ef cd14          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2f0 f2f1          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2f1 91ef          pop zl
00f2f2 91ff          pop zh
00f2f3 9631          adiw zl,1
00f2f4 912f          pop temp2
00f2f5 913f          pop temp3
00f2f6 17e2          cp zl, temp2
00f2f7 07f3          cpc zh, temp3
00f2f8 f399          breq PFA_DOPLUSLOOP1
00f2f9 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2fa ff06          .dw $ff06
00f2fb 6e75
00f2fc 6f6c
00f2fd 706f          .db "unloop"
00f2fe f2d2          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2ff f300          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f300 911f          pop temp1
00f301 910f          pop temp0
00f302 911f          pop temp1
00f303 910f          pop temp0
00f304 911f          pop temp1
00f305 910f          pop temp0
00f306 ccfd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f307 ff06          .dw $ff06
00f308 6d63
00f309 766f
00f30a 3e65          .db "cmove>"
00f30b f2fa          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f30c f30d          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f30d 93bf          push xh
00f30e 93af          push xl
00f30f 91e9          ld zl, Y+
00f310 91f9          ld zh, Y+ ; addr-to
00f311 91a9          ld xl, Y+
00f312 91b9          ld xh, Y+ ; addr-from
00f313 2f09          mov temp0, tosh
00f314 2b08          or temp0, tosl
00f315 f041          brbs 1, PFA_CMOVE_G1
00f316 0fe8          add zl, tosl
00f317 1ff9          adc zh, tosh
00f318 0fa8          add xl, tosl
00f319 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f31a 911e          ld temp1, -X
00f31b 9312          st -Z, temp1
00f31c 9701          sbiw tosl, 1
00f31d f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f31e 91af          pop xl
00f31f 91bf          pop xh
00f320 9189
00f321 9199          loadtos
00f322 cce1          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f323 ff02          .dw $ff02
00f324 3c3e          .db "><"
00f325 f307          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f326 f327          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f327 2f09          mov temp0, tosh
00f328 2f98          mov tosh, tosl
00f329 2f80          mov tosl, temp0
00f32a ccd9          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f32b ff03          .dw $ff03
00f32c 7075
00f32d 0040          .db "up@",0
00f32e f323          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f32f f330          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f330 939a
00f331 938a          savetos
00f332 01c2          movw tosl, upl
00f333 ccd0          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f334 ff03          .dw $ff03
00f335 7075
00f336 0021          .db "up!",0
00f337 f32b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f338 f339          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f339 012c          movw upl, tosl
00f33a 9189
00f33b 9199          loadtos
00f33c ccc7          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
00f33d ff03          .dw $ff03
00f33e 3e73
00f33f 0064          .db "s>d",0
00f340 f334          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00f341 f000          .dw DO_COLON
                 PFA_S2D:
00f342 f0be          .dw XT_DUP
00f343 f13f          .dw XT_LESSZERO
                 .include "words/not.asm"
00f344 f020      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
00f345 ff03          .dw $ff03
00f346 6f6e
00f347 0074          .db "not",0
00f348 f33d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
00f349 f000          .dw DO_COLON
                 PFA_NOT:
00f34a f12a          .dw XT_EQUALZERO
00f34b f020          .dw XT_EXIT
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f34c ff02          .dw $ff02
00f34d 6521          .db "!e"
00f34e f345          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f34f f350          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f350 01fc          movw zl, tosl
00f351 9189
00f352 9199          loadtos
00f353 b72f          in_ temp2, SREG
00f354 94f8          cli
00f355 d028          rcall PFA_FETCHE2
00f356 b500          in_  temp0, EEDR
00f357 1708          cp temp0,tosl
00f358 f009          breq PFA_STOREE3
00f359 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f35a 9631          adiw zl,1
00f35b d022          rcall PFA_FETCHE2
00f35c b500          in_  temp0, EEDR
00f35d 1709          cp temp0,tosh
00f35e f011          breq PFA_STOREE4
00f35f 2f89          mov tosl, tosh
00f360 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f361 bf2f          out_ SREG, temp2
00f362 9189
00f363 9199          loadtos
00f364 cc9f          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f365 99f9          sbic EECR, EEPE
00f366 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f367 b707          in_ temp0, SPMCSR
00f368 fd00          sbrc temp0,SPMEN
00f369 cffd          rjmp PFA_STOREE2
                 
00f36a bdf2          out_ EEARH,zh
00f36b bde1          out_ EEARL,zl
00f36c bd80          out_ EEDR, tosl
00f36d 9afa          sbi EECR,EEMPE
00f36e 9af9          sbi EECR,EEPE
                 
00f36f 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f370 ff02          .dw $ff02
00f371 6540          .db "@e"
00f372 f34c          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f373 f374          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f374 b72f          in_ temp2, SREG
00f375 94f8          cli
00f376 01fc          movw zl, tosl
00f377 d006          rcall PFA_FETCHE2
00f378 b580          in_ tosl, EEDR
                 
00f379 9631          adiw zl,1
                 
00f37a d003          rcall PFA_FETCHE2
00f37b b590          in_  tosh, EEDR
00f37c bf2f          out_ SREG, temp2
00f37d cc86          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f37e 99f9          sbic EECR, EEPE
00f37f cffe          rjmp PFA_FETCHE2
                 
00f380 bdf2          out_ EEARH,zh
00f381 bde1          out_ EEARL,zl
                 
00f382 9af8          sbi EECR,EERE
00f383 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f384 ff02          .dw $ff02
00f385 6921          .db "!i"
00f386 f370          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f387 082e          .dw PFA_DODEFER
                 PFA_STOREI:
00f388 000a          .dw EE_STOREI
00f389 07f2          .dw XT_EDEFERFETCH
00f38a 07f7          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f38b ff09          .dw $ff09
00f38c 2128
00f38d 2d69
00f38e 726e
00f38f 7777
00f390 0029          .db "(!i-nrww)",0
00f391 f384          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f392 f393          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f393 b71f        in temp1,SREG
00f394 931f        push temp1
00f395 94f8        cli
                 
00f396 019c        movw temp2, tosl ; save the (word) address
00f397 9189
00f398 9199        loadtos          ; get the new value for the flash cell
00f399 93af        push xl
00f39a 93bf        push xh
00f39b 93cf        push yl
00f39c 93df        push yh
00f39d d009        rcall DO_STOREI_atmega
00f39e 91df        pop yh
00f39f 91cf        pop yl
00f3a0 91bf        pop xh
00f3a1 91af        pop xl
                   ; finally clear the stack
00f3a2 9189
00f3a3 9199        loadtos
00f3a4 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f3a5 bf1f        out SREG,temp1
                 
00f3a6 cc5d        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f3a7 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f3a8 94e0        com temp4
00f3a9 94f0        com temp5
00f3aa 218e        and tosl, temp4
00f3ab 219f        and tosh, temp5
00f3ac 2b98        or tosh, tosl
00f3ad f019        breq DO_STOREI_writepage 
                 
00f3ae 01f9          movw zl, temp2
00f3af e002          ldi temp0,(1<<PGERS)
00f3b0 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3b1 01f9        movw zl, temp2
00f3b2 e004        ldi temp0,(1<<PGWRT)
00f3b3 d020        rcall dospm
                 
                   ; reenable RWW section
00f3b4 01f9        movw zl, temp2
00f3b5 e100        ldi temp0,(1<<RWWSRE)
00f3b6 d01d        rcall dospm
00f3b7 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3b8 01f9        movw zl, temp2
                   ; get the beginning of page
00f3b9 78e0        andi zl,low(pagemask)
00f3ba 7fff        andi zh,high(pagemask)
00f3bb 01ef        movw y, z
                   ; loop counter (in words)
00f3bc e8a0        ldi xl,low(pagesize)
00f3bd e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3be 01fe        movw z, y
00f3bf 2755
00f3c0 0fee
00f3c1 1fff
00f3c2 1f55
00f3c3 bf5b
00f3c4 9147
00f3c5 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3c6 01fe        movw z, y
00f3c7 17e2        cp zl, temp2
00f3c8 07f3        cpc zh, temp3
00f3c9 f011        breq pageload_newdata
00f3ca 010a          movw r0, temp6
00f3cb c002          rjmp pageload_cont
                 pageload_newdata:
00f3cc 017a          movw temp4, temp6
00f3cd 010c          movw r0, tosl
                 pageload_cont:
00f3ce 2700        clr temp0
00f3cf d004        rcall dospm
00f3d0 9621        adiw y, 1
00f3d1 9711        sbiw x, 1
00f3d2 f759        brne pageload_loop
                 
                 pageload_done:
00f3d3 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3d4 99f9        sbic EECR, EEPE
00f3d5 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3d6 b717        in_  temp1, SPMCSR
00f3d7 fd10        sbrc temp1, SPMEN
00f3d8 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3d9 2755
00f3da 0fee
00f3db 1fff
00f3dc 1f55
00f3dd bf5b        writeflashcell
                   ; execute spm
00f3de 6001        ori temp0, (1<<SPMEN)
00f3df bf07        out_ SPMCSR,temp0
00f3e0 95e8        spm
00f3e1 9508        ret
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3e2 ff02          .dw $ff02
00f3e3 6940          .db "@i"
00f3e4 f38b          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3e5 f3e6          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3e6 01fc          movw zl, tosl
00f3e7 2755
00f3e8 0fee
00f3e9 1fff
00f3ea 1f55
00f3eb bf5b
00f3ec 9187
00f3ed 9197          readflashcell tosl,tosh
00f3ee cc15          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 82 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 f3 01         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 5a 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 6c 0d         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 92 f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00000c 88 0c         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00000e 12 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000010 12 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000012 e2 f3         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000014 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000016 12 00         .dw EE_FORTHWORDLIST      ; get/set-order
000018               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000026 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000028 7a 07         .dw XT_REC_FIND
00002a 5d 07         .dw XT_REC_INTNUMBER
00002c 96 07         .dw XT_REC_NOTFOUND
00002e ff ff         .dw -1
000030 ff ff         .dw -1
000032 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000034 c5 0c         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000036 36 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000038 00 00         .dw 0  ; USER_STATE
00003a 00 00         .dw 0  ; USER_FOLLOWER
00003c ff 40         .dw rstackstart  ; USER_RP
00003e af 40         .dw stackstart   ; USER_SP0
000040 af 40         .dw stackstart   ; USER_SP
                     
000042 00 00         .dw 0  ; USER_HANDLER
000044 0a 00         .dw 10 ; USER_BASE
                     
000046 ec 00         .dw XT_TX  ; USER_EMIT
000048 fa 00         .dw XT_TXQ ; USER_EMITQ
00004a c2 00         .dw XT_RX  ; USER_KEY
00004c dc 00         .dw XT_RXQ ; USER_KEYQ
00004e 58 09         .dw XT_SOURCETIB ; USER_SKEY
000050 00 00         .dw 0            ; USER_G_IN
000052 44 09         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000054 33 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_FCPU:
000056 00 12
000058 7a 00         .dd F_CPU        ; CPU Clock
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1284P" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  61 r18:  58 r19:  42 r20:  13 r21:  44 r22:  11 r23:   3 
r24: 170 r25: 121 r26:  45 r27:  22 r28:   6 r29:   4 r30:  72 r31:  39 
x  :   4 y  : 183 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega1284P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  14 adiw  :  19 and   :   4 
andi  :   3 asr   :   1 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   8 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   3 brmi  :   3 
brne  :  15 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   0 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  23 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  13 cpc   :  13 
cpi   :   0 cpse  :   0 dec   :   8 elpm  :  20 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  19 inc   :   2 
jmp   :  23 ld    : 127 ldd   :   4 ldi   :  34 lds   :   2 lpm   :   0 
lsl   :  16 lsr   :   1 mov   :  11 movw  :  64 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  30 
pop   :  48 push  :  34 rcall :  47 ret   :   6 reti  :   2 rjmp  :  87 
rol   :  36 ror   :   3 sbc   :   8 sbci  :   3 sbi   :   8 sbic  :   3 
sbis  :   0 sbiw  :  13 sbr   :   0 sbrc  :   5 sbrs  :   5 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  60 std   :   8 
sts   :   3 sub   :   5 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 74 out of 114 (64.9%)

"ATmega1284P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01e7de   2006   8876  10882  131072   8.3%
[.dseg] 0x000100 0x0001f3      0    243    243   16384   1.5%
[.eseg] 0x000000 0x00005a      0     90     90    4096   2.2%

Assembly complete, 0 errors, 2 warnings
